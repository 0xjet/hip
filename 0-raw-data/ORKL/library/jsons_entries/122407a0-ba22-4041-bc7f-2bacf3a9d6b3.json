{
    "id": "122407a0-ba22-4041-bc7f-2bacf3a9d6b3",
    "created_at": "2023-01-12T14:58:58.184423Z",
    "updated_at": "2025-03-27T02:13:29.046673Z",
    "deleted_at": null,
    "sha1_hash": "ab11ec53dbf7959bbdad5752f5ac970129b3499e",
    "title": "2016-09-21 - Reversing GO binaries like a pro",
    "authors": "",
    "file_creation_date": "2022-05-28T19:17:15Z",
    "file_modification_date": "2022-05-28T19:17:15Z",
    "file_size": 2585010,
    "plain_text": "# Reversing GO binaries like a pro\n\n**[rednaga.io/2016/09/21/reversing_go_binaries_like_a_pro/](https://rednaga.io/2016/09/21/reversing_go_binaries_like_a_pro/)**\n\n[2016-09-21](https://rednaga.io/2016/09/21/reversing_go_binaries_like_a_pro/)\nGO binaries are weird, or at least, that is where this all started out. While delving into some\n[Linux malware named Rex, I came to the realization that I might need to understand more](http://securityaffairs.co/wordpress/50556/malware/linux-rex-1-botnet.html)\n[than I wanted to. Just the prior week I had been reversing Linux Lady which was also written](https://news.drweb.com/news/?i=10140&lng=en)\nin GO, however it was not a stripped binary so it was pretty easy. Clearly the binary was\nrather large, many extra methods I didn’t care about - though I really just didn’t understand\nwhy. To be honest - I still haven’t fully dug into the Golang code and have yet to really write\nmuch code in Go, so take this information at face value as some of it might be incorrect; this\nis just my experience while reversing some ELF Go binaries! If you don’t want to read the\n[whole page, or scroll to the bottom to get a link to the full repo, just go here.](https://github.com/strazzere/golang_loader_assist)\n\nTo illistrate some of my examples I’m going to use an extremely simple ‘Hello, World!’\nexample and also reference the Rex malware. The code and a Make file are extremely\nsimple;\n\nHello.go\n```\n  package main\n  import \"fmt\"\n  func main() {\n    fmt.Println(\"Hello,\n  World!\")\n  }\n\n```\nMakefile\n```\n  all:\n       GOOS=linux GOARCH=386 go build -o hello-stripped -ldflags \"-s\"\n  hello.go\n       GOOS=linux GOARCH=386 go build -o hello-normal hello.go\n\n```\n\n-----\n\nSince I m working on an OSX machine, the above `GOOS and` `GOARCH variables are`\nexplicitly needed to cross-compile this correctly. The first line also added the `ldflags`\noption to strip the binary. This way we can analyze the same executable both stripped and\nwithout being stripped. Copy these files, run `make and then open up the files in your`\ndisassembler of choice, for this blog I’m going to use IDA Pro. If we open up the unstripped\nbinary in IDA Pro we can notice a few quick things;\n\nWell then - our 5 lines of code has turned into over 2058 functions. With all that overhead of\nwhat appears to be a runtime, we also have nothing interesting in the `main() function. If`\nwe dig in a bit further we can see that the actual code we’re interested in is inside of\n```\nmain_main ;\n\n```\n\n-----\n\n-----\n\nThis is, well, lots of code that I honestly don’t want to look at. The string loading also looks a\nbit weird - though IDA seems to have done a good job identifying the necessary bits. We can\neasily see that the string load is actually a set of three `mov s;`\n\nString load\n```\n  mov   ebx, offset aHelloWorld ; \"Hello, World!\"\n  mov   [esp+3Ch+var_14], ebx ; Shove string into\n  location\n  mov   [esp+3Ch+var_10], 0Dh ; length of string\n\n```\nThis isn’t exactly revolutionary, though I can’t off the top of my head say that I’ve seen\nsomething like this before. We’re also taking note of it as this will come in handle later on.\nThe other tidbit of code which caught my eye was the `runtime_morestack_context call;`\n\nmorestack_context\n```\n  loc_80490CB:\n  call  \n  runtime_morestack_noctxt\n  jmp   main_main\n\n```\nThis style block of code appears to always be at the end of functions and it also seems to\nalways loop back up to the top of the same function. This is verified by looking at the crossreferences to this function. Ok, now that we know IDA Pro can handle unstripped binaries,\nlets load the same code but the stripped version this time.\n\n\n-----\n\nImmediately we see some, well, lets just call them “differences”. We have 1329 functions\ndefined and now see some undefined code by looking at the navigator toolbar. Luckily IDA\nhas still been able to find the string load we are looking for, however this function now seems\nmuch less friendly to deal with.\n\n\n-----\n\n-----\n\nWe now have no more function names, however - the function names appear to be retained\nin a specific section of the binary if we do a string search for `main.main (which would be`\nrepesented at `main_main in the previous screen shots due to how a` `. is interpreted by`\nIDA);\n\n.gopclntab\n```\n  .gopclntab:0813E174         db \n  6Dh ; m\n  .gopclntab:0813E175         db \n  61h ; a\n  .gopclntab:0813E176         db \n  69h ; i\n  .gopclntab:0813E177         db \n  6Eh ; n\n  .gopclntab:0813E178         db \n  2Eh ; .\n  .gopclntab:0813E179         db \n  6Dh ; m\n  .gopclntab:0813E17A         db \n  61h ; a\n  .gopclntab:0813E17B         db \n  69h ; i\n  .gopclntab:0813E17C         db \n  6Eh ; n\n\n```\nAlright, so it would appear that there is something left over here. After digging into some of\nthe Google results into `gopclntab and tweet about this - a friendly reverser George`\n(Egor?) Zaytsev showed me his IDA Pro scripts for renaming function and adding type\ninformation. After skimming these it was pretty easy to figure out the format of this section so\nI threw together some functionally to replicate his script. The essential code is shown below,\nvery simply put, we look into the segment `.gopclntab and skip the first 8 bytes. We then`\ncreate a pointer ( Qword or `Dword dependant on whether the binary is 64bit or not). The`\nfirst set of data actually gives us the size of the `.gopclntab table, so we know how far to`\ngo into this structure. Now we can start processing the rest of the data which appears to be\n\n\n-----\n\nthe `function_offset followed by the (function)` `name_offset ). As we create pointers to`\nthese offsets and also tell IDA to create the strings, we just need to ensure we don’t pass\n```\nMakeString any bad characters so we use the clean_function_name function to strip\n\n```\nout any badness.\n\nrenamer.py\n```\n  def create_pointer(addr, force_size=None):\n    if force_size is not 4 and (idaapi.get_inf_structure().is_64bit() or\n  force_size is 8):\n      MakeQword(addr)\n       return Qword(addr), 8\n    else:\n       MakeDword(addr)\n       return Dword(addr), 4\n  STRIP_CHARS = [ '(', ')', '[', ']', '{', '}', ' ', '\"' ]\n  REPLACE_CHARS = ['.', '*', '-', ',', ';', ':', '/', '\\xb7' ]\n  def clean_function_name(str):\n    # Kill generic 'bad' characters\n    str = filter(lambda x: x in string.printable, str)\n    for c in STRIP_CHARS:\n      str = str.replace(c, '')\n    for c in REPLACE_CHARS:\n      str = str.replace(c, '_')\n    return str\n  def renamer_init():\n    renamed = 0\n    gopclntab = ida_segment.get_segm_by_name('.gopclntab')\n    if gopclntab is not None:\n      # Skip unimportant header and goto section size\n      addr = gopclntab.startEA + 8\n      size, addr_size = create_pointer(addr)\n       addr += addr size\n\n```\n\n-----\n\n```\n    # Unsure if this end is correct\n    early_end = addr + (size * addr_size * 2)\n    while addr < early_end:\n      func_offset, addr_size = create_pointer(addr)\n      name_offset, addr_size = create_pointer(addr + addr_size)\n      addr += addr_size * 2\n      func_name_addr = Dword(name_offset + gopclntab.startEA + addr_size) +\ngopclntab.startEA\n      func_name = GetString(func_name_addr)\n      MakeStr(func_name_addr, func_name_addr + len(func_name))\n      appended = clean_func_name = clean_function_name(func_name)\n      debug('Going to remap function at 0x%x with %s - cleaned up as %s' %\n(func_offset, func_name, clean_func_name))\n      if ida_funcs.get_func_name(func_offset) is not None:\n        if MakeName(func_offset, clean_func_name):\n          renamed += 1\n        else:\n          error('clean_func_name error %s' % clean_func_name)\n  return renamed\ndef main():\n  renamed = renamer_init()\n  info('Found and successfully renamed %d functions!' % renamed)\n\n```\n\n-----\n\n[The above code won’t actually run yet (don’t worry full code available in this repo ) but it is](https://github.com/strazzere/golang_loader_assist)\nhopefully simple enough to read through and understand the process. However, this still\ndoesn’t solve the problem that IDA Pro doesn’t know all the functions. So this is going to\ncreate pointers which aren’t being referenced anywhere. We do know the beginning of\nfunctions now, however I ended up seeing (what I think is) an easier way to define all the\nfunctions in the application. We can define all the functions by utilizing\n```\nruntime_morestack_noctxt function. Since every function utilizes this (basically, there is\n\n```\n\n-----\n\nan edgecase it turns out), if we find this function and traverse backwards to the cross\nreferences to this function, then we will know where every function exists. So what, right? We\nalready know where every function started from the segment we just parsed above, right?\nAh, well - now we know the end of the function and the next instruction after the call to\n```\nruntime_morestack_noctxt gives us a jump to the top of the function. This means we\n\n```\nshould quickly be able to give the bounds of the start and stop of a function, which is\nrequired by IDA, while seperating this from the parsing of the function names. If we open up\nthe window for cross references to the function `runtime_morestack_noctxt we see there`\nare many more undefined sections calling into this. 1774 in total things reference this\nfunction, which is up from the 1329 functions IDA has already defined for us, this is\nhighlighted by the image below;\n\nAfter digging into mutliple binaries we can see the `runtime_morestack_noctext will`\nalways call into `runtime_morestack (with context). This is the edgecase I was referencing`\nbefore, so between these two functions we should be able to see cross refereneces to ever\nother function used in the binary. Looking at the larger of the two functions,\n```\nruntime_more_stack, of multiple binaries tends to have an interesting layout;\n\n```\n\n-----\n\n-----\n\nThe part which stuck out to me was `mov large dword ptr ds:1003h, 0 - this appeared`\nto be rather constant in all 64bit binaries I saw. So after cross compiling a few more I noticed\nthat 32bit binaries used `mov qword ptr ds:1003h, 0, so we will be hunting for this`\npattern to create a “hook” for traversing backwards on. Lucky for us, I haven’t seen an\ninstance where IDA Pro fails to define this specific function, we don’t really need to spend\nmuch brain power mapping it out or defining it outselves. So, enough talk, lets write some\ncode to find this function;\n\nfind_runtime_morestack.py\n```\n  def create_runtime_ms():\n    debug('Attempting to find runtime_morestack function for hooking on...')\n    text_seg = ida_segment.get_segm_by_name('.text')\n    # This code string appears to work for ELF32 and ELF64 AFAIK\n    runtime_ms_end = ida_search.find_text(text_seg.startEA, 0, 0, \"word ptr\n  ds:1003h, 0\", SEARCH_DOWN)\n    runtime_ms = ida_funcs.get_func(runtime_ms_end)\n    if idc.MakeNameEx(runtime_ms.startEA, \"runtime_morecontext\", SN_PUBLIC):\n      debug('Successfully found runtime_morecontext')\n    else:\n      debug('Failed to rename function @ 0x%x to runtime_morestack' %\n  runtime_ms.startEA)\n    return runtime_ms\n\n```\nAfter finding the function, we can recursively traverse backwards through all the function\ncalls, anything which is not inside an already defined function we can now define. This is\nbecause the structure always appears to be;\n\ngolang undefined function example\n\n\n-----\n\n```\n.text:08089910         ; Function start - however\nundefined currently according to IDA Pro\n.text:08089910 loc_8089910:              ; CODE XREF:\n.text:0808994B\n.text:08089910                     ; DATA XREF:\nsub_804B250+1A1\n.text:08089910         mov   ecx, large gs:0\n.text:08089917         mov   ecx, [ecx-4]\n.text:0808991D         cmp   esp, [ecx+8]\n.text:08089920         jbe   short loc_8089946\n.text:08089922         sub   esp, 4\n.text:08089925         mov   ebx, [edx+4]\n.text:08089928         mov   [esp], ebx\n.text:0808992B         cmp   dword ptr [esp], 0\n.text:0808992F         jz   short loc_808993E\n.text:08089931\n.text:08089931 loc_8089931:              ; CODE XREF:\n.text:08089944\n.text:08089931         add   dword ptr [esp], 30h\n.text:08089935         call  sub_8052CB0\n.text:0808993A         add   esp, 4\n.text:0808993D         retn\n.text:0808993E ; -------------------------------------------------------------------------.text:0808993E\n.text:0808993E loc_808993E:              ; CODE XREF:\n.text:0808992F\n.text:0808993E         mov   large ds:0, eax\n.text:08089944         jmp   short loc_8089931\n.text:08089946 ; -------------------------------------------------------------------------.text:08089946\n.text:08089946 loc_8089946:              ; CODE XREF:\n.text:08089920\n\n```\n\n-----\n\n```\n  .text:08089946         call  runtime_morestack ; Bottom of function,\n  calls out to runtime_morestack\n  .text:0808994B         jmp   short loc_8089910 ; Jump back to the \"top\"\n  of the function\n\n```\nThe above snippet is a random undefined function I pulled from the stripped example\napplication we compiled already. Essentially by traversing backwards into every undefined\nfunction, we will land at something like line `0x0808994B which is the` `call`\n```\nruntime_morestack . From here we will skip to the next instruction and ensure it is a jump\n\n```\nabove where we currently are, if this is true, we can likely assume this is the start of a\nfunction. In this example (and almost every test case I’ve run) this is true. Jumping to\n```\n0x08089910 is the start of the function, so now we have the two parameters required by\nMakeFunction function;\n\n```\ntraverse_functions.py\n```\n  def is_simple_wrapper(addr):\n    if GetMnem(addr) == 'xor' and GetOpnd(addr, 0) == 'edx' and GetOpnd(addr, 1)\n  == 'edx':\n      addr = FindCode(addr, SEARCH_DOWN)\n      if GetMnem(addr) == 'jmp' and GetOpnd(addr, 0) == 'runtime_morestack':\n        return True\n    return False\n  def create_runtime_ms():\n    debug('Attempting to find runtime_morestack function for hooking on...')\n    text_seg = ida_segment.get_segm_by_name('.text')\n    # This code string appears to work for ELF32 and ELF64 AFAIK\n    runtime_ms_end = ida_search.find_text(text_seg.startEA, 0, 0, \"word ptr\n  ds:1003h, 0\", SEARCH_DOWN)\n    runtime_ms = ida_funcs.get_func(runtime_ms_end)\n    if idc MakeNameEx(runtime ms startEA \"runtime morestack\" SN PUBLIC):\n\n```\n\n-----\n\n```\n    debug( Successfully found runtime_morestack )\n  else:\n    debug('Failed to rename function @ 0x%x to runtime_morestack' %\nruntime_ms.startEA)\n  return runtime_ms\ndef traverse_xrefs(func):\n  func_created = 0\n  if func is None:\n    return func_created\n  # First\n  func_xref = ida_xref.get_first_cref_to(func.startEA)\n  # Attempt to go through crefs\n  while func_xref != 0xffffffffffffffff:\n    # See if there is a function already here\n    if ida_funcs.get_func(func_xref) is None:\n      # Ensure instruction bit looks like a jump\n      func_end = FindCode(func_xref, SEARCH_DOWN)\n      if GetMnem(func_end) == \"jmp\":\n        # Ensure we're jumping back \"up\"\n        func_start = GetOperandValue(func_end, 0)\n        if func_start < func_xref:\n          if idc.MakeFunction(func_start, func_end):\n            func_created += 1\n          else:\n            # If this fails, we should add it to a list of failed\nfunctions\n            # Then create small \"wrapper\" functions and backtrack\nthrough the xrefs of this\n            error('Error trying to create a function @ 0x%x - 0x%x' %\n(func_start, func_end))\n    else:\n      xref_func = ida_funcs.get_func(func_xref)\n\n```\n\n-----\n\n```\n      # Simple wrapper is often runtime_morestack_noctxt, sometimes it\nisn't though...\n      if is_simple_wrapper(xref_func.startEA):\n        debug('Stepping into a simple wrapper')\n        func_created += traverse_xrefs(xref_func)\n      if ida_funcs.get_func_name(xref_func.startEA) is not None and 'sub_'\nnot in ida_funcs.get_func_name(xref_func.startEA):\n        debug('Function @0x%x already has a name of %s; skipping...' %\n(func_xref, ida_funcs.get_func_name(xref_func.startEA)))\n      else:\n        debug('Function @ 0x%x already has a name %s' %\n(xref_func.startEA, ida_funcs.get_func_name(xref_func.startEA)))\n    func_xref = ida_xref.get_next_cref_to(func.startEA, func_xref)\n  return func_created\ndef find_func_by_name(name):\n  text_seg = ida_segment.get_segm_by_name('.text')\n  for addr in Functions(text_seg.startEA, text_seg.endEA):\n    if name == ida_funcs.get_func_name(addr):\n      return ida_funcs.get_func(addr)\n  return None\ndef runtime_init():\n  func_created = 0\n  if find_func_by_name('runtime_morestack') is not None:\n    func_created += traverse_xrefs(find_func_by_name('runtime_morestack'))\n    func_created +=\ntraverse_xrefs(find_func_by_name('runtime_morestack_noctxt'))\n  else:\n    runtime_ms = create_runtime_ms()\n    func_created = traverse_xrefs(runtime_ms)\n  return func_created\n\n```\n\n-----\n\n-----\n\nThat code bit is a bit lengthy, though hopefully the comments and concept is clear enough. It\nlikely isn’t necessary to explicitly traverse backwards recursively, however I wrote this prior to\nunderstanding that `runtime_morestack_noctxt (the edgecase) is the only edgecase that I`\nwould encounter. This was being handled by the `is_simple_wrapper function originally.`\nRegardless, running this style of code ended up finding all the extra functions IDA Pro was\nmissing. We can see below, that this creates a much cleaner and easier experience to\nreverse;\n\n\n-----\n\n[This can allow us to use something like Diaphora as well since we can specifically target](https://github.com/joxeankoret/diaphora)\nfunctions with the same names, if we care too. I’ve personally found this is extremely useful\nfor malware or other targets where you really don’t care about any of the framework/runtime\nfunctions. You can quiet easily differentiate between custom code written for the binary, for\nexample in the Linux malware “Rex” everything because with that name space! Now onto the\nlast challenge that I wanted to solve while reversing the malware, string loading! I’m honestly\nnot 100% sure how IDA detects most string loads, potentially through idioms of some sort?\nOr maybe because it can detect strings based on the `\\00 character at the end of it?`\nRegardless, Go seems to use a string table of some sort, without requiring null character.\nThe appear to be in alpha-numeric order, group by string length size as well. This means we\nsee them all there, but often don’t come across them correctly asserted as strings, or we see\nthem asserted as extremely large blobs of strings. The hello world example isn’t good at\nillistrating this, so I’ll pull open the `main.main function of the Rex malware to show this;`\n\n\n-----\n\nI didn’t want to add comments to everything, so I only commented the first few lines then\npointed arrows to where there should be pointers to a proper string. We can see a few\ndifferent use cases and sometimes the destination registers seem to change. However there\nis definitely a pattern which forms that we can look for. Moving of a pointer into a register,\nthat register is then used to push into a (d)word pointer, followed by a load of a lenght of the\nstring. Cobbling together some python to hunt for the pattern we end with something like the\npseudo code below;\n\nstring_hunting.py\n```\n  # Currently it's normally ebx, but could in theory be anything - seen ebp\n  VALID_REGS = ['ebx', 'ebp']\n\n```\n\n-----\n\n```\n# Currently it s normally esp, but could in theory be anything seen eax\nVALID_DEST = ['esp', 'eax', 'ecx', 'edx']\ndef is_string_load(addr):\n  patterns = []\n  # Check for first part\n  if GetMnem(addr) == 'mov':\n    # Could be unk_ or asc_, ignored ones could be loc_ or inside []\n    if GetOpnd(addr, 0) in VALID_REGS and not ('[' in GetOpnd(addr, 1) or\n'loc_' in GetOpnd(addr, 1)) and('offset ' in GetOpnd(addr, 1) or 'h' in\nGetOpnd(addr, 1)):\n      from_reg = GetOpnd(addr, 0)\n      # Check for second part\n      addr_2 = FindCode(addr, SEARCH_DOWN)\n      try:\n        dest_reg = GetOpnd(addr_2, 0)[GetOpnd(addr_2, 0).index('[') +\n1:GetOpnd(addr_2, 0).index('[') + 4]\n      except ValueError:\n        return False\n      if GetMnem(addr_2) == 'mov' and dest_reg in VALID_DEST and ('[%s' %\ndest_reg) in GetOpnd(addr_2, 0) and GetOpnd(addr_2, 1) == from_reg:\n        # Check for last part, could be improved\n        addr_3 = FindCode(addr_2, SEARCH_DOWN)\n        if GetMnem(addr_3) == 'mov' and (('[%s+' % dest_reg) in\nGetOpnd(addr_3, 0) or GetOpnd(addr_3, 0) in VALID_DEST) and 'offset ' not in\nGetOpnd(addr_3, 1) and 'dword ptr ds' not in GetOpnd(addr_3, 1):\n          try:\n            dumb_int_test = GetOperandValue(addr_3, 1)\n            if dumb_int_test > 0 and dumb_int_test < sys.maxsize:\n              return True\n          except ValueError:\n            return False\ndef create_string(addr, string_len):\n  debug('Found string load @ 0x%x with length of %d' % (addr, string_len))\n  # This may be overly aggressive if we found the wrong area\n\n```\n\n-----\n\n```\n  if GetStringType(addr) is not None and GetString(addr) is not None and\nlen(GetString(addr)) != string_len:\n    debug('It appears that there is already a string present @ 0x%x' % addr)\n    MakeUnknown(addr, string_len, DOUNK_SIMPLE)\n  if GetString(addr) is None and MakeStr(addr, addr + string_len):\n    return True\n  else:\n    # If something is already partially analyzed (incorrectly) we need to\nMakeUnknown it\n    MakeUnknown(addr, string_len, DOUNK_SIMPLE)\n    if MakeStr(addr, addr + string_len):\n      return True\n    debug('Unable to make a string @ 0x%x with length of %d' % (addr,\nstring_len))\n  return False\n\n```\n\n-----\n\nThe above code could likely be optimized, however it was working for me on the samples I\nneeded. All that would be left is to create another function which hunts through all the\ndefined code segments to look for string loads. Then we can use the pointer to the string and\nthe string length to define a new string using the `MakeStr . In the code I ended up using,`\nyou need to ensure that IDA Pro hasn’t mistakenly already create the string, as it sometimes\ntries to, incorrectly. This seems to happen sometimes when a string in the table contains a\nnull character. However, after using code above, this is what we are left with;\n\n\n-----\n\nThis is a much better piece of code to work with. After we throw together all these functions,\n[we now have the golang_loader_assist.py module for IDA Pro. A word of warning though, I](https://github.com/strazzere/golang_loader_assist/blob/master/golang_loader_assist.py)\nhave only had time to test this on a few versions of IDA Pro for OSX, the majority of testing\non 6.95. There is also very likely optimizations which should be made or at a bare minimum\nsome reworking of the code. With all that said, I wanted to open source this so others could\nuse this and hopefully contribute back. Also be aware that this script can be painfully slow\ndepending on how large the `idb file is, working on a OSX El Capitan (10.11.6) using a 2.2`\nGHz Intel Core i7 on IDA Pro 6.95 - the string discovery aspect itself can take a while. I’ve\noften found that running the different methods seperately can prevent IDA from locking up.\nHopefully this blog and the code proves useful to someone though, enjoy!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-09-21 - Reversing GO binaries like a pro.pdf"
    ],
    "report_names": [
        "2016-09-21 - Reversing GO binaries like a pro.pdf"
    ],
    "threat_actors": [
        {
            "id": "f4f16213-7a22-4527-aecb-b964c64c2c46",
            "created_at": "2024-06-19T02:03:08.090932Z",
            "updated_at": "2025-03-27T02:05:17.387119Z",
            "deleted_at": null,
            "main_name": "GOLD NIAGARA",
            "aliases": [
                "Carbanak",
                "Carbon Spider ",
                "FIN7 ",
                "Navigator ",
                "Sangria Tempest ",
                "TelePort Crew ",
                "Calcium "
            ],
            "source_name": "Secureworks:GOLD NIAGARA",
            "tools": [
                " Carbanak",
                " Cobalt Strike",
                " DICELOADER",
                " DRIFTPIN",
                " GGLDR",
                " GRIFFON",
                " JSSLoader",
                " Meterpreter",
                " OFFTRACK",
                " PILLOWMINT",
                " POWERTRASH",
                " SUPERSOFT",
                " TAKEOUT",
                " TinyMet",
                "Bateleur"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a2b92056-9378-4749-926b-7e10c4500dac",
            "created_at": "2023-01-06T13:46:38.430595Z",
            "updated_at": "2025-03-27T02:00:02.831633Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Operation DarkSeoul",
                "APT38",
                "ATK117",
                "DEV-1222",
                "G0032",
                "APT 38",
                "Stardust Chollima",
                "APT-C-26",
                "ATK3",
                "Diamond Sleet",
                "Hidden Cobra",
                "Unit 121",
                "Subgroup: Bluenoroff",
                "NICKEL GLADSTONE",
                "DEV-0139",
                "Andariel",
                "Operation Troy",
                "COVELLITE",
                "TA404",
                "Lazarus group",
                "Dark Seoul",
                "G0082",
                "NewRomanic Cyber Army Team",
                "Bluenoroff",
                "Appleworm",
                "Nickel Academy",
                "COPERNICIUM",
                "Hastati Group",
                "Bureau 121",
                "Operation AppleJeus",
                "Whois Hacking Team",
                "Citrine Sleet",
                "Sapphire Sleet",
                "Group 77",
                "Labyrinth Chollima",
                "Operation GhostSecret",
                "BeagleBoyz"
            ],
            "source_name": "MISPGALAXY:Lazarus Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f32df445-9fb4-4234-99e0-3561f6498e4e",
            "created_at": "2022-10-25T16:07:23.756373Z",
            "updated_at": "2025-03-27T02:02:09.966155Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "APT-C-26",
                "ATK 3",
                "Appleworm",
                "Citrine Sleet",
                "DEV-0139",
                "Diamond Sleet",
                "Gleaming Pisces",
                "Gods Apostles",
                "Gods Disciples",
                "Group 77",
                "Guardians of Peace",
                "Hastati Group",
                "Hidden Cobra",
                "ITG03",
                "Jade Sleet",
                "Labyrinth Chollima",
                "Lazarus Group",
                "NewRomanic Cyber Army Team",
                "Operation 99",
                "Operation AppleJeus",
                "Operation AppleJeus sequel",
                "Operation Blockbuster: Breach of Sony Pictures Entertainment",
                "Operation CryptoCore",
                "Operation Dream Job",
                "Operation Dream Magic",
                "Operation Flame",
                "Operation GhostSecret",
                "Operation In(ter)caption",
                "Operation LolZarus",
                "Operation Marstech Mayhem",
                "Operation No Pineapple!",
                "Operation North Star",
                "Operation Phantom Circuit",
                "Operation Sharpshooter",
                "Operation Ten Days of Rain / DarkSeoul",
                "Operation Troy",
                "SectorA01",
                "Slow Pisces",
                "TA404",
                "TraderTraitor",
                "UNC2970",
                "UNC4034",
                "UNC4736",
                "UNC4899",
                "UNC577",
                "Whois Hacking Team"
            ],
            "source_name": "ETDA:Lazarus Group",
            "tools": [
                "3CX Backdoor",
                "3Rat Client",
                "3proxy",
                "AIRDRY",
                "ARTFULPIE",
                "ATMDtrack",
                "AlphaNC",
                "Alreay",
                "Andaratm",
                "AngryRebel",
                "AppleJeus",
                "Aryan",
                "AuditCred",
                "BADCALL",
                "BISTROMATH",
                "BLINDINGCAN",
                "BTC Changer",
                "BUFFETLINE",
                "BanSwift",
                "Bankshot",
                "Bitrep",
                "Bitsran",
                "BlindToad",
                "Bookcode",
                "BootWreck",
                "BottomLoader",
                "Brambul",
                "BravoNC",
                "Breut",
                "COLDCAT",
                "COPPERHEDGE",
                "CROWDEDFLOUNDER",
                "Castov",
                "CheeseTray",
                "CleanToad",
                "ClientTraficForwarder",
                "CollectionRAT",
                "Concealment Troy",
                "Contopee",
                "CookieTime",
                "Cyruslish",
                "DAVESHELL",
                "DBLL Dropper",
                "DLRAT",
                "DRATzarus",
                "DRATzarus RAT",
                "Dacls",
                "Dacls RAT",
                "DarkComet",
                "DarkKomet",
                "DeltaCharlie",
                "DeltaNC",
                "Dembr",
                "Destover",
                "DoublePulsar",
                "Dozer",
                "Dtrack",
                "Duuzer",
                "DyePack",
                "ECCENTRICBANDWAGON",
                "ELECTRICFISH",
                "Escad",
                "EternalBlue",
                "FALLCHILL",
                "FYNLOS",
                "FallChill RAT",
                "Farfli",
                "Fimlis",
                "FoggyBrass",
                "FudModule",
                "Fynloski",
                "Gh0st RAT",
                "Ghost RAT",
                "Gopuram",
                "HARDRAIN",
                "HIDDEN COBRA RAT/Worm",
                "HLOADER",
                "HOOKSHOT",
                "HOPLIGHT",
                "HOTCROISSANT",
                "HOTWAX",
                "HTTP Troy",
                "Hawup",
                "Hawup RAT",
                "Hermes",
                "HotCroissant",
                "HotelAlfa",
                "Hotwax",
                "HtDnDownLoader",
                "Http Dr0pper",
                "ICONICSTEALER",
                "Joanap",
                "Jokra",
                "KANDYKORN",
                "KEYMARBLE",
                "Kaos",
                "KillDisk",
                "KillMBR",
                "Koredos",
                "Krademok",
                "LIGHTSHIFT",
                "LIGHTSHOW",
                "LOLBAS",
                "LOLBins",
                "Lazarus",
                "LightlessCan",
                "Living off the Land",
                "MATA",
                "MBRkiller",
                "MagicRAT",
                "Manuscrypt",
                "Mimail",
                "Mimikatz",
                "Moudour",
                "Mydoom",
                "Mydoor",
                "Mytob",
                "NACHOCHEESE",
                "NachoCheese",
                "NestEgg",
                "NickelLoader",
                "NineRAT",
                "Novarg",
                "NukeSped",
                "OpBlockBuster",
                "PCRat",
                "PEBBLEDASH",
                "PLANKWALK",
                "POOLRAT",
                "PSLogger",
                "PhanDoor",
                "Plink",
                "PondRAT",
                "PowerBrace",
                "PowerRatankba",
                "PowerShell RAT",
                "PowerSpritz",
                "PowerTask",
                "Preft",
                "ProcDump",
                "Proxysvc",
                "PuTTY Link",
                "QUICKRIDE",
                "QUICKRIDE.POWER",
                "Quickcafe",
                "QuiteRAT",
                "R-C1",
                "ROptimizer",
                "Ratabanka",
                "RatabankaPOS",
                "Ratankba",
                "RatankbaPOS",
                "RawDisk",
                "RedShawl",
                "Rifdoor",
                "Rising Sun",
                "Romeo-CoreOne",
                "RomeoAlfa",
                "RomeoBravo",
                "RomeoCharlie",
                "RomeoCore",
                "RomeoDelta",
                "RomeoEcho",
                "RomeoFoxtrot",
                "RomeoGolf",
                "RomeoHotel",
                "RomeoMike",
                "RomeoNovember",
                "RomeoWhiskey",
                "Romeos",
                "RustBucket",
                "SHADYCAT",
                "SHARPKNOT",
                "SIGFLIP",
                "SIMPLESEA",
                "SLICKSHOES",
                "SORRYBRUTE",
                "SUDDENICON",
                "SUGARLOADER",
                "SheepRAT",
                "SierraAlfa",
                "SierraBravo",
                "SierraCharlie",
                "SierraJuliett-MikeOne",
                "SierraJuliett-MikeTwo",
                "SimpleTea",
                "SimplexTea",
                "SmallTiger",
                "Stunnel",
                "TAINTEDSCRIBE",
                "TAXHAUL",
                "TFlower",
                "TOUCHKEY",
                "TOUCHMOVE",
                "TOUCHSHIFT",
                "TOUCHSHOT",
                "TWOPENCE",
                "TYPEFRAME",
                "Tdrop",
                "Tdrop2",
                "ThreatNeedle",
                "Tiger RAT",
                "TigerRAT",
                "Trojan Manuscript",
                "Troy",
                "TroyRAT",
                "VEILEDSIGNAL",
                "VHD",
                "VHD Ransomware",
                "VIVACIOUSGIFT",
                "VSingle",
                "ValeforBeta",
                "Volgmer",
                "Vyveva",
                "W1_RAT",
                "Wana Decrypt0r",
                "WanaCry",
                "WanaCrypt",
                "WanaCrypt0r",
                "WannaCry",
                "WannaCrypt",
                "WannaCryptor",
                "WbBot",
                "Wcry",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "WinorDLL64",
                "Winsec",
                "WolfRAT",
                "Wormhole",
                "YamaBot",
                "Yort",
                "ZetaNile",
                "concealment_troy",
                "http_troy",
                "httpdr0pper",
                "httpdropper",
                "klovbot",
                "sRDI"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535538,
    "ts_updated_at": 1743041609,
    "ts_creation_date": 1653765435,
    "ts_modification_date": 1653765435,
    "files": {
        "pdf": "https://archive.orkl.eu/ab11ec53dbf7959bbdad5752f5ac970129b3499e.pdf",
        "text": "https://archive.orkl.eu/ab11ec53dbf7959bbdad5752f5ac970129b3499e.txt",
        "img": "https://archive.orkl.eu/ab11ec53dbf7959bbdad5752f5ac970129b3499e.jpg"
    }
}