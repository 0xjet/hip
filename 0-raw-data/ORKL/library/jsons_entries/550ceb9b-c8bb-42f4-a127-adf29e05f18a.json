{
    "id": "550ceb9b-c8bb-42f4-a127-adf29e05f18a",
    "created_at": "2023-01-12T15:07:44.34682Z",
    "updated_at": "2025-03-27T02:06:08.587284Z",
    "deleted_at": null,
    "sha1_hash": "ee8a8537e4977368033c4d9bf11912a4f1f9fef3",
    "title": "2021-09-20 - Building an Open Source IDS IPS service for Gateway Load Balancer",
    "authors": "",
    "file_creation_date": "2022-05-28T17:13:30Z",
    "file_modification_date": "2022-05-28T17:13:30Z",
    "file_size": 950725,
    "plain_text": "# Building an Open Source IDS IPS service for Gateway Load Balancer\n\n**aws.amazon.com/blogs/networking-and-content-delivery/building-an-open-source-ids-ips-service-for-gateway-load-**\nbalancer/\n\nThe [Gateway Load Balancer (GWLB) service launched with support from the partner](https://aws.amazon.com/elasticloadbalancing/gateway-load-balancer/)\nnetwork. These partners provide networking appliances that enable customers to perform\nvarying levels of packet inspection on flows that pass through them, taking action as\nnecessary and as defined within their configuration. For a list of partners that support GWLB,\n[refer to the following page. Whilst for some customers, using a partner supplied instance is a](https://aws.amazon.com/elasticloadbalancing/partners/)\npreferred choice (perhaps due to existing licensing, expertise or a specific capability), there\nis a segment of customers that wishes to benefit from all the capabilities that GWLB as a\nframework provides, but does not have any of the aforementioned considerations. For these\ncustomers, embracing open-source capabilities can make sense.\n\nThis blog provides the steps to create an open-source IDS/IPS service running in Docker\n[containers, using Amazon Elastic Container Service (ECS) and](https://aws.amazon.com/ecs/?whats-new-cards.sort-by=item.additionalFields.postDateTime&whats-new-cards.sort-order=desc&ecs-blogs.sort-by=item.additionalFields.createdDate&ecs-blogs.sort-order=desc) [Amazon Linux 2 (AL2). This](https://aws.amazon.com/amazon-linux-2/)\nservice provides stateless packet inspection and logging, whilst leveraging the simplicity,\nelasticity and scalability that GWLB enables.\n\nMeerkats (Suricata suricatta) are wonderful creatures. Amongst their\naccolades you’ll discover that as well as being robust, tenacious and\nsporting high levels of intelligence, they are highly observant (care of\ntheir binocular vision), have developed advanced levels of vocalisation\nthat they use to signal alarm and can physically dig their bodyweight in\nearth within seconds! Perhaps no surprise then that the Meerkat (Figure\n1) is the namesake from which the popular open-source IDS/IPS\n[service ‘Suricata’ takes its name. In a recent](https://suricata-ids.org/) [joint blog post the Open](https://aws.amazon.com/blogs/opensource/scaling-threat-prevention-on-aws-with-suricata/)\nInformation Security Foundation (OISF) and AWS discussed the\nimportance of open-source security and how we have worked together Figure 1, Meerkat\n[to bring compatible Suricata rulesets to AWS Network Firewall. If you](https://aws.amazon.com/network-firewall/?whats-new-cards.sort-by=item.additionalFields.postDateTime&whats-new-cards.sort-order=desc)\n[look at the source code for Suricata, you’ll find that additional functions have been added to](https://github.com/OISF/suricata/commit/5d955c1836745cb359fb041b3b58c5ec9983255b#diff-74993c6ec05bc7a8378cd2fedce778be7a7ea6746016dd329e5c79674f2b0603)\n[support the GENEVE protocol:](https://tools.ietf.org/html/draft-ietf-nvo3-geneve-08)\n\nThis can be seen here:\n\nFigure 2, Code Snippet\n\n\n-----\n\nThe addition of these functions in the Suricata code, enable us to scale Suricata instances\nbehind GWLB.\n\n## Deployment Overview\n\n_There are two key steps to the deployment:_\n\nThe first step sets up a baseline Appliance VPC, Internet Gateway, NAT Gateways, S3\n[Buckets and SSM Parameters using a single CloudFormation template. This template will](https://github.com/aws-samples/aws-gateway-load-balancer-suricata-ids-ips-nsm/blob/main/cloudformation/base-vpc.yaml)\nalso set up a Code Pipeline which is made up of a code repository, build and deployment\nsteps.\n\nFigure 3, Baseline Appliance VPC\n\nThe second step deploys the inspection solution – you will release the pipeline that was built\n[during the first step in order to do this. AWS Code Pipeline will deploy another](https://aws.amazon.com/codepipeline/)\nCloudFormation template that builds and deploys a Suricata based packet inspection\nsolution using GWLB and ECS. This is illustrated below:\n\n\n-----\n\nFigure 4, Inspection Solution\n\nThe pipeline creation and modification workflow is illustrated below:\n\nFigure 5, Pipeline Workflow\n\nFor more detailed instructions and descriptions of the parameters, you can reference the\n[public readme.](https://github.com/aws-samples/aws-gateway-load-balancer-suricata-ids-ips-nsm/blob/main/README.md)\n\nYou can choose to integrate this solution as appropriate for your requirements. Since the\nGWLB service uses [PrivateLink endpoints for connectivity, it means that you can choose to](https://docs.aws.amazon.com/vpc/latest/privatelink/vpce-gateway-load-balancer.html)\ndeploy this solution in a centralised, decentralised pattern or a combination of both. For\n[examples of GWLB implementation patterns, you can follow this guidance.](https://aws.amazon.com/blogs/networking-and-content-delivery/introducing-aws-gateway-load-balancer-supported-architecture-patterns/)\n\n## Solution Walkthrough\n\n\n-----\n\nWe wanted to take a moment to discuss the mechanics of the overall solution from the\nperspective of GWLB and how packets are inspected by the Suricata based instances.\n\nWe need to create a container image based on AL2 that holds the compiled Suricata code\nand rules along with any other parameters that are specific to the configuration. When the\npipeline is triggered, CodeBuild pulls this public AL2 image, builds the Suricata and\nRulesFetcher containers and then stores them within a private ECR repository which is used\nby the ECS hosts. At the host level, the ECS worker nodes need to be configured to facilitate\npacket forwarding from GWLB to the Suricata container; for this there are a few elements of\nthat warrant further discussion.\n\n### Packet path, Hooks and User space applications\n\nIn the Linux kernel, there are several hooks that allow actions on packets as they pass along\nthe packet path, these are the [netfilter hooks. Iptables provides a convenient interface into](http://www.netfilter.org/)\nthe netfilter framework and allows administrators to set rules for packets as they traverse\nthese hooks. All packets that flow into, through, and out of Linux traverse these hooks.\n\nThe packet path inside Linux as it relates to the netfilter hooks is illustrated below:\n\nFigure 6, Packet Path\n\nIptables can be used to create rules for packet handling in any one of these chains and in\nany number of the tables that are processed. The specific chains that are traversed depend\non the nature of the packet in the packet path. Since we are building Linux instances solely\nfor the purpose of transparent packet inspection, then the traversal order of the chains will be\nas follows:\n\n**PREROUTING => FORWARD => POSTROUTING**\n\n[GWLB uses GENEVE encapsulation and specific Type Length Values (TLV) in the GENEVE](https://aws.amazon.com/blogs/networking-and-content-delivery/integrate-your-custom-logic-or-appliance-with-aws-gateway-load-balancer/)\nheader to identify flows and maintain symmetry, it’s important that we maintain these as the\npackets pass through the packet path. We also need to perform some source and\n\n\n-----\n\ndestination Network Address Translation (NAT) actions on the packets so that they are\nreturned, back to the GWLB node that originally sent them to the inspection instance.\n\nFrom a firewalling or filtering perspective, unless the packet is decapsulated or decoded,\nIptables rules cannot take action on the passenger payload. However, since we know that\nSuricata understands the GENEVE protocol, we are able to route encapsulated packets to\nthe Suricata engine and let it decode, inspect and take action on the passenger payload.\nSuricata is a user space application and so to invoke it in IPS mode (so that it sits in the\n[packet path), we can use NFQUEUE. Essentially this tells Iptables to push packets that](https://home.regit.org/netfilter-en/using-nfqueue-and-libnetfilter_queue/)\ntraverse the Forward chain to a queue number that Suricata is listening on. You can read\n[more about NFQUEUE implementation in the Suricata documentation, here:](https://suricata.readthedocs.io/en/suricata-6.0.0/configuration/suricata-yaml.html?highlight=nfqueue#nfq)\n\nIn summary of the above, the flow works like this:\n\n1. Encapsulated packet arrives at the inspection instance from a GWLB node\n2. Destination NAT is handled first by the NAT table in the PreRouting chain. This rewrites\n\nthe destination of the packet to the GWLB node that delivered the packet\n3. NFQUEUE is invoked next by the queue statement in the FILTER table within the\n\nForward chain\n4. The Suricata instance will receive the encapsulated payload and take actions based on\n\nthe rules that have been created. Suricata is able to decode and read the passenger\npayload (Suricata puts the packet back in the packet path)\n5. Source NAT is handled next by the NAT table in the PostRouting chain. This rewrites\n\nthe source of the packet to the back-end instance that performed the packet filtration\n6. The GENEVE encapsulated packet is then put back on the wire\n\n**No modifications are made to the original packet, but its contents are inspected.**\n\nThe packet path modification for inline packet filtering is illustrated below:\n\n\n-----\n\nFigure 7, Inline Packet Filtering\n\n## Rule Creation and Monitoring\n\n### Container Static Rules\n\nStatic rules are built into the container image as part of the image build process by AWS\nCode Pipeline. You should use static rules when you want to keep your rules versioned\ntogether with the Suricata config and Suricata version or for rules that shall always be\nenforced and should not be removed. Rules in the static.rules file are NOT applied or\nupdated on-the-fly. You need to rebuild and redeploy the Suricata container with the updated\nrules.\n\n**Rule Example 1 – Logging outbound DNS queries**\n\nWith our solution deployed, let’s make a change to the static.rules file. I’d like know about\nany DNS requests that are going beyond my VPC boundaries (external DNS requests)\nThese rules are baked into the container image. I can make this change directly in the Code\nCommit console or I could subsequently clone the Code Commit repo and make the change\nin there and then commit the changes.\n\nalert ip [%cidr%] any -> ! [%cidr%] 53 (msg:”external dns traffic\nlogged”;sid:10000;rev:1;)\n\n\n-----\n\nFigure 8, Static Rule\n\n_NOTE: Modifications to the container code will begin an ECS container replacement_\n_operation. During this time, clients may lose connectivity and will need to re-establish any_\n_connections. Modifications to dynamic rules are performed without interruption._\n\nAfter a short while, pipeline should have deployed successfully – with your alerting rules\nbaked in. We shall look at the logs that are generated little later.\n\n### Local Dynamic Rules\n\nThe Dynamic Rules should be used when you want to deploy and apply rules on-the-fly and\ndon’t want, or need to keep your rules versioned together with the Suricata config and\nSuricata version.\n\nThese rules are applied and updated without the need to rebuild or redeploy the Suricata\ncontainer.\n\nDynamic rules are handled slightly differently to static rules. Whilst to Suricata they are just\nanother rule file that is specified within its configuration file – this solution uses the\nRulesFetcher container to pull the dynamic rules from S3 and then run the Suricata-update\ndaemon to load them into the engine. Dynamic rules are not tracked with the container\nimage.\n\nModification of dynamic rules follows a similar process to static rules. Simply modify the\ndynamic.rules file in the Code Commit repo and commit the changes.\n\nWe have specified three rule entries here:\n\n**Rule Example 2 – This rule drops all ICMP traffic between two VPCs that are connected by**\na Transit Gateway (TGW)\n\ndrop icmp [%cidr%] any <> [%cidr%] any (msg:”icmp traffic blocked”;sid:10001;rev:1;)\n\n**Rule Example 3 – This rule drops all external connections to an Application Load Balancer,**\nwhere the source IP address is identified as originating from within Great Britain (GB) *\n\ndrop ip ![%cidr%] any -> [%cidr%] 80 (msg:”geo-ip rule\nGB”;geoip:src,GB;sid:10002;rev:1;)\n\n\n-----\n\n**Rule Example 4 – This rule blocks access to a website based on the TLS information inside**\nthe certificate handshake\n\ndrop tls [%cidr%] any -> any any (msg:”block access to social media websites”;tls.sni;\ncontent:”facebook.com”; nocase; pcre:”/facebook.com$/” ;sid:10003;rev:1;)\n\nFigure 9, Dynamic Rules\n\n[*GeoIP functionality requires that prior to deployment, you must register with MaxMind and](https://www.maxmind.com/en/home)\n_provide an API key during initial pipeline setup (Step 2). For more details on the parameter_\n_[file that you need to modify, check the public readme documentation.](https://github.com/aws-samples/aws-gateway-load-balancer-suricata-ids-ips-nsm/blob/main/README.md)_\n\n### External Dynamic Rules\n\nThis solution provides the ability to load third-party rules-sets into the configuration. For\n[example, the rulesets provided in The Open Information Security Foundation rulesets list](https://www.openinfosecfoundation.org/rules/index.yaml)\nsuch as the popular: et/open ruleset. These rule-sets are managed by external parties and\ncan be loaded automatically into the configuration. To reference an external rule-set, simply\nmodify the CloudFormation stack template. The rules will be dynamically loaded.\n\n[Check the following link for further details on additional rulesets that can be loaded into the](https://doc.emergingthreats.net/bin/view/Main/AllRulesets)\nSuricata engine.\n\n## Logging and Validating the solution\n\nYou’ll remember that we specified a static rule and three dynamic rules. Let’s generate some\ntraffic, monitor the behaviour, and trace the log entries.\n\n**Rule Example 1 – Logging outbound DNS queries**\n\nLet’s perform a DNS query against an external DNS resolver, from one of our internal clients:\n\n\n-----\n\nFigure 10, Example DNS Query\n\nLet’s have a look at the Fast.log (this is where the alert will be generated) and also find the\nFlow statement in the Eve.log. If we search by the signature ID, we see entries in the\nFast.Log file:\n\nFigure 11, Fast.Log Analysis\n\nHere is the Flow entry; notice the detail that it provides. You can see the tunneling that is\nhappening from GWLB.\n\n\n-----\n\nFigure 12, DNS Eve.Log\n\n### ICMP, GeoIP and TLS\n\nIn our dynamic rule file, we created rules to block ICMP packets, restrict access to a public\nApplication Load Balancer (if the originating IP address was identified as being located\nsomewhere in Great Britain) and prevent access to social media websites. The Signature IDs\nfor those rules were “10001”, “10002” and “10003”, respectively. Let’s go and find the flow\nentries for those.\n\nWe can use JSON based matching to accomplish this in CloudWatch Logs. A query such as\nthis one should bring back the matching entries:\n\n**{ $.alert.signature_id = %signatureid% }**\n\n### Rule Example 2\n\nHere’s the event that was generated when a client attempted to ping another – via a TGW\nconnection. We can see that it was blocked – as expected.\n\n\n-----\n\nFigure 13, ICMP Eve.Log\n\n### Rule Example 3\n\nHere is another event that was generated when an entity within Great Britain attempted to\nconnect to an ALB that is being protected by a GeoIP filtering rule:\n\nFigure 14, GeoIP Eve.Log\n\nTo test this yourself, simply spin up an EC2 instance in the blocked region and attempt a\nconnection to the public facing IP address of the load balancer.\n\n### Rule Example 4\n\nWe also blocked access to social media sites. Let’s search for the signature id to discover\nany activity for this rule.\n\n\n-----\n\nFigure 15, TLS Eve.Log\n\nWe can see the traffic was blocked, the signature description, and some detail regarding the\nfingerprinting of the TLS communications.\n\nTo test this yourself, a simple curl command can be used to generate some traffic. This will\ngrab the headers only and report with enhanced detail. You should see that the TLS\nhandshake is broken when you do this.\n\n➜ ~ curl https://facebook.com -i -v\n\nThese rules are just examples so you can adjust the configuration to suit your deployment.\nSince you’ve built your own Suricata containers, there is more that you can do. This solution\n[was compiled with the LUA scripting module. With this capability you can write more](https://suricata.readthedocs.io/en/suricata-6.0.0/rules/rule-lua-scripting.html)\ncomplex rules that provide advanced matching against malware. Additionally, you could use\nthe packet capture capability so that you can debug the traffic that is flowing through your\n[inspection instances. See the public readme for more details on this and how to enable it.](https://github.com/aws-samples/aws-gateway-load-balancer-suricata-ids-ips-nsm/blob/main/README.md)\n\n## Clean-up\n\nClean-up is straightforward, you can delete the CloudFormation stack that was created by\nthe pipeline, and then delete the stack that defined the pipeline itself. You’ll be left with a\ncouple of S3 buckets and ECR repositories that you can either choose to keep or delete\nmanually.\n\n## Conclusion\n\n\n-----\n\nSo, there you have it. You built a GitOps driven IDS/IPS service using open-source code, on\ntop of [Gateway Load Balancer. You created rules that log particular types of traffic (DNS) as](https://aws.amazon.com/elasticloadbalancing/gateway-load-balancer/)\na baseline, added protections for your network traffic in blocking known protocols (ICMP) and\n[restricted access to an Application Load Balancer based on Geographic location metadata.](https://aws.amazon.com/elasticloadbalancing/application-load-balancer/)\nFinally, you prevented access to a social media website using data that is negotiated as part\nof a TLS handshake.\n\nWe also discovered a little more about just how impressive Meerkats are!\n\n## Author Bios\n\n### Adam Palmer\n\nAdam Palmer is a Senior Specialist Network Solutions Architect at AWS. Prior to joining\nAWS, Adam worked as an Architect in the Financial Service sector; specializing in\nNetworking, VMware, Microsoft platform and End-User Compute solutions. In his spare time,\nhe can be found climbing mountain faces, wherever the weather is good!\n\n### Jesper Eneberg\n\nJesper Eneberg is a Senior Solutions Architect based in Sweden and is working with global\nTelecommunications customers at AWS. Jesper is an open source advocate and have a\nbackground in Operations and Infrastructure. Prior to joining AWS, he implemented DevOps\nand worked with DevOps organizations in both the Public and private sector\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-20 - Building an Open Source IDS IPS service for Gateway Load Balancer.pdf"
    ],
    "report_names": [
        "2021-09-20 - Building an Open Source IDS IPS service for Gateway Load Balancer.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536064,
    "ts_updated_at": 1743041168,
    "ts_creation_date": 1653758010,
    "ts_modification_date": 1653758010,
    "files": {
        "pdf": "https://archive.orkl.eu/ee8a8537e4977368033c4d9bf11912a4f1f9fef3.pdf",
        "text": "https://archive.orkl.eu/ee8a8537e4977368033c4d9bf11912a4f1f9fef3.txt",
        "img": "https://archive.orkl.eu/ee8a8537e4977368033c4d9bf11912a4f1f9fef3.jpg"
    }
}