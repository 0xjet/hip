{
    "id": "8f08db15-e276-4d7b-b361-be5d38f5deeb",
    "created_at": "2023-01-12T15:00:13.867792Z",
    "updated_at": "2025-03-27T02:16:26.312638Z",
    "deleted_at": null,
    "sha1_hash": "d48149c9b6a6518a97b5f617b4d05d4750511472",
    "title": "2017-05-23 - Quakbot",
    "authors": "",
    "file_creation_date": "2022-05-28T21:54:15Z",
    "file_modification_date": "2022-05-28T21:54:15Z",
    "file_size": 586318,
    "plain_text": "# Threat Spotlight: The Return of Qakbot Malware\n\n**[cylance.com/en_us/blog/threat-spotlight-the-return-of-qakbot-malware.html](https://www.cylance.com/en_us/blog/threat-spotlight-the-return-of-qakbot-malware.html)**\n\nThe BlackBerry Cylance Threat Research Team\n\n## Introduction\n\nThe Cylance Threat Guidance team continuously looks for interesting trends and challenges\nthat incite organizations to engage with us. Recently, an influx of thousands of [Qakbot (aka](https://threatvector.cylance.com/en_us/home/cylanceprotect-vs-qakbot.html)\nQbot) infections have brought people to us to discuss how to block this malware from gaining\naccess to corporate systems.\n\n[Qakbot has been around for years (in fact, we made this video about it last April), but it’s](https://www.youtube.com/watch?v=QOm5AYQMdF8)\nnothing to be complacent about. This malware is well-known for its ability to steal credentials\nand quickly spread through an enterprise over network shares. Given its age, it might seem\nlogical that security controls would have this threat on lockdown. However, the occasional\nfunctional enhancements combined with its multiple layers of obfuscation and server-side\npolymorphism periodically breathe new life into this seemingly immortal malware.\n\nWhile it’s unclear why so many systems have suddenly fallen victim to Qakbot, it’s possible\nthat updated exploit kits play a role. After all, there is no shortage of new vulnerabilities and\nexploits for attackers to use to their advantage.\n\nSince the core functionality of Qakbot has remained fairly consistent over the years and is\nwell documented, we will not rehash that information here. Instead, we’ll evaluate several\nsamples from the recent surge in infections and explore how to correlate unique binaries.\n\n## Collecting Qakbot\n\n\n-----\n\nAs highlighted at the beginning of this article, the polymorphic nature of this threat is of great\ninterest given its goal of evading detection. Prior versions of Qakbot configured a scheduled\ntask to request updates, and the recent wave of infections was no different. For example, we\nobserved a sample that configured the following command to run on a weekly basis:\n\ncmd.exe /C \"start /MIN C:\\windows\\system32\\cscript.exe //E:javascript \"C:\\Users\\\n<USER>\\AppData\\Local\\Microsoft\\<5-8 random alphabetical characters>.wpl\"\"\n\nAs described in the command line, the WPL file contains JavaScript. Just in case the cryptic\ncode isn’t convincing enough, the header of the target file makes it all too clear the\nJavaScript is obfuscated (Figure 1).\n\n\n-----\n\n-----\n\n_Figure 1: Excerpt of Obfuscated JavaScript Update Script_\n\nBrief behavioral analysis revealed the code reaches out to the following URLs:\n\nhxxp://css.kbaf.myzen.co(dot)uk/TealeafTarget.php\nhxxp://projects.montgomerytech(dot)com/TealeafTarget.php\nhxxp://n.abcwd0.seed.fastsecureservers(dot)com/TealeafTarget.php\n\nLike earlier versions of Qakbot, a request to these update servers returns an encrypted\npayload, where the first 20 bytes serve as the RC4 key to decrypt the data. Once decrypted,\nthe first 20 bytes represent a SHA1 hash of the executable, and the remaining bytes are the\nfile contents.\n\nTo mimic Qakbot’s update process in a controlled manner, we created a Python script to\nsend HTTP requests to each of the three URLs over a 24-hour period. At the time of this\nwriting, requests for the first listed URL returned an HTTP 404 Not Found error, but requests\nfor the remaining two URLs returned the expected payload.\n\nThe script was executed from both a Windows 10 64-bit and Windows 10 32-bit OS for more\nthan 24 hours from 5/16/17 to 5/17/17, and the scripts were running simultaneously across\nboth operating systems during much of that time.\n\nAlthough the script was configured to send HTTP requests to each of the two working URLs\nevery 30 seconds, most requests resulted in pulling the same binary. In other words, the\nupdate server did not provide a new file with each request.\n\nFiles with a unique hash were only supplied approximately every 10 minutes. In total, we\ncollected 245 files across the two machines. However, because the servers supplied the\nsame file to each machine at a given time (i.e., they appeared to be in sync), the resulting\nunique set of files was much smaller, totaling 141 files.\n\n## Reviewing the Collection\n\nAll 141 downloaded files were 32-bit Windows executables. Searching public repositories for\nthese files revealed that only one had been previously logged, and that was within the\nprevious 12 hours.\n\nAcross the 141 files, all have unique compile timestamps, and the earliest one occurred on\nMay 15, 2017.\n\nWhile all 141 files have unique sha-256 file hashes, there are some similarities to consider.\nFirst, calculating the import hashes across the files showed three distinct groups:\n\n2E6AC2290F1E3D80ABC8D0D6F736D965\n651EF2DBA96011F47EED9B72BE7B4B8C\n\n\n-----\n\nF3CAA54DDE4056FADD52A024CF6B82ED\n\nAlthough import hashes are often used to correlate malware over long periods of time, the\nearliest compile timestamp we discovered for a file with any of the above import hashes was\n5/15/17. Given the polymorphic capabilities of this threat, this observation is not surprising.\n\nLet’s briefly take a look at two files that have the same import hash\n(2E6AC2290F1E3D80ABC8D0D6F736D965) but different file hashes:\n\n7DBD0DF279062090C34F796EFC7DD239ECCD46B99B67AAC370D6048D5ADBB9EC\n67F3BD674647CA0D294A894B6702362B6CFC4B6C2E147643E100903A6B4D715A\n\nBoth files are 458,752 bytes, and they consist of the following PE sections:\n\n.text\n.code\n.rdata\n.data\n.CRT\n.exp\n.code (yes, again)\n.rsc\n.reloc\n\nAmong these, all section hashes match except those for .text, .rdata, and .data. A different\n.text section may indicate a change in executable code. To investigate this observation, we\n[can use diaphora, a binary diffing tool compatible with IDA Pro. Performing a code](https://github.com/joxeankoret/diaphora)\ncomparison presents the following results (excerpt in Figure 2).\n\n_Figure 2: Binary Diff of Two Qakbot Samples With the Same Import Hash_\n\nDiaphora concludes all 27 identifiedfunctions are a 100% match.\n\nWhile we could investigate individual variations across the three PE sections mentioned\nearlier, it makes more sense to unravel any layers of obfuscation and compare the\nunderlying code.\n\n## Unpacking Qakbot\n\nTo unpack recent Qakbot samples, the below approach worked reliably. All instructions\nassume use of x32dbg, but similar steps can be performed with a debugger of your choice.\n\n\n-----\n\nLoad the sample into x32dbg (we ll be working with the file that has sha-256 hash\n7DBD0DF279062090C34F796EFC7DD239ECCD46B99B67AAC370D6048D5ADBB9EC)\n.\nSet a breakpoint on VirtualProtect (Figure 3).\n\n_Figure 3: Set a Breakpoint on VirtualProtect Within x32dbg_\n\n- Execute the code. On the first call to VirtualProtect, the protection on all sections owned\nby the process will be modified to 0x04, or PAGE_READWRITE (see red box in Figure 4).\n\n\n-----\n\n-----\n\n_Figure 4: Protection on Code Changed to PAGE_READWRITE_\n\n- As the code executes, those sections in memory will be manually overwritten using loops.\nLet the breakpoint hit two more times, and on the second hit notice that protection on the\n.text section is changed to 0x20, or PAGE_EXECUTE_READ (see red box in Figure 5).\n\n\n-----\n\n-----\n\n_Figure 5: Protection on .text Section Changed to PAGE_EXECUTE_READ_\n\n- Allow the call to complete and return back to user code so that the permissions change\ntakes effect.\n\n- Next, browse to the Memory Map and choose to disassemble the .text section (Figure 6).\n\n\n-----\n\n-----\n\n_Figure 6: Memory Map With Unpacked Code_\n\n- Once there, set a “Hardware on Execution” breakpoint to catch when this new code is\nexecuted (Figure 7).\n\n_Figure 7: Hardware Breakpoint on Original Entry Point (OEP)_\n\n- Run the code until the hardware breakpoint is triggered. You can then dump the process\n[using a plugin like OllyDumpEx and fix the import table using Scylla.](http://low-priority.appspot.com/ollydumpex/)\n\n## Correlating Qakbot\n\nFollowing the above process for both files produced two process dumps of the same size\n(418,304 bytes) and different file hashes. Turning again to diaphora revealed that most of the\n227 functions identified matched 100%. Only nine functions did not match 100% (see excerpt\n_in Figure 8)._\n\n_Figure 8: Binary Diff of Unpacked Code From Two Samples_\n\nA review of these nine functions showed that each referenced the file name and/or location\nof the file on disk. Since each file tested did indeed have a different filename and location,\nwe can explain this discrepancy. Therefore, despite variations in the sections across the\ncode, the resulting unpacked binary contains identical functionality.\n\nTo further explore correlation between deobfuscated samples, we can apply the same\nunpacking process to a sample with a different import hash. For example, the file with hash\n8891524E468BE1BD44723385C9238017090B536F922CCC007D8AC47C66802E3C is\n450,560 bytes and has the import hash 651EF2DBA96011F47EED9B72BE7B4B8C. It is\n8,192 bytes smaller than the previous two files and has only six sections (no section hashes\nmatch when compared to previous samples):\n\n.text\n.code\n.rdata\n.data\n.rsrc\n.reloc\n\nThe unpacking approach outlined above results in another dumped 418,304 byte file with a\ndifferent file hash. However, a code diff confirms that most of the 227 identified functions\nmatch 100%, and the nine functions that do not only differ by the filename and path, as\ndescribed earlier.\n\n\n-----\n\n## Conclusion\n\nQakbot continues to be a significant threat due to its credential collection capabilities and\npolymorphic features. Unhindered, this malware family can rapidly propagate through\nnetwork shares and create an enterprise-wide incident. In this post, we explored how to\ndissect, unpack, and compare multiple downloaded samples.\n\n[If you use our endpoint protection product CylancePROTECT®, you were](https://www.cylance.com/en_us/products/our-products/protect.html) [already protected](https://threatvector.cylance.com/en_us/home/cylance-vs-qakbot-malware.html)\nfrom this attack. If you don't have CylancePROTECT, [contact us to learn how our AI-driven](https://www.cylance.com/en_us/contact-us.html)\nsolution can predict and prevent unknown and emerging threats.\n\n## Indicators of Compromise (IoCs)\n\n**Sha-256 Hashes:**\n\n7DBD0DF279062090C34F796EFC7DD239ECCD46B99B67AAC370D6048D5ADBB9EC\n\n67F3BD674647CA0D294A894B6702362B6CFC4B6C2E147643E100903A6B4D715A\n8891524E468BE1BD44723385C9238017090B536F922CCC007D8AC47C66802E3C\n\n**URLs:**\n\nhxxp://css.kbaf.myzen.co(dot)uk/TealeafTarget.php\n\nhxxp://projects.montgomerytech(dot)com/TealeafTarget.php\n\nhxxp://n.abcwd0.seed.fastsecureservers(dot)com/TealeafTarget.php\n\nThe BlackBerry Cylance Threat Research Team\n\n## About The BlackBerry Cylance Threat Research Team\n\nThe BlackBerry Cylance Threat Research team examines malware and suspected malware\nto better identify its abilities, function and attack vectors. Threat Research is on the frontline\nof information security and often deeply examines malicious software, which puts us in a\nunique position to discuss never-seen-before threats.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-05-23 - Quakbot.pdf"
    ],
    "report_names": [
        "2017-05-23 - Quakbot.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535613,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653774855,
    "ts_modification_date": 1653774855,
    "files": {
        "pdf": "https://archive.orkl.eu/d48149c9b6a6518a97b5f617b4d05d4750511472.pdf",
        "text": "https://archive.orkl.eu/d48149c9b6a6518a97b5f617b4d05d4750511472.txt",
        "img": "https://archive.orkl.eu/d48149c9b6a6518a97b5f617b4d05d4750511472.jpg"
    }
}