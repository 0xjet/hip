{
    "id": "35f3d4db-b113-4b10-9d81-e18adbb22e7d",
    "created_at": "2023-01-12T15:03:14.809435Z",
    "updated_at": "2025-03-27T02:05:53.096428Z",
    "deleted_at": null,
    "sha1_hash": "3cdcb801c1f2d8883e9771fbe46fa1927773aa8e",
    "title": "2015-08-18 - Knowledge Fragment- Unwrapping Fobber",
    "authors": "",
    "file_creation_date": "2022-05-28T17:40:18Z",
    "file_modification_date": "2022-05-28T17:40:18Z",
    "file_size": 408369,
    "plain_text": "# Knowledge Fragment: Unwrapping Fobber\n\n**[byte-atlas.blogspot.ch/2015/08/knowledge-fragment-unwrapping-fobber.html](http://byte-atlas.blogspot.ch/2015/08/knowledge-fragment-unwrapping-fobber.html)**\n\nAbout two weeks ago I came across an interesting sample using an interesting anti-analysis\npattern.\n\nThe anti-analysis technique can be best described as \"runtime-only code decryption\". This\nmeans prior to execution of a function, the code is decrypted, then executed and finally\nencrypted again, but with a different key.\n\n[Malwarebytes has already published an analysis on this family they called \"Fobber\".](https://blog.malwarebytes.org/intelligence/2015/06/elusive-hanjuan-ek-caught-in-new-malvertising-campaign/)\n\nHowever, in this blog post I wanted to share how to \"unwrap\" the sample's encrypted\nfunctions for easier analysis. There is also another blog post detailing how to work around\nthe string encryption.\n\n[The sample and code related to this blog post can be found on bitbucket.](https://bitbucket.org/byte_atlas/fobber_decryption)\n\n## Fobber's Function Encryption Scheme\n\nFirst off, let's have a look how Fobber looks in memory, visualized by IDA's function analysis:\n\n\n-----\n\nIDA's first view on Fobber.\n\nIDA only recognizes a handful of functions. Among these is the actual code decryption\nroutine, as well as some code handling translating relevant addresses of the position\nindependent code into absolute offsets.\n\nNext, a closer look at how the on-demand decryption/encryption of functions works:\n\n\n-----\n\nThe Fobber-encrypted function sub_95112A, starting with call to decryptFunctionCode.\n\nWe can see that function sub_95112A starts with a call to what I renamed\n\"decryptFunctionCode\":\n\n\n-----\n\nFobber's on-demand decryption code for functions, revealing the parameter offsets\n\nneccessary for decryption.\n\nThis function does not make use of the stack, thus it is surrounded by a simple\npushad/popad prologue/epilogue. We can see that some references are made relative to the\nreturn address (initially put into esi by copying from [esp+20h]):\n\nField [esi-7] contains a flag indicating whether or not the function is already decrypted.\nField [esi-8h] contains the single byte key for encryption, while\nfield [esi-Ah] contains the length of the encrypted function, stored xor'ed with 0x461F.\n\nThe actual cryptXorCode takes those values as parameters and then loops over the\n\n\n-----\n\nencrypted function body, xor ing with the current key and then updating the key by rotating\n3bit and adding 0x53.\n\nFunction for decrypting one function, given the neccessary parameters.\n\nAfter decryption, our function makes a lot more sense and we can see the default function\nprologue (push ebp; mov ebp, esp) among other things.\n\n\n-----\n\nThe decrypted equivalent of function sub_95112A, revealing some \"real\" code.\n\nAlso note the parameters:\n\n0x951125 - key: 0x7B\n0x951126 - length: 0x4629^0x461F -> 0x36 bytes\n0x951128 - encryption flag: 0x01\n\nSo far so good. Now let's decrypt all of those functions automatically.\n\n## Decrypt All The Things\n\nFirst, we want to find our decryption function. For all Fobber samples I looked at, the regex\nr\"\\x60\\x8B.\\x24\\x20\\x66\" was delivering unique results for locating the decryption function.\n\nNext, we want to find all calls to this decryption function. For this we can use the regex\nr\"\\xE8\" to find all potential \"call rel_offset\" instructions.\n\nThen we just need to do some address math and check if the call destination (calculated as:\nimage_base + call_origin + relative_call_offset + 5) is equal to the address of our decryption\nfunction.\n\nShould this be the case, we can extract the parameters as described above and decrypt the\ncode.\n\n\n-----\n\nWe then only need to exchange the respective bytes in our binary with the decrypted bytes.\nIn the following code I also set the decryption flag and fix the function ending with a \"retn\"\n(0xC3) instruction to ease IDA's job of identifying functions afterwards. Otherwise,\nrinse/repeat until all functions are decrypted.\n\nCode:\n\n#!/usr/bin/env python\n\nimport re\nimport struct\n\ndef decrypt(buf, key):\ndecrypted = \"\"\nfor char in buf:\ndecrypted += chr(ord(char) ^ key)\n# rotate 3 bits\nkey = ((key >> 3) | (key << (8 - 3))) & 0xFF\nkey = (key + 0x53) & 0xFF\nreturn decrypted\n\ndef replace_bytes(buf, offset, bytes):\nreturn buf[:offset] + bytes + buf[offset + len(bytes):]\n\ndef decrypt_all(binary, image_base):\n# locate decryption function\ndecrypt_function_offset = re.search(r\"\\x60\\x8B.\\x24\\x20\\x66\", binary).start()\n# locate all calls to decryption function\nregex_call = r\"\\xe8(?P<rel_call>.{4})\"\nfor match in re.finditer(regex_call, binary):\ncall_origin = match.start()\npacked_call = binary[call_origin + 1:call_origin + 1 + 4]\nrel_call = struct.unpack(\"I\", packed_call)[0]\ncall_destination = (image_base + call_origin + rel_call + 5) & 0xFFFFFFFF\nif call_destination == image_base + decrypt_function_offset:\n# decrypt function and replace/fix\ndecrypted_flag = ord(binary[call_origin - 0x2])\nif decrypted_flag == 0x0:\nkey = ord(binary[call_origin - 0x3])\nsize = struct.unpack(\"H\", binary[call_origin - 0x5:call_origin - 0x3])[0] ^ 0x461F\nbuf = binary[call_origin + 0x5:call_origin + 0x5 + size]\ndecrypted_function = decrypt(buf, key)\nbinary = replace_bytes(binary, call_origin + 0x5, decrypted_function)\nbinary = replace_bytes(binary, call_origin + len(decrypted_function), \"\\xC3\")\n\n\n-----\n\nbinary = replace_bytes(binary, call_origin - 0x2, \\x01 )\nreturn binary\n\n[...]\n\nIDA likes this this already better:\n\nIDA's view on a code-decrypted Fobber sample.\n\nHowever, we are not quite done yet, as IDA still barfs on a couple of functions.\n\n## Conclusion\n\n\n-----\n\nAfter decrypting all functions, we can already start analyzing the sample effectively.\n[But we are not quite done yet, and the second post looks closer at the inline usage of](http://byte-atlas.blogspot.com/2015/08/knowledge-fragment-fobber-inline-string.html)\nencrypted strings.\n\nsample used:\nmd5: 49974f869f8f5d32620685bc1818c957\nsha256: 93508580e84d3291f55a1f2cb15f27666238add9831fd20736a3c5e6a73a2cb4\n\n[Repository with memdump + extraction code](https://bitbucket.org/byte_atlas/fobber_decryption)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2015/2015-08-18 - Knowledge Fragment- Unwrapping Fobber.pdf"
    ],
    "report_names": [
        "2015-08-18 - Knowledge Fragment- Unwrapping Fobber.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535794,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653759618,
    "ts_modification_date": 1653759618,
    "files": {
        "pdf": "https://archive.orkl.eu/3cdcb801c1f2d8883e9771fbe46fa1927773aa8e.pdf",
        "text": "https://archive.orkl.eu/3cdcb801c1f2d8883e9771fbe46fa1927773aa8e.txt",
        "img": "https://archive.orkl.eu/3cdcb801c1f2d8883e9771fbe46fa1927773aa8e.jpg"
    }
}