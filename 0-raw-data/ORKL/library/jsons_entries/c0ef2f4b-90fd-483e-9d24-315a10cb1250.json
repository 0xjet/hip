{
    "id": "c0ef2f4b-90fd-483e-9d24-315a10cb1250",
    "created_at": "2023-01-12T15:02:48.449947Z",
    "updated_at": "2025-03-27T02:13:46.519202Z",
    "deleted_at": null,
    "sha1_hash": "2a3b5c0bc8b24c91bb787f9e69aa3e778101c5ec",
    "title": "2021-07-06 - New TA402-MOLERATS Malware – Decrypting .NET Reactor Strings",
    "authors": "",
    "file_creation_date": "2022-05-27T22:03:44Z",
    "file_modification_date": "2022-05-27T22:03:44Z",
    "file_size": 1277536,
    "plain_text": "# New TA402/MOLERATS Malware – Decrypting .NET Reactor Strings\n\n**[0ffset.net/reverse-engineering/malware-analysis/molerats-string-decryption/](https://www.0ffset.net/reverse-engineering/malware-analysis/molerats-string-decryption/)**\n\n\nJuly 6, 2021\n\n\n-----\n\n[0verfl0w_](https://www.0ffset.net/author/dan489400/)\n6th July 2021\nNo Comments\n\nIt’s sure been a while since the last post! We’ve gone through several iterations of website\ndesign over the past few months (plus fixing all the malformed images due to the theme\ntransfer), but should be back for good now! For this commemorative post, we’ll be diving into\na recently discovered malware sample known as LastConn, a payload used by the\nMOLERATS APT group, which was obfuscated using .NET Reactor. The problem is, de4dot\nis unable to deobfuscate it, so the job falls upon us to do so. We’ll be examining the string\nencryption routine, replicating it in Python, testing it manually, and then automating it\nsomewhat to extract all string related indicators from the binary, and decrypt the relevant\nstrings! Let’s get into it!\n\n**LastConn MD5 Hash: D07654434D64B73FE8CB49CFB9B7E3FB**\n\n## Table Of Contents\n\n MOLERATS: Overview\n\nMOLERATS, also known as TA402, are a Middle Eastern based APT group known for\nperforming intrusions against Middle Eastern Government Organisations, including Israel,\nthe UAE, and Turkey. The most recent campaign, discovered by ProofPoint, once again\n\n\n-----\n\ntargeted government organisations and organisations with diplomatic relationships in the\nMiddle East. The prime focus of the attackers is to exfiltrate sensitive information in order to\ngather intelligence, using spear-phishing as an initial infection vector. In this campaign,\n[ProofPoint discovered the threat actors utilising a somewhat new malware dubbed as](https://www.proofpoint.com/us/blog/threat-insight/new-ta402-molerats-malware-targets-governments-middle-east)\nLastConn.\n\n## LastConn: Overview\n\nLastConn is believed to be an updated version of the SharpStage backdoor, previously\n[discovered by CyberReason back in December 2020. The SharpStage backdoor, developed](https://www.cybereason.com/blog/molerats-apt-new-malware-and-techniques-in-middle-east-espionage-campaign)\nin .NET, utilised DropBox API for exfiltration, and had specific checks for Arabic on the\ninfected machine. LastConn also implemented similar checks, as well as the DropBox API\nfor communication. One of the discovered samples utilised an obfuscator that De4Dot could\nnot successfully deobfuscate, known as .NET Reactor.\n\n## .NET Reactor: Overview\n\n[.NET Reactor is a powerful code protection and software licensing system for software](https://www.eziriz.com/dotnet_reactor.htm)\n_written for the .NET Framework, and supports all languages that generate .NET assemblies._\nIt is commercially available, and provides features such as string encryption, control flow\nobfuscation, and code virtualisation. A free trial is provided for the software as well, which\nseems to have been used by the threat actors, based on a string found in the list of\ndecrypted strings. Talking about decrypted strings, let’s start analysing!\n\n## Initial Analysis:\n\nOpening up the initial sample in PEStudio, we can confirm that we are dealing with a fairly\nlarge .NET binary. At a first look, my thoughts were that the main payload was packed,\nresulting in the large file size, however upon opening the sample in dnSpy we can see that it\nis not packed – in fact we can see the unobfuscated symbols in the Assembly Explorer, with\nclasses like Dropbox.Api and Newtonsoft.Json visible.\n\n\n-----\n\nAs mentioned, .NET Reactor provides functionality to encrypt strings, obfuscate control flow,\nand even virtualise the .NET instructions in a similar fashion to x86 Assembly virtualisation,\nwhich, luckily in this case, the threat actors chose not to enable! Instead, the main methods\nof protection in this binary surround the string encryption and control flow obfuscation, as\nwell as the addition of junk code. We can clearly see this in the entry point function, labelled\nas LsfApkF4M().\n\n\n-----\n\nYou’ll probably notice the junk code (subtraction of 212870 from 277629) which will always\nreturn true. However, the junk code isn’t limited to one-liners; two comparisons are\nperformed between null and the return values from the function dQWY6qG82SAbCK3Pxa()\n– which will also return null. Therefore, we can now take note that a large number of\nfunctions in the binary are probably going to be made up of junk code that all return a\nconstant value.\n\nThe main function of importance inside the entry point is at the very end, where we see the\nsample will execute Form1() – this is where the interesting stuff occurs. However, just before\nthat we do encounter the very first “anti-analysis” check, which is a date check. The sample\nwill refuse to continue execution if it has been executed after the 30th of June, 2021. While\nthis is not the most interesting function, it does show us the first instance of a string\n\n\n-----\n\ndecryption function. If the sample has been executed after the 30th of June, an exception will\nbe thrown. The argument passed to the Exception() call is a string, and is returned from the\nfunction MYcw9uffxdYPAXmUtn.pyM1eVFCveMv9BuGJ6().\n\nUpon checking the identified “anti-analysis” function again, and seeing that the function\nwould display “This assembly is protected by an unregistered version of Eziriz’s “.NET\n_Reactor”! This assembly won’t further work.”, it became clear that this is more likely to be a_\nfunction created by .NET Reactor, to prevent the obfuscated payload working after a specific\ntrial end date.\n\nThis particular function has the value 208444 passed as an argument, indicating that the\nstrings are potentially stored in some kind of an array/list. Regardless, we have now found\nwhat looks to be a string encryption routine, so let’s dive in!\n\n## String Decryption:\n\nUnfortunately for us, the control flow of this function has been highly obfuscated, with\nmultiple goto’s, loops, and plenty of conditional statements. However, we can piece some\ninformation together just by scrolling through the lines of code. Firstly, there is an array\nvariable which is constantly changing through the flow of execution, at least in the first loop.\nIt changes so often it would be very time consuming to manually calculate the bytes inside\nthe variable, and so dynamic analysis will have to be used.\n\n\n-----\n\nNext, we can see a variable named binaryReader is referred to quite a lot throughout the\nfunction. A simple CTRL+F indicates this will contain data read from the resource\n_28VD5i1hSj4mcdhHmc.KIl6nvHWBWAvSEm7PO. Initially, this data does not seem to be_\nused for anything interesting, however it is a strange blob of data and is still referenced in the\nfunction, so let’s go ahead and extract that to be used later on.\n\nAt the very end of the string decryption function, we can clearly see the variable returned is\nnamed string, and it is retrieved through the variable array3. array3 is initialized above, with\na Copy() call, which will copy the data from MYcw9uffxdYPAXmUtn.aAgdDBUcpQV to\n**array3. Another point of interest is the usage of the argument M448gdJtBGnIC5sjsy as the**\nindex – this argument is equal to 208444 in the first call to this function.\n\n\n-----\n\n**MYcw9uffxdYPAXmUtn.aAgdDBUcpQV is initialised using data inside 3 variables, and a**\nfunction call: array, array2, u, and MYcw9uffxdYPAXmUtn().K5vdDAvqBdJ(). array and\n**array2 are dynamically generated through the multiple loops and conditional statements, but**\n**u on the other hand contains the data inside binaryReader: the resource data we dumped**\npreviously.\n\nThe function MYcw9uffxdYPAXmUtn().K5vdDAvqBdJ() is our first real algorithm inside the\nstring encryption routine. The algorithm itself is seemingly custom to .NET Reactor, and uses\nthe data inside array to decrypt the resource data. The decrypted data is stored as an array,\nat which point the integer passed in as an argument to the initial string encryption routine is\nused as an offset.\n\nEnough about theory, let’s go ahead and debug the sample using dnSpy to extract the data\ninside array and array2, and then we can move onto looking at replicating the algorithm!\n\n\n-----\n\nDoing so should be fairly simple, as we know where the decrypted data is returned, so we\njust need to set a breakpoint on the function MYcw9uffxdYPAXmUtn().K5vdDAvqBdJ(), and\nthen dump the data inside the target variables. Buuut we cannot place a breakpoint on that\naddress, as dnSpy cannot create one.\n\nInstead, we will place a breakpoint just after the try block has come to an end, so where the\nvariable num5 is initialised. Sure enough, we can now dump both target variables – array is\n32 bytes long, and array2 is 16 bytes long, indicating a possible key and IV setup. With all\nthe pieces of the puzzle, we can now go ahead and attempt to replicate the decryption!\n\n\n-----\n\n## Replicating Algorithms:\n\nWe will be replicating the algorithm in Python, and luckily as dnSpy decompiles .NET\nbinaries very well, it should be a somewhat quick process considering how closely\ndecompiled .NET resembles Python. Before we do that, let’s go ahead and run the binary\nthrough de4dot, as it will provide us a nice base to work off by removing as much obfuscation\nas it can.\n\n\n-----\n\nViewing the string encryption function, it is clear that de4dot has done a great job. The\nbiggest difference however is inside the custom algorithm, in the function mmmdDDP5Yd6().\nIn the images below, you can see the difference between the original binary (left), and the\nde4dot altered binary (right). This difference will make it a lot easier to replicate the\nalgorithm.\n\nSo, let’s start by implementing the mmmdDDP5Yd6() function. If we were to copy and paste\nit (and remove the U’s), it would execute correctly, but the returned value would be incorrect.\nThe reason for this is Python is happy to work on a 64 bit integer, and so if we were to\nexecute the code using 4 as the value for the uint_0 variable, the result would be –\n**0x627474A8294. We only want to deal with 32 bit values, so we will be using &**\n**0xFFFFFFFF in our function a lot; specifically on every line, like shown below.**\n\nRunning the updated code, using the same value for uint_0, we get 0xB8B4C22C. So now\nwe know we can avoid dealing with 64 bit integers, we can jump back to the main algorithm,\nand replicate that!\n\nThe rest of the algorithm is fairly simple to implement, however there is 1 global variable that\nstands out: K2qdDH9707O. This is assigned in a call just before the string encryption\nalgorithm, and is in fact the data stored inside the variable array. Interestingly, array2 does\nnot seem to be used at all throughout the function, so we can ignore it from here on out.\n\n\n-----\n\nAfter converting the script from .NET to Python, we can now go ahead and test it! We already\nhave the array data, and the resource data, so all we need to figure out is how the function\nuses the argument to locate the correct string.\n\nWell, we don’t need to look very hard to find it – jumping right to the end we can see a fairly\nsimple block of code, which we covered at the beginning of the String Decryption chapter.\n\n\n-----\n\nFirst, num3 is calculated by calling ToInt32() and passing\n**MYcw9uffxdYPAXmUtn.aAgdDBUcpQV as the source data, and M448gdJtBGnIC5sjsy**\n(the function argument) as the start index. Next, the variable array3 is initialized to the size\nof num3, so we can safely assume that num3 is a string size. array3 is then filled with data\nfrom MYcw9uffxdYPAXmUtn.aAgdDBUcpQV, with the start index set to\n**M448gdJtBGnIC5sjsy + 4. This means the strings will be stored as follows:**\n```\n[4 BYTE SIZE][STRING]\n\n```\nAnd that is pretty much it! The string blob itself is decrypted all at once, and so the argument\nis only used to retrieve a specific string in the decrypted data. Putting all this together, we get\nthe following script:\n\n\n-----\n\nRunning it with a few values we can find in the script also yields some nice results! We can\nalso just dump all the decrypted strings to browse through, to get a good idea of what this\ntool is capable of doing!\n\nNow, it is all good being able to decrypt strings with user input, but let’s take this one step\nfurther and attempt to automate it!\n\n## Semi-Automation:\n\nAutomation is where things start to become quite complex. I don’t typically focus on .NET\nmalware, and so there’s still a number of things I have to figure out – including figuring out\nhow to have an automated string decrypter resolve strings or even comment similar to\nIDAPython. Currently, the automation of this string decrypter goes as far as locating all calls\nto the string decryption function, extracting the offset, and returning the correct string for that\nfunction. Unfortunately, this is where that stops. I have yet to successfully overwrite the IL\ninstructions with a simple ldstr (like [this blog post), and receive the following error:](https://rhotav.github.io/stringdecryptionwithpythonen)\n\n\n-----\n\nIf anyone has any idea what the issue is, I’d be very grateful if you could let me know!\nRegardless, let’s have a look at how we can use Python and DNLIB to locate function calls\nand offset arguments in the binary!\n\nIn order to load the dnlib library, we need to make sure we have pythonnet installed, which\ncan be installed using pip install pythonnet. Additionally, make sure you have the DNLIB DLL\ndownloaded! With that, we need to import the Common Language Runtime (manages\nexecution of .NET programs), as well as the System.Reflection namespace. This can be\ndone as follows:\n```\nimport clr\nfrom System.Reflection import Assembly, MethodInfo, BindingFlag\nfrom System import Type\n\n```\nThen, we need to load DNLIB using clr.AddReference(). This allows us to import functions\nfrom DNLIB, including the DotNet namespace. And now we’re ready to start parsing .NET\nbinaries!\n```\nclr.AddReference(r\"dnlib\")\nimport dnlib\nfrom dnlib.DotNet import *\nfrom dnlib.DotNet.Emit import OpCodes\n\n```\n[The parsing code was adapted from polynomenx’s](https://twitter.com/Rhotav) [blog post as listed above, and it is a](https://rhotav.github.io/stringdecryptionwithpythonen)\nbrilliant example of what is possible pairing DNLIB with Python. In this case, we can search\nthrough the binary in a similar way, searching for all mentions of the method\n**pyM1eVFCveMv9BuGJ6.**\n\n\n-----\n\nAfter executing the above script, we can view the glory that is automation! We can print all\nthe strings, or simply pipe the output to a file to view later on – providing us with the same\n[output that ProofPoint uploaded to their GitHub. While .NET Reactor obfuscated malware](https://github.com/EmergingThreats/threatresearch/blob/master/LastConn/decrypted_strs.txt)\ndoes not use the same encryption key, it’s fairly simple to reverse the string encryption (at\nleast in this version) and use the tools we covered in this post to develop a semi-automated\nstring decrypter, speeding your analysis up by 10-fold!\n\n\n-----\n\n[You can grab the full (and cleaned up) script from here!](https://github.com/0ffsetTrainingSolutions/MOLERATS/blob/main/StringDecrypt/reactor_decrypt.py)\n\nIt’s currently optimized for Python 2.7, but with some slight alterations it should be good to go\nfor Python 3!\n\nAfter uploading the script I noticed some issues with it not picking up several calls to the\nstring decryption function inside the main Pro.Form1(). It does pick up quite a few strings,\nthough there are some obvious strings that do not appear in the dump, but are visible in the\nstring dump on the ProofPoint ThreatResearch Github.\n\nIt could just be that I’m running the entire thing in Python instead of C#, but if anyone knows\nthe specifics I’d love to find out!\n\nAnd that wraps up this post on decrypting the strings inside the MOLERATS LastConn\npayload!\n\nYou may have noticed the changes to the website design, as well as cleaned up the course\npage – now we have finally finished working on the design and restoration, posts will be\nmore frequent, so stay tuned! We’ve got quite a lot planned over the next few months!\n\nAnyway, if you’ve got any feedback or questions, feel free to drop a comment down below,\n[drop me a message over Twitter (@0verfl0w_), or via email (daniel@0ffset.net)!](https://twitter.com/0verfl0w_)\n\nThanks for taking the time to read through the post!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-06 - New TA402-MOLERATS Malware – Decrypting .NET Reactor Strings.pdf"
    ],
    "report_names": [
        "2021-07-06 - New TA402-MOLERATS Malware – Decrypting .NET Reactor Strings.pdf"
    ],
    "threat_actors": [
        {
            "id": "0ad97d64-7970-48ca-83f6-3635c66e315c",
            "created_at": "2023-11-21T02:00:07.400003Z",
            "updated_at": "2025-03-27T02:00:03.251874Z",
            "deleted_at": null,
            "main_name": "TA402",
            "aliases": [],
            "source_name": "MISPGALAXY:TA402",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "1162e0d4-b69c-423d-a4da-f3080d1d2b0c",
            "created_at": "2023-01-06T13:46:38.508262Z",
            "updated_at": "2025-03-27T02:00:02.851407Z",
            "deleted_at": null,
            "main_name": "Molerats",
            "aliases": [
                "Gaza Hackers Team",
                "Gaza cybergang",
                "Gaza Cybergang",
                "Operation Molerats",
                "Extreme Jackal",
                "ALUMINUM SARATOGA",
                "G0021",
                "BLACKSTEM"
            ],
            "source_name": "MISPGALAXY:Molerats",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "0c502f6d-640d-4e69-bfb8-328ba6540d4f",
            "created_at": "2022-10-25T15:50:23.756782Z",
            "updated_at": "2025-03-27T02:00:55.539397Z",
            "deleted_at": null,
            "main_name": "Molerats",
            "aliases": [
                "Molerats",
                "Operation Molerats",
                "Gaza Cybergang"
            ],
            "source_name": "MITRE:Molerats",
            "tools": [
                "MoleNet",
                "DustySky",
                "DropBook",
                "SharpStage",
                "PoisonIvy"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "0a03e7f0-2f75-4153-9c4f-c46d12d3962e",
            "created_at": "2022-10-25T15:50:23.453824Z",
            "updated_at": "2025-03-27T02:00:55.473216Z",
            "deleted_at": null,
            "main_name": "Ke3chang",
            "aliases": [
                "Ke3chang",
                "APT15",
                "Vixen Panda",
                "GREF",
                "Playful Dragon",
                "RoyalAPT",
                "Nylon Typhoon"
            ],
            "source_name": "MITRE:Ke3chang",
            "tools": [
                "Okrum",
                "Systeminfo",
                "netstat",
                "spwebmember",
                "Mimikatz",
                "Tasklist",
                "MirageFox",
                "Neoichor",
                "ipconfig"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "7c8cf02c-623a-4793-918b-f908675a1aef",
            "created_at": "2023-01-06T13:46:38.309165Z",
            "updated_at": "2025-03-27T02:00:02.801298Z",
            "deleted_at": null,
            "main_name": "APT15",
            "aliases": [
                "BRONZE PALACE",
                "Nylon Typhoon",
                "VIXEN PANDA",
                "Playful Dragon",
                "BRONZE DAVENPORT",
                "BRONZE IDLEWOOD",
                "G0004",
                "Red Vulture",
                "Ke3Chang",
                "Metushy",
                "Lurid",
                "Social Network Team",
                "Royal APT"
            ],
            "source_name": "MISPGALAXY:APT15",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "847f600c-cf90-44c0-8b39-fb0d5adfcef4",
            "created_at": "2022-10-25T16:07:23.875541Z",
            "updated_at": "2025-03-27T02:02:10.005591Z",
            "deleted_at": null,
            "main_name": "Molerats",
            "aliases": [
                "ATK 89",
                "Aluminum Saratoga",
                "Extreme Jackal",
                "Gaza Cybergang",
                "Gaza Hackers Team",
                "Molerats",
                "Operation DustySky",
                "Operation DustySky Part 2",
                "Operation Molerats",
                "Operation Moonlight",
                "Operation SneakyPastes",
                "Operation TopHat",
                "TA402",
                "TAG-CT5"
            ],
            "source_name": "ETDA:Molerats",
            "tools": [
                "BadPatch",
                "Bladabindi",
                "BrittleBush",
                "Chymine",
                "CinaRAT",
                "Darkmoon",
                "Downeks",
                "DropBook",
                "DustySky",
                "ExtRat",
                "Gen:Trojan.Heur.PT",
                "H-Worm",
                "H-Worm RAT",
                "Houdini",
                "Houdini RAT",
                "Hworm",
                "Iniduoh",
                "IronWind",
                "Jenxcus",
                "JhoneRAT",
                "Jorik",
                "KasperAgent",
                "Kognito",
                "LastConn",
                "Micropsia",
                "MoleNet",
                "Molerat Loader",
                "NeD Worm",
                "NimbleMamba",
                "Njw0rm",
                "Pierogi",
                "Poison Ivy",
                "Quasar RAT",
                "QuasarRAT",
                "SPIVY",
                "Scote",
                "SharpSploit",
                "SharpStage",
                "WSHRAT",
                "WelcomeChat",
                "Xtreme RAT",
                "XtremeRAT",
                "Yggdrasil",
                "dinihou",
                "dunihi",
                "njRAT",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "efe6ff9a-822d-41a6-90c3-45265cac696b",
            "created_at": "2024-05-01T02:03:07.920302Z",
            "updated_at": "2025-03-27T02:05:17.246342Z",
            "deleted_at": null,
            "main_name": "ALUMINUM SARATOGA",
            "aliases": [
                "Arid Viper",
                "Desert Falcon",
                "Extreme Jackal ",
                "Gaza CyberGang",
                "Gaza CyberGang",
                "Molerats ",
                "Operation DustySky ",
                "TA402",
                "APT-C-23"
            ],
            "source_name": "Secureworks:ALUMINUM SARATOGA",
            "tools": [
                " BrittleBush",
                " DarkComet",
                " LastConn",
                " Micropsia",
                " NimbleMamba",
                " PoisonIvy",
                " QuasarRAT",
                " XtremeRat",
                "BlackShades"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535768,
    "ts_updated_at": 1743041626,
    "ts_creation_date": 1653689024,
    "ts_modification_date": 1653689024,
    "files": {
        "pdf": "https://archive.orkl.eu/2a3b5c0bc8b24c91bb787f9e69aa3e778101c5ec.pdf",
        "text": "https://archive.orkl.eu/2a3b5c0bc8b24c91bb787f9e69aa3e778101c5ec.txt",
        "img": "https://archive.orkl.eu/2a3b5c0bc8b24c91bb787f9e69aa3e778101c5ec.jpg"
    }
}