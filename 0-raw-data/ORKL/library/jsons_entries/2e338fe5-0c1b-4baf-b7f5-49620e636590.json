{
    "id": "2e338fe5-0c1b-4baf-b7f5-49620e636590",
    "created_at": "2023-05-06T02:08:27.376565Z",
    "updated_at": "2025-03-27T02:16:26.162865Z",
    "deleted_at": null,
    "sha1_hash": "a48467c67bfbefd86def4eec0a04dc6b98ec9355",
    "title": "2023-04-17 - An in-depth look at the Golang Windows calls",
    "authors": "",
    "file_creation_date": "2023-05-05T02:00:31Z",
    "file_modification_date": "2023-05-05T02:00:31Z",
    "file_size": 1044829,
    "plain_text": "# An in-depth look at the Golang Windows calls\n\n**[leandrofroes.github.io/posts/An-in-depth-look-at-Golang-Windows-calls/](https://leandrofroes.github.io/posts/An-in-depth-look-at-Golang-Windows-calls/)**\n\nLeandro Fróes April 17, 2023\n\nPosted Apr 17, 2023\nBy\n_29 min read_\n\nHi! This is my very first blog entry! I’ve created this blog to do both force myself to publish\nmore of my study notes as well as to share as much as I can online so I hope you enjoy it.\n=)\n\n## Disclaimer\n\nIt’s important to mention this research is a work in progress and might receive updates\nin the future. If you find anything wrong here please let me know and I’ll be happy to\nfix it!\n\n\n-----\n\nThe code snippets presented in this blogpost were obtained from the Golang source\ncode. To make it easier to understand I added some more comments on it and\nremoved some parts of the code for better visualization.\nWhen I started this research I found no one talking about these internals aspects,\nspecially how those could be abused so I’m assuming what I’m presenting here is a\nkind of “novel approach” (uuuh, fancy… hahaha). If you know someone that did this\nkind of work in the past please let me know! I would love to check it.\n\n## Motivation\n\nAt the end of last year (2022) I had to analyze some obfuscated and trojanized Go\nmalwares, basically perform some triage to know more about what it does and how it does\nthe stuff. Due to the Go nuances and runtime aspects my first approach was analyze it\nstatically and after some time into it I thought I was wasting too much time for what should\nbe just a simple triage in the first place.\n\nThat said, I decided to go to a dynamic approach and my first idea was something that I\nthink most part of RE people would do: trace the API calls. In order to do that I used API\nMonitor cause it’s easy to use and very powerful. Unfortunatelly the output was very noisy\nand not that complete and I was not happy with it. This experiment made me ask myself\nwhy it’s that noisy? How are those Windows API calls performed? And this is how I started\nthis research.\n\n## From a Golang function to the Windows API\n\nThe big question we want to answer in this blogpost is: what happens when an application\ncompiled using Go calls a function? Regardless what it does in the middle the program\nwould need to either compile the Windows libraries statically or call into the OS functions at\nsome point (e.g. calling the exported function, performing the syscall directly, etc)\n\n### A simple Go call\n\nTo answer that question, let’s take the Hostname function from the [os package as an](https://pkg.go.dev/os)\nexample:\n\n\n-----\n\n```\n  package os\n\n  // Hostname returns the host name reported by the\n  kernel.\n\n  func Hostname() (name string, err error) {\n\n       return hostname()\n\n  }\n\n```\nAs we can see, this function is just a wrapper for another function named hostname, also\ndefined in the os package:\n\n\n-----\n\n```\nfunc hostname() (name string, err error) {\n\n     // Use PhysicalDnsHostname to uniquely identify host in a cluster\n\n     const format = windows.ComputerNamePhysicalDnsHostname\n\n     n := uint32(64)\n\n     for {\n\n          b := make([]uint16, n)\n\n          err := windows.GetComputerNameEx(format, &b[0], &n) // Our\ntarget\n\n          if err == nil {\n\n              return syscall.UTF16ToString(b[:n]), nil\n\n          }\n\n          if err != syscall.ERROR_MORE_DATA {\n\n              return \"\", NewSyscallError(\"ComputerNameEx\", err)\n\n          }\n\n          // If we received an ERROR_MORE_DATA, but n doesn't get\nlarger,\n\n          // something has gone wrong and we may be in an infinite\nloop\n\n          if n <= uint32(len(b)) {\n\n              return \"\", NewSyscallError(\"ComputerNameEx\", err)\n\n          }\n\n     }\n\n}\n\n```\n\n-----\n\nDespite some checks performed this function is very simple, it just calls a function named\n```\nGetComputerNameEx in the windows package in order to get the hostname. The curious\n\n```\n[thing about it is that the name of this function is also the name of a Windows API function](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamew)\nthat is also used to retrieve the hostname.\n\n[Doing a quick search in the Go source code we can find the function implementation and](https://github.com/golang/go)\nnotice it ends up calling a function named Syscall:\n```\n  func GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) {\n\n       r1, _, e1 := syscall.Syscall(procGetComputerNameExW.Addr(), 3,\n  uintptr(nametype), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)))\n\n       if r1 == 0 {\n\n           err = errnoErr(e1)\n\n       }\n\n       return\n\n  }\n\n\n```\nTo understand what’s going on here let’s start looking at the procGetComputerNameExW\nvariable being passed as the first parameter to the Syscall function.\n\nChecking a bit more into the windows package source we can see this\n```\nprocGetComputerNameExW variable being initialized earlier using both the NewLazyDLL and\nNewProc functions:\n\n```\n\n-----\n\n```\n  moddwmapi  = NewLazySystemDLL(\"dwmapi.dll\")\n\n  modiphlpapi = NewLazySystemDLL(\"iphlpapi.dll\")\n\n  modkernel32 = NewLazySystemDLL(\"kernel32.dll\") // Our target module\n\n  modmswsock = NewLazySystemDLL(\"mswsock.dll\")\n\n  modnetapi32 = NewLazySystemDLL(\"netapi32.dll\")\n\n  // reducted\n\n  procGetCommTimeouts = modkernel32.NewProc(\"GetCommTimeouts\")\n\n  procGetCommandLineW = modkernel32.NewProc(\"GetCommandLineW\")\n\n  procGetComputerNameExW = modkernel32.NewProc(\"GetComputerNameExW\") // Our target\n  function\n\n  procGetComputerNameW = modkernel32.NewProc(\"GetComputerNameW\")\n\n  procGetConsoleMode = modkernel32.NewProc(\"GetConsoleMode\")\n\n```\nThe first thing to notice here is that there’s a lot of real Windows API function and DLL\nnames being passed to those functions. At this point we can start to assume this might\nhave something to do with the API itself, so let’s keep going!\n\nWhat those two functions being used do is simply initialize the procGetComputerNameExW\nvariable as a LazyProc and that will basically allow it to have access to the Addr function,\nwhich is the function being called in the parameter for the syscall.Syscall call:\n```\n  // NewLazyDLL creates new LazyDLL associated with DLL file.\n\n  func NewLazyDLL(name string) *LazyDLL {\n\n       return &LazyDLL{Name: name}\n\n  }\n\n  type LazyDLL struct {\n\n       Name string\n\n       // System determines whether the DLL must be loaded from the\n\n       // Windows System directory, bypassing the normal DLL search\n\n       // path.\n\n       System bool\n\n       mu sync.Mutex\n\n       dll *DLL // non nil once DLL is loaded\n\n```\n\n-----\n\n```\n}\n\n// NewProc returns a LazyProc for accessing the named procedure in the\nDLL d.\n\nfunc (d *LazyDLL) NewProc(name string) *LazyProc {\n\n     return &LazyProc{l: d, Name: name}\n\n}\n\n// A LazyProc implements access to a procedure inside a LazyDLL.\n\n// It delays the lookup until the Addr function is called.\n\ntype LazyProc struct {\n\n     Name string\n\n     mu  sync.Mutex\n\n     l  *LazyDLL\n\n     proc *Proc\n\n}\n\n```\n\n-----\n\n### Resolving the Windows API functions\n\nOnce the Addr function is called it performs some calls here and there but the important\nfunction it calls is named Find. This function calls a function named Load followed by one\nnamed FindProc:\n```\n  // Addr returns the address of the procedure represented by p.\n\n  // The return value can be passed to Syscall to run the procedure.\n\n  // It will panic if the procedure cannot be found.\n\n  func (p *LazyProc) Addr() uintptr {\n\n       p.mustFind()\n\n       return p.proc.Addr()\n\n  }\n\n  // mustFind is like Find but panics if search fails.\n\n  func (p *LazyProc) mustFind() {\n\n       e := p.Find()\n\n       if e != nil {\n\n           panic(e)\n\n       }\n\n  }\n\n  func (p *LazyProc) Find() error {\n\n       // Non-racy version of:\n\n       // if p.proc == nil {\n\n       if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc))) == nil\n  { // Check if the func addr is not resolved already\n\n           p.mu.Lock()\n\n           defer p.mu.Unlock()\n\n           if p.proc == nil {\n\n                e := p.l.Load() // Attempt to load the module\n\n                if e != nil {\n\n                     return e\n\n                }\n\n                proc, e := p.l.dll.FindProc(p.Name) // Resolve export\n  function addr\n\n                if e != nil {\n\n                     return e\n\n                }\n\n                // Non-racy version of:\n\n                // p.proc = proc\n\n                atomic.StorePointer((*unsafe.Pointer)\n  (unsafe.Pointer(&p.proc)), unsafe.Pointer(proc))\n\n           }\n\n       }\n\n       return nil\n\n  }\n\n```\n\n-----\n\n-----\n\nIf you’re a bit familiar with Windows and RE you probably already figured what’s going on\nhere. The Load function is responsible for loading the module in which exports the\nrequested Windows API function and FindProc resolves the exported function address.\nThis steps are performed using the classic combination of LoadLibrary + GetProcAddress:\n```\n  func (d *LazyDLL) Load() error {\n\n       // Non-racy version of:\n\n       // if d.dll != nil {\n\n       if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll))) != nil\n  { // Check if the module is loaded already\n\n           return nil\n\n       }\n\n       d.mu.Lock()\n\n       defer d.mu.Unlock()\n\n       if d.dll != nil {\n\n           return nil\n\n       }\n\n       // kernel32.dll is special, since it's where LoadLibraryEx comes from.\n\n       // The kernel already special-cases its name, so it's always\n\n       // loaded from system32.\n\n       var dll *DLL\n\n       var err error\n\n       if d.Name == \"kernel32.dll\" {\n\n           dll, err = LoadDLL(d.Name) // Wrapper to syscall_loadlibrary\n\n       } else {\n\n           dll, err = loadLibraryEx(d.Name, d.System) // Wrapper to\n  LoadLibraryExW\n\n       }\n\n       if err != nil {\n\n           return err\n\n       }\n\n       // Non-racy version of:\n\n       // d.dll = dll\n\n       atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll)),\n  unsafe.Pointer(dll))\n\n       return nil\n\n  }\n\n  func LoadDLL(name string) (dll *DLL, err error) {\n\n       namep, err := UTF16PtrFromString(name)\n\n       if err != nil {\n\n           return nil, err\n\n       }\n\n       h, e := syscall_loadlibrary(namep) // Perform the LoadLibraryA call\n\n       if e != 0 {\n\n           return nil, &DLLError{\n\n                Err:   e,\n\n                ObjName: name,\n\n                Msg:   \"Failed to load \" + name + \": \" + e.Error(),\n\n           }\n\n       }\n\n       d := &DLL{\n\n           Name:  name,\n\n           Handle: h,\n\n       }\n\n```\n\n-----\n\n```\n     return d, nil\n\n}\n\n// loadLibraryEx wraps the Windows LoadLibraryEx function.\n\n//\n// See https://msdn.microsoft.com/enus/library/windows/desktop/ms684179(v=vs.85).aspx\n\n//\n// If name is not an absolute path, LoadLibraryEx searches for the DLL\n\n// in a variety of automatic locations unless constrained by flags.\n\n// See: https://msdn.microsoft.com/en-us/library/ff919712%28VS.85%29.aspx\n\nfunc loadLibraryEx(name string, system bool) (*DLL, error) {\n\n     loadDLL := name\n\n     var flags uintptr\n\n     if system {\n\n          if canDoSearchSystem32() {\n\n              flags = LOAD_LIBRARY_SEARCH_SYSTEM32\n\n          } else if isBaseName(name) {\n\n              // WindowsXP or unpatched Windows machine\n\n              // trying to load \"foo.dll\" out of the system\n\n              // folder, but LoadLibraryEx doesn't support\n\n              // that yet on their system, so emulate it.\n\n              systemdir, err := GetSystemDirectory()\n\n              if err != nil {\n\n                   return nil, err\n\n              }\n\n              loadDLL = systemdir + \"\\\\\" + name\n\n          }\n\n     }\n\n     h, err := LoadLibraryEx(loadDLL, 0, flags) // Wrapper to syscall.Syscall\nusing procLoadLibraryExW\n\n     if err != nil {\n\n          return nil, err\n\n     }\n\n     return &DLL{Name: name, Handle: h}, nil\n\n}\n\n// FindProc searches DLL d for procedure named name and returns *Proc\n\n// if found. It returns an error if search fails.\n\nfunc (d *DLL) FindProc(name string) (proc *Proc, err error) {\n\n     namep, err := BytePtrFromString(name)\n\n     if err != nil {\n\n          return nil, err\n\n     }\n\n     a, e := syscall_getprocaddress(d.Handle, namep) // Perform the\nGetProcAddress call\n\n     if e != 0 {\n\n          return nil, &DLLError{\n\n              Err:   e,\n\n              ObjName: name,\n\n              Msg:   \"Failed to find \" + name + \" procedure in \" +\nd.Name + \": \" + e.Error(),\n\n          }\n\n     }\n\n     p := &Proc{\n\n          Dll: d,\n\n          Name: name,\n\n          addr: a,\n\n     }\n\n     return p, nil\n\n}\n\n```\n\n-----\n\n-----\n\n-----\n\n-----\n\nWhat version of the LoadLibrary function it uses? It depends. During the runtime\n[initialization it uses LoadLibraryA to load kernel32.dll and LoadLibraryExA to load the rest of](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya)\n[the modules the runtime requires. All the other modules are loaded via LoadLibraryExW. Of](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexw)\ncourse this can change in future versions of Go so what really matters here is that the\nmodule will be loaded.\n\nOnce the address of the desired function is obtained it’s returned by the previously\nmentioned Addr function and passed to the syscall.Syscall function.\n\nVery nice, right?! This is exactly how Golang resolves the address of (almost) all the\nWindows API functions required by a Golang application. So yes, it’s basically the classic\n[runtime linking approach.](https://learn.microsoft.com/en-us/windows/win32/dlls/run-time-dynamic-linking)\n\nNow you might be wondering: ok, the desired Windows API functions are resolved using\n```\nGetProcAddress, but how is the address of GetProcAddress function resolved? Well,\n\n```\nthere’s no magic here. The GetProcAddress address, along with other functions the runtime\npackage depends on are present in every Golang application Import Table, so their\naddresses are resolved by the Windows Loader in load time.\n\n_[Example of the Import Table of a Golang application using DIE](https://github.com/horsicq/Detect-It-Easy)_\n\n\n-----\n\nAnother question that you might ask is: are literally all the Windows API functions resolved\nthis way? Well, not exactly. As mentioned already, some functions used by the runtime\npackage would be resolved by the Windows loader, but there’s some others that seems to\nbe “optional” (but still part of the runtime package and still resolved) that would take a\ndifferent path and do not rely on those “Syscall” calls. Those would use calls with the\n```\nstdcall prefix. However, regardless the path it takes those would still rely on\nGetProcAddress and will take the same “final path”. We’ll learn more about it in a bit.\n\n```\nSince most part of the functions we care about (the ones that are not part of the runtime)\nare resolved using the Syscall path we’ll focus on those.\n\nThat said, if we search for some function named like “syscall_whatever” (e.g.\n```\nsyscall_CreateFile) in a tool like IDA we’ll always see exactly the functions we discussed\n\n```\nbeing called (i.e. Addr followed by a Syscall<n>).\n\n_Disassembly view of syscall_CreateFile in IDA_\n\nIf you want to play with what we’ve learned so far here’s a nice exercise for you: a way to\nmonitor what Windows API functions are being resolved by a Go application is setting a\n[conditional breakpoint at GetProcAddress using x64dbg and logging the second parameter](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)\n\n\n-----\n\nto the call (lpProcName). Then you can use something like {utf8@rdx} (x64 environment in\nthis case) as the log text and 0 as the break condition to make sure it will not break. By\ndoing so you’re going to see functions from all the packages being resolved in the Log\noutput:\n\n_Example of the functions_\n\n_resolved by a Go application using x64dbg_\n\nSince both the runtime package and the other dependencies would rely on GetProcAddress\nthe output would be a bit noisy, but still interesting. By the end of this article we’ll learn how\nto filter the noise and only get the functions being resolved by the main package.\n\nNow that we kind of understand part of the chain the remanining question is: how are the\ncalls actually performed? How the Go package interacts with the Windows API? We saw\nfunctions like syscall_getprocaddress being called or even the syscall.Syscall one, but\nwhat exactly happens there?\n\nBefore we move forward I would like to give a step back and introduce a few more concepts\nto make the rest of the reading easier to follow.\n\n## Goroutines\n\nA [goroutine can be defined as a function executing concurrently with other goroutines in the](https://go.dev/tour/concurrency/1)\nsame address space. Go implements an architecture that uses way less resources than the\nregular threads to execute code. Some examples that make goroutines kind of better in\nterms of performance when compared against the regular multithreading model is that\nusually it’s stack start very small (around 2KB) and it doesn’t need to switch to kernel mode\nor save too much registers in the context switch.\n\n\n-----\n\nAll the goroutines are handled by an usermode scheduler implemented in the Go runtime\npackage. During execution the Go runtime creates a few threads and schedules the\ngoroutines onto those OS threads to be executed. Once a goroutine is blocked in an\noperation (e.g. sleep, network input, channel operations) the scheduler changes the context\nto other goroutines, with no impact in the real threads. This architecture makes Go\napplications very performatic cause although they’re multithread some of the negative\nimpacts caused by the classic multithread approach are handled by the runtime.\n\nOf course regardless this abstraction the code would still end up going through the real\nthread, but the key here is the design of the language.\n\n## The Go Scheduler\n\nGo implements a scheduler that works in an M:N model, where M goroutines are scheduled\nonto N OS threads throughout the program execution. The scheduler manages three types\nof resources:\n```\n   G: represents a goroutine and contains information about the code to execute.\n   M: represents an OS thread and where to execute the goroutine code.\n   P: represents a “processor”. Basically a resource that is required to execute Go code.\n\n```\nThe max number of Ps is defined in the GOMAXPROCS var.\n\nEach M must be associated to a P and a P can have multiple M, but only one can be\nexecuting. The scheduler works with a global and a local queue of goroutines and manages\ntheir execution using a work sharing/stealing model.\n\nAnd how Go creates/handles these structures for each thread? It uses the Windows Thread\nLocal Storage (TLS) mechanism.\n\n## The Go system calls\n\nAlright, now let’s go back to the GetComputerNameEx function. Remember the\n```\nsyscall.Syscall call? It turns out that Golang defines several functions using the “Syscall”\n\n```\nprefix and those are all wrappers to another function named SyscallN:\n```\n  //go:linkname syscall_Syscall syscall.Syscall\n\n  //go:nosplit\n\n  func syscall_Syscall(fn, nargs, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n\n       return syscall_SyscallN(fn, a1, a2, a3)\n\n  }\n\n  //go:linkname syscall_Syscall6 syscall.Syscall6\n\n  //go:nosplit\n\n  func syscall_Syscall6(fn, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err\n  uintptr) {\n\n       return syscall_SyscallN(fn, a1, a2, a3, a4, a5, a6)\n\n```\n\n-----\n\n```\n  }\n\n  //go:linkname syscall_Syscall9 syscall.Syscall9\n\n  //go:nosplit\n\n  func syscall_Syscall9(fn, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr)\n  (r1, r2, err uintptr) {\n\n       return syscall_SyscallN(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9)\n\n  }\n\n  //go:linkname syscall_Syscall12 syscall.Syscall12\n\n  //go:nosplit\n\n  func syscall_Syscall12(fn, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,\n  a12 uintptr) (r1, r2, err uintptr) {\n\n       return syscall_SyscallN(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n  a11, a12)\n\n  }\n\n  // etc\n\n```\nThe rule for the number following the “Syscall” prefix is based on the number of arguments\nthe function takes. The Syscall takes up to 3 arguments, the Syscall6 takes from 4 to 6,\nthe Syscall9 takes from 7 to 9 and so on.\n\n\n-----\n\nWhy Go implements it this way? I m not sure, maybe to avoid the need to create a Syscall\nfunction for each number of arguments (e.g. Syscall1, Syscall2, Syscall3, etc), making it\nmore generic?! I don’t know. The “downside” of this approach is that the number of\nparameters provided by Go to an API function might not be precise (e.g. CreateFileW would\nbe invoked using 9 parameters but the real API call takes only 7). Either way, that would still\nwork cause Windows would not care about it and only handle the real parameters.\n\n[Anyway, let’s see how SyscallN is implemented in the runtime package:](https://github.com/golang/go/tree/master/src/runtime)\n```\n  func syscall_SyscallN(trap uintptr, args ...uintptr) (r1, r2, err uintptr) {\n\n       nargs := len(args)\n\n       // asmstdcall expects it can access the first 4 arguments\n\n       // to load them into registers.\n\n       var tmp [4]uintptr\n\n       switch {\n\n       case nargs < 4:\n\n           copy(tmp[:], args)\n\n           args = tmp[:]\n\n       case nargs > maxArgs: // Check if the number of args is more than the\n  suported value\n\n           panic(\"runtime: SyscallN has too many arguments\")\n\n       }\n\n       lockOSThread()\n\n       defer unlockOSThread()\n\n       // What we actually care about\n\n       c := &getg().m.syscall // Init the Golang system call structure\n\n       c.fn = trap // Set the Windows API function address\n\n       c.n = uintptr(nargs) // Set the number of arguments\n\n       c.args = uintptr(noescape(unsafe.Pointer(&args[0]))) // Set the\n  arguments array\n\n       cgocall(asmstdcallAddr, unsafe.Pointer(c)) // Call the asmcgocall\n\n       return c.r1, c.r2, c.err\n\n  }\n\n```\n\n-----\n\nIn this function we’ll focus on 2 things: the c variable initialization and the call to the cgocall\nfunction.\n\nRegarding the initialization, remember the g we talked about in the scheduler introduction?\nThe getg() function is the one responsible for getting the current goroutine information. In\nthe snippet above it also access the m structure inside the g, which as we learned\nrepresents the thread the goroutine is associated to. It then access another structure\nnamed syscall and assign it to the c variable.\n\nThis syscall is of the type libcall and this structure defines all the information the Go\nruntime needs to perform a Windows API call:\n\n\n-----\n\n```\n  // Defined inside the \"m\" struct in the \"runtime\"\n  package\n\n  syscall  libcall // stores syscall parameters on\n  windows\n\n  // reducted\n\n  type libcall struct {\n\n       fn  uintptr // Windows function address\n\n       n  uintptr // Number of parameters\n\n       args uintptr // Parameters array\n\n       r1  uintptr // Return values\n\n       r2  uintptr // Floating point return value\n\n       err uintptr // Error number\n\n  }\n\n```\nNow that we know more about the libcall structure definition, the SyscallN operations\nstart to be easier to understand. The initialization steps are the following:\n```\n   c := &getg().m.syscall: initialize c with the libcall structure, allowing it to access\n\n```\nthe required Windows API information.\n```\n   c.fn = trap: set the resolved Windows API address (first parameter of SyscallN).\n   c.n = uintptr(nargs): set the number of arguments based on the Syscall<n>\n\n```\nfunction used.\n```\n   c.args = uintptr(noescape(unsafe.Pointer(&args[0]))): set the array of\n\n```\narguments to be used in the API function (second parameter of SyscallN)\n\nOnce it’s all set the c variable is then passed to the cgocall call as a parameter (a structure\npointer), along with another variable named asmstdcall (a function pointer).\n\nOne thing that is important to mention is that for x86 binaries there’s no SyscallN so the\n```\ncgocall is called by the Syscall<n> functions directly:\n\n```\n\n-----\n\n_Example of a Syscall call in x64_\n\n\n-----\n\n_Example of a Syscall call in x86_\n\nNow that we’ve learned a bit more about it all, remember the syscall_getprocaddress and\n```\nsyscall_loadlibrary calls? Since they are kind of special due to the fact they are resolved\n\n```\nby the Windows loader they would not rely on the “Syscall” path, but as mentioned already\nthe “final path” to actually perform the OS call is still the same. As we can see the steps it\nperforms are pretty much the same of SyscallN:\n```\n  //go:linkname syscall_loadlibrary syscall.loadlibrary\n\n  //go:nosplit\n\n  //go:cgo_unsafe_args\n\n  func syscall_loadlibrary(filename *uint16) (handle, err uintptr) {\n\n       lockOSThread()\n\n       defer unlockOSThread()\n\n```\n\n-----\n\n```\n     c : &getg().m.syscall\n\n     c.fn = getLoadLibrary() // Get the address at the IAT\n\n     c.n = 1 // Hardcoded argc\n     c.args = uintptr(noescape(unsafe.Pointer(&filename)))\n\n     cgocall(asmstdcallAddr, unsafe.Pointer(c))\n\n     KeepAlive(filename)\n\n     handle = c.r1\n\n     if handle == 0 {\n\n          err = c.err\n\n     }\n\n     return\n\n}\n\n//go:linkname syscall_getprocaddress syscall.getprocaddress\n\n//go:nosplit\n\n//go:cgo_unsafe_args\n\nfunc syscall_getprocaddress(handle uintptr, procname *byte) (outhandle, err\nuintptr) {\n\n     lockOSThread()\n\n     defer unlockOSThread()\n\n     c := &getg().m.syscall\n\n     c.fn = getGetProcAddress() // Get the address at the IAT\n\n     c.n = 2 // Hardcoded argc\n     c.args = uintptr(noescape(unsafe.Pointer(&handle)))\n\n     cgocall(asmstdcallAddr, unsafe.Pointer(c))\n\n     KeepAlive(procname)\n\n     outhandle = c.r1\n\n     if outhandle == 0 {\n\n          err = c.err\n\n     }\n\n     return\n\n}\n\n```\n\n-----\n\n## cgocall & asmcgocall\n\nAt this point we know that cgocall function receives both a variable named asmstdcall\nand a pointer to the c structure as parameters.\n\nThis function is responsible for things such as call the entersyscall function in order to not\nblock neither other goroutines nor the garbage collector and then call exitsyscall that\nblocks until this m can run Go code without violating the GOMAXPROCS limit. Though this is not\nthat important for our goal, the step that matters for us here is a call performed to a function\nnamed [asmcgocall, passing the asmstdcall variable and the c structure to it (the fn and](https://github.com/golang/go/blob/master/src/runtime/asm_amd64.s#L832)\n```\narg arguments passed to cgocall):\n\n```\n\n-----\n\n```\n  // runtime.cgocall(_cgo_Cfunc_f, frame)\n\n  func cgocall(fn, arg unsafe.Pointer) int32 {\n\n       // reducted\n\n       errno := asmcgocall(fn, arg) // func asmcgocall(fn, arg unsafe.Pointer)\n  int32\n\n```\n_Disassemlby view of the cgocall call_\n\nSince we’re in a x64 environment due to the Go ABI the first parameter would be passed\nvia RAX and the second via RBX.\n\n[The asmcgocall function switches to a system-allocated stack and then calls the asmstdcall](https://github.com/golang/go/blob/master/src/runtime/sys_windows_amd64.s#L15)\nfunction (the variable passed to cgocall).\n\n\n-----\n\nBoth asmcgocall and asmstdcall functions are gcc-compiled functions written by cgo\nhence the attempt to switch to what Go calls the “system stack” to be safer to run gcccompiled code.\n\n_Disassemlby view of_\n\n_the asmcgocall call_\n\n## asmstdcall: the “magic call gate”\n\nWe finally reached the most important function in this whole chain! The asmstdcall is the\nGo runtime function responsible for calling the real Windows API function. This function\nreceives a single parameter passed through RCX in x64 and ESP+4 in x86. And what is\nreceived via this parameter? The famous c structure!\n\nThe image bellow is an example of the asmstdcall in a x64 environment. I added some\ncomments in each assembly instruction to make it easier to understand:\n\n\n-----\n\n_asmstdcall view in IDA_\n\nOverall this function would simply prepare the registers for the API call (copy the\nparameters to the proper registers, use the stack if needed, etc), perform the call to the API\nitself and then set the results of it into the c structure.\n\nTo summarize everything we’ve learned so far I’ve created a very simple image with the Go\ncall flow:\n\n\n-----\n\n_General overview of how Go handles_\n\n_the API calls_\n\nThis explanation finishes up the whole flow of how binaries written in Go would resolve and\ncall the Windows API functions.\n\n## Tracing Golang Windows API calls with gftrace\n\nAs we can see, asmstdcall is a very powerful function, not only because it’s the one that\nperforms the real Windows API call, but also because it manipulates all the relevant\ninformation needed for that call (e.g. function address, parameters, return value etc).\n\n\n-----\n\nAfter a lot of tests I also noticed this function is present in a lot of Go versions (if not all),\nmaking this function very portable and reliable. I didn’t test all of the Go versions but I can\nsay for sure it was there in a lot of different versions.\n\nWith that in mind, I decided to create a tool to “abuse” the Go runtime behavior, specifically\nthe asmstdcall function and this was how I ended up creating a Windows API tracing tool I\nnamed [gftrace.](https://github.com/leandrofroes/gftrace/)\n\n### How it works?\n\nThe way it works is very straight forward, it injects the gftrace.dll file into a suspended\nprocess (the filepath is passed through the command line) and this DLL performs a midfunction hook inside the asmstdcall function. The main thread of the target process is then\nresumed and the target program starts. At this point, every Windows API call performed by\nthe Go application is analyzed by gftrace and it decides if the obtained information needs\nto be logged or not based on the filters provided by the user. The tool will only log the\n[functions specified by the user in the gftrace.cfg file.](https://github.com/leandrofroes/gftrace/blob/master/tracer/gftrace.cfg)\n\nThe tool collects all the API information manipulated by asmstdcall (the c information),\nformats it and prints to the user. Since the hook is performed after the API call itself gftrace\nis also able to collect the API function return value.\n\nAs an example, the following is part of the output generated by the tool against the\nSunshuttle malware:\n\n\n-----\n\n```\n  C:\\Users\\User>gftrace.exe sunshuttle.exe\n\n  - CreateFileW(\"config.dat.tmp\", 0x80000000, 0x3, 0x0, 0x3, 0x1, 0x0) =\n  0xffffffffffffffff (-1)\n\n  - CreateFileW(\"config.dat.tmp\", 0xc0000000, 0x3, 0x0, 0x2, 0x80, 0x0) = 0x198\n  (408)\n\n  - CreateFileW(\"config.dat.tmp\", 0xc0000000, 0x3, 0x0, 0x3, 0x80, 0x0) = 0x1a4\n  (420)\n\n  - WriteFile(0x1a4, 0xc000112780, 0xeb, 0xc0000c79d4, 0x0) = 0x1 (1)\n\n  - GetAddrInfoW(\"reyweb.com\", 0x0, 0xc000031f18, 0xc000031e88) = 0x0 (0)\n\n  - WSASocketW(0x2, 0x1, 0x0, 0x0, 0x0, 0x81) = 0x1f0 (496)\n\n  - WSASend(0x1f0, 0xc00004f038, 0x1, 0xc00004f020, 0x0, 0xc00004eff0, 0x0) = 0x0\n  (0)\n\n  - WSARecv(0x1f0, 0xc00004ef60, 0x1, 0xc00004ef48, 0xc00004efd0, 0xc00004ef18,\n  0x0) = 0xffffffff (-1)\n\n  - GetAddrInfoW(\"reyweb.com\", 0x0, 0xc000031f18, 0xc000031e88) = 0x0 (0)\n\n  - WSASocketW(0x2, 0x1, 0x0, 0x0, 0x0, 0x81) = 0x200 (512)\n\n  - WSASend(0x200, 0xc00004f2b8, 0x1, 0xc00004f2a0, 0x0, 0xc00004f270, 0x0) = 0x0\n  (0)\n\n  - WSARecv(0x200, 0xc00004f1e0, 0x1, 0xc00004f1c8, 0xc00004f250, 0xc00004f198,\n  0x0) = 0xffffffff (-1)\n\n  [...]\n\n### The simpler the better\n\n```\nMost part of the time in order to monitor API calls you need to hook them in some way and\nalso have a prototype for the function, otherwise would be tricky to guess the number of\nparameters the function takes as well as the type of those parameters.\n```\ngftrace uses the information provided by c to figure what is the name of the function being\n\n```\ncalled and the number of arguments it takes. It also tries to figure the type of the\nparameters by performing some simple checks to determine if it’s a string, an address, etc.\nBy doing so it does not require any function prototype in order to work and it’s able to trace\nevery single API function performed by a Go application. The only information the user\nneeds to provide in the gftrace.cfg file is a list of the API function names to trace. Simple\nlike that!\n\n\n-----\n\n### Ignoring the runtime noise\n\nDuring my tests I noticed that one of the last initilization functions called in Golang\napplications is a init function in the os package. This init function performs a call to\n```\nsyscall_GetCommandLine and that call ends up being a call to the Windows\n\n```\n[GetCommandLineW function.](https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinew)\n\nWhat gftrace does is use GetCommandLineW as a kind of sentinel. It waits for this call to\nhappen and only after that it starts to trace the API calls according to the user filters. By\ndoing so it avoids resolving and printing all the API calls performed by the runtime package,\nmaking the tool output very clean and focused on the main package calls.\n\n### Some other interesting aspects\n\nAfter spending some time playing with the tool I noticed some interesting things regarding\nthe Windows API calls Go uses:\n\n1. It always rely on the unicode version of the Windows functions (CreateFileW,\n\nCreateProcessW, GetComputerNameExW, etc).\n2. Due to the Go design some calls would be very noisy by default before the call to the\n\ndesired function. As an example, when you execute a command via cmd in Go it would\nfirst perform several calls to CreateFileW before a call to CreateProcessW.\n3. Memory and thread management functions such as VirtualAlloc,\n```\n   GetThreadContext, CreateThread, etc are usually used several times by the runtime\n\n```\nand probably will not be used by the main package.\n\nI created a config file in gftrace project that considers it all. It does not includes the regular\nfunctions used by the runtime and also only filters by the unicode versions. For item 3 it’s up\nto the user to figure what function is more interesting for each scenario.\n\n### Why gftrace might be a good option?\n\nOf course it would always be a matter of preference, there’s some amazing tools available\nthat can handle API tracing, but here’s some reasons I believe gftrace is also a nice\noption:\n\n1. Golang binaries might be a pain to reverse sometimes so this tool can be very handy\n\nfor fast malware triage for example since it’s very easy and fast to use.\n2. It performs a single hook in the runtime package without touching any Windows API\n\nfunction and does not require function prototypes. Those things make the tool very\nportable, fast and reliable.\n3. It’s designed for Go applications specifically so it handles all the runtime nuances\n\nsuch as the runtime calls noise before the calls from the main package.\n\n\n-----\n\nIf you want to check how to configure and use the tool make sure you check the project\npage!\n\n## Final thoughts\n\nI need to say I had a lot of fun in this research and eventually I still play with it all. It made\nme learn A LOT about how Golang Internals work. There’s a few other details I didn’t put\nhere in this blogpost but I might update it in the future.\n\nRegarding the source code, I’ve tried to put as much comments as possible and also make\nit very clean in order to be easy and nice to people use to study, etc. The tool is still under\ndevelopment and probably has a lot of things to be improved so please threat it as a PoC\ncode for now.\n\nAnyway, I hope you enjoyed the reading.\n\nHappy reversing!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-17 - An in-depth look at the Golang Windows calls.pdf"
    ],
    "report_names": [
        "2023-04-17 - An in-depth look at the Golang Windows calls.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1683338907,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1683252031,
    "ts_modification_date": 1683252031,
    "files": {
        "pdf": "https://archive.orkl.eu/a48467c67bfbefd86def4eec0a04dc6b98ec9355.pdf",
        "text": "https://archive.orkl.eu/a48467c67bfbefd86def4eec0a04dc6b98ec9355.txt",
        "img": "https://archive.orkl.eu/a48467c67bfbefd86def4eec0a04dc6b98ec9355.jpg"
    }
}