{
    "id": "e412159f-f91c-4946-9a54-8f4f7294bf16",
    "created_at": "2023-01-12T14:59:52.378375Z",
    "updated_at": "2025-03-27T02:16:26.091239Z",
    "deleted_at": null,
    "sha1_hash": "e3e022e33459a83cfc31a24d0489296165f2d97c",
    "title": "2021-05-07 - An In-Depth analysis of the new Taurus Stealer",
    "authors": "",
    "file_creation_date": "2022-05-28T15:41:42Z",
    "file_modification_date": "2022-05-28T15:41:42Z",
    "file_size": 2089198,
    "plain_text": "# An In-Depth analysis of the new Taurus Stealer\n\n**[blueliv.com/cyber-security-and-cyber-threat-intelligence-blog-blueliv/an-in-depth-analysis-of-the-new-taurus-stealer/](https://www.blueliv.com/cyber-security-and-cyber-threat-intelligence-blog-blueliv/an-in-depth-analysis-of-the-new-taurus-stealer/)**\n\nAn In-Depth analysis of the new Taurus Stealer\n\n07.May.2021\n\nBlueliv, an Outpost24 company\n\n[Threat Intelligence](https://www.blueliv.com/blog?tags=335)\n\nMost of the changes from earlier Taurus Stealer versions are related to the networking functionality of the malware, although other changes in\nthe obfuscation methods have been made. In the following pages, we will analyze in-depth how this new Taurus Stealer version works and\ncompare its main changes with previous implementations of the malware.\n\n\n-----\n\nAn In Depth analysis of the new Taurus Stealer\n\n\n## Introduction\n\n**Taurus Stealer, also known as Taurus or Taurus Project, is a C/C++ information stealing malware that has been in the wild since April 2020.**\n[The initial attack vector usually starts with a malspam campaign that distributes a malicious attachment, although it has also been seen being](https://www.zscaler.com/blogs/security-research/taurus-new-stealer-town)\ndelivered by the [Fallout Exploit Kit. It has many similarities with Predator The Thief at different levels (load of initial configuration, similar](https://blog.malwarebytes.com/malwarebytes-news/2020/09/taurus-project-stealer-now-spreading-via-malvertising-campaign/)\nobfuscation techniques, functionalities, overall execution flow, etc.) and this is why this threat is sometimes misclassified by Sandboxes and\nsecurity products. However, it is worth mentioning that Taurus Stealer has gone through multiple updates in a short period and is actively\n\n\n-----\n\nbe g used t e d ost o t e c a ges o ea e au us Stea e e s o s a e e ated to t e **et o** **g u ct o a ty o t e** a a e,\nalthough other changes in the obfuscation methods have been made. In the following pages, we will analyze in-depth how this new Taurus\nStealer version works and compare its main changes with previous implementations of the malware.\n\n## Underground information\n\nThe malware appears to have been developed by the author that created Predator The Thief, “Alexuiop1337”, as it was promoted on their\nTelegram channel and Russian-language underground forums, though they claimed it has no connection to Taurus. Taurus Stealer is\nadvertised by the threat actor “Taurus Seller” (sometimes under the alias “Taurus_Seller”), who has a presence on a variety of Russianlanguage underground forums where this threat is primarily sold. The following figure shows an example of this threat actor in their post on one\nof the said forums:\n\nFigure 1. Taurus Seller post in underground forums selling Taurus Stealer\n\nThe initial description of the ad (translated by Google) says:\nStiller is written in C ++ (c ++ 17), has no dependencies (.NET Framework / CRT, etc.).\n\nThe traffic between the panel and the build is encrypted each time with a unique key.\n\nSupport for one backup domain (specified when requesting a build).\n\nWeight: 250 KB (without obfuscation 130 KB).\n\nThe build does not work in the CIS countries.\n\n**Taurus Stealer sales began in April 2020. The malware is inexpensive and easily acquirable. Its price has fluctuated somewhat since its**\ndebut. It also offers temporal discounts (20% discount on the eve of the new year 2021, for example). At the time of writing this analysis, the\nprices are:\n\n**Concept** **Price**\n\nLicense Cost – (lifetime) 150 $\n\nUpgrade Cost 0 $\n\nTable 1. Taurus Stealer prices at the time writing this analysis\n\nThe group has on at least one occasion given prior clients the upgraded version of the malware for free. As of January 21, 2021, the group\nonly accepts payment in the privacy-centric cryptocurrency Monero. The seller also explains that the license will be lost forever if any of these\nrules are violated (ad translated by Google):\n\nIt is forbidden to scan the build on VirusTotal and similar merging scanners\nIt is forbidden to distribute and test a build without a crypt\nIt is forbidden to transfer project files to third parties\nIt is forbidden to insult the project, customers, seller, coder\n\nThis explains why most of Taurus Stealer samples found come packed.\n\n## Packer\n\nThe malware that is going to be analyzed during these lines comes from the packed sample\n2fae828f5ad2d703f5adfacde1d21a1693510754e5871768aea159bbc6ad9775, which we had successfully detected and classified as Taurus\nStealer. However, it showed some different behavior and networking activity, which suggested a new version of the malware had been\ndeveloped. The first component of the sample is the Packer. This is the outer layer of Taurus Stealer and its goal is to hide the malicious\npayload and transfer execution to it in runtime. In this case, it will accomplish its purpose without the need to create another process in the\nsystem. The packer is written in C++ and its architecture consists of 3 different layers, we will describe here the steps the malware takes to\nexecute the payload through these different stages and the techniques used to and slow-down analysis.\n\n\n-----\n\nFigure 2. 2fae828f5ad2d703f5adfacde1d21a1693510754e5871768aea159bbc6ad9775 Packer layers\n\n**Layer 1 The first layer of the Packer makes use of junk code and useless loops to avoid analysis and prevent detonation in automated**\nanalysis systems. In the end, it will be responsible for executing the following essential tasks:\n\n1. Allocating space for the Shellcode in the process’s address space\n2. Writing the encrypted Shellcode in this newly allocated space.\n3. Decrypting the Shellcode\n4. Transferring execution to the Shellcode\n\nThe initial WinMain() method acts as a wrapper using junk code to finally call the actual “main” procedure. Memory for the Shellcode is\nreserved using VirtualAlloc and its size appears hardcoded and obfuscated using an ADD instruction. The pages are reserved with read, write\nand execute permissions (PAGE_EXECUTE_READWRITE).\n\nFigure 3. Memory allocation for the Shellcode\n\nWe can find the use of junk code almost anywhere in this first layer, as well as useless long loops that may prevent the sample from detonating\nif it is being emulated or analyzed in simple dynamic analysis Sandboxes. The next step is to load the Shellcode in the allocated space. The\npacker also has some hardcoded offsets pointing to the encrypted Shellcode and copies it in a loop, byte for byte. The following figure shows\nthe core logic of this layer. The red boxes show junk code whilst the green boxes show the main functionality to get to the next layer.\n\n\n-----\n\nFigure 4. Core functionality of the first layer\n\nThe Shellcode is decrypted using a 32 byte key in blocks of 8 bytes. The decryption algorithm uses this key and the encrypted block to perform\narithmetic and byte-shift operations using XOR, ADD, SUB, SHL and SHR. Once the Shellcode is ready, it transfers the execution to it using\n_JMP EAX, which leads us to the second layer._\n\nFigure 5. Layer 1 transferring execution to next layer\n\n**Layer 2 Layer 2 is a Shellcode with the ultimate task of decrypting another layer. This is not a straightforward process, an overview of which**\ncan be summarized in the following points:\n\n1. Shellcode starts in a wrapper function that calls the main procedure.\n2. Resolve LoadLibraryA and GetProcAddress from kernel32.dll\n3. Load pointers to .dll functions\n4. Decrypt layer 3\n5. Allocate decrypted layer\n6. Transfer execution using JMP\n\nFinding DLLs and Functions This layer will use the TIB (Thread Information Block) to find the PEB (Process Environment Block) structure,\nwhich holds a pointer to a PEB_LDR_DATA structure. This structure contains information about all the loaded modules in the current process.\nMore precisely, it traverses the InLoadOrderModuleList and gets the BaseDllName from every loaded module, hashes it with a custom\nhashing function and compares it with the respective “kernel32.dll” hash.\n\n\n-----\n\nFigure 6. Traversing InLoadOrderModuleList and hashing BaseDllName.Buffer to find kernel32.dll\n\nOnce it finds \"kernel32.dll\" in this doubly linked list, it gets its DllBase address and loads the Export Table. It will then use the AddressOfNames\nand AddressOfNameOrdinals lists to find the procedure it needs. It uses the same technique by checking for the respective “LoadLibraryA” and\n\"GetProcAddress\" hashes. Once it finds the ordinal that refers to the function, it uses this index to get the address of the function using\n_AddressOfFunctions list._\n\n\n-----\n\nFigure 7. Resolving function address using the ordinal as an index to AddressOfFunctions list\n\nThe hashing function being used to identify the library and function names is custom and uses a parameter that makes it support both ASCII\nand UNICODE names. It will first use UNICODE hashing when parsing InLoadOrderModuleList (as it loads UNICODE_STRING _DllBase) and_\nASCII when accessing the AddressOfNames list from the Export Directory.\n\n\n-----\n\nFigure 8. Custom hashing function from Layer 2 supporting both ASCII and UNICODE encodings\n\nOnce the malware has resolved LoadLibraryA and GetProcAddress from kernel32.dll, it will then use these functions to resolve more\nnecessary APIs and save them in a “Function Table”. To resolve them, it relies on loading strings in the stack before the call to\n_GetProcAddress. The API calls being resolved are:_\n\nGlobalAlloc\nGetLastError\nSleep\nVirtualAlloc\nCreateToolhelp32Snapshot\nModule32First\nCloseHandle\n\nFigure 9. Layer 2 resolving functions dynamically for later use\n\n\n-----\n\nec ypt o o aye 3 te eso g d s a d t e u ct o s t e te s t e o o g p ocedu e, espo s b e o p epa g t e e t stage,\nallocating space for it and transferring its execution through a JMP instruction.\n\nFigure 10. Decryption and execution of Layer 3 (final layer)\n\n**Layer 3 This is the last layer before having the unpacked Taurus Stealer. This last phase is very similar to the previous one but surprisingly**\nless stealthy (the use of hashes to find .dlls and API calls has been removed) now strings stored in the stack, and string comparisons, are\nused instead. However, some previously unseen new features have been added to this stage, such as anti-emulation checks. This is how it\nlooks the beginning of this last layer. The value at the address 0x00200038 is now empty but will be overwritten later with the OEP (Original\nEntry Point). When calling unpack the first instruction will execute POP EAX to get the address of the OEP, check whether it is already set\nand jump accordingly. If not, it will start the final unpacking process and then a JMP EAX will transfer execution to the final Taurus Stealer.\n\nFigure 11. OEP is set. Last Layer before and after the unpacking process.\n\nFinding DLLs and Functions As in the 2nd layer, it will parse the PEB to find DllBase of kernel32.dll walking through InLoadOrderModuleList,\nand then parse kernel32.dll Exports Directory to find the address of LoadLibraryA and GetProcAddress. This process is very similar to the one\nseen in the previous layer, but names are stored in the stack instead of using a custom hash function.\n\n\n-----\n\nFigure 12. Last layer finding APIs by name stored in the stack instead of using the hashing approach\n\nOnce it has access to LoadLibraryA and GetProcAddressA it will start resolving needed API calls. It will do so by storing strings in the stack\nand storing the function addresses in memory. The functions being resolved are:\n\nVirtualAlloc\nVirtualProtect\nVirtualFree\nGetVersionExA\nTerminateProcess\nExitProcess\nSetErrorMode\n\n\n-----\n\nFigure 13. Last Layer dynamically resolving APIs before the final unpack\n\nAnti-Emulation After resolving these API calls, it enters in a function that will prevent the malware from detonating if it is being executed in an\nemulated environment. We‘ve named this function anti_emulation. It uses a common environment-based opaque predicate calling\n_SetErrorMode API call._\n\nFigure 14. Anti-Emulation technique used before transferring execution to the final Taurus Stealer\n\n[This technique has been previously documented. The code calls SetErrorMode() with a known value (1024) and then calls it again with a](http://joxeankoret.com/blog/2010/02/23/antiemulation-techniques-malware-tricks-ii/)\ndifferent one. SetErrorMode returns the previous state of the error-mode bit flags. An emulator not implementing this functionality properly\n(saving the previous state), would not behave as expected and would finish execution at this point.  Transfer execution to Taurus Stealer After\nthis, the packer will allocate memory to copy the clean Taurus Stealer process in, parse its PE (more precisely its Import Table) and load all the\nnecessary imported functions. As previously stated, during this process the offset 0x00200038 from earlier will be overwritten with the OEP\n(Original Entry Point). Finally, execution gets transferred to the unpacked Taurus Stealer via JMP EAX.\n\n\n-----\n\nFigure 15. Layer 3 transferring execution to the final unpacked Taurus Stealer\n\nWe can dump the unpacked Taurus Stealer from memory (for example after copying the clean Taurus process, before the call to VirtualFree).\nWe will focus the analysis on the unpacked sample with hash d6987aa833d85ccf8da6527374c040c02e8dfbdd8e4e4f3a66635e81b1c265c8.\n\n## Taurus Stealer (Unpacked)\n\nThe following figure shows Taurus Stealer's main workflow. Its life cycle is not very different from other malware stealers. However, it is worth\nmentioning that the Anti-CIS feature (avoid infecting machines coming from the Commonwealth of Independent States) is not optional and is\nthe first feature being executed in the malware.\n\n\n-----\n\nFigure 16. Taurus Stealer main workflow\n\nAfter loading its initial configuration (which includes resolving APIs, Command and Control server, Build Id, etc.), it will go through two checks\nthat prevent the malware from detonating if it is running in a machine coming from the Commonwealth of Independent States (CIS) and if it has\na modified C2 (probably to avoid detonating on cracked builds). These two initial checks are mandatory. After passing the initial checks, it will\nestablish communication with its C2 and retrieve dynamic configuration (or a static default one if the C2 is not available) and execute the\nfunctionalities accordingly before exfiltration. After exfiltration, two functionalities are left: Loader and Self-Delete (both optional). Following\nthis, a clean-up routine will be responsible for deleting strings from memory before finishing execution. Code Obfuscation Taurus Stealer\nmakes heavy use of code obfuscation techniques throughout its execution, which translates to a lot of code for every little task the malware\nmight perform. Taurus string obfuscation is done in an attempt to hide traces and functionality from static tools and to slow down analysis.\nAlthough these techniques are not complex, there is almost no single relevant string in cleartext. We will mostly find:\n\nXOR encrypted strings\nSUB encrypted strings\n\n\n-----\n\nO e c ypted st gs e ca d e c ypted st gs be g oaded t e stac a d dec ypted just be o e ts use au us usua y sets a t a\nhardcoded XOR key to start decrypting the string and then decrypts it in a loop. There are different variations of this routine. Sometimes there\nis only one hardcoded key, whilst other times there is one initial key that decrypts the first byte of the string, which is used as the rest of the\nXOR key, etc. The following figure shows the decryption of the string “\\Monero” (used in the stealing process). We can see that the initial key is\nset with ‘PUSH + POP’ and then the same key is used to decrypt the whole string byte per byte. Other approaches use strcpy to load the\ninitial encrypted string directly, for instance.\n\nFigure 17. Example of “\\Monero” XOR encrypted string\n\nSUB encrypted strings This is the same approach as with XOR encrypted strings, except for the fact that the decryption is done with\nsubtraction operations. There are different variations of this technique, but all follow the same idea. In the following example, the SUB key is\nfound at the beginning of the encrypted string and decryption starts after the first byte.\n\n\n-----\n\nFigure 18. Example of “DisplayVersion” SUB encrypted string\n\nEarlier Taurus versions made use of stack strings to hide strings (which can make code blocks look very long). However, this method has\nbeen completely removed by the XOR and SUB encryption schemes - probably because these methods do not show the clear strings unless\ndecryption is performed or analysis is done dynamically. Comparatively, in stack strings, one can see the clear string byte per byte. Here is an\nexample of such a replacement from an earlier Taurus sample, when resolving the string \"wallet.dat” for DashCore wallet retrieval purposes.\nThis is now done via XOR encryption:\n\nFigure 19. Stack strings are replaced by XOR and SUB encrypted strings\n\n\n-----\n\ne co b at o o t ese ob uscat o tec ques eads to a ot o u ecessa y oops t at s o do a a ys s a d de u ct o a ty o stat c\ntools. As a result, the graph view of the core malware looks like this:\n\nFigure 20. Taurus Stealer core functionality call graph\n\n**Resolving APIs The malware will resolve its API calls dynamically using hashes. It will first resolve LoadLibraryA and GetProcAddress from**\n_kernel32.dll to ease the resolution of further API calls. It does so by accessing the PEB of the process - more precisely to access the DllBase_\nproperty of the third element from the InLoadOrderModuleList (which happens to be “kernel32.dll\") - and then use this address to walk through\nthe Export Directory information.\n\n\n-----\n\nFigure 21. Retrieving kernel32.dll DllBase by accessing the 3rd entry in the InLoadOrderModuleList list\n\nIt will iterate kernel32.dll _AddressOfNames structure and compute a hash for every exported function until the corresponding hash for_\n“LoadLibraryA\" is found. The same process is repeated for the “GetProcAddress” API call. Once both procedures are resolved, they are saved\nfor future resolution of API calls.\n\nFigure 22. Taurus Stealer iterates AddressOfNames to find an API using a hashing approach\n\nFor further API resolutions, a “DLL Table String” is used to index the library needed to load an exported function and then the hash of the\nneeded API call.\n\n\n-----\n\nFigure 23. DLL Table String used in API resolutions\n\n**Resolving initial Configuration Just as with** [Predator The Thief, Taurus Stealer will load its initial configuration in a table of function pointers](https://fumik0.com/2019/12/25/lets-play-again-with-predator-the-thief/)\nbefore the execution of the WinMain() function. These functions are executed in order and are responsible for loading the C2, Build Id and the\n**Bot Id/UUID. C2 and Build Id are resolved using the SUB encryption scheme with a one-byte key. The loop uses a hard-coded length, (the**\nsize in bytes of the C2 and Build Id), which means that this has been pre-processed beforehand (probably by the builder) and that these\nprocedures would work for only these properties.\n\nFigure 24. Taurus Stealer decrypting its Command and Control server\n\n\n-----\n\n**O** **/ UU** **Ge e at o** au us ge e ates a u **que de t** **e** o e e y ected ac e a e e s o s o t s a a e a so used t s\nidentifier as the .zip filename containing the stolen data. This behavior has been modified and now the .zip filename is randomly generated (16\nrandom ASCII characters).\n\nFigure 25. Call graph from the Bot Id / UUID generation routine\n\nIt starts by getting a bitmask of all the currently available disk drives using GetLogicalDrivers and retrieving their VolumeSerialNumber with\n[GetVolumeInformationA. All these values are added into the register ESI (holds the sum of all VolumeSerialNumbers from all available Drive](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationa)\nLetters). ESI is then added to itself and right-shifted 3 bytes. The result is a hexadecimal value that is converted to decimal. After all this\nprocess, it takes out the first two digits from the result and concatenates its full original part at the beginning. The last step consists of\ntransforming digits in odd positions to ASCII letters (by adding 0x40). As an example, let’s imagine an infected machine with \"C:\\\\\", \"D:\\\\\" and\n\"Z:\\\\\" drive letters available.\n\n1. Call GetLogicalDrivers to get a bitmask of all the currently available disk drives.\n\n2. Get their VolumeSerialNumber using GetVolumeInformationA:\n\nESI holds the sum of all VolumeSerialNumber from all available Drive Letters\n```\nGetVolumeInformationA(\"C:\\\\\") -> 7CCD8A24h\nGetVolumeInformationA(\"D:\\\\\") -> 25EBDC39h\n\n```\n```\nGetVolumeInformationA(\"Z:\\\\\") -> 0FE01h\nESI = sum(0x7CCD8A24+0x25EBDC3+0x0FE01) = 0xA2BA645E\n\n```\n\n-----\n\n3 O ce s ed t e su, t\n```\nmov edx, esi\n\n```\n```\nedx = (edx >> 3) + edx\n\n```\nWhich translates to:\n\n```\n(0xa2ba645e >> 0x3) + 0xa2ba645e = 0xb711b0e9\n\n```\n4. HEX convert the result to decimal\n\n```\nresult = hex(0xb711b0e9) = 3071389929\n\n```\n5. Take out the first two digits and concatenate its full original part at the beginning:\n\n```\n307138992971389929\n\n```\n6. Finally, it transforms digits in odd positions to ASCII letters:\n\n```\ns0w1s8y9r9w1s8y9r9\n\n```\n**Anti – CIS**\n\nTaurus Stealer tries to avoid infection in countries belonging to the Commonwealth of Independent States (CIS) by checking the language\n[identifier of the infected machine via GetUserDefaultLangID. Earlier Taurus Stealer versions used to have this functionality in a separate](https://docs.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getuserdefaultlangid)\nfunction, whereas the latest samples include this in the main procedure of the malware. It is worth mentioning that this feature is mandatory\nand will be executed at the beginning of the malware execution.\n\nFigure 26. Taurus Stealer Anti-CIS feature\n\nGetUserDefaultLandID returns the [language identifier of the Region Format setting for the current user. If it matches one on the list, it will finish](https://docs.microsoft.com/en-us/windows/desktop/Intl/language-identifiers)\nexecution immediately without causing any harm.\n\n**Language Id** **SubLanguage Symbol** **Country**\n\n0x419 SUBLANG_RUSSIAN_RUSSIA Russia\n\n\n-----\n\n**Language Id** **SubLanguage Symbol** **Country**\n\n0x42B SUBLANG_ARMENIAN_ARMENIA Armenia\n\n0x423 SUBLANG_BELARUSIAN_BELARUS Belarus\n\n0x437 SUBLANG_GEORGIAN_GEORGIA Georgia\n\n0x43F SUBLANG_KAZAK_KAZAKHSTAN Kazakhstan\n\n0x428 SUBLANG_TAJIK_TAJIKISTAN Tajikistan\n\n0x843 SUBLANG_UZBEK_CYRILLIC Uzbekistan\n\n0x422 SUBLANG_UKRAINIAN_UKRAINE Ukraine\n\nTable 2. Taurus Stealer Language Id whitelist (Anti-CIS)\n\n**Anti – C2 Mod. After the Anti-CIS feature has taken place, and before any harmful activity occurs, the retrieved C2 is checked against a**\n**hashing function to avoid running with an invalid or modified Command and Control server. This hashing function is the same used to resolve**\nAPI calls and is as follows:\n\nFigure 27. Taurus Stealer hashing function\n\nEarlier taurus versions make use of the same hashing algorithm, except they execute two loops instead of one. If the hash of the C2 is not\nmatching the expected one, it will avoid performing any malicious activity. This is most probably done to protect the binary from cracked\nversions and to avoid leaving traces or uncovering activity if the sample has been modified for analysis purposes.\n\n## C2 Communication\n\nPerhaps the biggest change in this new Taurus Stealer version is how the communications with the Command and Control Server are\nmanaged. Earlier versions used two main resources to make requests:\n\n**Resource** **Description**\n\n/gate/cfg/?post=1&data=<bot_id> Register Bot Id and get dynamic config. Everything is sent in cleartext\n\n/gate/log?post=2&data=<summary_information> Exfiltrate data in ZIP (cleartext) summary_information is encrypted\n\nTable 3. Networking resources from earlier Taurus versions\n\nhis new Taurus Stealer version uses:\n\n**Resource** **Description**\n\n/cfg/ Register Bot Id and get dynamic config. BotId is sent encrypted\n\n/dlls/ Ask for necessary .dlls (Browsers Grabbing)\n\n/log/ Exfiltrate data in ZIP (encrypted)\n\n/loader/complete/ ACK execution of Loader module\n\nTable 4. Networking resources from new Taurus samples\n\nThis time no data is sent in cleartext. Taurus Stealer uses wininet APIs InternetOpenA, InternetSetOptionA, InternetConnectA,\n_HttpOpenRequestA, HttpSendRequestA, InternetReadFile and InternetCloseHandle for its networking functionalities._\n\n**User-Agent generation**\n\n\n-----\n\nFigure 28. User-Agent generation routine call graph\n\nThe way Taurus generates the User-Agent that it will use for networking purposes is different from earlier versions and has introduced more\nsteps in its creation, ending up in more variable results. This routine follows the next steps:\n1. It will first get OS Major Version and OS Minor Version information from the PEB. In this example, we will let OS Major Version be 6 and\nOS Minor Version be 1.\n\n1.1 Read TIB[0x30] -> PEB[0x0A] -> OS Major Version -> 6\n\n1.2 Read PEB[0xA4] -> OS Minor Version -> 1\n\n2. Call to IsWow64Process to know if the process is running under WOW64 (this will be needed later).\n\n3. Decrypt string “.121 Safari/537.36”\n\n4. Call GetTickCount and store result in EAX (for this example: EAX = 0x0540790F)\n\n5. Convert HEX result to decimal result: 88111375\n\n6. Ignore the first 4 digits of the result: 1375\n\n7. Decrypt string “ AppleWebKit / 537.36 (KHTML, like Gecko) Chrome / 83.0.”\n\n8. Check the result from the previous call to IsWow64Process and store it for later.\n\n8.1 If the process is running under WOW64: Decrypt the string “ WOW64)”\n\n8.2 If the process is not running under WOW64: Load char “)” In this example we will assume the process is running under WOW64.\n\n9. Transform from HEX to decimal OS Minor Version (“1”)\n\n10. Transform from HEX to decimal OS Major Version (“6”)\n\n11. Decrypt string “Mozilla/5.0 (Windows NT ”\n\n\n-----\n\nppe d OS ajo e s o o a/5 0 ( do s 6\n\n13. Append ‘.’ (hardcoded) -> “Mozilla/5.0 (Windows NT 6.”\n\n14. Append OS Minor Version -> “Mozilla/5.0 (Windows NT 6.1”\n\n15. Append ‘;’ (hardcoded) -> “Mozilla/5.0 (Windows NT 6.1;”\n\n16. Append the WOW64 modifier explained before -> “Mozilla/5.0 (Windows NT 6.1; WOW64)”\n\n17. Append string “ AppleWebKit / 537.36 (KHTML, like Gecko) Chrome / 83.0.” -> “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit /\n537.36 (KHTML, like Gecko) Chrome / 83.0.”\n\n18. Append result of from the earlier GetTickCount (1375 after its processing) -> “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit /\n537.36 (KHTML, like Gecko) Chrome / 83.0.1375”\n\n19. Append the string “.121 Safari/537.36” to get the final result:\n\n“Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit / 537.36 (KHTML, like Gecko) Chrome / 83.0.1375.121 Safari/537.36”\n\nWhich would have looked like this if the process was not running under WOW64:\n\n“Mozilla/5.0 (Windows NT 6.1;) AppleWebKit / 537.36 (KHTML, like Gecko) Chrome / 83.0.1375.121 Safari/537.36”\n\nThe bold characters from the generated User-Agent are the ones that could vary depending on the OS versions, if the machine is running\nunder WOW64 and the result of GetTickCount call.\n\n**How the port is set In the analyzed sample, the port for communications is set as a hardcoded value in a variable that is used in the code.**\nThis setting is usually hidden. Sometimes a simple “push 80” in the middle of the code, or a setting to a variable using “mov [addr], 0x50” is\nused. Other samples use https and set the port with a XOR operation like “0x3a3 ^ 0x218” which evaluates to “443”, the standard https port. In\nthe analyzed sample, before any communication with the C2 is made, a hardcoded “push 0x50 + pop EDI” is executed to store the port used\nfor communications (port 80) in EDI. EDI register will be used later in the code to access the communications port where necessary. The\nfollowing figure shows how Taurus Stealer checks which is the port used for communications and how it sets dwFlags for the call to\n_HttpOpenRequestA accordingly._\n\n\n-----\n\nFigure 29. Taurus Stealer sets dwFlags according to the port\n\nSo, if the samples uses port 80 or any other port different from 443, the following flags will be used:\n0x4400100 = INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_PRAGMA_NOCACHE\n\nIf it uses port 443, the flags will be:\n0x4C00100 = NTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_SECURE |\nINTERNET_FLAG_PRAGMA_NOCACHE\n\n**[RC4 Taurus Stealer uses RC4 stream cipher as its first layer of encryption for communications with the C2. The symmetric key used for this](https://en.wikipedia.org/wiki/RC4)**\nalgorithm is randomly generated, which means the key will have to be stored somewhere in the body of the message being sent so that the\nreceiver can decrypt the content. Key Generation The procedure we’ve named getRandomString is the routine called by Taurus Stealer to\ngenerate the RC4 symmetric key. It receives 2 parameters, the first is an output buffer that will receive the key and the second is the length of\nthe key to be generated. To create the random chunk of data, it generates an array of bytes loading three XMM registers in memory and then\ncalling rand() to get a random index that it will use to get a byte from this array. This process is repeated for as many bytes as specified by the\nsecond parameter. Given that all the bytes in these XMM registers are printable, this suggests that getRandomString produces an\nalphanumeric key of n bytes length.\n\n\n-----\n\nFigure 30. Taurus Stealer getRandomString routine\n\nGiven the lack of srand, no seed is initialized and the rand function will end up giving the same “random” indexes. In the analyzed sample,\nthere is only one point in which this functionality is called with a different initial value (when creating a random directory in\n_%PROGRAMDATA% to store .dlls, as we will see later). We’ve named this function getRandomString2 as it has the same purpose. However, it_\nreceives an input buffer that has been processed beforehand in another function (we’ve named this function getRandomBytes). This input\nbuffer is generated by initializing a big buffer and XORing it over a loop with the result of a GetTickCount call. This ends up giving a “random”\ninput buffer which getRandomString2 will use to get indexes to an encrypted string that resolves in runtime as\n“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789”, and finally generate a random string for a given length. We\nhave seen other Taurus Stealer samples moving onto this last functionality (using input buffers XORed with the result of a GetTickCount call to\ngenerate random chunks of data) every time randomness is needed (generation communication keys, filenames, etc.). The malware sample\n_d0aa932e9555a8f5d9a03a507d32ab3ef0b6873c4d9b0b34b2ac1bd68f1abc23 is an example of these Taurus Stealer variants._\n\n\n-----\n\nFigure 31. Taurus Stealer getRandomBytes routine\n\n**BASE64 This is the last encoding layer before C2 communications happen. It uses a classic BASE64 to encode the message (that has been**\npreviously encrypted with RC4) and then, after encoding, the RC4 symmetric key is appended to the beginning of the message. The receiver\nwill then need to get the key from the beginning of the message, BASE64 decode the rest of it and use the retrieved key to decrypt the final\nRC4 encrypted message. To avoid having a clear BASE64 alphabet in the code, it uses XMM registers to load an encrypted alphabet that is\ndecrypted using the previously seen SUB encryption scheme before encoding.\n\n\n-----\n\nFigure 32. Taurus Stealer hiding Base64 alphabet\n\nThis is what the encryption procedure would look like:\n\n1. Generate RC4 key using getRandomString with a hardcoded size of 16 bytes.\n2. RC4 encrypt the message using the generated 16 byte key.\n3. BASE64 **encode the encrypted message.**\n4. Append RC4 symmetric key at the beginning of the encoded message.\n\n\n-----\n\nFigure 33. Taurus Stealer encryption routine\n\n**Bot Registration + Getting dynamic configuration Once all the initial checks have been successfully passed, it is time for Taurus to register**\nthis new Bot and retrieve the dynamic configuration. To do so, a request to the resource /cfg/ of the C2 is made with the encrypted Bot Id as\na message. For example, given a BotId “s0w1s8y9r9w1s8y9r9 and a key “IDaJhCHdIlfHcldJ”:\nRC4(\"IDaJhCHdIlfHcldJ\", \"s0w1s8y9r9w1s8y9r9\") = 018784780c51c4916a4ee1c50421555e4991\n\nIt then BASE64 encodes it and appends the RC4 key at the beginning of the message:\n**IDaJhCHdIlfHcldJAYeEeAxRxJFqTuHFBCFVXkmR**\n\nAn example of the response from the C2 could be:\n**xBtSRalRvNNFBNqAx0wL840EWVYxho+a6+R+rfO/Dax6jqSFhSMg+rwQrkxh4U3t6EPpqL8xAL8omji9dhO6biyzjESDBIPBfQSiM4Vs7qQMSg==**\n\nThe responses go through a decryption routine that will reverse the steps described above to get the plaintext message. As you can see in the\nfollowing figure, the key length is hardcoded in the binary and expected to be 16 bytes long.\n\n\n-----\n\nFigure 34. Taurus Stealer decrypting C2 responses\n\nTo decrypt it, we do as follow: 1. Get RC4 key (first 16 bytes of the message) `xBtSRalRvNNFBNqA 2. BASE64 decode the rest of the`\nmessage (after the RC4 key)\n```\nc41b5245a951bcd34504da80c74c0bf38d04595631868f9aebe47eadf3bf0dac7a8ea485852320fabc10ae4c61e14dede843e9a8bf3100bf289a38b\n\n```\n3. Decrypt the message using RC4 key (get dynamic config.) `[1;1;1;1;1;0;1;1;1;1;1;1;1;1;1;1;1;5000;0;0]#[]#`\n```\n[156.146.57.112;US]#[] We can easily see that consecutive configurations are separated by the character “;”, while the character ‘#’ is\n\n```\nused to separate different configurations. We can summarize them like this: `[STEALER_CONFIG]#[GRABBER_CONFIG]#[NETWORK_CONFIG]#`\n```\n[LOADER_CONFIG]  In case the C2 is down and no dynamic configuration is available, it will use a hardcoded configuration stored in the\n\n```\nbinary which would enable all stealers, Anti-VM, and Self-Delete features. (Dynamic Grabber and Loader modules are not enabled by default\nin the analyzed sample).\n\n\n-----\n\nFigure 35. Taurus uses a static hardcoded configuration If C2 is not available\n\n**Anti - VM (optional) This functionality is optional and depends on the retrieved configuration. If the malware detects that it is running in a**\nVirtualized environment, it will abort execution before causing any damage. It makes use of old and common x86 Anti-VM instructions (like\nthe **[RedPill technique) to detect the Virtualized environment in this order:](https://search.unprotect.it/technique/sidt-red-pill/)**\n\nSIDT\nSGDT\nSTR\nCPUID\nSMSW\n\n\n-----\n\nFigure 36. Taurus Stealer Anti-VM routine\n\n## Stealer / Grabber\n\nWe can distinguish 5 main grabbing methods used in the malware. All paths and strings required, as usual with Taurus Stealer, are created at\nruntime and come encrypted in the methods described before. Grabber 1 This is one of the most used grabbing methods, along with the\nmalware execution (if it is not used as a call to the grabbing routine it is implemented inside another function in the same way), and consists of\ntraversing files (it ignores directories) by using kernel32.dll _FindFirstFileA, FindNextFileA and FindClose API calls. This grabbing method does_\n**not use recursion. The grabber expects to receive a directory as a parameter for those calls (it can contain wildcards) to start the search with.**\nEvery found file is grabbed and added to a ZIP file in memory for future exfiltration. An example of its use can be seen in the Wallets Stealing\nfunctionality, when searching, for instance, for Electrum wallets: Grabber 2 This grabber is used in the Outlook Stealing functionality and uses\n_advapi32.dll_ _RegOpenKeyA, RegEnumKeyA, RegQueryValueExA and RegCloseKey API calls to access the and steal from Windows_\n**Registry. It uses a recursive approach and will start traversing the Windows Registry searching for a specific key from a given starting point**\nuntil RegEnumKeyA has no more keys to enumerate. For instance, in the Outlook Stealing functionality this grabber is used with the starting\nRegistry key “HKCU\\software\\microsoft\\office\" searching for the key “9375CFF0413111d3B88A00104B2A667\". Grabber 3 This grabber is\nused to steal browsers data and uses the same API calls as Grabber 1 for traversing files. However, it loops through all files and directories\nfrom %USERS% directory and favors recursion. Files found are processed and added to the ZIP file in memory. One curious detail is that if a\n“wallet.dat” is found during the parsing of files, it will only be dumped if the current depth of the recursion is less or equal to 5. This is\nprobably done in an attempt to avoid dumping invalid wallets. We can summarize the files Taurus Stealer is interested in the following table:\n\n**Grabbed File** **Affected Software**\n\nHistory Browsers\n\nformhistory.sqlite Mozilla Firefox & Others\n\ncookies.sqlite Mozilla Firefox & Others\n\nwallet.dat Bitcoin\n\nlogins.json Chrome\n\nsignongs.sqlite Mozilla Firefox & Others\n\nplaces.sqlite Mozilla Firefox & Others\n\nLogin Data Chrome / Chromium based\n\n\n-----\n\n**Grabbed File** **Affected Software**\n\nCookies Chrome / Chromium based\n\nWeb Data Browser\n\nTable 5. Taurus Stealer list of files for Browser Stealing functionalities\n\n**Grabber 4**\n\nThis grabber steals information from the Windows Vault, which is the default storage vault for the credential manager information. This is\ndone through the use of Vaultcli.dll, which encapsulates the necessary functions to access the Vault. Internet Explorer data, since it’s version\n10, is stored in the Vault. The malware loops through its items using:\n\nVaultEnumerateVaults\nVaultOpenVault\nVaultEnumerateItems\nVaultGetItem\nVaultFree\n\n**Grabber 5 This last grabber is the customized grabber module (dynamic grabber). This module is responsible for grabbing files configured by**\nthe threat actor operating the botnet. When Taurus makes its first request to the C&C, it retrieves the malware configuration, which can\ninclude a customized grabbing configuration to search and steal files. This functionality is not enabled in the default static configuration from\nthe analyzed sample (the configuration used when the C2 is not available). As in earlier grabbing methods, this is done via file traversing using\n_kernel32.dll FindFirstFileA, FindNextFileA and FindClose API calls. The threat actor may set recursive searches (optional) and multiple_\n**wildcards for the search.**\n\nFigure 37. Threat Actor can add customized grabber rules for the dynamic grabber\n\n**Targeted Software This is the software the analyzed sample is targeting. It has functionalities to steal from: Wallets:**\n\nElectrum\nMultiBit\nArmory\nEthereum\nBytecoin\nJaxx\nAtomic\nExodus\nDahscore\nBitcoin\nWasabi\nDaedalus\nMonero\n\nGames:\n\nSteam\n\nCommunications:\n\nTelegram\nDiscord\nJabber\n\nMail:\n\nFoxMail\nOutlook\n\nFTP:\n\nFileZilla\nWinSCP\n\n2FA Software:\n\nAuthy\n\n\n-----\n\nNordVPN\n\nBrowsers:\n\nMozilla Firefox (also Gecko browsers)\nChrome (also Chromium browsers)\nInternet Explorer\nEdge\nBrowsers using the same files the grabber targets.\n\nHowever, it has been seen in other samples and their advertisements that Taurus Stealer also supports other software not included in the list\nlike BattleNet, Skype and WinFTP. As mentioned earlier, they also have an open communication channel with their customers, who can\nsuggest new software to add support to. Stealer Dependencies Although the posts that sell the malware in underground forums claim that\nTaurus Stealer does not have any dependencies, when stealing browser information (by looping through files recursively using the \"Grabber 3\"\nmethod described before), if it finds \"logins.json\" or \"signons.sqlite\" it will then ask for needed .dlls to its C2. It first creates a directory in\n_%PROGRAMDATA%\\<bot id>, where it is going to dump the downloaded .dlls. It will check if “%PROGRAMDATA%\\<bot id>\\nss3.dll\" exists_\nand will ask for its C2 (doing a request to /dlls/ resource) if not. The .dlls will be finally dumped in the following order:\n\n1. freebl3.dll\n2. mozglue.dll\n3. msvcp140.dll\n4. nss3.dll\n5. softokn3.dll\n6. vcruntime140.dll\n\nIf we find the C2 down (when analyzing the sample, for example), we will not be able to download the required files. However, the malware will\nstill try, no matter what, to load those libraries after the request to /dlls/ has been made (starting by loading “nss3.dll”), which would lead to a\ncrash. The malware would stop working from this point. In contrast, if the C2 is alive, the .dlls will be downloaded and written to disk in the\norder mentioned before. The following figure shows the call graph from the routine responsible for requesting and dumping the required\nlibraries to disk.\n\n\n-----\n\nFigure 38. Taurus Stealer dumping retrieved .dlls from its Command and Control Server to disk\n\n**Information Gathering After the Browser stealing process is finished, Taurus proceeds to gather information from the infected machine along**\nwith the Taurus Banner and adds this data to the ZIP file in memory with the filename \"Information.txt\". All this functionality is done through a\nseries of unnecessary steps caused by all the obfuscation techniques to hide strings, which leads to a horrible function call graph:\n\n\n-----\n\nFigure 39. Taurus Stealer main Information Gathering routine call graph\n\nIt gets information and concatenates it sequentially in memory until we get the final result:\n' ______ _____ __ __ '\n\n' '\n\n' /_ __/___ ___ _________ _______ / ___// /____ ____ _/ /__ '\n\n' _____'\n\n' / / / __ `/ / / / ___/ / / / ___/ \\__ \\/ __/ _ \\/ __ `/ / _ \\'\n\n'/ ___/'\n\n' / / / /_/ / /_/ / / / /_/ (__ ) ___/ / /_/ __/ /_/ / / __/'\n\n' / '\n\n'/_/ \\__,_/\\__,_/_/ \\__,_/____/ /____/\\__/\\___/\\__,_/_/\\___/_'\n\n'/\n\n\n-----\n\n_________________________________________________________________\n\n'____________'\n\n'|Buy at Telegram: t.me/taurus_seller |Buy at Jabber: taurus_selle'\n\n'r@exploit.im|'\n\n'`````````````````````````````````````````````````````````````````'\n\n'`````````````'\n\n'UID: s0w1s8y9r9w1s8y9r9'\n\n'Prefix: MyAwesomePrefix'\n\n'Date: 15.4.2021 14:57’\n\n'IP: '\n\n'Country: '\n\n'OS: Windows 6.1 7601 x64'\n\n'Logical drives: C: D: Z: '\n\n'Current username: User'\n\n'Computername: USER-PC'\n\n'Domain: WORKGROUP'\n\n'Computer users: All Users, Default, Default User, Public, User, '\n\n'Keyboard: Spanish (Spain, International Sort)/English (United States)'\n\n'Active Window: IDA - C:\\Users\\User\\Desktop\\TAURUS_v2.idb (TAURUS_'\n\n'v2.exe)'\n\n'CPU name: Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz'\n\n'Number of CPU kernels: 2'\n\n'GPU name: VirtualBox Graphics Adapter'\n\n'RAM: 3 GB'\n\n'Screen resolution: 1918x1017'\n\n'Working path: C:\\Users\\User\\Desktop\\TAURUS_v2.exe',0\n\nOne curious difference from earlier Taurus Stealer versions is that the Active Window from the infected machine is now also included in the\ninformation gathering process.\n\n**Enumerate Installed Software As part of the information gathering process, it will try to get a list of the installed software from the infected**\nmachine by looping in the registry from “HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall” and retrieving DisplayName and\n_DisplayVersion with RegQueryValueExA until RegEnumKeyA does not find more keys. If software in the registry list has the key_\n“DisplayName”, it gets added to the list of installed software. Then, if it also has “Display Version” key, the value is appended to the name. In\ncase this last key is not available, “[Unknown]” is appended instead. Following the pattern: “DisplayName\\tDisplayVersion” As an example:\n\n“Cheat Engine 6.5.1\\t[Unknown]” “Google Chrome\\t[89.0.4389.90]” (…)\n\nThe list of software is included in the ZIP file in memory with the filename “Installed Software.txt”\n\n## C2 Exfiltration\n\nDuring the stealing process, the data that is grabbed from the infected machine is saved in a ZIP file in memory. As we have just seen,\ninformation gathering files are also included in this fileless ZIP. When all this data is ready, Taurus Stealer will proceed to:\n\n1. Generate a Bot Id results summary message.\n2. Encrypt the ZIP file before exfiltration.\n\n\n-----\n\n3 t ate t e e to Co a d a d Co t o se e\n4. Delete traces from networking activity\n\n**Generate Bot Id results summary The results summary message is created in 2 stages. The first stage loads generic information from the**\ninfected machine (Bot Id, Build Id, Windows version and architecture, current user, etc.) and a summary count of the number of passwords,\ncookies, etc. stolen. As an example:\ns0w1s8y9r9w1s8y9r9|MyAwesomePrefix|Windows 6.1 7601 x64|USER-PC|WORKGROUP|||0|576|0|7|empty\n\nFinally, it concatenates a string that represents a mask stating which Software has been available to steal information from (e.g. Telegram,\nDiscord, FileZilla, WinSCP. etc.).\ns0w1s8y9r9w1s8y9r9|MyAwesomePrefix|Windows 6.1 7601 x64|USERPC|WORKGROUP|||0|576|0|7|empty|1|1|0|0|0|1|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0\n\nThis summary information is then added in the memory ZIP file with the filename “LogInfo.txt”. This behavior is different from earlier Taurus\nStealer versions, where the information was sent as part of the URL (when doing exfiltration POST request to the resource /gate/log/) in the\nparameter “data”. Although this summary information was encrypted, the exfiltrated ZIP file was sent in cleartext. Encrypt ZIP before\n**exfiltration Taurus Stealer will then encrypt the ZIP file in memory using the techniques described before: using the RC4 stream cipher with a**\nrandomly generated key and encoding the result in BASE64. Because the RC4 key is needed to decrypt the message, the key is included at\nthe beginning of the encoded message. In the analyzed sample, as we saw before, the key length is hardcoded and is 16 bytes. As an\nexample, this could be an encrypted message being sent in a POST request to the /log/ resource of a Taurus Stealer C2, where the RC4 key is\nincluded at the beginning of the message (first 16 characters).\n\"jaCghbIiGeGEADIjMayhQpGzXwORMFuHXzsUCiVH12jIA\" (...)\n\n**Exfiltrate ZIP file to Command and Control server As in the earlier versions, it uses a try-retry logic where it will try to exfiltrate up to 10**\ntimes (in case the network is failing, C2 is down, etc.). It does so by opening a handle using HttpOpenRequestA for the “/log/” resource and\nusing this handle in a call to HttpSendRequestA, where exfiltration is done (the data to be exfiltrated is in the post_data argument). The\nfollowing figure shows this try-retry logic in a loop that executes HttpSendRequestA.\n\nFigure 40. Taurus Stealer will try to exfiltrate up to 10 times\n\nThe encrypted ZIP file is sent with Content-Type: application/octet-stream. The filename is a randomly generated string of 16 bytes. However,\nearlier Taurus Stealer versions used the Bot Id as the .zip filename. Delete traces from networking activity After exfiltration, it uses\n\n\n-----\n\n_e eteU Cac e_ _t y_ t t e C as a pa a ete o t e ca, c de etes t e cac e e t y o a g e U s s t e ast step o t e\nexfiltration process and is done to avoid leaving traces from the networking activity in the infected machine.\n\n## Loader (optional)\n\nUpon exfiltration, the Loader module is executed. This module is optional and gets its configuration from the first C2 request. If the module is\nenabled, it will load an URL from the Loader configuration and execute URLOpenBlockingStream to download a file. This file will then be\ndumped in %TEMP% folder using a random filename of 8 characters. Once the file has been successfully dumped in the infected machine it\nwill execute it using ShellExecuteA with the option nShowCmd as “SW_HIDE”, which hides the window and activates another one. If\n**persistence is set in the Loader configuration, it will also schedule a task in the infected machine to run the downloaded file every minute**\nusing:\nC:\\windows\\system32\\cmd.exe /c schtasks /create /F /sc minute /mo 1 /tn “\\WindowsAppPool\\AppP ool” /tr\n“C:\\Users\\User\\AppData\\Local\\Temp\\FfjDEIdA.exe”\n\nThe next figure shows the Schedule Task Manager from an infected machine where the task has been scheduled to run every minute\nindefinitely.\n\nFigure 41. Loader persistence is carried out by creating a scheduled task to run every minute indefinitely\n\nOnce the file is executed, a new POST request is made to the C2 to the resource /loader/complete/. The following figure summarizes the\nmain responsibilities of the Loader routine.\n\n\n-----\n\nFigure 42. Taurus Stealer Loader routine call graph\n\n## Self-Delete (optional)\n\nThis functionality is the last one being executed in the malware and is also optional, although it is enabled by default if no response from the\nC2 was received in the first request. It will use CreateProcessA to execute cmd.exe with the following arguments:\ncmd.exe /c timeout /t 3 & del /f /q <malware_filepath>\n\n_Malware_filepath is the actual path of the binary being executed (itself). A small timeout is set to give time to the malware to finish its final_\ntasks. After the creation of this process, only a clean-up routine is executed to delete strings from memory before finishing execution.\n\n## YARA rule\n\nThis memory Yara rule detects both old and new Taurus Stealer versions. It targets some unique functionalities from this malware family:\n\n**Hex2Dec: Routine used to convert from a Hexadecimal value to a Decimal value.**\n**Bot Id/UUID generation routine.**\n**getRandomString: Routine used to generate a random string using rand() over a static input buffer**\n**getRandomString2: Routine used to generate a random string using rand() over an input buffer previously “randomized” with**\nGetTickCount\n**getRandomBytes: Routine to generate “random\" input buffers for getRandomString2**\n**Hashing algorithm used to resolve APIs and Anti – C2 mod. feature.**\n\n\n-----\n\nu e tau us_stea e _ e o y {\nmeta:\ndescription = “Detects Taurus Stealer”\nauthor = “Blueliv”\ndate = “27/04/2021”\nstrings:\n/* Hex2Dec */\n$op00 = { 33 D2 4E 6A 0A 59 F7 F1 80 C2 30 88 16 85 C0 75 EF 51 8D 45 FD 8B CF 50 56 E8 ?? ?? ?? ?? 8B C7 5F 5E C9 C3 }\n/* Bot Id/UUID Generation */\n$op01 = { 8D ?? ?? ?? ?? 8D [2-3] 7? ?? [4-5] 0F [3-4] 8A 04 ?? 04 40 EB }\n/* getRandomString */\n$op02 = { E8 ?? ?? ?? ?? 99 6A 17 59 F7 F9 (83 ?? ?? ?? 8D ?? ?? | 8D ?? ?? 83 ?? ?? ??) [0-3] 0F 43 ?? ?? }\n/* getRandomString2 */\n$op03 = { 33 D2 F7 36 8B 74 8E 08 8B 4D FC 6A 3F 03 74 91 08 33 D2 8B 41 4C F7 31 }\n/* getRandomBytes */\n$op04 = { C7 46 ?? ?? 42 0F 00 C7 46 ?? ?? 42 0F 00 C7 46 ?? ?? 42 0F 00 89 ?? ?? E8 ?? ?? ?? ?? FF D0 39 1E 76 0A 31 07 43 8D 7F 04\n3B 1E 72 F6 }\n/* Hashing algorithm */\n$op05 = { 0F BE [1-2] 33 C2 (C1 EA 08 0F B6 C0 | 0F B6 C0 C1 EA 08) 33 14 85 ?? ?? ?? ?? 4? }\ncondition:\n4 of them\n}\n\n## MITRE ATT&CK\n\n**Tactic** **Technique ID** **Technique**\n\nExecution T1059 [Command and Scripting Interpreter](https://attack.mitre.org/techniques/T1059/)\n\nExecution / Persistence T1053 [Scheduled Task/Job](https://attack.mitre.org/techniques/T1053/)\n\nDefense Evasion T1140 [Deobfuscate/Decode Files or Information](https://attack.mitre.org/techniques/T1140/)\n\nDefense Evasion T1070 [Indicator Removal on Host](https://attack.mitre.org/techniques/T1070/)\n\nDefense Evasion T1027 [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027/)\n\nDefense Evasion / Discovery T1497 [Virtualization/Sandbox Evasion](https://attack.mitre.org/techniques/T1497/)\n\nCredential Access T1539 [Steal Web Session Cookie](https://attack.mitre.org/techniques/T1539/)\n\nCredential Access T1555 [Credentials from Password Stores](https://attack.mitre.org/techniques/T1555/)\n\nCredential Access T1552 [Unsecured Credentials](https://attack.mitre.org/techniques/T1552/)\n\nDiscovery T1087 [Account Discovery](https://attack.mitre.org/techniques/T1087/)\n\nDiscovery T1010 [Application Window Discovery](https://attack.mitre.org/techniques/T1010/)\n\nDiscovery T1083 [File and Directory Discovery](https://attack.mitre.org/techniques/T1083/)\n\nDiscovery T1120 [Peripheral Device Discovery](https://attack.mitre.org/techniques/T1120/)\n\nDiscovery T1012 [Query Registry](https://attack.mitre.org/techniques/T1012/)\n\nDiscovery T1518 [Software Discovery](https://attack.mitre.org/techniques/T1518/)\n\nDiscovery T1082 [System Information Discovery](https://attack.mitre.org/techniques/T1082/)\n\nDiscovery T1016 [System Network Configuration Discovery](https://attack.mitre.org/techniques/T1016/)\n\nDiscovery T1033 [System Owner/User Discovery](https://attack.mitre.org/techniques/T1033/)\n\nDiscovery T1124 [System Time Discovery](https://attack.mitre.org/techniques/T1124/)\n\nCollection T1560 [Archive Collected Data](https://attack.mitre.org/techniques/T1560/)\n\nCollection T1005 [Data from Local System](https://attack.mitre.org/techniques/T1005/)\n\nCollection T1113 [Screen Capture](https://attack.mitre.org/techniques/T1113/)\n\n\n-----\n\nCommand and Control T1071 [Application Layer Protocol](https://attack.mitre.org/techniques/T1071/)\n\nCommand and Control T1132 [Data Encoding](https://attack.mitre.org/techniques/T1132/)\n\nCommand and Control T1041 [Exfiltration over C2 Channel](https://attack.mitre.org/techniques/T1041/)\n\n## Conclusion\n\nInformation Stealers like Taurus Stealer are dangerous and can cause a lot of damage to individuals and organizations (privacy violation,\nleakage of confidential information, etc.). Consequences vary depending on the significance of the stolen data. This goes from usernames and\npasswords (which could be targetted by threat actors to achieve privilege escalation and lateral movement, for example) to information that\ngrants them immediate financial profit, such as cryptocurrency wallets. In addition, stolen email accounts can be used to send spam and/or\ndistribute malware. As has been seen throughout the analysis, Taurus Stealer looks like an evolving malware that is still being updated\n(improving its code by adding features, more obfuscation and bugfixes) as well as it’s Panel, which keeps having updates with more\nimprovements (such as adding filters for the results coming from the malware or adding statistics for the loader). The fact the malware is being\n**actively used in the wild suggests that it will continue evolving and adding more features and protections in the future, especially as**\ncustomers have an open dialog channel to request new software to target or to suggest improvements to improve functionality. For more\n[details about how we reverse engineer and analyze malware, visit our targeted malware module page.](https://www.blueliv.com/products/cyber-threat-intelligence/malware-protection)\n\n## IOCs\n\n**Hashes Taurus Stealer (earlier version):**\n\nPacked: 4a30ef818603b0a0f2b8153d9ba6e9494447373e86599bcc7c461135732e64b2\nUnpacked: ddc7b1bb27e0ef8fb286ba2b1d21bd16420127efe72a4b7ee33ae372f21e1000\n\nTaurus Stealer (analyzed sample):\n\nPacked: 2fae828f5ad2d703f5adfacde1d21a1693510754e5871768aea159bbc6ad9775\nUnpacked: d6987aa833d85ccf8da6527374c040c02e8dfbdd8e4e4f3a66635e81b1c265c8\n\n**C2 64[.]225[.]22[.]106 (earlier Taurus Stealer) dmpfdmserv275[.]xyz (analyzed Taurus Stealer)**\n\n## References\n\nCyber Intelligence Infoblox, “WordyThief: A Malicious Spammer”, October, 2020. [Online].\n[Available: https://docs.apwg.org/ecrimeresearch/2020/56_Wordythief-AMaliciousSpammer_20201028.pdf [Accessed April 25, 2021]](https://docs.apwg.org/ecrimeresearch/2020/56_Wordythief-AMaliciousSpammer_20201028.pdf)\n\nfumik0, “Predator The Thief: In-depth analysis (v2.3.5)”, October, 2018. [Online]. Available: https://fumik0.com/2018/10/15/predator-the-thief-indepth-analysis-v2-3-5/ [Accessed April 25, 2021]\n\nfumik0, “Let’s play (again) with Predator the thief”, December, 2019. [Online]. Available: https://fumik0.com/2019/12/25/lets-play-again-withpredator-the-thief/ [Accessed April 25, 2021]\n\nThreat Intelligence Team, “Taurus Project stealer now spreading via malvertising campaign”, September, 2020. [Online].\nAvailable: https://blog.malwarebytes.com/malwarebytes-news/2020/09/taurus-project-stealer-now-spreading-via-malvertisingcampaign/ [Accessed April 25, 2021]\n\nAvinash Kumar, Uday Pratap Singh, “Taurus: The New Stealer in Town”, June, 2020. [Online]\n[Available: https://www.zscaler.com/blogs/security-research/taurus-new-stealer-town [Accessed April 25, 2021]](https://www.zscaler.com/blogs/security-research/taurus-new-stealer-town)\n\nJoxean Koret, “Antiemulation Techniques (Malware Tricks II)”, February, 2010. [Online]\n[Available: http://joxeankoret.com/blog/2010/02/23/antiemulation-techniques-malware-tricks-ii/ [Accessed April 25, 2021]](http://joxeankoret.com/blog/2010/02/23/antiemulation-techniques-malware-tricks-ii/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-07 - An In-Depth analysis of the new Taurus Stealer.pdf"
    ],
    "report_names": [
        "2021-05-07 - An In-Depth analysis of the new Taurus Stealer.pdf"
    ],
    "threat_actors": [
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "a66438a8-ebf6-4397-9ad5-ed07f93330aa",
            "created_at": "2022-10-25T16:47:55.919702Z",
            "updated_at": "2025-03-27T02:05:17.412024Z",
            "deleted_at": null,
            "main_name": "IRON VIKING",
            "aliases": [
                "ATK14 ",
                "BlackEnergy Group",
                "Blue Echidna ",
                "CTG-7263 ",
                "ELECTRUM ",
                "FROZENBARENTS ",
                "Hades/OlympicDestroyer ",
                "IRIDIUM ",
                "Qudedagh ",
                "Sandworm Team ",
                "Seashell Blizzard ",
                "TEMP.Noble ",
                "Telebots ",
                "Voodoo Bear ",
                "APT44 "
            ],
            "source_name": "Secureworks:IRON VIKING",
            "tools": [
                " BlackEnergy",
                " GCat",
                " GreyEnergy",
                " Industroyer",
                " KillDisk",
                " NotPetya",
                " PSCrypt",
                " TeleBot",
                " TeleDoor",
                " xData",
                "BadRabbit"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "b3e954e8-8bbb-46f3-84de-d6f12dc7e1a6",
            "created_at": "2022-10-25T15:50:23.339976Z",
            "updated_at": "2025-03-27T02:00:55.446795Z",
            "deleted_at": null,
            "main_name": "Sandworm Team",
            "aliases": [
                "Sandworm Team",
                "ELECTRUM",
                "Telebots",
                "IRON VIKING",
                "BlackEnergy (Group)",
                "Quedagh",
                "Voodoo Bear",
                "IRIDIUM",
                "Seashell Blizzard",
                "FROZENBARENTS",
                "APT44"
            ],
            "source_name": "MITRE:Sandworm Team",
            "tools": [
                "Bad Rabbit",
                "Mimikatz",
                "Exaramel for Linux",
                "Exaramel for Windows",
                "GreyEnergy",
                "PsExec",
                "Prestige",
                "P.A.S. Webshell",
                "VPNFilter",
                "Cyclops Blink",
                "SDelete",
                "AcidRain",
                "Industroyer",
                "Industroyer2",
                "BlackEnergy",
                "Cobalt Strike",
                "NotPetya",
                "KillDisk",
                "PoshC2",
                "Impacket",
                "Invoke-PSImage",
                "Olympic Destroyer"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "3a0be4ff-9074-4efd-98e4-47c6a62b14ad",
            "created_at": "2022-10-25T16:07:23.590051Z",
            "updated_at": "2025-03-27T02:02:09.878211Z",
            "deleted_at": null,
            "main_name": "Energetic Bear",
            "aliases": [
                "ATK 6",
                "Blue Kraken",
                "Crouching Yeti",
                "Dragonfly",
                "Electrum",
                "Energetic Bear",
                "Ghost Blizzard",
                "Group 24",
                "ITG15",
                "Iron Liberty",
                "Koala Team",
                "TG-4192"
            ],
            "source_name": "ETDA:Energetic Bear",
            "tools": [
                "Backdoor.Oldrea",
                "CRASHOVERRIDE",
                "Commix",
                "CrackMapExec",
                "CrashOverride",
                "Dirsearch",
                "Dorshel",
                "Fertger",
                "Fuerboos",
                "Goodor",
                "Havex",
                "Havex RAT",
                "Hello EK",
                "Heriplor",
                "Impacket",
                "Industroyer",
                "Karagany",
                "Karagny",
                "LightsOut 2.0",
                "LightsOut EK",
                "Listrix",
                "Oldrea",
                "PEACEPIPE",
                "PHPMailer",
                "PsExec",
                "SMBTrap",
                "Subbrute",
                "Sublist3r",
                "Sysmain",
                "Trojan.Karagany",
                "WSO",
                "Webshell by Orb",
                "Win32/Industroyer",
                "Wpscan",
                "nmap",
                "sqlmap",
                "xFrost"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8941e146-3e7f-4b4e-9b66-c2da052ee6df",
            "created_at": "2023-01-06T13:46:38.402513Z",
            "updated_at": "2025-03-27T02:00:02.824555Z",
            "deleted_at": null,
            "main_name": "Sandworm",
            "aliases": [
                "G0034",
                "IRIDIUM",
                "Blue Echidna",
                "FROZENBARENTS",
                "Seashell Blizzard",
                "IRON VIKING",
                "ELECTRUM",
                "TeleBots",
                "UAC-0113",
                "UAC-0082",
                "APT44",
                "Quedagh",
                "VOODOO BEAR",
                "TEMP.Noble"
            ],
            "source_name": "MISPGALAXY:Sandworm",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535592,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653752502,
    "ts_modification_date": 1653752502,
    "files": {
        "pdf": "https://archive.orkl.eu/e3e022e33459a83cfc31a24d0489296165f2d97c.pdf",
        "text": "https://archive.orkl.eu/e3e022e33459a83cfc31a24d0489296165f2d97c.txt",
        "img": "https://archive.orkl.eu/e3e022e33459a83cfc31a24d0489296165f2d97c.jpg"
    }
}