{
    "id": "885e52e2-5db0-4ec1-a9eb-a8ee1f60583a",
    "created_at": "2022-10-25T16:48:25.182213Z",
    "updated_at": "2025-03-27T02:17:11.22185Z",
    "deleted_at": null,
    "sha1_hash": "6f1dfb7fc2367f5787b076deb44f37704a682caa",
    "title": "En Route with Sednit Part 2: Observing the Comings and Goings",
    "authors": "ESET",
    "file_creation_date": "2016-10-24T13:44:49Z",
    "file_modification_date": "2016-10-24T13:45:00Z",
    "file_size": 2283550,
    "plain_text": "## En Route with\n\n#### Part 2: Observing the Comings and Goings\n\n###### Version 1.0 • October 2016\n\n\n-----\n\n# En Route with Sednit\n\n#### Part 2: Observing the Comings and Goings\n\n###### Version 1.0 • October 2016\n\n\n-----\n\n##### Table of Content\n\n**Executive Summary** **5**\n\n**Introduction** **6**\n\nThe Sednit Group 6\n\nThe Second Part of the Trilogy 7\n\nAttribution 8\n\nPublication Strategy 8\n\n**Xagent: Backdoor Specially Compiled for You** **10**\n\nIdentikit 10\n\nTimeline 11\n\nContext 12\n\nInitialization 14\n\nModules 15\n\nCommunication Channels 21\n\nConclusion and Open Questions 27\n\n**Sedreco: The Flexible Backdoor** **28**\n\nIdentikit 28\n\nContext 29\n\nDropper Workflow 29\n\nPayload Workflow 30\n\nConclusion and Open Questions 35\n\n**Xtunnel: Reaching Unreachable Machines** **36**\n\nIdentikit 36\n\nTimeline 37\n\nBig Picture 38\n\nTraffic Proxying 39\n\nAdditional Features 42\n\nConclusion and Open Questions 45\n\n**Closing Remarks** **46**\n\n**Indicators of Compromise** **47**\n\nXagent 47\n\nSedreco 48\n\nXtunnel 49\n\n**References** **51**\n\n\n-----\n\n##### List of Tables\n\nTable 1. Xagent version 2 Linux modules 15\n\nTable 2. AgentKernel accepted commands 20\n\nTable 3. Xagent version 2 Linux channels 21\n\nTable 4. Sedreco payload commands 31\n\nTable 5. Xtunnel Parameters 43\n\n##### List of Figures\n\nFigure 1. Timeline of 0-day vulnerabilities exploited by the Sednit group in 2015. 6\n\nFigure 2. Main attack methods and malware used by the Sednit group since 2014,\nand how they are related 7\n\nFigure 3. Xagent major events 11\n\nFigure 4. Partial directory listing of Xagent source files 12\n\nFigure 5. Xagent communication workflow 18\n\nFigure 6. CryptRawPacket data buffer format 19\n\nFigure 7. URL for GET and POST requests, X.X.X.X being the C&C server IP address 22\n\nFigure 8. Format of the token value 22\n\nFigure 9. Proxy server source files 23\n\nFigure 10. Communication workflow between an Xagent infected computer using\nMailChannel and its C&C server, via a proxy server 24\n\nFigure 11. Email subject generated by the P2 protocol. 25\n\nFigure 12. Dropper workflow with the developers’ names for each step 29\n\nFigure 13. Extract of Sedreco configuration. The names of the fields are those created\nby ESET’s analysts. Field sizes are in bytes. 30\n\nFigure 14. Command registration — CMD functions are the commands handlers 31\n\nFigure 15. Data flow between Sedreco on a compromised host and its C&C server 32\n\nFigure 16. Network contact message format. Computer name is a variably-sized field 32\n\nFigure 17. Inbound file format. Field sizes are in bytes 33\n\nFigure 18. Outbound file format. Field sizes are in bytes 33\n\nFigure 19. Extract of LZW algorithm C source code 34\n\nFigure 20. Plugin Init export 35\n\nFigure 21. Plugin UnInit export 35\n\nFigure 22. XTunnel major events 37\n\nFigure 23. Xtunnel core behavior 38\n\nFigure 24. Xtunnel communication workflow 39\n\nFigure 25. Extract of T initialization code 40\n\nFigure 26.1 Message to open tunnel 0x100 on IP address 192.168.124.1 and port 4545 41\n\nFigure 26.2 Message to open tunnel 0x200 on domain name test.com and port 4646 41\n\nFigure 27.1 Xtunnel CFG before obfuscation 44\n\nFigure 27.2 Xtunnel CFG after obfuscation 45\n\n\n-----\n\n### En Route with Sednit\n\n\n##### Executive Summary\n\nThe Sednit group — also known as APT28, Fancy Bear and Sofacy — is a group of attackers\noperating since 2004 if not earlier and whose main objective is to steal confidential information\nfrom specific targets.\n\nThis is the second part of our whitepaper “En Route with Sednit”, which covers the Sednit’s group\nactivities since 2014. Here, we focus on Sednit’s espionage toolkit, which is deployed on targets\ndeemed interesting after a reconnaissance phase (described in the first part of the whitepaper).\n\nThe key points described in this second installment are the following:\n\n- The Sednit group developed two different spying backdoors for long term monitoring,\nnamed Sedreco and Xagent, in order to maximize the chance of avoiding detection\n\n- The Xagent backdoor can communicate with its C&C server over email with a custom\n\nprotocol, which in some cases is based on Georgian words\n\n- The Sednit group developed a network proxy tool, named Xtunnel, to effectively transform\na compromised computer into a network pivot, in order to contact machines that are normally\nunreachable from the Internet\n\n- The Xagent source code, the Xagent C&C server configuration, and the Xtunnel binaries\n\nall contain traces of Russian, strongly reinforcing the hypothesis that this is the language\nemployed by the Sednit group’s members\n\n[For any inquiries related to this whitepaper, contact us at: threatintel@eset.com](mailto:threatintel%40eset.com?subject=En%20Route%20with%20Sednit%20Part%202)\n\n\n-----\n\n### En Route with Sednit\n\n\n##### Introduction\n\n_Readers who have already read the first part of our Sednit trilogy might want to skip the following section_\n_(duplicated from the previous part) and go directly to the specific introduction of this second part._\n\n###### The Sednit Group\n\nThe Sednit group — variously also known as APT28, Fancy Bear, Sofacy, Pawn Storm, STRONTIUM\nand Tsar Team — is a group of attackers operating since 2004 if not earlier, whose main objective\nis to steal confidential information from specific targets. Over the past two years, this group’s activity\nhas increased significantly, with numerous attacks against government departments and embassies\nall over the world.\n\nAmong their most notable presumed targets are the American Democratic National Committee [1],\nthe German parliament [2] and the French television network TV5Monde [3]. Moreover, the Sednit\ngroup has a special interest in Eastern Europe, where it regularly targets individuals and organizations\ninvolved in geopolitics.\n\nOne of the striking characteristics of the Sednit group is its ability to come up with brand-new 0-day [4]\nvulnerabilities regularly. In 2015, the group exploited no fewer than six 0-day vulnerabilities, as shown\nin Figure 1.\n\n\n**CVE-2015-3043**\nFlash\n\n**CVE-2015-1701**\nWindows LPE\n\n\n**CVE-2015-2590**\nJava\n\n**CVE-2015-4902**\nJava click-to-play bypass\n\n\n**CVE-2015-7645**\nFlash\n\n\n**APR** **MAY** **JUN** **JUL** **AUG** **SEP** **OCT**\n\n**CVE-2015-2424**\nOffice RCE\n\nFigure 1. Timeline of 0-day vulnerabilities exploited by the Sednit group in 2015\n\nThis high number of 0-day exploits suggests significant resources available to the Sednit group, either\nbecause the group members have the skills and time to find and weaponize these vulnerabilities,\nor because they have the budget to purchase the exploits.\n\nAlso, over the years the Sednit group has developed a large software ecosystem to perform\nits espionage activities. The diversity of this ecosystem is quite remarkable; it includes dozens\nof custom programs, with many of them being technically advanced, like the Xagent and Sedreco\nmodular backdoors (described in the second part of this whitepaper), or the Downdelph bootkit\nand rootkit (described in the third part of this whitepaper).\n\nWe present the results of ESET’s two-year pursuit of the Sednit group, during which we uncovered\nand analyzed many of their operations. We split our publication into three independent parts:\n\n1. “Part 1: Approaching the Target” describes the kinds of targets the Sednit group is after,\nand the methods used to attack them. It also contains a detailed analysis of the group’s\nmost-used reconnaissance malware.\n\n\n-----\n\n### En Route with Sednit\n\n\n2. “Part 2: Observing the Comings and Goings” describes the espionage toolkit deployed on some\n\ntarget computers, plus a custom network tool used to pivot within the compromised\norganizations.\n\n3. “Part 3: A Mysterious Downloader” describes a surprising operation run by the Sednit group,\n\nduring which a lightweight Delphi downloader was deployed with advanced persistence\nmethods, including both a bootkit and a rootkit.\n\nEach of these parts comes with the related indicators of compromise.\n\n###### The Second Part of the Trilogy\n\nFigure 2 shows the main components that the Sednit group has used over the last two years,\nwith their interrelationships. It should not be considered as a complete representation of their\narsenal, which also includes numerous small custom tools.\n\n**ATTACK** **FIRST-STAGE** **SECOND-STAGE** **PIVOT**\n**METHODS** **MALWARE** **MALWARE** **MALWARE**\n\n**Seduploader** **Seduploader** **Sedreco** **Sedreco**\n\n**Xtunnel**\n\ndropper payload dropper payload\n\nSedkit\n\n**Usbstealer**\n\nEmail\nattachments\n\n**Downdelph** **Xagent**\n\nFake webmail\nlogin panels\n\nEn Route with En Route En Route\n\nSednit with Sednit with Sednit\n**Part 1** **Part 3** **Part 2**\n\nFigure 2. Main attack methods and malware used by the Sednit group since 2014,\nand how they are related\n\nWe divide Sednit’s software into three categories: the first-stage software serves for reconnaissance\nof a newly compromised host, then comes the second-stage software intended to spy on machines\ndeemed interesting, while the pivot software finally allows the operators to reach other computers.\n\nIn this second part, we focus on Sednit’s espionage toolkit, which serves for long term monitoring\nof compromised computers. The components described in this second part are outlined in blue\nin Figure 2, which includes the two spying backdoors Sedreco and Xagent, and the network\ntool Xtunnel.\n\nThe usual workflow of Sednit’s operators is to deploy both Sedreco and Xagent on a newlycompromised computer, after a reconnaissance phase with first-stage malware (Seduploader,\ndescribed in the first part of this whitepaper, or Downdelph, described in the third part). Deploying\nboth spying backdoors at the same time allows them to remain in contact if one of them becomes\ndetected. The network tool Xtunnel comes later, in order to reach other accessible computers.\n\n|Col1|Col2|Col3|Col4|Col5|\n|---|---|---|---|---|\n||||||\n||||||\n||||||\n||||||\n||||||\n\n|Seduploader Seduploader Sedreco Sedreco Xtunnel dropper payload dropper payload Sedkit Usbstealer Email attachments Downdelph Xagent Fake webmail login panels En Route with En Route En Route Sednit with Sednit with Sednit Part 1 Part 3 Part 2|Col2|\n|---|---|\n|||\n|||\n\n\n**SECOND-STAGE**\n**MALWARE**\n\n**Sedreco** **Sedreco**\ndropper payload\n\n**Xagent**\n\nEn Route\nwith Sednit\n**Part 2**\n\n\n**ATTACK**\n**METHODS**\n\nSedkit\n\nEmail\nattachments\n\nFake webmail\nlogin panels\n\n\n-----\n\n### En Route with Sednit\n\n\nAll the components shown in Figure 2 are described in this whitepaper,\nwith the exception of Usbstealer, a tool to exfiltrate data from air-gapped\nmachines that we have already described at WeLiveSecurity [5]. Recent\nversions have been documented by Kaspersky Labs [6] as well.\n\nReaders who have already read the first part of our Sednit trilogy may skip the following sections\nand go directly to Xagent’s analysis.\n\n###### Attribution\n\nOne might expect this reference whitepaper to add new information about attribution. A lot has\nbeen said to link the Sednit group to some Russian entities [7], and we do not intend to add anything\nto this discussion.\n\nPerforming attribution in a serious, scientific manner is a hard problem that is out of scope\nof ESET’s mission. As security researchers, what we call “the Sednit group” is merely a set of software\nand the related network infrastructure, which we can hardly correlate with any specific organization.\n\nNevertheless, our intensive investigation of the Sednit group has allowed us to collect numerous\nindicators of the language spoken by its developers and operators, as well as their areas of interest,\nas we will explain in this whitepaper.\n\n###### Publication Strategy\n\nBefore entering the core content of this whitepaper, we would like to discuss our publication strategy.\nIndeed, as security researchers, two questions we always find difficult to answer when we write\nabout an espionage group are “when to publish?”, and “how to make our publication useful to those tasked\n_with defending against such attacks?”._\n\nThere were several detailed reports on the Sednit group published in 2014, like the Operation Pawn\nStorm report from Trend Micro [8] and the APT28 report from FireEye [9]. But since then the public\ninformation regarding this group has mainly came in the form of blog posts describing specific\ncomponents or attacks. In other words, no public attempts have been made to present the big\npicture on the Sednit group since 2014.\n\nMeanwhile, the Sednit group’s activity has significantly increased, and its arsenal differs from those\ndescribed in previous whitepapers.\n\nTherefore, our intention here is to provide a detailed picture of the Sednit group’s activities over\nthe past two years. Of course, we have only partial visibility into those activities, but we believe\nthat we possess enough information to draw a representative picture, which should in particular\nhelp defenders to handle Sednit compromises.\n\nWe tried to follow a few principles in order to make our whitepaper useful to the various types\nof readers:\n\n- Keep it readable: while we provide detailed technical descriptions, we have tried to\n\nmake them readable, without sacrificing precision. For this reason we decided to split\nour whitepaper into three independent parts, in order to make such a large amount of\ninformation easily digestible. We also have refrained from mixing indicators of compromise\nwith the text.\n\n- Help the defenders: we provide indicators of compromise (IOC) to help detect current Sednit\n\ninfections, and we group them in the IOC section and on ESET’s GitHub account [10]. Hence,\nthe reader interested only in these IOCs can go straight to them, and find more context\nin the whitepaper afterwards.\n\n\n-----\n\n### En Route with Sednit\n\n\n\n- Reference previous work: a high profile group such as Sednit is tracked by numerous entities.\nAs with any research work, our investigation stands on the shoulders of the previous\npublications. We have referenced them appropriately, to the best of our knowledge.\n\n- Document also what we do not understand: we still have numerous open questions\n\nregarding Sednit, and we highlight them in our text. We hope this will encourage fellow\nmalware researchers to help complete the puzzle.\n\nWe did our best to follow these principles, but there may be cases where we missed our aim.\n[We encourage readers to provide feedback at threatintel@eset.com, and we will update](mailto:threatintel%40eset.com?subject=Sednit)\nthe whitepaper accordingly.\n\n\n-----\n\n### En Route with Sednit\n\n\n##### Xagent: Backdoor Specially Compiled for You\n\n\n-----\n\n### En Route with Sednit\n\n\n###### Timeline\n\nThe dates posited in the timeline mainly rely on Xagent compilation timestamps, which we believe\nhave not been tampered with because they match up with our telemetry data. These dates may\nbe later than the actual events though, as we do not have all Xagent samples, but enough\nare present to give a good approximation. In particular, we dated the appearance of Xagent\nas independent malware in November 2012, but fellow malware researchers reported to us privately\nthat parts of its code were used before that.\n\n\n##### 2012\n**November**\n\nIntroduction of Xagent\nversion 1 for Windows\n\n##### 2016\n**May**\n\nXagent found on\nthe servers of the\nDemocratic National\nCommittee (DNC)\n\n\n##### 2014\n**February**\n\nIntroduction of Xagent\nversion 2 for both Linux\nand Windows\n\n##### 2015\n**December**\n\nIntroduction of Xagent\nversion 3 for Linux\n\n\n##### 2014\n**September**\n\nXagent deployed\nwith Sedkit exploit kit\n\nIntroduction of\nversion 3 for Windows;\nModules now have\nobfuscated Run-Time Type\nInformation (RTTI)\n\n##### 2015\n**February**\n\nXagent for iOS found\nby Trend Micro _[13]_\n\n\nFigure 3. **Xagent major events**\n\n\n-----\n\n### En Route with Sednit\n\n\n###### Context\n\nDuring our investigations, we were able to retrieve the complete Xagent source code for the Linux\noperating system. To the best of our knowledge, this is the first time this Xagent source code\nhas been found and documented by security researchers.\n\nThis source code is a fully working C++ project, which was used by Sednit operators to compile\na binary in July 2015 (at least). The project contains around 18,000 lines of code among 59 classes;\na partial directory listing of the source files is shown in Figure 4.\n\nFigure 4. Partial directory listing of Xagent source files\n\n\n-----\n\n### En Route with Sednit\n\n\nWe believe the Linux source code is derived from the Windows version of Xagent. In other words,\nOS-specific operations have been re-implemented, but the core logic remains the same on both\nplatforms. As an example of this lineage, the following code snippet shows some Windows API calls\nfor thread termination commented out by the developers, and replaced with a call to the Linux\npthreads [14] interface.\n```\n   if(handleGetPacket != 0)\n   {\n   pthread_exit(&handleGetPacket);\n   //TerminateThread(handleGetPacket, 0);\n   //CloseHandle(handleGetPacket);\n   }\n\n```\nAccording to its internal version numbering, this source code is version 2 of Xagent, while currently\ndistributed Windows and Linux binaries are version 3. Nevertheless, there appear to be only minor\ndifferences between the two versions, and the source code matches the core logic of the most recent\nsamples on both Windows and Linux platforms. Also, the iOS version of Xagent found by Trend\nMicro [13] — not documented in this white paper — is based on this source code, according\nto our own analysis.\n\nTherefore, we decided to present an analysis of Xagent mainly based on the source code,\nand not on binaries, to ease the explanations.\n\nIn order to facilitate the reading of the source code, we made the following syntactic choices:\n\n- Parts of the code not relevant to our analysis have been replaced by […​]\n\n- As the code is heavily commented by its developers, we decided to leave those comments\nuntouched. For the reader this comes at the price of enduring poorly-worded English\ncomments, but this allows a finer understanding of what the developers were thinking.\n\n- Our own comments on the code appear after the snippets, and are indicated by numbered tags\n\n- When the developers’ comments are in Russian, we added the translation in the form\nof /* Translates to: …​*/\n\n\n-----\n\n### En Route with Sednit\n\n\n###### Initialization\n\nWe begin our journey through Xagent source code in the file main.cpp in the function\n```\nstartXagent(), which contains the instantiations of the main objects, as shown below.\n   int startXagent(wstring path)\n   {\n     [...]\n\n```\n`AgentKernel krnl( (wchar_t *)path.c_str() );` ➊\n\n`IAgentChannel* http_channel = new HttpChannel();` ➋\n```\n     //IAgentChannel* smtp_channel = new MailChannel();\n\n```\n`IAgentModule* remote_shell = new RemoteShell();` ➌\n```\n     IAgentModule* file_system = new FSModule();\n     //IAgentModule* key_log = new RemoteKeylogger();\n\n```\n`krnl.registerChannel(http_channel);` ➍\n```\n     //krnl.registerChannel(smtp_channel);\n     krnl.registerModule(remote_shell);\n     krnl.registerModule(file_system);\n     //krnl.registerModule(key_log);\n\n```\n`krnl.startWork();` ➎\n```\n     [...]\n   }\n\n```\n➊ Instantiation of an AgentKernel object, called “kernel” hereafter, which is the Xagent\nexecution manager.\n\n➋ Instantiation of an IAgentChannel object, called “channel” hereafter, which is the means\n\nof communication with the C&C server. The source code contains two different channel\nimplementations, one over HTTP and one over email. Here the developers have commented\nout the email channel instantiation.\n\n➌ Instantiations of several IAgentModule objects, called “modules” hereafter, which implement\n\nXagent functionalities. Here the developers have commented out the keylogger\nmodule instantiation.\n\n➍ Calls to the AgentKernel::registerChannel() and AgentKernel::registerModule()\nmethods, through which the kernel starts managing these modules’ executions, and pass\ntheir communications through the registered channel. Registrations of the unused channel\nand module are commented out.\n\n➎ Call to the AgentKernel::startWork() method, which creates execution threads\non the worker methods of each registered module and channel.\n\nCommenting out module and channel instantiations is a strategy we previously observed when\nanalyzing Xagent binaries. Each sample does indeed come with a specific combination of modules\nand channels, even though the Xagent kernel is completely capable of managing all of them\nin parallel (including multiple channels).\n\nBy doing so, operators probably intend to adapt Xagent binaries for specific targets, and avoid\nexposing the whole Xagent code to security researchers. Moreover, operators may still deploy\nadditional modules and channels during execution, as we will explain later.\n\n\n-----\n\n### En Route with Sednit\n\n\n###### Modules\n\nThe core Xagent functionalities lie in its modules. As shown in the startXagent() snippet,\nXagent Linux source code contains three modules, plus the kernel which is itself also a module.\nThese modules are listed in Table 1:\n\n\nTable 1. **Xagent version 2 Linux modules**\n\n\nName ID Purpose Name of equivalent module\non Windows\n\n\n`AgentKernel` `0x0002` Manages Xagent execution and relay\ncommunications between the modules\nand the C&C server\n\n```\nAgentKernel\n\n```\n\n`RemoteKeylogger` `0x1002` Logs keystrokes `ModuleRemoteKeyLogger`\n\n\n`FSModule` `0x1122` Provides wrappers for file system\noperations (find, read, write, execute, etc)\n\n`RemoteShell` `0x1302` Executes supplied commands in Linux\ncommand-line interpreter /bin/sh\n\n```\nModuleFileSystem\nProcessRetranslatorModule\n\n```\n\nAs shown in the second column, each module is identified by a 2-byte ID, which is a combination\nof a version number and a module identifier. For example, when AgentKernel ID is set to 0x0002,\nit corresponds to version 2 and the module numbered 0.\n\nCurrently distributed Xagent binaries possess a kernel ID of 0x3303,\nthus corresponding to kernel version 3 and the module — strangely — numbered 33. The oldest Xagent versions had a kernel ID of 0x0001.\n\nEach Linux Xagent module has an equivalent module in the Windows version, as shown in the fourth\ncolumn of Table 1 (Windows names come from Run-Time Type Information (RTTI) [12] left in some\nbinaries). Due to operating system peculiarities, the module implementations differ between\nWindows and Linux, but their IDs and the commands they accept are the same.\n\nIn the following section, we will present an in-depth description of the kernel module, leaving aside\nthe other, more straightforward, modules.\n\nWhile recent versions of Xagent for Windows only have the modules\ndescribed in Table 1, older versions have been seen with additional modules,\nsuch as:\n\n               - `DirectoryObserverModule, which monitors all mounted volumes for files`\nwith specific extensions (.doc, .docx, .pgp, .gpg, .m2f, .m2o)\n\n               - `ModuleNetFlash, which monitors removable drives for C&C messages,`\nin a similar way to Usbstealer _[5]_\n\n               - `ModuleNetWatcher, which maps network resources`\n\n\n-----\n\n### En Route with Sednit\n\n\n###### Kernel\n\nAs described in Table 1, AgentKernel is the execution manager, and the only module\nthat has to be present in all Xagent binaries.\n\nConstructor\n\nOur analysis of AgentKernel begins in its constructor:\n```\n   AgentKernel::AgentKernel(wchar_t *path_Xagent)\n   {\n     [...]\n\n```\n`local_storage_ = new LocalStorage(path_Xagent);` ➊\n```\n     [...]\n     cryptor_ = new Cryptor(kernel_main_crypto_key, sizeof(kernel_main_crypto_\n\n```\n`key));` ➋\n```\n     [...]\n\n```\n`channel_controller_ = new ChannelController(this);` ➌\n\n`reserved_ = new ReservedApi();` ➍\n```\n     [...]\n\n```\n`modules_.insert(modules_.begin(), this);` ➎\n```\n   }\n\n```\n➊ Instantiation of a LocalStorage object, which is the kernel store. It contains both\na file-based storage for the communications with the C&C server, and an SQLite3 [15]\ndatabase to store various configuration parameters.\n\n➋ Instantiation of a Cryptor object, which is the cryptographic engine of the kernel.\nIt will serve in particular to encrypt the communications with the C&C server.\n\n➌ Instantiation of a ChannelController object, which is the interface to contact\nthe C&C server, as we will explain later.\n\n➍ Instantiation of a ReservedApi object. It implements some helper functions used by the kernel,\nlike ReservedApi::initAgentId() to generate a 4-byte ID for the Xagent infected computer.\n\n➎ The kernel being a module, it inserts itself in the list of modules whose execution will be managed.\n\nIn the kernel constructor code and elsewhere, important strings are accessed through a class\nnamed Coder, which is a wrapper around an encrypted string. The string is then decrypted on-demand\nby an exclusive-or (XOR) with a key defined at the time the Coder object was instantiated.\n\n\n-----\n\n### En Route with Sednit\n\n\nFor example, in the following code snippet KERNEL_PATH_MAIN_KEY is the encrypted string\nand mask the key, while the decrypted string is then retrieved by calling the method\n```\nCoder::getDencodeAscii() [sic].\n   Coder* coder = new Coder((u_char *)KERNEL_PATH_MAIN_KEY,\n                     sizeof(KERNEL_PATH_MAIN_KEY), mask, sizeof(mask) );\n   string name_bd = coder->getDencodeAscii();\n\n```\nThis mechanism theoretically allows Xagent to keep strings encrypted until they are used.\nNevertheless, a macro in the source code allows them to be left unencrypted (the key in Coder\nbeing forced to zeros), which is actually the case in all Linux binaries we analyzed. On the other\nhand, the Coder class is indeed used with encrypted strings in Windows Xagent.\n\nThe kernel constructor code refers to some configuration parameters whose\nvalues are hardcoded in the header file AgentKernel.h. The definitions\nof these parameters appear to have been automatically extracted from\na XML file, as shown for example below for the Xagent mutex name.\n\n```\n/* <xmlblok config=”MESSAGE” type=”u_char”><![CDATA[ */ static /*\n  ]]> */\n  /* <type><![CDATA[ */ wchar_t /* ]]> */ /* </type> */\n  /* <static><![CDATA[ */ MUTEX_OF_XAGENT [] = /* ]]></static>\n  */\n  /* <config operation=”L’unicode’={byte}”><![CDATA[\nL”XSQWERSystemCriticalSection_for_1232321” /* ]]> */ ; /* </\n  config> */\n  /* </xmlblok> */\n\n```\n\n-----\n\n### En Route with Sednit\n\n\n###### Core Logic\n\nAs for all modules, the core logic of the kernel lies in its run() method, on which an execution thread\nhas been created by the previously described startWork() method. The purpose of the kernel run()\nmethod is to relay the communications between the modules and the C&C server, as shown in Figure 5,\nand as described below.\n\nModules\n\nAgentKernel::giveMessage() AgentKernel::run()\n\nAgentKernel::takeMessage()\n\nReports to C&C server\n\nRemoteShell::giveMessage()\n\nthe list of installed modules\n\nRemoteShell::takeMessage()\n\nFSModule::giveMessage() Fetches messages from\n\nmodules for the C&C server\n\nFSModule::takeMessage()\n\nFetches messages\n\nRemoteKeylogger::giveMessage() from C&C server for modules\n\nRemoteKeylogger::takeMessage()RemoteKeylogger::takeMessage()\n\nAgentKernel::translateToModule() AgentKernel::translateToController()\n\n1. Decrypts message 1. Encrypts message\n2. Transfer to intended module 2. Stores it into LocalStorage\n\n_get_questions Local Storage\n(C++ vector) (File on harddrive)\n\nChannelController::getDataToServer() ChannelController::sendDataToServer()\n\nIf there is an inbound\n\nIf currently selected\n\npacket in currently selected channel is not working, Fetches message from Sends it through currently\nchannel, writes it into switch to another channel LocalStorage selected channel\n```\n   _get_questions vector\n\n```\nIAgentChannel::getRawPacket() IAgentChannel::sendRawPacket()\n\n**Legend**\n\nData flow\nUnencrypted messages\n(ModuleMsg objects)\n\nData flow\nEncrypted messages\n(CryptRawPacket objects)\n\nC&C Server Control flow\nconnected to Internet C++ method\n\nFigure 5. **Xagent communication workflow**\n\n\n-----\n\n### En Route with Sednit\n\n\nHello Message\n\nFirst things first, AgentKernel::run() reports the list of installed modules to the C&C server.\nMore precisely, the kernel behaves as if it had received a command called PING_REQUEST from\nthe C&C server (the kernel’s commands will be described in the following section). It then builds\na report in a ModuleMsg object, which is the class encapsulating messages to or from modules,\nand whose important fields are shown in the following code snippet.\n```\n   class ModuleMsg\n   {\n   private:\n     // ID агента от/кому предназначено сообщение\n     /* Translates to: The agent ID from/to whom the message is intended */\n     int agentId;\n     // ID модуля от/кому предназначено сообщение\n     /*Translates to: The module ID from/to whom the message is intended */\n     u_short modId;\n     // ID команды, которую выполнил модуль или которую нужно выполнить\n     /* Translates to: ID of the command that was executed, or will be executed */\n     u_char cmdId;\n     // Указатель на память, где лежат данные команды\n     /* Translates to: Pointer to the memory where data are */\n     u_char* data;\n   [...]\n   }\n\n```\nIn this report message the modId field is set to the kernel ID 0x0002, cmdId to PING_REQUEST,\nand data points to the list of installed module IDs separated by the character #.\n\nThe ModuleMsg object is then passed to the AgentKernel::translateToController() method,\nwhich takes charge of its encryption, resulting in a CryptRawPacket object. This object just contains\na pointer to a buffer whose format is described in Figure 6.\n\nHeader\n\n**0** **4** **8** **n-15** **n-4** **n**\n\n\nAgent ID Checksum Serialized ModuleMsg `DATA_TOKEN` RC4 register\n\n**Legend**\n\nUnencrypted text data\n\nRC4-encrypted data\n\nFigure 6. `CryptRawPacket data buffer format`\n\nThe buffer starts with a header composed of the agent ID and a checksum calculated on the rest\nof the data. This checksum is a 2-byte cyclic redundancy check (CRC) [16] calculated on the data\nwith a 2-byte pseudo-randomly generated polynomial. These two values are appended to each other\nto form the checksum field 4-byte value.\n\n\n-----\n\n### En Route with Sednit\n\n\nThen comes the serialized ModuleMsg object followed by an 11-byte value named DATA_TOKEN, both\nRC4-encrypted. The DATA_TOKEN value is hardcoded in the source code and probably serves to check\nthe integrity of the message during decryption by the C&C server. The key used for RC4-encryption\nis the concatenation of a hardcoded 50-byte value and a pseudo-randomly generated 4-byte value,\nnamed register and appended to the encrypted data.\n\nThe exact same 50-byte value is used to form an RC4-key, also with\na “register”, in Downdelph and Seduploader.\n\nAs shown in Figure 5, the resulting buffer is written into a file maintained by the LocalStorage\nobject. The encrypted data are then retrieved from this file and sent to the C&C server\nby the ChannelController::sendDataToServer() method, through the currently selected\nchannel (channel implementation will be described in the next section).\n\nCommunications Loop\n\nAs shown in Figure 5, AgentKernel::run() then enters in an infinite loop relaying communications\nbetween the modules and the C&C server:\n\n- It fetches ModuleMsg objects from the modules, which are then transmitted to the C&C server\n\nby the process previously described for the initial report. For example, the RemoteKeylogger\nmodule regularly sends a message containing the captured keystrokes to the C&C server.\n\n- It retrieves CryptRawPacket objects sent by the C&C server from a C++ vector dubbed _get_\n```\n questions and filled by the ChannelController::getDataFromServer() method. Those\n\n```\nobjects are decrypted and deserialized into ModuleMsg objects, which are then transmitted\nto the intended module. For example, the C&C server can send a message with the command\n```\n START for the RemoteKeylogger module, which then begins its keylogging activity.\n\n```\nAccepted Commands\n\nThe kernel accepts 12 different commands from the C&C server, as listed in Table 2. In practice these\ncommands are integer values corresponding to macros defined in the source code.\n\n\nTable 2. `AgentKernel accepted commands`\n\n\nName Integer Purpose\nValue\n\n`GET_AGENT_INFO` 1 Reports IDs and settings of modules and channels to the C&C server\n\n`PING_REQUEST` 2 Reports IDs of modules to the C&C server\n\n`CHANGE_PING_TIMEOUT` 31 Sets the parameter defining the amount of time to wait before initially\ncontacting the C&C server to the given value\n\n`CHANGE_STEP_TIME` 32 Sets the parameter defining the amount of time to wait between\ntwo attempts to reach the C&C server to the given value\n\n`SET_PARAMETERS` 33 Saves the two previous parameters current values into the LocalStorage\nSQLite3 database, such that those values will be re-used at next startup\n\n`CHANGE_CHANNEL` 41 Changes the currently selected channel to the channel identified\nby the given ID (see next section for details on the channels)\n\n\n-----\n\n### En Route with Sednit\n\n\nName Integer Purpose\nValue\n\n`CHANNEL_SET_` 42 Changes the settings of the channel identified by the given ID.\n`PARAMETERS` For example, it may be used to change the C&C server address.\n\n`LOAD_NEW_MODULE` 51 Instantiates an IAgentModule object from the given data, and\nregisters this new module with the kernel\n\n`UNLOAD_MODULE` 52 Unloads the module identified by the given ID\n\n`LOAD_NEW_CHANNEL` 53 Instantiates an IAgentChannel object from the given data,\nand registers this new channel with the kernel\n\n`UNLOAD_CHANNEL` 54 Unloads the channel identified by the given ID\n\n`UNINSTALL_XAGENT` 61 Kills the Xagent process (no uninstallation procedure implemented)\n\n###### Communication Channels\n\nThe ChannelController object is in charge of contacting the C&C server through the currently\nselected communication channel, as shown in Figure 5. This controller is unaware of the underlying\nimplementation of the channel, and can use for that purpose any object implementing the abstract\nclass named IAgentChannel.\n\nThe Linux source code contains two channels, one using HTTP and one using emails, as described\nin Table 3.\n\n\nTable 3. **Xagent version 2 Linux channels**\n\n\nName ID Network Protocols Name of equivalent channel\non Windows\n\n`HttpChannel` `0x2102` HTTP `WinHttp`\n\n\n`MailChannel` `0x2302` SMTP to send emails and POP3\nto receive emails (over TLS)\n\n```\nAgentExternSMTPChannel\n\n```\n(only to send emails)\n\n\nEach channel is identified by a 2-byte ID similar to the previously described module ID. There exists\nan implementation for the HTTP-based channel on Windows, while we only found a channel to send\nemails, without the ability to receive emails, on this platform.\n\nBy implementing the IAgentChannel abstract class, the channels provide a getRawPacket()\nmethod to fetch a message from the C&C server, and a sendRawPacket() method to send\na message to the C&C server. As previously explained, those messages are CryptRawPacket objects.\nWe describe in this section the implementations of these methods for the two Linux channels.\n\nWhile Xagent samples usually come with only one channel, the Channel```\n          Controller object can manage several of them in parallel. In particular it\n\n```\nwill automatically switch to a different channel — if there is one — in case the\ncurrently selected one is broken, as shown in Figure 5. Additionally, the operators can deploy a completely new channel through the previously described\n```\n          LOAD_NEW_CHANNEL kernel command.\n\n```\n\n-----\n\n### En Route with Sednit\n\n\n###### HttpChannel\n\nThe HttpChannel::getRawPacket() method is implemented as a HTTP GET request — the message\nfrom the server being then in the HTTP answer body — while HttpChannel::sendRawPacket()\nis an HTTP POST request, whose body contains the message. The C&C IP address is hardcoded\nin the associated header file HttpChannel.h.\n\nBoth GET and POST requests are done on a URL following the format pictured in Figure 7.\n\n\nSeries of randomly\nchosen characters\nfrom base64 alphabet\n\n|Col1|Series of ra chosen cha|\n|---|---|\n||chosen ch from base|\n|||\n\n```\nhttp://X.X.X.X/path/?parameter1=value1&parameter2=value2&...&mark-token&...\n\n```\n\nChosen among\n15 possible values\n\n|eter1=value1&parame|Col2|\n|---|---|\n|||\n||Chosen a|\n\n\nFigure 7. URL for GET and POST requests, X.X.X.X being the C&C server IP address\n\nRoughly summarized, this URL is a series of pseudo-randomly chosen parameters associated\nwith pseudo-randomly generated values, except for a special parameter called mark. This special\nparameter (whose value is set to ai in the Linux source code) is associated with a so-called token,\nwhich is a 20-byte value encoding the agent ID in the format pictured in Figure 8.\n\n**0** **5** **9** **16** **20**\n\n\nJunk Key `URL_TOKEN xor key` Agent ID\n\n**Legend**\n\nRandomly chosen Base64\ncharacters from encoded data\nbase 64 alphabet\n\nFigure 8. Format of the token value\n\nIn this token, the Key is pseudo-randomly generated, while URL_TOKEN is hardcoded in the source\ncode and probably serves to check the integrity of the message by the C&C server.\n\nThe bodies of the POST requests, and of the responses to GET requests, follow exactly the same\nformat as the token, except that they contain a CryptRawPacket object in place of the agent ID.\nAlso, the hardcoded value is a different one, called DATA_TOKEN by the developers.\n\n###### MailChannel\n\nThe MailChannel object is an implementation of Xagent communication channel over emails,\nwhere messages are sent and received as attachments to emails.\n\nDuring an investigation, we discovered the source code of a proxy server employed to relay traffic\nbetween Xagent infected computers using MailChannel (dubbed “agents” hereafter) and a C&C server.\nThis source code was left in an open directory on the proxy server, which was then indexed\nby the Google search engine.\n\n\n-----\n\n### En Route with Sednit\n\n\nThe proxy code is a set of Python scripts containing more than 12,200 lines of code among 14 files;\nthe files are shown in Figure 9. It also contains some log files indicating it was in use from April 2015\nto June 2015.\n\n```\n$ls -hog\n  877B 27 Feb 2015 ConsoleLogger.py\n  4.8K 14 Apr 2015 FSLocalStorage.py\n  6.9K 14 Apr 2015 FSLocalStorage.pyc\n  1.6K 27 Feb 2015 FileConsoleLogger.py\n  2.6K 7 Apr 2015 FileConsoleLogger.pyc\n  5.8K 27 Feb 2015 MailServer.py\n  11K 7 Apr 2015 MailServer2.py\n  9.6K 16 Apr 2015 MailServer3.py\n  2.3K 7 Apr 2015 P2Scheme.py\n  2.2K 7 Apr 2015 P2Scheme.pyc\n  1.6K 7 Apr 2015 P3Scheme.py\n  2.4K 7 Apr 2015 P3Scheme.pyc\n  745B 27 Feb 2015 WsgiHttp.py\n  2.3K 14 Apr 2015 XABase64.py\n  3.1K 14 Apr 2015 XABase64.pyc\n   0B 6 Apr 2015 __init__.py\n  2.9M 19 Jun 2015 _w3.log\n  12K 16 Apr 2015 _w3server.log\n  1.5K 3 Apr 2015 quickstart.py\n  2.4K 15 Apr 2015 settings.py\n  1.6K 15 Apr 2015 settings.pyc\n  4.2K 15 Apr 2015 w3s.py\n  605B 27 Feb 2015 wsgi.py\n\n```\n\nFigure 9. Proxy server source files\n\nAs can be seen from the files’ names, the proxy is actually more than a simple relay of communications:\nit translates the email channel protocol from the agents into HTTP requests for the C&C server.\nTherefore, we decided to include this proxy in our analysis of the email communication channel.\nFigure 10 represents the whole communication workflow that will be described in this section.\n\n\n-----\n\n### En Route with Sednit\n\n\n**P2Scheme**\n(”Level 2 Protocol”)\n\nProxy Server\n\n**P3Scheme**\n(”Level 3 Protocol”)\n\n\nEmail received at\nexfil@example.com\n\n\nEmail received at\norders@example.com\n\n|MailServer.py For all known agents Fetch new email Send “TO” folder content as email attachment Validate email subject if valid Save attachment in “FROM” folder of the sender agent Server Storage folders for agent 9312312 FROM TO w3s.py Send “FROM” folder content Ask C&C server for data to C&C server and stores it into “TO” folder For all known agents eme rotocol”)|Col2|Col3|Col4|\n|---|---|---|---|\n||MailServer.py For all known agents Fetch new email Send “TO” folder content as email attachment Validate email subject if valid Save attachment in “FROM” folder of the sender agent Storage folders for agent 9312312 FROM TO w3s.py Send “FROM” folder content Ask C&C server for data to C&C server and stores it into “TO” folder For all known agents|||\n\n\nC&C Server\nconnected to Internet\n\nFigure 10. Communication workflow between an Xagent infected computer using\n```\n      MailChannel and its C&C server, via a proxy server\n\n```\n\n-----\n\n### En Route with Sednit\n\n\nThe proxy source code contains a few unused instructions related to agents\ncommunicating over HTTP, i.e. using HttpChannel rather than MailChan```\n          nel. Nevertheless, the main class responsible for relaying HTTP traffic \n\n```\nfrom agents — named W3Server — is absent and its instantiation has been\ncommented out. Similar to Xagent, the operators therefore seem to deploy\nthe components of the proxy server only if needed, and this one was intended\nto relay MailChannel traffic only.\n\nOn the Agent\n\nThe MailChannel::sendRawPacket() method is in charge of sending CryptRawPacket objects\nas email attachments. For that purpose, the code contains an SMTP server address with an email\naddress and a password to log in, plus a recipient email address to which the emails will be sent.\nDepending on the sample, this recipient email address may belong to a freemail provider, a custom\nSednit domain, or even a hacked target.\n\nBuilding a C&C protocol over email brings at least two problems for the operators: they need\nto be able to distinguish Xagent emails from unrelated emails in the inbox (like spam emails),\nand they need to bypass spam filters. To do so, they implemented a protocol named P2Scheme\n(and dubbed “P2” hereafter), which defines the format of the emails. This protocol is described\nas a “level 2 protocol” by the developers, and defines the following email fields:\n\n- The email subject is the base64 encoding of a value following the format pictured in Figure 11.\n\n**0** **5** **12** **16**\n\nKey `SUBJ_TOKEN` Agent ID xor\nxor key key\n\nFigure 11. Email subject generated by the P2 protocol.\n\nIn this format, the Key is pseudo-randomly generated, while SUBJ_TOKEN is a 7-byte value\nhardcoded in the source code and strangely containing the string “china” (prefixed with bytes 0x55\n```\n 0xAA). This specific subject serves to distinguish Xagent emails from unrelated emails in an inbox,\n\n```\nas we will explain.\n\n- The email body and the attachment name are the base64 encodings of pseudo-randomly\n\ngenerated values.\n\n- The boundary value, used to separate a MIME multipart message in parts [17], is a pseudorandomly generated value.\n\nNevertheless, in practice only the boundary is actually generated with the P2 protocol, as the code\nto generate the others fields has been commented out in the Linux source code. Instead, these fields\nare set to fixed values, likely chosen to avoid attracting attention from Georgian targets:\n\n- the email subject is set to piradi nomeri, which refers to a national ID number in Georgian\n\n- the email body is set to gamarjoba, which means hello in Georgian\n\n- the attachment name is set to detaluri_X.dat, where X is the current time (detaluri\nmeans detailed in Georgian)\n\n\n-----\n\n### En Route with Sednit\n\n\nGeorgian institutions are well-known targets of the Sednit group,\nas documented by FireEye in 2014 [9].\n\nOnce the email has been built, the CryptRawPacket object is added as an attachment. Finally,\nthe email is sent with the SMTP protocol over TLS to the recipient email address (exfil@example.com\nin Figure 10). It will be retrieved by the proxy server, and the message will be forwarded\nto the C&C server, as we will describe below.\n\nIn the other direction, the MailChannel::getRawPacket() method retrieves emails containing\nmessages from the C&C server with the POP3 protocol over TLS. The email address to receive messages\nis a different one than the one used to send messages (orders@example.com in Figure 10). For each\nreceived email, the method checks that the subject is set to piradi nomeri and, if so, instantiates\na CryptRawPacket object from the attachment, which is then transmitted to the intended module.\n\nOn the Proxy Server\n\nThe MailServer.py script manages the communications by emails with the agents. To do so,\nit regularly fetches emails from the inbox agents have sent their messages to (exfil@example.com\nin Figure 10).\n\nThe script then checks for each email whether the subject matches the P2 protocol; that is, if once\ndecoded it contains the SUBJ_TOKEN value (see Figure 11). Alternatively, it checks whether the subject\nis set to piradi nomeri, which is the case with the Linux source code as we just explained.\n\nIf the subject is valid, MailServer.py stores the email attachment into a “FROM” folder associated\nwith the sender agent, using a custom format defined in a class named P3Scheme. This format, dubbed\n“level 3 protocol”, is a variation of the one presented in Figure 8 for the HTTP token: namely,\nthe length of Junk is set to 9 and the hardcoded value is different.\n\nThe script LocalStorage.py manages a storage with a “FROM” and “TO”\nfolder for each agent that sent an email to the monitored inbox (the agent ID\nbeing retrieved from the CryptRawPacket attached to the email).\n\nThe second important script is w3s.py, which manages the HTTP communications with the C&C server.\nFor all known agents, the script retrieves the messages dropped in the “FROM” folder, and sends them\nto the C&C server in the body of a HTTP POST request. The URL for this request is built by the following\nPython code:\n\n```\nBASE_URL = “http://” + XAS_IP + XAS_GATE\ndef url_for_agent(agent_id):\n  url = BASE_URL + “?s=” + P3_Scheme.pack_service_data(struct.pack(“<I”, SERVER_\n  UID)) +\\\n    “&a=” + P3_Scheme.pack_data(struct.pack(“<I”, agent_id))\n  return url\n\n```\n\nThe values XAS_IP and XAS_GATE are respectively the C&C server address and URL path,\nwhile SERVER_UID is a 4-byte value identifying the proxy server. The P3_Scheme.pack_service_\n```\ndata() method encodes data following the previously-described P3 format.\n\n```\n\n-----\n\n### En Route with Sednit\n\n\nIn the other direction, the w3s.py script regularly sends a HTTP GET request to the C&C server,\non the URL previously described, for all known agents. The body of the C&C answer is a message\nencoded with the P3 protocol that will be stored in the “TO” folder. Then, the MailServer.py script\nwill retrieve the message and attach it to an email following the P2 protocol, which will be sent\nto the agent.\n\nFrom the log files contained in the proxy open folder, we can infer that it was\na Windows server configured in the Russian language (Python console error\nmessages were output in Russian language).\n\n###### Conclusion and Open Questions\n\nXagent is a well-designed backdoor that has become the flagship espionage malware of the Sednit\ngroup over the past few years. The ability to communicate over HTTP or via emails make it a versatile\ntool for the operators.\n\nMoreover, the existence of Xagent versions for Windows, Linux and iOS shows the importance\nof this backdoor in their arsenal. We speculate that there are versions for others platforms, like Android.\n\n\n-----\n\n### En Route with Sednit\n\n\n##### Sedreco: The Flexible Backdoor\n\n\n-----\n\n### En Route with Sednit\n\n\n###### Context\n\nSedreco has two binary components, a dropper and the spying backdoor usually contained\nin this dropper. The dropper part of Sedreco has also been used to deploy a different payload:\na lightweight downloader (not described in this whitepaper) named msdeltemp.dll by its developers.\n\nWe believe Sedreco was first used in 2012, while our analysis was performed on samples\ncompiled mid-2016.\n\n###### Dropper Workflow\n\nThe workflow of Sedreco’s dropper is composed of the five steps presented in Figure 12.\n\nConfiguration Payload Payload Payload\ndropping dropping persistence execution\n\nReport to\n```\n        “INST MSD” “INST FL” “INST RUN” “ST DL”\n```\nC&C server\n\nFigure 12. Dropper workflow with the developers’ names for each step\n\nWhile straightforward, this workflow possesses some features worth mentioning:\n\n- The payload configuration is installed on the system by the dropper, in a file or in a registry\n\nkey, depending on the sample. It means that analyzing a Sedreco payload sample itself will\nnot reveal configuration information, such as the C&C server address (configuration content\nwill be described below).\n\n- Payload persistence is usually ensured by registering an auto-start entry in the Windows\n\nRegistry, but we have observed other methods, like registering the payload as a Shell Icon\nOverlay handler COM object [18].\n\n- During its execution the dropper builds a small report, which is then sent to the C&C server.\n\nHere is an example of such a report:\n\n```\nINST MSD=0\nINST FL=0\nINST RUN=0\nST DL=0\n\n```\n\nEach line corresponds to one step of the dropper workflow, as described in Figure 12.\nThe value 0 means success, while there would be an error code returned from the Windows API\n```\nGetLastError otherwise.\n\n```\n\n-----\n\n### En Route with Sednit\n\n\n###### Payload Workflow\n\nIn this section we will describe the internal working of the Sedreco payload: first, its configuration\nfile format; second, the commands it can execute; then, how it communicates with its C&C server;\nand finally, how its functionality can be extended with plugins.\n\n###### Configuration\n\nThe first action of Sedreco’s payload is to retrieve the configuration file previously installed\nby the dropper. This configuration file consists of a series of variably-sized data fields, preceded\nby a header, as described in Figure 13.\n\n\n**0**\n\n\n**6**\n\n\n**7**\n\n\n**8**\n\n\n**9**\n\nComputer\nname size\n\n\nC&C1\nsize\n\n\n**10**\n\n\n**11**\n\n\n**12**\n\n\n**13**\n\n\n**14**\n\n\n**15**\n\n\n**16**\n\n\nKey\n\n\nTimer1\nsize\n\n\nTimer2\nsize\n\n\nC&C2\nsize\n\n\nOperation\nname size\n\n\nKeylogger\nMaxBuffer\nsize\n\n\nKeylogger\nMaxTimeout\nsize\n\n\nKeylogger\nflag\n\n\nC&C3\nsize\n\n\n**16** **17** **18** **28** **29** **35** **41**\n\n|size size 6 17 18 28 29 35 41|Col2|Col3|Col4|Col5|Col6|\n|---|---|---|---|---|---|\n|||||||\n\n\nPlugin1\npath size\n\n\nPlugin2\npath size\n\n\nPlugin10\npath size\n\n\nTimer1 Timer2\n\n\nFigure 13. Extract of Sedreco configuration. The names of the fields are those created\nby ESET’s analysts. Field sizes are in bytes.\n\nThe configuration is encrypted with a custom algorithm using a 6-byte key stored at its beginning.\nAn implementation of this algorithm in Python can be found in ESET’s GitHub repository [10].\n\nFollowing the key come 10 1-byte fields, each of them containing the size of a corresponding\ndata field. Those data fields contain the following values (ESET’s names):\n\n1. Timer1: Time to wait between two attempts to ask the C&C server for a command\nto execute (usually set to 10 minutes)\n\n2. Timer2: Time to wait between two attempts to exfiltrate data to the C&C server (usually\nset to 10 minutes)\n\n3. Computer Name: Computer name to which a pseudo-randomly generated 6-byte value\nis appended, plus a two-byte value hardcoded in the dropper\n\n4. C&C1: Domain name of the first C&C server\n\n5. C&C2: Domain name of the second C&C server\n\n6. Operation Name: 4-character string initially hardcoded in the dropper, which likely\n\nidentifies the operation or the target. So far, we have observed the following values: rhze,\n```\n  rhdn, rhst, rhbp, mtfs, mctf, mtqs. We do not know the exact meaning of these values.\n\n```\n7. Keylogger MaxBuffer: Maximum size of the memory buffer where keystrokes are logged,\nbefore they are dumped to the outbound file (described below)\n\n8. Keylogger MaxTimeout: Maximum time to wait before the logged keystrokes are dumped\n\nto the outbound file (described below)\n\n9. Keylogger Flag: Specify whether to enable the keylogger or not\n\n10. C&C3: Domain name of the third C&C server\n\n\n-----\n\n### En Route with Sednit\n\n\nThe next ten data fields are the paths to the plugins that Sedreco will load at startup. These fields\nare initially empty, and are updated when Sedreco receives a plugin to load from the C&C server.\n\n###### Commands\n\nOnce it is running, Sedreco provides numerous commands to its operators, identified by a number,\nas described in Table 4. Those commands allow the attackers to spy on the target, but also to collect\ninformation on other computers accessible from the compromised machine.\n\n\nTable 4. **Sedreco payload commands**\n\n\nNumber Purpose Number Purpose\n\n0 Update configuration value 14 Terminate process\n\n1 Load plugin 15 List loaded plugins\n\n2 Unload plugin 16 Run Windows shell command\n(output temporarily stored in a file\nnamed tmp.dat)\n\n3 Start keylogger 17 List connected devices\n\n4 Stop keylogger 18 Update Sedreco payload binary\non disk\n\n5 List directories 19 Read file from a specified offset\n\n6 Read file 20 Map network resources\n\n7 Write file 21 Run systeminfo Windows shell\ncommand\n\n8 Delete file or directory 22 List files and directories\n\n9 Enumerate registry key 23 Read file (wrapper for command 6)\n\n10 Write registry key 24 Run a given Sedreco command\n\n11 Delete registry key 25 Create thread\n\n12 List running processes 36 Start remote shell over HTTP\n(plugin command, see below)\n\n13 Create process\n\nInterestingly, the commands are registered at runtime by calling an internal function — usually\nexported under the name RegisterNewCommand — with the command number and the address\nof the command handler. For example, Figure 14 shows the registration of the first six commands.\n\nFigure 14. Command registration — CMD functions are the commands handlers\n\n\n-----\n\n### En Route with Sednit\n\n\nThis mechanism makes Sedreco a flexible backdoor, which includes only the commands in a sample\nthat are currently needed (which means in particular that the previous list of commands may\nnot be complete). It also allows plugins to easily register new commands, as we will explain later.\n\n###### Communications with the C&C server\n\nSedreco communicates with its C&C server in a quite unusual way, pictured in Figure 15.\n\nCompromised\n\ncomputer\n\nInbound file\n```\n                      (_2315tmp.dat)\n\n```\n**Sedreco** **Sedreco**\n**core threads** **network threads**\n\nOutbound file\nC&C Server\n```\n                      (_4964tmp.dat)\n```\nconnected to Internet\n\nFigure 15. Data flow between Sedreco on a compromised host and its C&C server\n\nOn one hand, Sedreco network threads periodically ask the C&C server for orders, and store them\nin an “inbound file”. Those orders are then fetched and processed by Sedreco core threads. On the other\nhand, the data to exfiltrate (logged keystrokes, results of executed commands, etc) are queued\nin an “outbound file”, and periodically transmitted in bulk to the server by the network threads.\n\nAs this asynchronous communication method limits the number of network contacts with the\nC&C server, it might reduce the chance of attracting attention in the target’s network. Moreover,\nusing files rather than keeping the data buffered in memory avoids losing the data if the machine\nshuts down or loses network connectivity.\n\nIn the following sections, we describe the network communications and the exact format\nof the inbound/outbound files.\n\nInbound Communications\n\nSedreco regularly asks its C&C server for a command to run — usually every 10 minutes. The C&C server\ndomain names are retrieved from the configuration, and they are contacted in their order of appearance\nin this configuration (see configuration format). In other words, if the first C&C server is up — C&C1\nin Figure 13 — the others are never contacted.\n\nThe actual contact is a POST request over HTTP or, depending of the sample, HTTPS, on the URI\n```\n/update. The body of the request contains the base64-encoding of the data structure pictured \n\n```\nin Figure 16.\n\n**0** **1** **5** **n-14** **n-10** **n-6** **n**\n\nType Operation name Computer Operation name Encrypted Key\n\nname size + computer data size\nname size\n\n**Legend**\n\nEncrypted text data\n\nPlain text data\n\nFigure 16 Network contact message format Computer name is a variably-sized field\n\n|0 1|1 5|5 n-1|-14 n-1|10 n-|-6 n|\n|---|---|---|---|---|---|\n|||||||\n|Type Operation name Computer Operation name Encrypted Key name size + computer data size||||||\n\n\n-----\n\n### En Route with Sednit\n\n\nThis data structure is encrypted with the 6-byte key stored at the end, using the same algorithm\nas that used to encrypt the configuration file. The Type field is set to 0, which distinguishes inbound\nfrom outbound.\n\nThe C&C server will then answer with the information about a command to run, the commands\nbeing stored in the inbound file by Sedreco network threads. The inbound file is usually named\n```\n__2315tmp.dat and located in the %TEMP% directory. This file consists of a series of variably-sized\n\n```\nentries, each entry containing the information from the C&C server for one command to run,\nas described in Figure 17.\n\n**0** **2** **6**\n\nNumber Entry 1 size Entry 1 data Entry N size Entry N data\nof entries\n\n**0** **6** **10** **14** **Legend**\n\n\nKey Magic\n\n\nCommand Command\nnumber arguments\n(optional)\n\n\nFigure 17. Inbound file format. Field sizes are in bytes\n\nAs before, each entry starts with a 6-byte key to decrypt the entry data, again using the same algorithm\nused for the configuration. Then comes a 4-byte magic value, which, in all the samples we analyzed,\nhas to be set to 0x75DF9115 for the command to be executed. The entry may also contain the arguments\nto pass to the command handler.\n\nFinally, Sedreco core threads process the inbound file to extract and run the commands.\n\nOutbound Communications\n\nSedreco core threads store the output generated by a command execution in the outbound file,\nwhich is usually named __4964tmp.dat and located in the %TEMP% directory. Similarly to the inbound\nfile, it consists of a series of variably-sized entries, each entry describing one particular command\nexecution, as shown in Figure 18.\n\n**0** **2** **34**\n\nNumber Entry 1 header Entry 1 Entry N header Entry N\nof entries\n\n\n**0** **4**\n\nMagic\n\n\nEntry size\n\n\n**8**\n\n\n**12**\n\nCommand\nreturn status\n\n\n**28**\n\n\n**32**\n\n\nTimestamp\n\n\nCommand\nnumber\n\n\nFigure 18. Outbound file format. Field sizes are in bytes\n\nEach entry begins with a 32-byte header, containing in particular a 4-byte magic number (0xB2745DAF),\nthe command return status code, a timestamp of the command execution (in a SYSTEMTIME\nWindows structure [19]), and the actual command number. Then comes the output data generated\nby the command execution, compressed with a custom implementation of the Lempel–Ziv–Welch\n(LZW) algorithm [20].\n\n\n-----\n\n### En Route with Sednit\n\n\nA source code search engine allowed us to retrieve what we believe\nto be the C source code of the LZW algorithm implementation employed\nby Sedreco _[21]. Figure 19 shows an extract of the compressed data header_\ninitialization in the source code, with the distinctive LZW! signature.\n```\n               ((Dword *)buff)[0] = 0x21575A4C; /* 'LZW!' signature */\n               ((Dword *)buff)[1] = bSize;\n               ((Dword *)buff)[2] = GetCRC32(data, bSize);\n               lastByte += 12;\n               LZWENTRY lzwTable[0x1000];\n               int tableSize = 0, beginTable = 0x100;\n               for (int k = 0; k <= 0xFF; k++) {\n                 lzwTable[k].next = lzwTable[k].substrIndex = 0;\n                 lzwTable[k].substrSize = 1;\n               }\n               Dword currentPos = 0;\n               while (currentPos < bSize)\n               {\n                   /* Поиск самой длинной подстроки */\n\n```\nFigure 19. Extract of LZW algorithm C source code\n\nSedreco network threads regularly — usually every 10 minutes — fetch the data from the outbound\nfile and encrypt them with the 3DES algorithm and a hardcoded key. The data structure described\nin Figure 16 is then appended to the encrypted data, thus acting as a footer. In this case, the Type\nfield is set to 1.\n\nFinally, the resulting encrypted data are transmitted to the C&C server by Sedreco network threads.\n\n###### Plugins\n\nAn interesting feature of Sedreco is its ability to run external plugins. The downloading and execution\nof those plugins can be requested by the C&C server with command number 1, while their unloading\ncan be accomplished with command number 2 (see commands list).\n\nA Sedreco plugin comes as a Windows DLL with two exported functions named Init and UnInit.\nThe plugin is loaded in the same address space as Sedreco’s payload with a call to the Windows API\n```\nLoadLibraryA. The plugin’s Init export is then called, with the following structure as its argument:\n\n```\n```\nstruct PluginArguments {\n  void *RegisterNewCommand;  // Developers’ name (see Figure 13)\n  void *FN_read_file;  // ESET’s name (also applies to next fields)\n  void *FN_write_in_outbound_file;\n  void *FN_unregister_command;\n  HKEY_TYPE handle_opened_registry_hive;\n  void *output_buffer;\n  void *FN_append_to_output_buffer;\n};\n\n```\n\n-----\n\n### En Route with Sednit\n\n\nThis structure contains some helper functions’ addresses, plus some data addresses, from Sedreco’s\npayload, that the plugin may need during its execution.\n\nWe only found one Sedreco plugin during our investigation. Once loaded in memory, this plugin\nregisters a new command, numbered 36, as shown in Figure 20.\n\nFigure 20. Plugin Init export\n\nWhen called by the operators, the newly registered command will open a remote Windows\nshell over HTTP.\n\nWhen Sedreco exits, the payload unloads all plugins and calls their UnInit exports. In the case\nof the plugin we retrieved, this export simply unregisters the command it provides, as shown\nin Figure 21.\n\nFigure 21. Plugin UnInit export\n\nInterestingly, parts of the plugin code are shared with the Windows Xagent\nmodule named ProcessRetranslatorModule (see table 1). In particular,\nthe function in charge of creating a Windows shell process with some communication pipes is exactly the same in both binaries, including some custom error messages such as #EXC_1 Cannot create ExtToProc Pipe!.\n\n###### Conclusion and Open Questions\n\nWith its ability to register new commands dynamically, Sedreco is a flexible backdoor that has been\nused for many years by the Sednit group.\n\nAn interesting feature of Sedreco is the ability to load external plugins. As we only found one plugin,\nwe hope this report will encourage other researchers to contribute further pieces to the puzzle.\nIn particular, it would be interesting to search for other code-sharing cases between Sedreco plugins\nand Xagent modules.\n\n\n-----\n\n### En Route with Sednit\n\n\n##### Xtunnel: Reaching Unreachable Machines\n\n\n-----\n\n### En Route with Sednit\n\n\n###### Timeline\n\nWe have analyzed Xtunnel samples for three years. The dates posited in the timeline mainly rely\non Xtunnel compilation timestamps that we believe have not been tampered with, because\nthey match up with our telemetry data.\n\n\n##### 2013\n**May**\n\nOldest known\nXtunnel sample\n\n##### 2015\n**June**\n\nNew feature\nConnection\nto C&C server through\na persistent HTTP\nconnection\n\n##### 2015\n**July**\n\nCode obfuscation\nintroduced\n\n\n##### 2013\n**August**\n\nNew feature\nUDP tunneling\n\n##### 2015\n**May**\n\nXtunnel found\non the servers of the\nGerman politic party\n“Die Linke”    , as part [22]\nof an attack against the\nBundestag (the German\nparliament)[23]\n\n##### 2016\n**May**\n\nXtunnel found on\nthe servers of the\nDemocratic National\nCommittee (DNC) _[7]_\n\n\n##### 2014\n**April**\n\nNew feature\nTLS encryption\n\nConnection to C&C server\nthrough an HTTP proxy\n\n##### 2015\n**April**\n\nNew feature\nCommand line\nparameters parser\n\n##### 2016\n**August**\n\nMost recently known\nXtunnel sample\n\n\nFigure 22. **XTunnel major events**\n\n\n-----\n\n### En Route with Sednit\n\n\n###### Big Picture\n\nXtunnel proxies network traffic between a C&C server on the Internet and a target computer, hence\ncreating a “tunnel” between the two. Multiple tunnels can be opened at the same time — from\nthe C&C server to several machines — with Xtunnel taking charge of routing the traffic to the intended\ncomputer, as shown in Figure 23 with computers A and B.\n\n**Internet**\n\nC&C Server\n\nID 12345 ID 45678\n\nPivot computer\n\n**Target internal** (Xtunnel infected)\n**network**\n\nTarget Target\ncomputer A computer B\n\nFigure 23. **Xtunnel core behavior**\n\nThe network link between the Xtunnel-infected machine and the C&C server is encrypted to complicate\nnetwork detection at the external boundary of the network. However, the links with the target\ncomputers remain unencrypted to allow any kind of traffic to be sent to the target. In particular,\nit should be emphasized that those target computers are not necessarily under the control\nof the Sednit group.\n\n“Xtunnel” is the developers name for this software. This was determined\nby the function export table left unremoved by its authors in several samples.\nThe developers also forgot to remove program database (PDB) [24] file paths,\nfrom which we can deduce another internal name, “XAPS”. Interestingly,\nthose PDB paths sometimes contain words in Russian, such as:\n\n```\nH:\\last version 23.04\\UNvisible crypt version XAPS select \n```\n**копия\\XAPS_OBJECTIVE\\Release\\XAPS_OBJECTIVE.pdb**\n```\nC:\\Users\\John\\Documents\\Новая папк\\XAPS_OBJECTIVE\\Release\\XAPS_\nOBJECTIVE.pdb\n\n```\n\nThe word “копия” translates to “copy”, while “Новая папк” means “New folder”.\n\n\n-----\n\n### En Route with Sednit\n\n\n###### Traffic Proxying\n\nThe logic for traffic proxying remained the same in all Xtunnel samples that we analyzed, which cover\na period of three years. This core behavior begins with a handshake with the C&C server to establish\nan RC4-encrypted link. The C&C server can then order Xtunnel to open a tunnel with a designated\nmachine, so that any data coming from the C&C server will be forwarded to this machine,\nand similarly any data coming from the target machine will be forwarded to the C&C server.\n\nThis process can be repeated so as to have multiple tunnels opened in parallel, as shown in Figure 24\nwith computers A and B, and as explained in detail in the following section.\n\n\nTarget\ncomputer B\n\n\nC&C Server Pivot computer\nconnected to Internet (Xtunnel infected)\n\nSends cryptographic\nkey & proof of correct\n\nEncryption encryption\nhandshake\n\nSends “OK”\n\nSends fallback port\nnumber\n\nOrders to open tunnel\n1 on computer A\n\nTunnel 1\nopening\n\nReports tunnel 1\nopened\n\nSends “DATA”\nfor tunnel 1\n\nReports “ANSWER”\nreceived from tunnel 1\n\nReports “DATA2”\nreceived from tunnel 1\n\nOrders to open tunnel 2\non computer B\n\nTunnel 2\nopening\n\nReports tunnel 2\nopened\n\nFigure 24. Xtunnel communication workflow\n\n###### Encryption Handshake\n\n\nTarget\ncomputer A\n\n\nTCP connects\n\n|connected|to Internet (Xtunnel|infected) compu|uter A|\n|---|---|---|---|\n|||TCP connects Sends “DATA” Sends “ANSWER” Sends “DATA2”|TCP|\n||Sends cryptographic key & proof of correct encryption Sends “OK”|||\n||Sends fallback port number|||\n||Orders to open tunnel 1 on computer A Reports tunnel 1 opened|||\n||Sends “DATA” for tunnel 1 Reports “ANSWER” received from tunnel 1 Reports “DATA2” received from tunnel 1|||\n||Orders to open tunnel 2 on computer B Reports tunnel 2 opened|||\n|||||\n|||||\n\n|nects|Col2|\n|---|---|\n\n\nXtunnel makes a custom encryption handshake with its C&C server, whose IP address and port\nare either given as command line parameters or hardcoded directly in the program. The purpose\nof this handshake is to share a cryptographic key for encrypting the link between Xtunnel\nand the C&C server with the RC4 algorithm.\n\n\n-----\n\n### En Route with Sednit\n\n\nTo do so, the Xtunnel binary contains a Table T composed of 256 rows of 32 bytes each, initially filled\nwith fixed values in the code, as shown in Figure 25.\n\nFigure 25. Extract of T initialization code\n\nXtunnel pseudo-randomly chooses one 32-byte row of T as the cryptographic key to share\nwith the C&C server. The actual handshake then starts by sending the offset _O in T of the chosen_\nrow to the C&C server.\n\nThis message also includes a “proof” that the sender really knows T — that is, the offset sent is not\njust some random 4-byte value. This proof consists of the row located at offset O + 128 (modulo 256)\nencrypted with the chosen key. The C&C then checks the proof and, assuming it is correct, answers\n```\nOK encrypted with the chosen RC4 key.\n\n```\nIt should be emphasized that the chosen cryptographic key is never sent over\nthe network, only its 4-byte offset in T. This prevents traffic decryption\nby an eavesdropper not knowing the Table and, of course, means\nthe C&C server also knows T.\n\nBefore going further, the C&C server provides a port number to the infected machine, which\nwill serve as a fallback in case the connection closes on the currently used port on the C&C server.\n\n###### Tunneling\n\nAt this point an encrypted link has been established between Xtunnel and its C&C server. The C&C server\ncan then use the Xtunnel infected machine as a pivot to contact local computers that are normally\nunreachable from the Internet.\n\n\n-----\n\n### En Route with Sednit\n\n\nTo do so, the C&C server sends messages to Xtunnel beginning (once decrypted) with a two-byte\ntunnel identifier — denoted TunnelID hereafter — and followed by data of arbitrary length. When\na particular TunnelID value is sent for the first time, it means the C&C server wants to open a new\ntunnel. The information in this first packet contains data about the target machine: either an IP address\nor a domain name, plus a port number. Two examples of such tunnel-opening messages are given\nin Figures 26.1 and 26.2.\n\n**01** **00** **01** **C0** **A8** **7C** **01** **11** **C1**\n\nTunnelID Command IP address Port\n“open tunnel by IP” (192.168.124.1) (4545)\n\nFigure 26.1 Message to open tunnel 0x100 on IP address 192.168.124.1 and port 4545\n\n**02** **00** **03** **08** **74** **65** **73** **74** **2E** **63** **6F** **6D** **12** **26**\n\nTunnelID Command Domain name Port\n\n“open tunnel (test.com) (4646)\nby domain name”\n\nDomain name\nlength\n\nFigure 26.2 Message to open tunnel 0x200 on domain name test.com and port 4646\n\nCommands 1 and 3 pictured in these messages are the only ones implemented, and Xtunnel searches for such a command byte only when it is the first\ntime it received a particular TunnelID value.\n\nXtunnel then makes a TCP connection on the designated target and if successful, the tunnel is considered\nfully opened. At this point, each message from the C&C server beginning with the corresponding TunnelID\nwill be forwarded to the target machine by Xtunnel — after having removed TunnelID from the message.\nIn other words, any kind of TCP data can be sent through the tunnel.\n\nOn the other side of the tunnel the target machine can also send data, and Xtunnel will prefix\nit with the associated TunnelID before forwarding it to the C&C server.\n\nSince in general the size of the data to be transferred is unknown, each\ncommunication between C&C server and Xtunnel starts with a 4-byte value\ncontaining the number of bytes to be sent.\n\n\n-----\n\n### En Route with Sednit\n\n\nAdditionally, the C&C server can send the message is you live? [sic] to check the status\nof Xtunnel, to which Xtunnel answers OK if everything is fine.\n\nThe quality of Xtunnel code is far from being good; here are two examples\nof incongruities found in tunneling code:\n\n1. After a tunnel has been opened, Xtunnel reports a 6-byte message\nto the C&C server composed of the IP address and the port of the target\nmachine. Except that the developer forgot to increase the memory pointer\nafter writing the IP address in memory, and thus the port overwrites the first\ntwo bytes of the IP address. Thus, it is likely that the C&C server does\nnot process this message.\n\n2. The TunnelID sent by the C&C server happens to be also used as the maximum\nsize of data processed from the received packet, for no obvious reason.\nConsequently, it is impossible, for example, to open a tunnel by IP address\nwith a TunnelID smaller than 7, because information about the target\ncomputer takes 7 bytes — see Figure 26.1 —, and will therefore be truncated.\nWe speculate that the C&C server usually chooses large TunnelID values,\nexplaining why this problem has gone unnoticed by the operators.\n\n###### Additional Features\n\nESET researchers have retrieved multiple versions of Xtunnel, starting in 2013, when it apparently\nwas first deployed, to mid-2016 for the most recent versions. This allows us to observe over time\nthe introduction of new features around the core tunneling logic, shedding light on the operator’s\nobjectives and concerns.\n\n###### UDP Tunneling (August 2013)\n\nXtunnel initially only proxied TCP traffic, but in August 2013 UDP traffic tunneling was introduced.\nTo do so, the C&C server can then ask to open a tunnel over UDP rather than TCP.\n\nStrangely, the C&C server address used for UDP tunneling is hardcoded in the binary (176.31.112.10),\nand any C&C address potentially given as input to Xtunnel is ignored — even in recent samples.\nAs this particular C&C server stopped being used mid-2015, we believe UDP tunneling was a test\nor a feature needed on a particular target, and is not used anymore.\n\nIn some samples the UDP tunneling code contains a few debug messages,\nsuch as:\n\n```\ni`m wait\nerror 2003 recv from TPS - %d\nerror 2002 send to server UDP - %d\nrecv from client UDP - %d\n\n```\n\nAccording to those messages, the C&C server is called “client UDP” or “TPS”\nby the developers, whereas “server UDP” corresponds to the target machine.\nThe “TPS” acronym remains mysterious to us in this context.\n\n\n-----\n\n### En Route with Sednit\n\n\n###### TLS Encryption (April 2014)\n\nA major feature introduced in April 2014 is the encryption of the communications with the C&C server\nwith the Transport Layer Security (TLS) protocol [25]. These new Xtunnel binaries are statically linked\nwith OpenSSL 1.0.1e — a version released in February 2013. Inside the TLS encapsulation, Xtunnel\nnetwork protocol for tunneling remains the same (including the RC4 encryption).\n\nThe TLS certificate used by the C&C server is not verified by Xtunnel,\nwhich means anyone could play the role of Xtunnel C&C server.\n\n###### HTTP Proxy Connection (February 2015)\n\nSome organizations force their computers to pass through an HTTP proxy to access the Internet.\nMalware running on such machines therefore cannot contact the C&C server directly, but has to pass\nthrough the proxy. Sednit developers took that into account by creating special Xtunnel versions\nwith HTTP proxy awareness.\n\nIn these binaries, Xtunnel first tries to retrieve the Internet Explorer proxy configuration by calling\nthe Windows API function WinHttpGetIEProxyConfigForCurrentUser _[26]. In the event that_\nno information can be retrieved, it uses the hardcoded address 10.1.1.1:8080, which is the default\naddress of the Squid caching proxy [27]. This intention is clearly stated in the PDB path in one of the\nsamples: xaps_through_squid_default_proxy.\n\nOnce a proxy IP address has been chosen, Xtunnel uses the HTTP CONNECT method [28] to reach\nits C&C server.\n\n###### Command Line Parameter Parser (April 2015)\n\nTo gain in flexibility and manage novel features, in April 2015 Xtunnel developers introduced\na command line parameter parser. This parser accepts the parameters described in Table 5.\n\n\nTable 5. **Xtunnel Parameters**\n\n\nParameter Prefix Meaning\n\n-SSL activate TLS tunneling\n\n-Si C&C server IP address\n\n-Sp C&C server port\n\n-Up C&C server UDP port (but management code is missing)\n\n-Pi proxy IP address\n\n-Pp proxy port\n\n-HTTP activate HTTP persistent connection (explained later)\n\n\n-----\n\n### En Route with Sednit\n\n\nIn most Xtunnel samples, the parser actually processes a command line hardcoded in the binary,\nwithout even looking for input parameters. Here are some examples of such command lines found\nin some samples:\n\n```\n-Si 176.31.96.178 -Sp 443 -Pi 10.30.0.47 -Pp 8080 -SSL\n-Si 46.183.216.209 -Sp 443 -Pi 10.30.0.11 -Pp 8080 -SSL\n-Si 95.215.46.27 -Sp 443 -HTTP\n\n```\n\nThe proxy IP addresses shown in these examples do not correspond\nto any known default proxy address, indicating that these binaries were likely\ncompiled for specific targets.\n\n###### HTTP Persistent Connection (June 2015)\n\nIn June 2015, a novel way to connect to the C&C server was introduced: an HTTP persistent\nconnection [29]. When this feature is enabled, Xtunnel exchanges data with its C&C server\nover the HTTP protocol (encapsulated in TLS protocol), probably as a way to bypass firewalls.\n\nTo open such a persistent connection, an HTTP GET request is encapsulated in TLS protocol and sent\nto the C&C server. This request comes with the HTTP header Connection: keep-alive to enable\nthe persistent connection.\n\nAnother HTTP request header hardcoded in Xtunnel is Accept-Language:\n```\n          ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4, which interestingly contains\n\n```\nthe language code ru-RU. This header may have been copied from a request\nmade from a computer whose default language is Russian.\n\n###### Code Obfuscation (July 2015)\n\nIn July 2015, Xtunnel binaries changed drastically from a syntactic point of view, due to the introduction\nof code obfuscation. This obfuscation was applied only to Xtunnel-specific code, while statically\nlinked libraries were left untouched. The method employed is a mix of classic obfuscation techniques,\nlike insertion of junk code and opaque predicates [30].\n\nConsequently, Xtunnel binaries are now about 2 MB in size, while the previous non-obfuscated versions\nwere about 1 MB with most of that being the statically linked OpenSSL library. The obfuscated version\nis, of course, much harder to understand and, to illustrate that, the following Figures show the control\nflow graph (CFG) [31] of a small Xtunnel function, before and after obfuscation.\n\nFigure 27.1 **Xtunnel CFG before obfuscation**\n\n\n-----\n\n### En Route with Sednit\n\n\nFigure 27.2 **Xtunnel CFG after obfuscation**\n\nWhile the control flow has been heavily obfuscated, strangely the strings\nand data are kept in plain text. We speculate that the developers applied\nan (unknown) code obfuscation tool, which was enough to achieve their\ngoal — probably bypassing some security products.\n\n###### Conclusion and Open Questions\n\nWe believe Xtunnel to be of high importance to the Sednit operators, despite the questionable\nquality of the code as we discussed in the analysis. In particular, it is the only Sednit component\nwe know with heavy code obfuscation. Additionally, the numerous features added over the last\nthree years indicate an ongoing development effort.\n\nFinally, we would like to stress that our analysis is solely based on the capabilities found in the binaries.\nIn particular, we do not have in-the-wild examples on how Xtunnel is deployed, and what kind\nof network traffic is usually forwarded.\n\n\n-----\n\n### En Route with Sednit\n\n\n##### Closing Remarks\n\nIn order to perform its espionage activities, the Sednit group mainly relies on two backdoors, Xagent\nand Sedreco, which were intensively developed over the past years. Similarly, notable effort has been\ninvested into Xtunnel, in order to pivot in a stealthy way. Overall, these three applications should\nbe a primary focus to anyone wanting to understand and detect the Sednit group’s activities.\n\nNevertheless, the spying and pivoting capabilities of Sednit are not limited to the software\ndescribed in this second part of our whitepaper. For example, they regularly deploy the following\non target computers:\n\n- Password retrieval tools for browsers and email clients; some of these tools are custom,\nwhile others are publicly available (like the SecurityXploded tools [32])\n\n- Windows password retrieval tools, with custom builds of the infamous mimikatz [33]\nand some custom tools\n\n- A custom tool to take regular screenshots of the target computer\n\nMoreover, the Sednit group created numerous small executables to perform specific tasks, like\ncopying or removing files. The developers seem therefore to closely follow the operational needs\nof the group, causing us to speculate that they are not outsiders paid for a one-time job,\nbut fully-fledged members of the group.\n\n\n-----\n\n### En Route with Sednit\n\n\n##### Indicators of Compromise\n\n###### Xagent\n\n ESET Detection Names\n```\n   Linux/Fysbis\n   Win32/Agent.VQQ\n   Win32/Agent.WGJ\n   Win32/Agent.WLF\n   Win32/Agent.XIO\n   Win32/Agent.XIP\n   Win32/Agent.XPY\n   Win32/Agent.XPZ\n   Win32/Agent.XVD\n   Win32/Agent.XWX\n   Win64/Agent.ED\n   Win64/Agent.EZ\n   iOS/XAgent.A\n   iOS/XAgent.B\n\n Hashes\n\n```\nWindows\n```\n   072933fa35b585511003f36e3885563e1b55d55a\n   082141f1c24fb49981cc70a9ed50cda582ee04dd\n   08c4d755f14fd6df76ec86da6eab1b5574dfbafd\n   0f04dad5194f97bb4f1808df19196b04b4aee1b8\n   3403519fa3ede4d07fb4c05d422a9f8c026cedbf\n   499ff777c88aeacbbaa47edde183c944ac7e91d2\n   4b74c90c9d9ce7668aa9eb09978c1d8d4dfda24a\n   4bc32a3894f64b4be931ff20390712b4ec605488\n   5f05a8cb6fef24a91b3bd6c137b23ab3166f39ae\n   71636e025fa308fc5b8065136f3dd692870cb8a4\n   780aa72f0397cb6c2a78536201bd9db4818fa02a\n   a70ed3ae0bc3521e743191259753be945972118b\n   baa4c177a53cfa5cc103296b07b62565e1c7799f\n   c18edcba2c31533b7cdb6649a970dce397f4b13c\n   c2e8c584d5401952af4f1db08cf4b6016874ddac\n   d00ac5498d0735d5ae0dea42a1f477cf8b8b0826\n   d0db619a7a160949528d46d20fc0151bf9775c32\n   e816ec78462b5925a1f3ef3cdb3cac6267222e72\n   f1ee563d44e2b1020b7a556e080159f64f3fd699\n\n```\nLinux\n```\n   7e33a52e53e85ddb1dc8dc300e6558735acf10ce\n   9444d2b29c6401bc7c2d14f071b11ec9014ae040\n   ecdda7aca5c805e5be6e0ab2017592439de7e32c\n   f080e509c988a9578862665b4fcf1e4bf8d77c3e\n\n###### File Names\n   rwte.dll\n   splm.dll\n   lg3.exe\n   api-ms-win-downlevel-profile-l1-1-0.dll\n\n```\n\n-----\n\n### En Route with Sednit\n\n\n###### C&C server Domain Names\n```\n   ciscohelpcenter.com\n   microsoftsupp.com\n   timezoneutc.com\n   inteldrv64.com\n   advpdxapi.com\n\n C&C server IP Addresses\n   185.106.120.101\n   185.86.149.223\n   31.220.43.99\n   5.135.183.154\n   69.12.73.174\n   89.32.40.4\n   92.114.92.125\n   93.115.38.125\n\n Sedreco\n\n ESET Detection Names\n   Win32/Sednit.AJ\n   Win32/Sednit.AL\n   Win32/Sednit.AO\n   Win32/Sednit.C\n   Win32/Sednit.E\n   Win32/Sednit.F\n   Win32/Sednit.H\n   Win32/Sednit.S\n   Win32/Sednit.U\n   Win32/Sednit.W\n   Win32/Sednit.Y\n   Win64/Sednit.B\n   Win64/Sednit.G\n\n Hashes\n\n```\nDropper\n```\n   4f895db287062a4ee1a2c5415900b56e2cf15842\n   87f45e82edd63ef05c41d18aeddeac00c49f1aee\n   8ee6cec34070f20fd8ad4bb202a5b08aea22abfa\n   9e779c8b68780ac860920fcb4a8e700d97f084ef\n   c23f18de9779c4f14a3655823f235f8e221d0f6a\n   e034e0d9ad069bab5a6e68c1517c15665abe67c9\n   e17615331bdce4afa45e4912bdcc989eacf284bc\n\n```\nPayload\n```\n   04301b59c6eb71db2f701086b617a98c6e026872\n   11af174294ee970ac7fd177746d23cdc8ffb92d7\n   e3b7704d4c887b40a9802e0695bae379358f3ba0\n\n###### File Names\n\n```\nDropper\n```\n   scroll.dll\n   wintraysys.exe\n\n```\n\n-----\n\n### En Route with Sednit\n\n\nPayload\n```\n   advstorshell.dll\n   mfxscom.dll\n\n###### Dropped Files\n   %ALLUSERSPROFILE%\\msd\n   %TEMP%\\__2315tmp.dat\n   %TEMP%\\__4964tmp.dat\n\n Registry Keys\n   HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Path\n   HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Path\n\n Mutexes\n   \\BaseNamedObjects\\AZZYMTX\n   \\BaseNamedObjects\\MutYzAz\n\n C&C server Domain Names\n   1oo7.net\n   akamaisoft.com\n   cloudflarecdn.com\n   driversupdate.info\n   kenlynton.com\n   microsoftdriver.com\n   microsofthelpcenter.info\n   nortonupdate.org\n   softwaresupportsv.com\n   symantecsupport.org\n   updatecenter.name\n   updatesystems.net\n   updmanager.com\n   windowsappstore.net\n\n Xtunnel\n\n ESET Detection Names\n   Win32/Agent.RGB\n   Win32/Agent.RGD\n   Win32/Agent.RGS\n   Win32/Agent.RKP\n   Win32/Agent.RME\n   Win32/Agent.RMG\n   Win32/Agent.RMR\n   Win32/Agent.RQI\n\n Hashes\n   0450aaf8ed309ca6baf303837701b5b23aac6f05\n   067913b28840e926bf3b4bfac95291c9114d3787\n   1535d85bee8a9adb52e8179af20983fb0558ccb3\n   42dee38929a93dfd45c39045708c57da15d7586c\n   8f4f0edd5fb3737914180ff28ed0e9cca25bf4cc\n   982d9241147aaacf795174a9dab0e645cf56b922\n   99b454262dc26b081600e844371982a49d334e5e\n   c637e01f50f5fbd2160b191f6371c5de2ac56de4\n   c91b192f4cd47ba0c8e49be438d035790ff85e70\n   cdeea936331fcdd8158c876e9d23539f8976c305\n\n```\n\n-----\n\n### En Route with Sednit\n\n```\n   db731119fca496064f8045061033a5976301770d\n   de3946b83411489797232560db838a802370ea71\n   e945de27ebfd1baf8e8d2a81f4fb0d4523d85d6a\n\n###### C&C server IP Addresses\n   131.72.136.165\n   167.114.214.63\n   176.31.112.10\n   176.31.96.178\n   192.95.12.5\n   46.183.216.209\n   80.255.10.236\n   80.255.3.93\n   81.17.30.29\n   95.215.46.27\n\n PDB Paths\n   H:\\last version 23.04\\UNvisible crypt version XAPS select - копия\\XAPS_OBJECTIVE\\\n   Release\\XAPS_OBJECTIVE.pdb\n   C:\\Users\\User\\Desktop\\xaps_through_squid_default_proxy\\Release\\XAPS_OBJECTIVE.pdb\n   C:\\Users\\John\\Documents\\Новая папк\\XAPS_OBJECTIVE\\Release\\XAPS_OBJECTIVE.pdb\n   E:\\PROJECT\\XAPS_OBJECTIVE_DLL\\Release\\XAPS_OBJECTIVE.pdb\n\n```\n\n-----\n\n### En Route with Sednit\n\n\n##### References\n\n_1._ The Washington Post, Russian government hackers penetrated DNC, stole opposition research on Trump,\n\n[https://www.washingtonpost.com/world/national-security/russian-government-hackers-penetrated-dnc-](https://www.washingtonpost.com/world/national-security/russian-government-hackers-penetrated-dnc-stole-opposition-research-on-trump/2016/06/14/cf006cb4-316e-11e6-8ff7-7b6c1998b7a0_story.html)\n[stole-opposition-research-on-trump/2016/06/14/cf006cb4-316e-11e6-8ff7-7b6c1998b7a0_story.html, June 2016](https://www.washingtonpost.com/world/national-security/russian-government-hackers-penetrated-dnc-stole-opposition-research-on-trump/2016/06/14/cf006cb4-316e-11e6-8ff7-7b6c1998b7a0_story.html)\n\n_2._ [The Wall Street Journal, Germany Points Finger at Russia Over Parliament Hacking Attack, http://www.wsj.com/](http://www.wsj.com/articles/germany-points-finger-at-russia-over-parliament-hacking-attack-1463151250)\n[articles/germany-points-finger-at-russia-over-parliament-hacking-attack-1463151250, May 2016](http://www.wsj.com/articles/germany-points-finger-at-russia-over-parliament-hacking-attack-1463151250)\n\n_3._ Reuters, France probes Russian lead in TV5Monde hacking: sources,\n\n[http://www.reuters.com/article/us-france-russia-cybercrime-idUSKBN0OQ2GG20150610, June 2015](http://www.reuters.com/article/us)\n\n_4._ [ESET VirusRadar, Zero-day, http://www.virusradar.com/en/glossary/zero-day](http://www.virusradar.com/en/glossary/zero)\n\n_5._ [ESET, Sednit Espionage Group Attacking Air-Gapped Networks, http://www.welivesecurity.com/2014/11/11/sednit-](http://www.welivesecurity.com/2014/11/11/sednit-espionage-group-attacking-air-gapped-networks/)\n[espionage-group-attacking-air-gapped-networks/, November 2014](http://www.welivesecurity.com/2014/11/11/sednit-espionage-group-attacking-air-gapped-networks/)\n\n_6._ [Kaspersky, Sofacy APT hits high profile targets with updated toolset, https://securelist.com/blog/research/72924/](https://securelist.com/blog/research/72924/sofacy)\n[sofacy-apt-hits-high-profile-targets-with-updated-toolset/, December 2015](https://securelist.com/blog/research/72924/sofacy)\n\n_7._ CrowdStrike, Bears in the Midst: Intrusion into the Democratic National Committee,\n\n[https://www.crowdstrike.com/blog/bears-midst-intrusion-democratic-national-committee/, June 2016](https://www.crowdstrike.com/blog/bears)\n\n_8._ [Trend Micro, Pawn Storm Espionage Attacks Use Decoys, Deliver SEDNIT, https://www.trendmicro.com/vinfo/us/](https://www.trendmicro.com/vinfo/us/security/news/cyber-attacks/pawn-storm-espionage-attacks-use-decoys-deliver-sednit)\n[security/news/cyber-attacks/pawn-storm-espionage-attacks-use-decoys-deliver-sednit, October 2014](https://www.trendmicro.com/vinfo/us/security/news/cyber-attacks/pawn-storm-espionage-attacks-use-decoys-deliver-sednit)\n\n_9._ [FireEye, APT28: A Window into Russia’s Cyber Espionage Operations?, https://www.fireeye.com/blog/](https://www.fireeye.com/blog/threat-research/2014/10/apt28-a-window-into-russias-cyber-espionage-operations.html)\n[threat-research/2014/10/apt28-a-window-into-russias-cyber-espionage-operations.html](https://www.fireeye.com/blog/threat-research/2014/10/apt28-a-window-into-russias-cyber-espionage-operations.html)\n\n_10._ [GitHub, ESET Indicators of Compromises, https://github.com/eset/malware-ioc/tree/master/sednit](https://github.com/eset/malware-ioc/tree/master/sednit)\n\n_11._ [ESET, Sednit espionage group now using custom exploit kit, http://www.welivesecurity.com/2014/10/08/sednit-](http://www.welivesecurity.com/2014/10/08/sednit-espionage-group-now-using-custom-exploit-kit/)\n[espionage-group-now-using-custom-exploit-kit/, October 2014](http://www.welivesecurity.com/2014/10/08/sednit-espionage-group-now-using-custom-exploit-kit/)\n\n_12._ [Microsoft Developer Network, Run-Time Type Information, https://msdn.microsoft.com/en-us/library/b2ay8610.aspx](https://msdn.microsoft.com/en-us/library/b2ay8610.aspx)\n\n_13._ [Trend Micro, Pawn Storm Update: iOS Espionage App Found, https://blog.trendmicro.com/trendlabs-security-](https://blog.trendmicro.com/trendlabs-security-intelligence/pawn)\n[intelligence/pawn-storm-update-ios-espionage-app-found/, February 2015](https://blog.trendmicro.com/trendlabs-security-intelligence/pawn)\n\n_14._ [Die.net, pthreads(7) - Linux man page, http://linux.die.net/man/7/pthreads](http://linux.die.net/man/7/pthreads)\n\n_15._ [SQLite, SQLite, https://www.sqlite.org/](https://www.sqlite.org)\n\n_16._ [Wikipedia, Cyclic redundancy check, https://en.wikipedia.org/wiki/Cyclic_redundancy_check](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)\n\n_17._ [W3C, The Multipart Content-Type, https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html](https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html)\n\n_18._ Microsoft Developer Network, How to Implement Icon Overlay Handlers,\n\n[https://msdn.microsoft.com/en-us/library/windows/desktop/hh127442(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/hh127442)\n\n_19._ Microsoft Developer Network, SYSTEMTIME structure,\n\n[https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950)\n\n_20._ [Wikipedia, Lempel–Ziv–Welch, https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch](https://en.wikipedia.org/wiki/Lempel)\n\n_21._ [4coder, LZW Algorithm Implementation, http://4coder.org/c-c-source-code/243/](http://4coder.org/c-c-source-code/243)\n\n_22._ Netzpolitik.org, Digital Attack on German Parliament: Investigative Report on the Hack of the Left Party\n\n[Infrastructure in Bundestag, https://netzpolitik.org/2015/digital-attack-on-german-parliament-investigative-](https://netzpolitik.org/2015/digital)\nreport-on-the-hack-of-the-left-party-infrastructure-in-bundestag/, June 2015\n\n_23._ [Spiegel, Cyberangriff auf das Parlament: Bundestag bestätigt Abfluss von E-Mail-Daten, https://www.spiegel.de/](https://www.spiegel.de/netzwelt/netzpolitik/cyberangriff-bundestag-bestaetigt-diebstahl-von-e-mail-daten-a-1039816.html)\n[netzwelt/netzpolitik/cyberangriff-bundestag-bestaetigt-diebstahl-von-e-mail-daten-a-1039816.html, June 2015](https://www.spiegel.de/netzwelt/netzpolitik/cyberangriff-bundestag-bestaetigt-diebstahl-von-e-mail-daten-a-1039816.html)\n\n_24._ [PDB Files, https://github.com/Microsoft/microsoft-pdb#what-is-a-pdb](https://github.com/Microsoft/microsoft-pdb#what-is-a-pdb)\n\n_25._ Internet Engineering Task Force, The Transport Layer Security (TLS) Protocol,\n\n[https://tools.ietf.org/html/rfc5246#section-1](https://tools.ietf.org/html/rfc5246#section-1)\n\n_26._ Microsoft Developer Network, WinHttpGetIEProxyConfigForCurrentUser function,\n\n[https://msdn.microsoft.com/en-us/library/windows/desktop/aa384096(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384096)\n\n_27._ [Squid, Home Page, http://www.squid-cache.org/](http://www.squid-cache.org)\n\n\n-----\n\n### En Route with Sednit\n\n\n_28._ [Wikipedia, HTTP CONNECT tunneling, https://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling](https://en.wikipedia.org/wiki/HTTP_tunnel)\n\n_29._ [Wikipedia, HTTP persistent connection, https://en.wikipedia.org/wiki/HTTP_persistent_connection](https://en.wikipedia.org/wiki/HTTP_persistent_connection)\n\n_30._ [Wikipedia, Opaque predicate, https://en.wikipedia.org/wiki/Opaque_predicate](https://en.wikipedia.org/wiki/Opaque_predicate)\n\n_31._ [Wikipedia, Control flow graph, https://en.wikipedia.org/wiki/Control_flow_graph](https://en.wikipedia.org/wiki/Control_flow_graph)\n\n_32._ [SecurityXploded, Home Page, http://securityxploded.com/](http://securityxploded.com)\n\n_33._ [mimikatz, GitHub page, https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz)\n\nLast updated 2016-09-07 19:38:00 EDT\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        },
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "http://www.welivesecurity.com/wp-content/uploads/2016/10/eset-sednit-part-2.pdf",
        "https://app.box.com/s/lmaensc7vzdugsy1nsh4bwligl07q53b",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2016/2016.10.25.Lifting_the_lid_on_Sednit/eset-sednit-part-2.pdf"
    ],
    "report_names": [
        "eset-sednit-part-2.pdf",
        "eset-sednit-part2(10-25-2016)",
        "eset-sednit-part-2"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "761d1fb2-60e3-46f0-9f1c-c8a9715967d4",
            "created_at": "2023-01-06T13:46:38.269054Z",
            "updated_at": "2025-03-27T02:00:02.789278Z",
            "deleted_at": null,
            "main_name": "APT3",
            "aliases": [
                "TG-0110",
                "Group 6",
                "Buckeye",
                "Boyusec",
                "BORON",
                "BRONZE MAYFAIR",
                "Red Sylvan",
                "GOTHIC PANDA"
            ],
            "source_name": "MISPGALAXY:APT3",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e3767160-695d-4360-8b2e-d5274db3f7cd",
            "created_at": "2022-10-25T16:47:55.914348Z",
            "updated_at": "2025-03-27T02:05:17.411172Z",
            "deleted_at": null,
            "main_name": "IRON TWILIGHT",
            "aliases": [
                "ATK5 ",
                "Blue Athena ",
                "BlueDelta ",
                "FROZENLAKE ",
                "Fancy Bear ",
                "Fighting Ursa ",
                "Forest Blizzard ",
                "GRAPHITE ",
                "Group 74 ",
                "PawnStorm ",
                "STRONTIUM ",
                "Sednit ",
                "Snakemackerel ",
                "Sofacy ",
                "TG-4127 ",
                "Tsar Team ",
                "APT28 "
            ],
            "source_name": "Secureworks:IRON TWILIGHT",
            "tools": [
                " Downdelph",
                " Drovorub",
                " EVILTOSS",
                " HIDEDRV",
                " Headlace",
                " LoJack",
                " Powershell Empire",
                " SCONATO",
                " SEDUPLOADER",
                " SHARPFRONT",
                " Scaramouche",
                " Sedkit Exploit Kit",
                " Sofacy downloader",
                " X-Agent",
                " X-Tunnel",
                " Zebrocy",
                " reGeorg",
                "DEALERSCHOICE"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "730dfa6e-572d-473c-9267-ea1597d1a42b",
            "created_at": "2023-01-06T13:46:38.389985Z",
            "updated_at": "2025-03-27T02:00:02.821388Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "FROZENLAKE",
                "BlueDelta",
                "SNAKEMACKEREL",
                "TG-4127",
                "ITG05",
                "TA422",
                "Fancy Bear",
                "FANCY BEAR",
                "Sednit",
                "IRON TWILIGHT",
                "G0007",
                "Sofacy",
                "Forest Blizzard",
                "GruesomeLarch",
                "Pawn Storm",
                "Tsar Team",
                "STRONTIUM",
                "ATK5",
                "Blue Athena",
                "APT-C-20",
                "Group 74",
                "SIG40",
                "Grizzly Steppe",
                "Fighting Ursa",
                "T-APT-12",
                "UAC-0028"
            ],
            "source_name": "MISPGALAXY:APT28",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ae320ed7-9a63-42ed-944b-44ada7313495",
            "created_at": "2022-10-25T15:50:23.671663Z",
            "updated_at": "2025-03-27T02:00:55.518748Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "APT28",
                "IRON TWILIGHT",
                "SNAKEMACKEREL",
                "Group 74",
                "Sednit",
                "Sofacy",
                "Pawn Storm",
                "Fancy Bear",
                "STRONTIUM",
                "Tsar Team",
                "Threat Group-4127",
                "TG-4127",
                "Forest Blizzard",
                "FROZENLAKE"
            ],
            "source_name": "MITRE:APT28",
            "tools": [
                "Wevtutil",
                "certutil",
                "Forfiles",
                "DealersChoice",
                "Mimikatz",
                "ADVSTORESHELL",
                "Komplex",
                "HIDEDRV",
                "JHUHUGIT",
                "Koadic",
                "Winexe",
                "XTunnel",
                "Drovorub",
                "CORESHELL",
                "OLDBAIT",
                "Downdelph",
                "XAgentOSX",
                "USBStealer",
                "Zebrocy",
                "Fysbis",
                "LoJax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "06f622cb-3a78-49cf-9a4c-a6007a69325f",
            "created_at": "2022-10-25T16:07:23.315239Z",
            "updated_at": "2025-03-27T02:02:09.733197Z",
            "deleted_at": null,
            "main_name": "APT 3",
            "aliases": [
                "APT 3",
                "Bronze Mayfair",
                "Buckeye",
                "Gothic Panda",
                "Group 6",
                "Operation Clandestine Fox",
                "Operation Clandestine Fox, Part Deux",
                "Operation Clandestine Wolf",
                "Operation Double Tap",
                "Red Sylvan",
                "TG-0110",
                "UPS Team"
            ],
            "source_name": "ETDA:APT 3",
            "tools": [
                "APT3 Keylogger",
                "Agent.dhwf",
                "BKDR_HUPIGON",
                "Backdoor.APT.CookieCutter",
                "Badey",
                "Bemstour",
                "CookieCutter",
                "Destroy RAT",
                "DestroyRAT",
                "DoublePulsar",
                "EXL",
                "EternalBlue",
                "HTran",
                "HUC Packet Transmit Tool",
                "Hupigon",
                "Hupigon RAT",
                "Kaba",
                "Korplug",
                "LaZagne",
                "MFC Huner",
                "OSInfo",
                "Pirpi",
                "PlugX",
                "RedDelta",
                "RemoteCMD",
                "SHOTPUT",
                "Sogu",
                "TIGERPLUG",
                "TTCalc",
                "TVT",
                "Thoper",
                "Xamtrav",
                "remotecmd",
                "shareip",
                "w32times"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d2516b8e-e74f-490d-8a15-43ad6763c7ab",
            "created_at": "2022-10-25T16:07:24.212584Z",
            "updated_at": "2025-03-27T02:02:10.141001Z",
            "deleted_at": null,
            "main_name": "Sofacy",
            "aliases": [
                "APT 28",
                "ATK 5",
                "Blue Athena",
                "BlueDelta",
                "FROZENLAKE",
                "Fancy Bear",
                "Fighting Ursa",
                "Forest Blizzard",
                "Grey-Cloud",
                "Grizzly Steppe",
                "Group 74",
                "GruesomeLarch",
                "ITG05",
                "Iron Twilight",
                "Operation DealersChoice",
                "Operation Dear Joohn",
                "Operation Komplex",
                "Operation Pawn Storm",
                "Operation Russian Doll",
                "Operation Steal-It",
                "Pawn Storm",
                "SIG40",
                "Sednit",
                "Snakemackerel",
                "Sofacy",
                "Strontium",
                "T-APT-12",
                "TA422",
                "TAG-0700",
                "TAG-110",
                "TG-4127",
                "Tsar Team",
                "UAC-0028",
                "UAC-0063"
            ],
            "source_name": "ETDA:Sofacy",
            "tools": [
                "ADVSTORESHELL",
                "AZZY",
                "Backdoor.SofacyX",
                "CHERRYSPY",
                "CORESHELL",
                "Carberp",
                "Computrace",
                "DealersChoice",
                "Delphacy",
                "Downdelph",
                "Downrage",
                "Drovorub",
                "EVILTOSS",
                "Foozer",
                "GAMEFISH",
                "GooseEgg",
                "Graphite",
                "HATVIBE",
                "HIDEDRV",
                "Headlace",
                "Impacket",
                "JHUHUGIT",
                "JKEYSKW",
                "Koadic",
                "Komplex",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "LoJack",
                "LoJax",
                "MASEPIE",
                "Mimikatz",
                "NETUI",
                "Nimcy",
                "OCEANMAP",
                "OLDBAIT",
                "PocoDown",
                "PocoDownloader",
                "Popr-d30",
                "ProcDump",
                "PythocyDbg",
                "SMBExec",
                "SOURFACE",
                "SPLM",
                "STEELHOOK",
                "Sasfis",
                "Sedkit",
                "Sednit",
                "Sedreco",
                "Seduploader",
                "Shunnael",
                "SkinnyBoy",
                "Sofacy",
                "SofacyCarberp",
                "SpiderLabs Responder",
                "Trojan.Shunnael",
                "Trojan.Sofacy",
                "USB Stealer",
                "USBStealer",
                "VPNFilter",
                "Win32/USBStealer",
                "WinIDS",
                "Winexe",
                "X-Agent",
                "X-Tunnel",
                "XAPS",
                "XTunnel",
                "Xagent",
                "Zebrocy",
                "Zekapab",
                "carberplike",
                "certutil",
                "certutil.exe",
                "fysbis",
                "webhp"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716505,
    "ts_updated_at": 1743041831,
    "ts_creation_date": 1477316689,
    "ts_modification_date": 1477316700,
    "files": {
        "pdf": "https://archive.orkl.eu/6f1dfb7fc2367f5787b076deb44f37704a682caa.pdf",
        "text": "https://archive.orkl.eu/6f1dfb7fc2367f5787b076deb44f37704a682caa.txt",
        "img": "https://archive.orkl.eu/6f1dfb7fc2367f5787b076deb44f37704a682caa.jpg"
    }
}