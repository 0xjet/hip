{
    "id": "7953376b-bedc-46e5-8a73-edda18bab3ed",
    "created_at": "2023-04-05T02:08:25.856323Z",
    "updated_at": "2025-03-27T02:05:46.465246Z",
    "deleted_at": null,
    "sha1_hash": "2347dde16ec0d520533a65de0f1cf3afe61afe6c",
    "title": "2023-02-24 - Snip3 Crypter Reveals New TTPs Over Time",
    "authors": "",
    "file_creation_date": "2023-04-03T08:26:45Z",
    "file_modification_date": "2023-04-03T08:26:45Z",
    "file_size": 1877954,
    "plain_text": "# Snip3 Crypter Reveals New TTPs Over Time\n\n**[zscaler.com/blogs/security-research/snip3-crypter-reveals-new-ttps-over-time](https://www.zscaler.com/blogs/security-research/snip3-crypter-reveals-new-ttps-over-time)**\n\nZscaler ThreatLabz researchers observed multiple threat campaigns utilizing the Snip3\ncrypter, a multi-stage remote access trojan (RAT) loader with new TTPs and available since\n2021 as a crypter-as-a-service offering.\n\nThe Snip3 Crypter service uses advanced evasion, obfuscation, and reflective code loading\ntechniques in its multi-stage infection chain, along with new Tactics, Techniques, and\nProcedures (TTPs). As a crypter-as-a-service model, even less technically skilled threat\nactors can obtain and utilize this service in their attack campaigns against organizations.\nDue to the widespread use of the Snip3 Crypter, its developers provide frequent updates to\nenhance the crypter with new sophisticated techniques that can evade detection and\neffectively deploy the final Remote Access Trojan (RAT) payload on the targeted machines.\n\nThreatLabz has recently identified use of the crypter with new TTPs deploying RAT families\nincluding DcRAT and QuasarRAT targeting victims across multiple industry verticals such\nas healthcare, energy and utilities, and manufacturing via spear phishing emails with\nsubject lines related to “tax statements” in order to lure victims into execution.\n\nBelow are the takeaways from the team’s in-depth analysis of the Snip3 Crypter campaign\nand the corresponding infection chain, which showcases the observed changes in the\nTTPs.\n\n## Key Takeaways\n\nThreat actors utilize spear phishing emails with subjects related to \"tax statements\"\nas a bait to lure the victims into execution of the multi-staged infection chain.\n\nThe top 3 targeted industries are:\n\nHealthcare\nEnergy, oil, and gas\nManufacturing\nSnip3 Crypter operates with new TTPs to deliver remote access trojans like DcRAT\nand QuasarRAT to targets.\n\n\n-----\n\nThe following are the new techniques used in the Snip3 Crypter Infection chain:\n\nMalicious strings are fetched from database servers via ADODB connections\nAMSI bypass is performed by forcing an error\nIn-memory stages are decrypted using hardcoded keys with custom decryption\nroutines\nThe final Snip3 RAT loader is downloaded from the server along with the\ncorresponding user-agent containing system information\nCommands are received from the download server to decide the flow of\nexecution for delivering the final RAT payload\nInfrastructure is shifted periodically to evade malicious domain-based detections\nURLs are shortened using TinyURL to download the Stage-2 and Stage-3 PS\nscript\nUser-agent changes are used to download the final stage and addition of\nversion variable ($VER = 'v0.2')in the Stage-3 PS Script\n\n## New Threat Campaign Analysis\n\nThreatLabz has observed multiple Snip3 campaigns in the Zscaler Cloud targeting a variety\nof industry verticals. Healthcare emerged as the most targeted sector as shown in the graph\nbelow. Other targeted sectors include energy, manufacturing, materials, finance, retail, and\ntechnology. Organizations across these sectors should remain vigilant and deploy\nadvanced security measures to protect against Snip3 Crypter and other such threats.\n\n_Fig 1. Industry verticals targeted by the latest Snip3 crypter campaign(s)_\n\nHere, the initial VBS payloads with the file-name “Releve Fiscal” (tax relief) were\ndownloaded as an attachment via a phishing email with a subject line related to “tax\nstatements” across 2022.\n\n\n-----\n\n_Fig 2. The many observed Snip3 crypter campaigns and their dates_\n\n## The Infection Chain\n\n_Fig 3. The Attack Chain_\n\nThe ongoing Snip3 campaign constitutes a complex and multifaceted attack, which uses a\nseries of sophisticated evasion techniques and multiple obfuscated scripts. The latest\nversion of the Snip3 crypter is utilized to implement new tactics, techniques, and\nprocedures (TTPs), leading to the successful execution of the final payload and subsequent\nsystem infection.\n\nThe attack is initiated through a spear phishing email that has the subject line \"Download\nyour tax statement\" or, in French, \"Télécharger votre relevé fiscal.\" The emails are designed\nto create a sense of urgency and importance, thereby enticing users to open the attached\nfiles without much consideration. This marks the start of the infection chain.\n\n\n-----\n\n_Fig.4 Spear phishing email with tax statement bait and corresponding attachments_\n\nThe screenshot above shows that the email contains several attachments, including a\ncorrupted PDF file named \"Info.pdf\" and a corrupted CSV file named \"ID102332541.csv.\"\nThese decoy files are included alongside the malicious script called \"Votre Releve Fiscal6.vbs\" in order to deceive the user into running it.\n\n**Stage-1: VBScript**\n\nWhen the Stage-1 VBScript is executed, it establishes a connection to a database by\ncreating an ADODB connection and record object. The details of the provider, including the\ndata source, user ID, and password, are decrypted using an encoding method that utilizes\nthe Chr and CLng functions, as illustrated in the screenshot below.\n\n\n-----\n\n_Fig.5 Stage-1 VBScript decoding the provider details using Chr and CLng functions_\n\n**Decoding routine:**\n\nChr(657040/CLng(“&H13fae”)) -> Chr(657040/81838) -> Character “P”\nAfter decoding the provider details, the script proceeds to establish a connection to the\nSQL8001.site4now.net data source using the decoded user ID and password. If the\nconnection is established successfully, it executes the following two database queries to\nretrieve the relevant data from the table:\n\nSELECT ID, NAME, AGE, PHONE From TBL_CUSTOMERS\nSELECT * From TBL_PRODUCTS\n\nThe results of these queries are then processed using \"SqlReader.Fields.Item[index_val]\" to\nextract the values from each column, and the values are concatenated together as shown in\nthe screenshot below.\n\n_Fig.6 Execution and parsing of database queries_\n\nThe output from parsing and indexing the queries is saved into two variables named\n\"CustomerInfo\" and \"ProductInfo.\" The variables are populated with the following values\nafter the execution and query parsing:\n\nCustomerInfo = \"Wscript.Shell\"\nProductInfo = \"Powershell.exe -ExecutionPolicy RemoteSigned -Command\"\n\nThis technique allows the script to avoid detection from static-string-based signatures for\nthe specific command lines, as the values are retrieved after execution in memory.\n\nFollowing this, the script proceeds to decode a Downloader PowerShell script by replacing\nthe string \"12BBf02emp410+]@Mdk!!#1022==\" with a null value. The decoded script is then\nsaved into a variable named \"Camtasia,\" as shown below.\n\n\n-----\n\n_Fig.7 Decoding Downloader PS script using Replace()_\n\nBelow is the decoded Downloader PowerShell Script:\n\n_Fig.8 Downloader PowerShell script_\n\nThe decoded PowerShell script is saved in the \"Camtasia\" variable and executed together\nwith the parsed database query response from the server. This creates a WScript.shell\nobject, which then runs the concatenated command \"Powershell.exe -ExecutionPolicy\nRemoteSigned -Command 'Decoded PowerShell Script'.\"\n\n_Fig.9 Execution of Downloader Powershell script_\n\nAfter executing the decoded downloader PowerShell script, the Stage-2 PowerShell script is\ndownloaded from https[:]pastetext.net/raw/lcscgt0mss using $Client.DownloadData in\nbyte format. The script is then converted to string format using UTF8.GetString() and\nwritten to the disk at C:\\Users\\Public\\lcscgt0mss.ps1. The downloaded Stage-2\nPowerShell script is then executed using Invoke-Expression, with the execution policy set\nas RemoteSigned. This allows the PowerShell interpreter to run unsigned scripts from the\nlocal computer.\n\n**Stage-2: PasteText Downloaded PowerShell Script (lcscgt0mss.ps1)**\n\nThe Stage-2 PowerShell script initially runs the \"DroptoStartUp\" function, which is illustrated\nin the screenshot below.\n\n\n-----\n\n_Fig.10 Stage-2 PowerShell script DroptoStartUp function_\n\nUpon running the \"DroptoStartUp\" function, a byte stream is converted via GetString() to a\nstring and stored in the variable $startup. This string is then written to the Startup Folder\nusing the WriteAllText() function and is named as\n\"GoogleChromeUpdateHandlerx64.vbs\". By doing this, the script is able to maintain\npersistence as files in the Startup Folder are executed by the system whenever the user\nlogs on or starts Windows. The %FILE% argument is the $PSCommandPath environment\nvariable which corresponds to the full path and file name of the script that invoked the\ncurrent command.\n\n_Fig.11 Stage-2 GoogleChromeUpdateHandlerx64.vbs dropped in the startup folder_\n\nOn every system startup, the “GoogleChromeUpdateHandlerx64.vbs” script is executed\nfrom the startup folder, which initializes the WScript.Shell object and the Powershell\nexecution policy with the RemoteSigned parameter to execute an unsigned Stage-2\nPowershell script from the specified path. Therefore, the Stage-2 script, lcscgt0mss.ps1, is\nexecuted every time the system is restarted by dropping the script and setting the\n$PSCommandPath to the file name of the script that invoked the current command at\nruntime.\n\nThe second part of the Stage-2 script decrypts another PowerShell script in-memory and\nexecutes it, as shown in the screenshot below.\n\n\n-----\n\n_Fig.12 Stage-2 Decryption (in-memory) of Stage-3 Powershell script_\n\nThe script begins by initializing an encrypted integer stream called $rawData, which is\npassed on to a function called \"IntegerToBytes()\" along with the string argument $sKey\n\"Qoepl10Msple1VCmle\". Inside the function, a $dataBuffer is initialized to store the\ndecrypted output, and a decryption loop is performed as follows below.\n\n**Decryption logic:**\n\nThe Decryption loop sets up a counter variable $i=0 and increments it to the length of the\n$rawData stream (3473) by 1 upon completion of each loop. This is the decryption logic:\n\nThe first character of the $sKey, i.e., Q is converted to its corresponding character\ncode using AscW($sKey) and stored in $ascwKey = “81”, only this is used for\ndecryption\nThen, the encrypted integer stream is accessed one digit at a time and divided by the\nkey length multiplied by 128 = $iData[$i] / ($sKey.Length * 128) and saved into the\n$deBuff variable\nThis $deBuff variable is then subtracted from the $ascwKey i.e “81” and stored in the\n**$decData variable. The $decData variable is the decrypted byte which is added into**\nthe $dataBuffer till the completion of the loop\n\nOnce the loop is completed, the script converts the $dataBuffer to ArrayList object in proper\nsequence by using the $dataBuffer.ToArray() function and returns the final value. The final\narray is then converted to string using UTF8.GetString(final_value) and then stored in a\nvariable $PDF which is another powershell script.\n\nFinally, the Stage-2 PowerShell Script executes and loads the decrypted Stage-3\nPowerShell Script into memory using Invoke-Expression.\n\n**Stage-3: In-memory decrypted Powershell script**\n\nUpon execution, the Stage-3 PowerShell script is decrypted with a key and run via InvokeExpression. Subsequently, the script generates an XMLHTTP object to send arbitrary HTTP\nrequests and receive their responses.\n\n\n-----\n\nAdditionally, the script initializes the following configurations related to the download server:\n\n**$IP = “185[.]81[.]157[.]59”**\n**$Port = “3333”**\n**$Splitter = “|V|”**\n**$ErrorActionPreference = “Silently Continue**\n\n_Fig.13 Stage-3 In-memory decrypted Powershell script download server configuration_\n\nThe \"DropToStartUp()\" function is executed by the Stage-3 PowerShell script after\ninitialization. This function is the same one used in the Stage-2 script, which converts the\nbyte stream to a string and writes it to the startup folder with the name\n**GoogleChromeUpdateHandler.vbs. Consequently, when the system reboots, the**\n**GoogleChromeUpdateHandler.vbs script automatically executes the Stage-3 PowerShell**\nscript by initializing the Wscript.Shell object. The $PSCommandPath variable, which\ncontains the path of the invoking script, is already concatenated into the script at runtime.\n\n_Fig.14 GoogleChromeUpdateHandler.vbs dropped in the startup folder for persistence_\n\nThe \"INF()\" function is used to gather system information in the Stage-3 PowerShell script.\nFirstly, it retrieves the universally unique identifier (UUID) of the system by passing the\ncomputer name through the $env:computername environment variable to the \"HWID()\"\nfunction. The \"HWID()\" function executes a WMI Object query (\"get-wmiobject\n**Win32_ComputerSystemProduct | Select-Object -ExpandProperty UUID\") to fetch the**\n\n\n-----\n\nUUID and converts it into a string using the ToString() method. Next, the UUID is parsed\nto concatenate only the first two values while removing the \"-\" splitter from the identifier.\nFinally, the concatenated UUID is returned.\n\n_Fig.15 Fetches system UUID via WMI object queries_\n\nAdditionally, in the Stage-3 Powershell script, the operating system's name, version, and\narchitecture (32-bit or 64-bit) are collected using the following WMI object queries: Get**WMIObject Win32_OperatingSystem.Name (which splits the output string via “|”) and**\n**Get-WMIObject Win32_OperatingSystem.OSArchitecture. The script also collects the**\ncomputer name and username of the system. Once all of the necessary information is\ncollected, it is arranged and concatenated with specific constant strings in a particular order,\nas displayed in the screenshot below.\n\n_Fig.16 System information gathering and concatenation_\n\nAfter gathering system information, the Stage-3 Powershell script arranges the data and\nstores it in the $INFO variable in the following format:\n\n**Novo_<UUID><Computer_name><UserName><OS_Version_Architecture>\\Windows**\n**Defender\\Yes\\Yes\\FALSE\\**\n\nNext, the script calls the HTTP() function to download the Stage-4 Powershell script from\nthe Download Server. The HTTP() function takes two arguments: the first is set to “Vre” and\nthe second is null, as shown in the screenshot below.\n\n_Fig.17 “Vre” parameter passed on to the HTTP function_\n\nThe HTTP() Function then sends across a HTTP request via the XMLHttpRequest.Open()\nwith following parameters:\n\n\n-----\n\n- Method: POST\n\n- Url: http://$IP:Port/Vre (Download Server IP and Port)\n\nWhere in this case $IP = “185[.]81[.]157[.]59” and $Port = “3333”\n\n**Note: The value of the $IP and $Port keeps on changing as per the final payload to be**\nexecuted on the infected machine\nFurther, it sets up the user-agent via the XMLHttpRequest.setRequestHeader() with the\n$INFO variable, which was assigned to the formatted version of the gathered system\ninformation defined previously. Then, the POST request is sent across with the required\nparameters to the download server in order to download the next stage, the Stage-4\nPowershell script. The response is then encapsulated and converted into string and\nreturned to the previous function for parsing as shown in the screenshot below.\n\n_Fig.18 Downloads the Stage-4 Powershell script from the download server_\n\nThe following request is then sent to the download server:\n\n_Fig.19 Request to the download server_\n\nFurther, the downloaded data, i.e., the Stage-4 Powershell script, is passed to the Split()\nfunction along with the separator $Splitter = “|V|'' which was initialized before. The Split()\nfunction then separates the downloaded data into two parts:\n\n“TR|V|Add-Type -AssemblyName System.Windows.FormsAdd-Type -AssemblyName..”\n\n\n-----\n\nThe split function then separates the script in two parts. One is TR, which is the command\nfrom the downloader server, and second is the Stage-4 Powershell script. The first part,\ni.e., index “0”, the command from the downloader server, is then passed on to the switch\nstatement which consists of three conditions as shown in the screenshot below.\n\nswitch($command){\n\n<condition_1> if $command = “TR” - Perform the Malicious Routine\n<condition_2> if $command = “Cl” - Exit the code\n\n<condition_2> if $command = “Un” - Exit the code\n\n}\n\n_Fig.20 Switch statement as per the command input_\n\nTherefore, if the command from the download server equals “TR” after splitting the\ncomplete downloaded data into two parts, the malicious code routine is executed.\n\nThis code routine initially generates a random GUID using the NewGuid function then\nremoves the ‘-’ from the Guid and concatenates it with “.PS1”. This becomes the FileName\nfor the Stage-4 Powershell script eg. 0d0c2fb5b767451788a2751ca5ebea2a.PS1. The\nFilename is then concatenated with the system’s temp path which becomes the file path for\nthe Powershell script, and then the Stage-4 Powershell script is written using WriteAllText()\nfunction at the temp path.\n\nFurther, in order to maintain persistence, the same technique used in the previous\n“DropToStartUp()” function is implemented where the byte stream is converted to string and\nthen written in the startup folder with the file named as WinLogonUpdate.vbs in this case.\nTherefore whenever the system is restarted, the Stage-4 Powershell script is executed\nautomatically by the system using the WinLogonUpdate.vbs script by initially creating an\nWscript.Shell Object. Then the Stage-4 Powershell Script, as the Temp File path of the\nPowershell script, is updated at runtime while dropping the script as shown in the\nscreenshot below.\n\n\n-----\n\n_Fig.21 Dropping of Stage-4 Powershell script in the temp path along with persistence_\n\nOnce the persistence is laid out, the Stage-4 Powershell script from the download server is\nexecuted from the temp path via invocation of Powershell.exe with hidden window style and\nthe execution policy is set to RemoteSigned. At the end, Stage-3 Powershell script sleeps\nfor “3000” milliseconds and then closes off.\n\n**Stage-4 - The Final Stage - RAT Loader**\n\nThe Stage-4 Powershell script is the “Final Stage - RAT Loader” and has been used\neffectively by the “Snip3 Crypter crew” as the final loader in the infection chain which\ndelivers and executes numerous RAT families onto target machines. The loader compiles\n**the RunPE source code at runtime which is embedded in the Powershell script as a**\n**compressed GZIP byte stream in order to perform Process Hollowing to execute the**\n**RAT. Implementing this technique allows the loader to stay under the radar and evade**\ndetection mechanisms in place.\n\nThe loader initially executes the INSTALL function which is the same as the\n“DropToStartUp()” function explained previously. The function writes the following VBS\nscript in the startUp folder by first converting the byte stream into string and then writing it\nusing WriteAllText() and concatenating the Snip3 Crypter File path at runtime.\n\n_Fig.22 VBS script dropped in startup folder in order to maintain persistence_\n\nFurther, the most important function of the Snip3 Crypter, the CodeDom(),is executed. The\nCodeDom function takes three arguments. The first one is the GZIP compress RUNPE\ncode in byte format, the second is the type object, “Git.Repository”, where Git is the\nnamespace and Repository is the class name, and the third, “Execute”, is the method to be\ninvoked after sleeping for 2000 milliseconds as shown in the screenshot below.\n\n\n-----\n\n_Fig.23 Execution of the CodeDom() function_\n\nUpon being executed, the CodeDom function initializes the CodeDom compiler. a .NET API\nwhich allows devs to programmatically compile code using the .NET compilers where the\nversion is set to v4 in this case. Along with the version, the compiler parameters such as\nCompilerOptions and IncludeDebugInformation are initiated during the compilation process\nshown in the screenshot below\n\n_Fig.24 CodeDom compiler initialization_\n\nPost-initialization of the CodeDom Compiler the GZIP compressed RunPE byte stream is\ndecompressed via the Decompress($RunPE) function. This uses the\nSystem.IO.Compression.GzipStream with the “Decompress” parameters with input as the\nGZIP compressed RunPE byte stream, as shown below.\n\n_Fig.25 GZIP Decompression of RunPE Byte Stream_\n\n\n-----\n\nOnce the RunPE Byte Stream is decompressed, it s then compiled dynamically at runtime\nusing CompileAssemblyFromSource via the CodeDom API, where the argument to the\nfunctions is the Decompressed RunPE Byte stream. During the compilation, the CSC.exe,\ni.e., the C# command line compiler process, is spawned, and the compiler creates a\ntemporary CS source code file in the temp directory. After analyzing the dropped source\ncode file, the ThreatLabz team was able to formulate that “RunPE” technique is been used\nin order to inject the final RAT payload into remote process via process hollowing,as shown\nin the following screenshot.\n\n_Fig.26 Runtime compilation of RunPe source code using CodeDom_\n\n_Fig.27 Command line compiler process being spawned_\n\nFurther, the decoding routine of the final RAT payload takes place where fthe URL encoded\npayload was decoded to a byte array using the UrlDecodeToBytes() function. Then, the\noutput is passed on to the Decompress() function where the URL-decoded byte array is\nGZIP decompressed. The GZIP decompressed file is the final executable RAT file with the\n“MZ” header, as shown in the following screenshot.\n\n_Fig.28 Runtime compilation of RunPe source code using CodeDom_\n\n\n-----\n\nOnce the RunPE source has been dynamically compiled and the RAT payload has been\ndecoded, the Snip3 Crypter reflectively loads the compiled RunPE loader in-memory via an\nInvoke() function where the executed method is “execute” and the arguments are the path\nto AppLaunch.exe gathered via GetRuntimeDirectory().\n\n_Fig.29 Reflective loading of the compiled RunPE payload alongside the arguments_\n\nThe reflectively loaded RunPE payload then processes the following two arguments\nprovided by the Snip3 Crypter:\n\nPath to AppLaunch.exe: Target process for process hollowing\nRAT payload: The final RAT executable\n\n_Fig.30 Arguments to the reflectively loaded RunPE Payload_\n\nFurther, the RunPE payload then performs process hollowing in order to inject the RAT\npayload into the remote process “AppLaunch.exe” by creating the target process via\nCreateProcessA() in a suspended state\n\nThe payload then unmaps or empties out the target process memory via\nZwUnMapViewOfSection()\n\n\n-----\n\nThen, memory is allocated in the remote target process depending on the size of the\npayload via VirtualAllocEx(), then the Final RAT Payload is written at the allocated memory\nlocation via WriteProcessMemory().\n\nTowards the end of the process hollowing, the threat context is reconfigured via\nGetThreadContext() and SetThreatContext() and the SetThreadContext() post\nreconfiguration points to the beginning of the malicious code.\n\nAt last, the RunPE payload simply resumes the thread and the final RAT payload is\nexecuted in the remote process “AppLaunch.exe” injected via process hollowing.\n\n_Fig.31 Process Hollowing the RAT in the Remote Process “AppLaunch.exe”_\n\nFurther, the ThreatLabz team dumped the RAT payload from the remote process\n“AppLaunch.exe” then extracted the configuration as shown in the following screenshot. By\nanalyzing the configuration, they were able to attribute the malware as “DcRat” as per the\nmutex value: DcRatMutex_qwqdanchun and the certificate information: DcRAT Server as\nseen in the extracted configuration.\n\n\n-----\n\nCommand and control for DcRAT = crazydns[.]linkpc[.]net:5900\n\n_Fig.32 DcRAT Extracted Configuration_\n\nThe ThreatLabz team analyzed multiple different Snip3 Crypter’s delivering DcRAT where\nthe loader was almost similar and found that the changes were made only in the case of the\ntarget process selected for hollowing such as “RegSvcs.exe”/“InstallUtil.exe”/”RegAsm.exe”.\nIn some cases, the RAT decoding routine consists of the StrReverse() function along with\nthe URL UrlDecodeToBytes() function, which would first reverse the URL-encoded string\nand then URl decode it in order to deliver the final DcRAT payload.\n\n_Fig.33 StrReverse() and different Injection target Process been used for delivering the_\n_DcRAT_\n\nFurther, the ThreatLabz team also came across samples leveraging the Snip3 crypter with\nnew TTPs in order to deliver “QuasarRAT” on the targeted systems with the similar\ninfection chain as explained before.\n\nIn this case, the final Snip3 crypter RAT loader is downloaded from a different download\nserver: 185[.]81[.]157[.]172:6594/Vre\n\n\n-----\n\n_Fig.34 Download server for QuasarRAT delivery_\n\nThe downloaded Snip3 RAT loader is exactly the same as the previous ones including their\nrespective decryption and loader routines. Here, only the target process for hollowing is\n“RegAsm.exe” as shown in the screenshot below.\n\n_Fig.35 Snip3 RAT loader for executingQuasarRAT_\n\nPost this the QuasarRAT payload is injected into the “RegAsm.exe” using the Dynamically\ncompiled RunPE code which internally uses Process Hollowing as a Process Injection\nmechanism.\n\n_Fig.36 Snip3 RAT Loader for execution of QuasarRAT_\n\nFurther, the ThreatLabz team dumped the RAT payload from “RegAsm.exe” and extracted\nthe configuration which helped them in the Attribution by analyzing the Mutex value:\n**“QSR_MUTEX_M611SwpmZ8q66BUDI” and the autorun_regkey_name: “Quasar Client**\nStartup” leading to the conclusion that the Snip3 Crypter was being leveraged in order to\ndeliver QuasarRAT on the targeted machines.\n\nCommand and control server for QuasarRAT: 185[.]81[.]157[.]203:1111\n\n\n-----\n\n_Fig.37 QuasarRAT configuration_\n\n**Tracking the Snip3 crypter - New TTPs Over Time:**\n\nOver the course of several months, the ThreatLabz team has been tracking the Snip3\ncrypter infection chain and has observed changes in the group's tactics, techniques, and\nprocedures (TTPs). The following modifications were identified:\n\nThe DB server used to fetch malicious strings by the initial VBScript was periodically\nchanged, moving from SQL8001[.]site4now[.]net to SQL8003[.]site4now[.]net and\nthen to SQL8004[.]site4now[.]net. This approach helps the group evade domainbased detections.\nThe Snip3 crew began using TinyURL to shorten URLs for downloading the Stage-2\nor Stage-3 PowerShell scripts. These URLs were redirected to toptal[.]com, which\nhosted the next PS stage.\n\n\n-----\n\n_Fig.38 Usage of TinyURLs to download the next PS stage_\n\nChanges were made to the Stage-3 PS script, including alterations to the user-agent\nfrom \"Novo_\" to \"New_\" and the initialization of a new version variable [String] $VER =\n'v0.2' in the PS script.\n\n_Fig.39 Implementing a new user-agent_\n\nAn AMSI bypass was discovered in the initial PowerShell script, decoded via the\nVBScript. This bypass involved setting the AmsiContext to \"0,\" which causes\nAmsiScanBuffer/AmsiScanString to return E_INVALIDARG, effectively bypassing\nAMSI. ThreatLabz also came across an AMSI bypass implemented in the Initial PS\nScript (decoded via the VBScript). Here, the AmsiContext is set to “0” which makes\nthe AmsiScanBuffer/AmsiScanString to return E_INVALIDARG, which in turn\nbypasses the AMSI.\n\n\n-----\n\n_Fig.40 AMSI Bypass_\n\nBy constantly evolving their TTPs, the Snip3 crypter threat actors can successfully deliver\nremote access trojans such as DcRAT and QuasarRAT on target machines using a multistaged infection chain. The ThreatLabz team is committed to monitoring these attacks and\nproviding timely updates.\n\n**Zscaler Sandbox Coverage:**\n\nFigure 41: The Zscaler Cloud Sandbox successfully detected the crypter\n\n[VBS.Downloader.DCRat](https://threatlibrary.zscaler.com/threats/061ac608-dd60-44bc-bec9-e3a24d4ecc0f)\n\n**Conclusion: In conclusion, the Snip3 crypter is a threat that continues to evolve with new**\ntechniques of obfuscation and evasion. The as-a-service model allows threat actors with\nlimited technical abilities to obtain and use the crypter in their attacks. The multi-stage\n\n\n-----\n\ninfection chain, combined with the use of new tactics, makes it a formidable threat that can\ncompromise organizations' systems. The Zscaler ThreatLabz team is actively monitoring\nthese attacks and will continue to work to help protect its customers from this and other\nemerging threats. It is important for organizations to remain vigilant and adopt robust\nsecurity measures to safeguard their systems and data from such threats.\n\n**Indicators of Compromise (IoCs):**\n\n1.Stage-1 VBScript:\n\nbd23ae38590d87243af890505d6fbeec\na41de1ef870e970e265cc35b766a5ec8\nSQL8001[.]site4now[.]net - Downloads Malicious strings\nSQL8003[.]site4now[.]net - Downloads Malicious strings\nSQL8004[.]site4now[.]net - Downloads Malicious strings\npastetext[.]net/raw/lcscgt0mss - Stage-2 Downloader URL\ntoptal[.]com/developers/hastebin/raw/buliforayu - Stage-3 Downloader URL\n\n2. Stage-2 Powershell:\n\na5b76ca780ddff061db6f86f03d3b120\n\n3. Stage-3 Powershell:\n\nb78c9bb6070340bb4d352c712a0a28b7\n\n4. Final RAT Loader Downloader IPs:\n\n185[.]81[.]157[.]59\n185[.]81[.]157[.]172\n185[.]81[.]157[.]136\n185[.]81[.]157[.]117\n\n5. Snip3 Final RAT Loader:\n\nDcRAT Loader: 923f46f8a9adfd7a48536de6f851d0f7\nQuasarRAT Loader: dda2ba195c9ebc9f169770290cd9f68a\n\n6. Final RAT Payloads:\n\nDcRAT: ef2236c85f915cae6380c64cc0b3472a\nQuasarRAT: 0bbc89719ff3c4a90331288482c95eac\n\n7. RAT Command & Control:\n\n\n-----\n\nDcRAT: crazydns[.]linkpc[.]net:5900\nQuasarRAT: 185[.]81[.]157[.]203:1111\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-02-24 - Snip3 Crypter Reveals New TTPs Over Time.pdf"
    ],
    "report_names": [
        "2023-02-24 - Snip3 Crypter Reveals New TTPs Over Time.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1680660505,
    "ts_updated_at": 1743041146,
    "ts_creation_date": 1680510405,
    "ts_modification_date": 1680510405,
    "files": {
        "pdf": "https://archive.orkl.eu/2347dde16ec0d520533a65de0f1cf3afe61afe6c.pdf",
        "text": "https://archive.orkl.eu/2347dde16ec0d520533a65de0f1cf3afe61afe6c.txt",
        "img": "https://archive.orkl.eu/2347dde16ec0d520533a65de0f1cf3afe61afe6c.jpg"
    }
}