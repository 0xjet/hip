{
    "id": "174fc244-0b04-40e7-821d-3e7f21c50e29",
    "created_at": "2022-10-25T16:48:16.085752Z",
    "updated_at": "2025-03-27T02:16:25.585248Z",
    "deleted_at": null,
    "sha1_hash": "50511389957f7c2e0127031d8633724ae05354f3",
    "title": "It'S Not The End Of The World: Darkcomet Misses By A Mile",
    "authors": "Arbor Networks",
    "file_creation_date": "2012-03-15T15:22:51Z",
    "file_modification_date": "2012-03-15T15:23:25Z",
    "file_size": 592419,
    "plain_text": "# It's not the end of the world: DarkComet misses by a mile\n\n_Reversing the DarkComet RAT's crypto- 3/13/2012_\n\nJeff Edwards, Research Analyst, Arbor Networks ASERT\n\nIn this article, we will continue our series on reversing DDoS malware crypto systems. Previous subjects have included\n[Armageddon,](http://ddos.arbornetworks.com/2012/03/its-2012-and-armageddon-has-arrived/) [Khan (now believed to be a very close \"cousin\" of Dirt Jumper version 5), and PonyDOS. Today we'll be](http://ddos.arbornetworks.com/2012/03/kahn/)\ndiving deep into the details of DarkComet's crypto. Over the last several months, we have encountered a large number of\nDarkComet samples, numbering well over a thousand. DarkComet is primarily a general purpose remote access trojan\n(RAT). It's capabilities support quite an extensive laundry list of mischief, including but not limited to key logging, web\ncam (and sound card) spying, deleting victim files, scanning ports, hijacking MSN sessions, etc.\n\n**Figure 1. Dark Comet's pretty logo**\n\n\n-----\n\nOf course the malware includes DDoS capabilities as well - hence our interest in reversing its communications so that we\ncan keep tabs on whom the DarkComet botnets are attacking.  In fact, it is believed to have been used as a DDoS weapon\n[by supporters of the Syrian regime against opposition forces in the recent Syrian uprisings; TrendMicro has a nice article](http://blog.trendmicro.com/darkcomet-surfaced-in-the-targeted-attacks-in-syrian-conflict/)\n/on this topic.\n\nDarkComet has been studied by a number of researchers. In particular, in November 2011 Laura Aylward of Contextis\n[published an excellent analysis](http://www.contextis.com/research/blog/darkcometrat/) [http://www.contextis.com/research/blog/darkcometrat/ ] of Dark Comet in which she\ndescribed the basic cryptographic mechanism used by DarkComet bots to hide their communications; Laura's analysis\n[saved us a considerable amount of time. It was also included in Curt Wilson's recent survey of modern DDoS weapons](http://ddos.arbornetworks.com/2012/02/ddos-tools/) .\n\nThe DarkComet sample upon which we will primarily focus on today is 462,848 bytes in size and has an MD5 hash of\n```\n63f2ed5d2ee50e90cda809f2ac740244. It happens to be an instance of DarkComet Version 4.2; however, the\n\n```\nresults presented here apply to most other versions of DarkComet as well.\n\nWhen executed in a sandbox, we observed it connecting to a command & control (C&C) server at newrat2.no```\nip.org on TCP port 1604. The RAT uses a raw TCP protocol to exchange information with its C&C; on the wire, the\n\n```\ncomms look something like this (modified and re-encrypted to protect some of our sensitive sandbox information):\n```\n      C&C:\n      155CAD31A61F\n      Bot:\n      0F5DAB3EB308\n      C&C:\n      1B7D8D3BBF14C6B619480C265C2F4664F9DCB878EA7DFC6F2637\n      Bot:\n      35769F079329B4E04603496A432E5A7CFC90A477F478F07A3826A1B436AB92852B685636\n      F72B52C56D70434D7691F3307D637118B869586A1D19FD15B8C6AE14F8F8C57EFAFCCC09\n      964E8EE8EED553886AB188665F1AB96586F4F2581C093E75DCF2A8ADC817558BF3452344\n      0CDBE43CA4C05AC6E8D90D00F35BE795A44AE0E2EDE36C061EAEBD754461F680DBD9893A\n      CF6211698AF22B0BBB92A9B47363AE86E69A08C29DD3DBA59D287E4A0E12664B312A81C0\n      E9FE4D6E538AB5CC8952CCB372869F57D168CE8ABB52B8D7F8E78547A5EB009931735868\n\n```\nArbor Networks | 2\n\n\n-----\n\n```\n      ADEC6BA2B73A94C7A9A6784B1A81C58CF746D384B645DD02D4616479A055420DADEF0458\n      658A33EEA62BF7F12ABF1C0E00CB6B971869FBC275A3270E8DEBFA20E53E8C3BC6CA2744\n      A88897E0B16FBBDCAA731B93A72D75FF6DC297\n      Bot:\n      KEEPALIVE144357\n      Bot: \n      C: KEEPALIVE160360\n      C&C:\n      S: KeepAlive|27120274\n      Bot: \n      C: KEEPALIVE176363\n      Bot: \n      C: KEEPALIVE192366\n      C&C:\n      S: KeepAlive|27160288\n\n```\n**Figure 2. Example of DarkComet's encrypted comms**\n\n[These communications are consistent with those reported by Contextis in their DarkComet report. It certainly looks like an](http://www.contextis.com/research/blog/darkcometrat/)\ninitial \"phone home\" exchange of information, after which the bot and C&C send periodic \"Keep Alive\" messages to each\nother. Besides being encrypted, this protocol is somewhat unusual in that the C&C sends the first payload; it is much more\ncommon for the bot to send the first payload.\n\nSo in order to develop a tracker that impersonates a DarkComet bot so as to snoop on DDoS attacks, we need to reverse the\nmalware's crypto system and write decryption and encryption routines in Python. Let's start reversing by loading a process\n[memory dump of the running bot in IDA Pro. We'll then start poking around looking for routines that might implement the](http://www.hex-rays.com/products/ida/index.shtml)\nphone home protocol. Since DarkComet clearly uses raw TCP for communication (as opposed to, say, HTTP), we'll focus\non finding WinSock2 calls such as socket(), connect(), send(), and recv().\n\nWell, it turns out that the bot is riddled with vast numbers of WinSock2 calls; not surprising, since DarkComet has a great\ndeal of RAT functions that require network communication. So to narrow down on the actual bot-C&C comms loop, we\n\nArbor Networks | 3\n\n\n-----\n\nlocate the lengthy list of command strings, such as KeylogOn, GetOfflineLogs, WEBCAMLIVE, GetMsnList,\n```\nDDOSHTTPFLOOD, etc. In particular, we note that all these command strings are referenced from the same function. \n\n```\nFurthermore, this function is structured as a very long sequence of if-else statements that compare each of these\ncommand strings against the same buffer. Even better, there is only a single caller of this function. Hmmm, that certainly\nsounds like the bot's primary command dispatch routine; we'll call it DispatchCommands_sub_493DAC().\n\nChecking out the caller function, we see that it operates in a loop. On each iteration through the loop, it basically performs\nthe following actions:\n\n1. Calls recv() to read network traffic into a buffer;\n2. Performs some copies and operations on this buffer to produce an intermediate buffer;\n3. Performs an operation (decryption perhaps?) on the intermediate buffer and a global string to produce a final buffer;\n3. Passes the final buffer to the aforementioned DispatchCommands_sub_493DAC() function;\n\nYes, this sounds like the main comms loop for which we are looking; we'll name this caller function\n```\nMainCommsLoop_sub_493A30(), and focus our attention on the aforementioned loop:\n\n```\nArbor Networks | 4\n\n\n-----\n\nArbor Networks | 5\n\n\n-----\n\n**Figure 3. Function MainCommsLoop_sub_493A30()**\n\nIt definitely looks like a great candidate for the decryption operation. It follows the general structure that is quite common\namong bot families that encrypt their comms; namely, a pre-processing operation applied to a buffer, followed by the\nactual decryption step. In particular, one strong clue is that the (assumed) decryption step takes a third argument which, in\nthis case, is a reference to a global string - very likely to be the decryption key string!\n\nSo first let's see what our (tentatively named) DecryptCommandBuffer_sub_44C628() function looks like.\nDarkComet being a Delphi-based bot, the decryption function is passed the source (encrypted) buffer in EAX, the\n(presumed) crypto key in EDX, and an output string buffer in ECX. After checking to make sure neither the source nor key\nstrings are empty, the function gets down to business. The first substantive operation is to pass the raw (encrypted) source\nbuffer src_buf_var_4 via EAX, along with an output buffer temp_buf_var_420 via EDX, to function\n```\nsub_44C1C0(); the output buffer is then copied back into the original source buffer src_buf_var_4:\n\n```\n**Figure 4. Function DecryptCommandBuffer_sub_44C628()**\n\nArbor Networks | 6\n\n\n-----\n\nSo sub_44C1C0() seems like it might be doing some pre-processing on the encrypted source buffer; let's see what kind\nof pre-processing it is doing. Skipping past the obligatory checks for empty source buffers, etc., we arrive at some code\nthat loops over the source buffer, referenced by src_buf_var_4; however, it makes only one loop iteration for every\ntwo bytes in src_buf_var_4. This is accomplished by extracting the DWORD just in front of the source string and\nshifting it one bit to the right, in order to calculate the number of pairs of source characters:\n\n**Figure 5. Function PreProcess_sub_44C1C0()**\n\nArbor Networks | 7\n\n\n-----\n\nThis works because in Delphi, the AnsiString class stores its length at an offset of 4 bytes in front of the first actual\nbyte of string content:\n\n**Figure 6. Structure of a Delphi AnsiString**\n\nFor example, in the case of the initial encrypted payload received by the bot from the C&C, 155CAD31A61F, the length\nof the source buffer is 12, so the code will make only 6 iterations through the loop. On each iteration of the loop,\nDarkComet will process a pair of two source bytes to yield one output byte.\n\nThe first operation inside the loop is to test whether or not the value of the first source byte in the pair is greater than 0x39,\nand branch accordingly. After using the one-based index EBX to pull out the first of the two source bytes in the pair, it adds\n```\n0xD0, subtracts 0x0A, and then tests whether the resulting value is greater than or equal to zero. Since it is operating on\n\n```\nthe 8-bit register AL, the result is that source bytes with values of 0x3A or greater will be processed by one branch, and\nthose with values of 0x39 and less will be processed by a second branch:\n\nArbor Networks | 8\n\n\n-----\n\n**Figure 7. Function PreProcess_sub_44C1C0()**\n\nIf the first source byte in the pair has value 0x39 or less, the bot will subtract 0x30 from it and save the result to the\ncurrent index within the output buffer:\n\nArbor Networks | 9\n\n\n-----\n\n**Figure 8. Function PreProcess_sub_44C1C0()**\n\nIn other words, it will convert the ASCII representations (0x30, 0x31, ..., 0x39) of the digits 0 through 9 into their\nequivalent integer representations (0x00, 0x01, ..., 0x09).\n\nThe second branch performs a similar operation: it first tests to make sure that the value of the source byte is not 0x47 or\ngreater (in which case it will immediately bail out of the loop and jump to the end of the PreProcess_sub_44C1C0()\nfunction.) It will then subtract 0x37 from the source byte and save the result into the current index within the output\nbuffer:\n\nArbor Networks | 10\n\n\n-----\n\n**Figure 9. Function PreProcess_sub_44C1C0()**\n\n\nArbor Networks | 11\n\n\n-----\n\nIn other words, it will convert the ASCII representations (0x41, 0x42, ..., 0x46) of the upper-case letters A through F\ninto their equivalent hexadecimal representations (0x0A, 0x0B, ..., 0x0F).\n\nThe two branches (for handling digits and upper-case A through F) will then re-join, and the resulting integer/hexadecimal\nrepresentation of the first source byte will be left-shifted by four (thus multiplying it by 16):\n\n**Figure 10. Function PreProcess_sub_44C1C0()**\n\nAt this point, it is pretty clear what is going on. The PreProcess_sub_44C1C0() function is converting the ASCII\nrepresentation of the source string of bytes into the equivalent hexadecimal representation. This conjecture is confirmed\nupon inspection of the remaining portion of the loop, which applies the same ASCII-to-hex operation on the second byte of\neach pair of source bytes, and adds the result to the left-shifted output from the first byte of the pair. So at the end of the\nday, the first line of raw encrypted source payload from the C&C is pre-processed from the 12-character ASCII string\n```\n155CAD31A61F to its equivalent sequence of six hexadecimal bytes 0x15 0x5C 0xAD 0x31 0xA6 0x1F, as follows:\n src index 0 1 2 3 4 5 6 7 8 9 10 11\n src (ASCII) 1 5 5 C A D 3 1 A 6 1 F\n src (raw) 0x31 0x35 0x35 0x43 0x41 0x44 0x33 0x31 0x41 0x36 0x31 0x46\n src (hex) 0x01 0x05 0x05 0x0C 0x0A 0x0D 0x03 0x01 0x0A 0x06 0x01 0x0F\n shifted 0x10 0x50 0xA0 0x30 0xA0 0x10\n dst 0x15 0x5C 0xAD 0x31 0xA6 0x1F\n\n```\nArbor Networks | 12\n\n|src index|0|1|2|3|4|5|6|7|8|9|10|11|\n|---|---|---|---|---|---|---|---|---|---|---|---|---|\n|src (ASCII)|1|5|5|C|A|D|3|1|A|6|1|F|\n|src (raw)|0x31|0x35|0x35|0x43|0x41|0x44|0x33|0x31|0x41|0x36|0x31|0x46|\n|src (hex)|0x01|0x05|0x05|0x0C|0x0A|0x0D|0x03|0x01|0x0A|0x06|0x01|0x0F|\n|shifted|0x10||0x50||0xA0||0x30||0xA0||0x10||\n|dst|0x15||0x5C||0xAD||0x31||0xA6||0x1F||\n\n\n-----\n\n**Figure 11. ASCII to Integer Conversion**\n\nSo we will rename this function as Integerize_sub_44C1C0(), and head back to the main\n```\nDecryptCommandBuffer_sub_44C628() function to continue reversing the crypto algorithm. After the raw source\n\n```\nbuffer has been converted from ASCII form to integer form, the next substantive code block initializes a 256-element\narray stable_var_41C:\n\nArbor Networks | 13\n\n\n-----\n\n**Figure 12. Function DecryptCommandBuffer_sub_44C628()**\n\nEach element in stable_var_41C is a 32-bit DWORD; the elements are initialized to the values 0x00000000 through\n```\n0x000000FF in ascending order:\n\n```\nIndex ESI `0` `1` `2` `3` `4` `... 253` `254` `255`\nValue subst_var_41C[ESI] `0x00 0x01 0x02 0x03 0x04 ... 0xFD 0xFE 0xFF`\n\n**Figure 13. Initial state of substitution table stable_var_41C**\n\nAt this point, we can guess that stable_var_41C is going to play the role of a substitution table for decrypting the\nsource buffer src_buf_var_4, so let's see how DarkComet builds this table.\n\nAfter initializing the substitution table to hold all the values between 0x00 and 0xFF in a nice ascending order, it\nproceeds to vigorously scramble up the elements of the table. It makes 256 iterations through a loop; on each iteration, it\nswaps the positions of two of the elements in the substitution table. On the kth iteration, one of the swapped elements is\nalways the kth element, which is pointed to by register ECX; the other is chosen based on the key string. The core of the\nloop that scrambles up the substitution table is as follows:\n\nArbor Networks | 14\n\n|Index ESI|0|1|2|3|4|...|253|254|255|\n|---|---|---|---|---|---|---|---|---|---|\n|Value subst_var_41C[ESI]|0x00|0x01|0x02|0x03|0x04|...|0xFD|0xFE|0xFF|\n\n\n-----\n\nArbor Networks | 15\n\n\n-----\n\n**Figure 14. Function DecryptCommandBuffer_sub_44C628()**\n\nThe first code block in the above IDA listing chooses which element of stable_var_41C should be swapped with the\n```\nk[th] element. It uses an accumulator variable, implemented by register EBX and initialized to zero. On each pass through\n\n```\nthe loop, it updates the acccumulator EBX by adding to it the value of the k[th] element of stable_var_41C and the value\nof the current key string byte. One byte of key string is used per iteration, and whenever the key string is \"used up\", it\nrestarts again at the beginning of the key; register EDI holds the length of the key string, so the bot just computes k\nmodulo EDI (at instruction 0x0044C767) to choose which byte of the key to use on the k[th] iteration.\n\nThe last code block performs the actual swapping, using swap_temp_var_15 as the temporary variable to do the swap.\nOnce 256 such swaps have been performed, the loop exits and the substitution table stable_var_41C has been nicely\nscrambled and is ready for use.\n\nAt this point, the actual process of decryption is performed. DarkComet iterates through its decryption loop once for each\nbyte in the encrypted source message (after conversion from ASCII to integer representation.) The decryption loop\nperforms the following two steps:\n\nFirst, it performs an additional scrambling operation on the substitution table stable_var_41C by swapping two\nelements. When processing the k[th] source byte, the first element of the swap pair is always the k+1[th] element of table\n```\nstable_var_41C; it uses another accumulator variable, implemented by register EDI, to choose the second element of\n\n```\nthe swap pair:\n\nArbor Networks | 16\n\n\n-----\n\nArbor Networks | 17\n\n\n-----\n\n**Figure 15. Function DecryptCommandBuffer_sub_44C628()**\n\nAfter performing this swap operation, DarkComet finally decrypts a byte of message. It sums up the values of the two\nswapped elements (at instruction 0x0044C85F), then uses the result (modulo 256) to re-index into the\n```\nstable_var_41C table to pull out a third element (at instruction 0x0044C874). This third element is XORed against\n\n```\nthe current (k[th]) source byte to produced a decrypted character.\n\nIt should be pointed out that conceptually, this decryption mechanism - both the manner in which the substitution table is\n[built, as well as how it is used for XOR-based decryption - is very similar to that used by the Trojan.PonyDOS malware](http://ddos.arbornetworks.com/2012/03/not-just-a-one-trick-ponydos/)\nfamily. The actual implementation has quite a few differences, but the basic encryption algorithm is the same.\nTrojan.PonyDOS, however, adds a few additional layers to secure its communications protocol above and beyond the core\ncrypto algorithm which it shares with DarkComet; specifically, the computation of some cryptographic hashes. Also,\nTrojan.PonyDOS does not go to the trouble of converting its encrypted data payloads into ASCII representations as\nDarkComet does.\n\nNow that we've reversed the core DarkComet decryption mechanism (needed to read C&C commands), we'll want to\nconfirm that the encryption mechanism (needed to read and/or fake bot phone home messages) is symmetric. And indeed,\nby following references to the socket handle used to recv() the initial C&C command, we can trace through to find the\nencryption routine called by DarkComet just prior to send()ing back its response messages. Sure enough, the encryption\nroutine, Encrypt_sub_44C34C(), is functionally identical to the decryption routine, as hoped and expected; the only\ndifference being that the Integerize_sub_44C1C0() routine prior to decryption is absent, and a new routine, which\nwe'll call Integer2String_sub_409C6C(), is called following the encryption step; this routine simply converts the\nraw encrypted data back into the ASCII version of its hexadecimal values.\n\nOf course, in order to have a fully functional implementation of DarkComet's crypto system, we'll need to know what key\nstrings it uses. We see that there are two locations where DecryptCommandBuffer_sub_44C628() is called, and\none of those locations, EncryptData_sub_49D9EC(), has a hard-coded string with an uncanny resemblance to a\ndecryption key:\n\nArbor Networks | 18\n\n\n-----\n\n**Figure 16. Function EncryptData_sub_49D9EC()**\n\nWe see that the decryption string key_var_10, passed to DecryptCommandBuffer_sub_44C628() via EDX, is\nformed by concatenating a hard-coded string #KCMDDC42F#- with some mystery string stored at [EBX+8]. It turns out\nthat this mysterious value stored at an offset from EBX is passed into EncryptData_sub_49D9EC() via the EAX\nregister. Tracing backwards up the stack, we follow the reference to EAX as the baton is passed from register to register. It\ndoes not take long to come across the following routine, which we will label ComputeKeySuffix_sub_48F52C():\n\nArbor Networks | 19\n\n\n-----\n\nArbor Networks | 20\n\n\n-----\n\n**Figure 17. Function ComputeKeySuffix_sub_48F52C()**\n\nYou don't run into code like this very often. It receives an output buffer passed via EAX. It then uses register EBX to do\nsome rather \"inefficient\" operations. First, it assigns EBX the value 0xFFFFFF8F, or -71. It then adds 1000 to EBX,\nyielding 887. Then it goes through four iterations of a loop that has no purpose other than to increment EBX by one on\neach iteration, resulting in a value of 891. Finally, it completes its laborious calculations by decrementing EBX by one,\nyielding a final answer of 890. This integer is passed to a standard integer-to-string API, which writes the string 890 into\nthe output buffer. In C, these shenanigans would look something like the following:\n```\n      int nAddend = 1000;\n      int nSuffix = -71;\n      int nResult = nSuffix + nAddend;\n      for (int k=0; k<4; k++)\n        nResult += 1;\n      sprintf(suffix, \"%d\", --nResult);\n\n```\nThis is a very roundabout way of assigning the hard-coded string 890 to a buffer. Clearly the DarkComet author is\n(wisely) trying to avoid having the entire decryption key string hard-coded in the bot executable.\n\nSo at this point, we know that the decryption key is composed of the prefix #KCMDDC42F#- concatenated with the suffix\n```\n890, yielding #KCMDDC42F#-890.\n\n```\nOne final note regarding the encryption key strings used by DarkComet: as first documented in\n[Contextis' Laura Aylward's DarkComet analysis, each version of DarkComet uses a different hard-coded string for the key](http://www.contextis.com/research/blog/darkcometrat/)\nprefix. For example, we have observed the following:\n\n**Dark Comet version** **Crypto Key Prefix (Default)**\nVersion 4.0 `#KCMDDC4#-890`\nVersion 4.2 `#KCMDDC42F#-890`\n\nArbor Networks | 21\n\n|Dark Comet version|Crypto Key Prefix (Default)|\n|---|---|\n|Version 4.0|#KCMDDC4#-890|\n|Version 4.2|#KCMDDC42F#-890|\n\n\n-----\n\nVersion 5.0 `#KCMDDC5#-890`\n\n**Figure 18. Standard crypto key prefixes for DarkComet versions**\n\nFurthermore, and also documented by Contextis, DarkComet supports the use of an optional password that is appended to\nthe default (version-specific) crypto key. For example, the default password (if enabled) string is 0123456789. This 10digit string will be appended to the standard crypto key #KCMDDC42F#-890 (in the case of DarkComet version 4.2) to\nyield a final key of #KCMDDC42F#-8900123456789. The code that performs this concatenation is found in a routine\nwe'll call FormCryptoKey_sub_49D2F4():\n\n**Figure 19. Function FormCryptoKey_sub_49D2F4()**\n\nArbor Networks | 22\n\n|Version 5.0|#KCMDDC5#-890|\n|---|---|\n\n\n-----\n\nThis code concatenates the three components of the final crypto key: the hard-coded prefix (e.g., #KCMDDC42F#-), the\nthree-digit string 890 that is not technically hard-coded but deterministically computed using the aforementioned\n```\nComputeKeySuffix_sub_48F52C() routine, and the optional botnet password stored in the global variable\nPWD_off_4A4B84.\n\n```\nThe password itself is actually stored as an encrypted resource. Upon initialization, it is decrypted using a preliminary\ncrypto key comprised only of the first two components (e.g., #KCMDDC42F#-890) using a routine we've labeled\n```\nDecryptResource_sub_49D9EC(). To make a long story short, this routine uses the Windows APIs\nFindResource(), LoadResource(), etc. to extract a named resource of type RT_RCDATA (code 0x0A), intended\n\n```\nfor \"application-defined resources (raw data)\". The raw data is then decrypted using the preliminary crypto key.\n\nIn the case of the crypto password, the name of the resource is PWD. The resource is extracted, decrypted, and stored for\nfuture use in the global variable PWD_off_4A4B84 by a function we call DecryptResources_sub_49F92C():\n\nArbor Networks | 23\n\n\n-----\n\n**Figure 20. Function DecryptResources_sub_49F92C()**\n\nIn the case of the default password 0123456789, the encrypted resource will hold the value\n```\n6811E636E69E9AEFA5C6. This DecryptResources_sub_49F92C() function actually decrypts a lot of\n\n```\nencrypted bot parameters stored in various resources; some of the more interesting ones are as follows:\n\n**Resource Name** **Encrypted Data** **Decrypted Value**\n```\nFAKEMSG 69 1\nGENCODE 6146B749A3CF9C9FE8CFAB2C 9fcLqd0Gu00j\nMSGCORE 1100A768B3C7C0F8FCDFC907B6F9 I small a RAT!\nMSGTITLE 1C41A66E91C4C1BDE9 DarkComet\n\n```\nArbor Networks | 24\n\n|Resource Name|Encrypted Data|Decrypted Value|\n|---|---|---|\n|FAKEMSG|69|1|\n|GENCODE|6146B749A3CF9C9FE8CFAB2C|9fcLqd0Gu00j|\n|MSGCORE|1100A768B3C7C0F8FCDFC907B6F9|I small a RAT!|\n|MSGTITLE|1C41A66E91C4C1BDE9|DarkComet|\n\n\n-----\n\n```\nMUTEX 1C638B4887FFE980B0B9AE72B1EA40A3 DC_MUTEX-F54S21D\nNETDATA 6919E62BE39D94F6ACCFAB68D5ED4BD67BA333 192.168.100.75:1604\nPWD 6811E636E69E9AEFA5C6 0123456789\nSID 1F55B176A69A9A Guest16\n\n```\n**Figure 21. Interesting encrypted resources**\n\n[Of particular interest is the encrypted NETDATA resource, which holds the C&C hostname and port. The Resource Hacker](http://www.angusj.com/resourcehacker/)\ntool is a great utility for viewing and extracting the various DarkComet encrypted parameters:\n\nArbor Networks | 25\n\n|MUTEX|1C638B4887FFE980B0B9AE72B1EA40A3|DC_MUTEX-F54S21D|\n|---|---|---|\n|NETDATA|6919E62BE39D94F6ACCFAB68D5ED4BD67BA333|192.168.100.75:1604|\n|PWD|6811E636E69E9AEFA5C6|0123456789|\n|SID|1F55B176A69A9A|Guest16|\n\n\n-----\n\n**Figure 22. Resource Hacker extracting DarkComet resources**\n\nSo to summarize, DarkComet uses a hard-coded (although different for each version) preliminary key string, such as\n```\n#KCMDDC42F#-890, to decrypt its sensitive parameters from various raw resources - such as the C&C information and\n\n```\ncommunications password stored in the NETDATA and PWD resources, respectively. It then appends the decrypted comms\npassword (stored in the PWD resource) to the end of the preliminary crypto key string to form the final key,\n```\n#KCMDDC42F#-8900123456789, that it uses for securing the network traffic to and from its C&C server.\n\n```\nPutting everything together into a complete DarkComet crypto module yields the following Python script:\n```\n# DarkComet decryptor/encryptor\n# Copyright (c) 2012 Arbor Networks\nimport sys\nclass DarkCometCryptor(object):\n  def __init__(self, key):\n    self._len_key = len(key)\n    self._key = [ord(token) for token in key]\n  def decrypt(self, src):\n    # Convert ASCII to hex representation\n    buf = [int(\"0x%s\" % src[k*2:k*2+2], 16) for k in range(len(src)//2)]\n    self._cryption(buf)\n    return \"\".join([chr(token) for token in buf])\n  def encrypt(self, src):\n    buf = [ord(token) for token in src]\n\n```\nArbor Networks | 26\n\n\n-----\n\n```\n    self._cryption(buf)\n    # Convert to hex codes (upper case)\n    return \"\".join([\"%02x\" % tok for tok in buf]).upper()\n  def _cryption(self, src):\n    # Build subst table\n    stable = list(range(256))\n    accum = 0\n    for k in range(256):\n      accum += stable[k]\n      accum += self._key[k % self._len_key]\n      accum &= 0xff\n      stable[k], stable[accum] = stable[accum], stable[k]\n    # Apply subst table\n    accum = 0\n    for k in range(len(src)):\n      elem_a_idx = self._LS_BYTE(k + 1)\n      accum += stable[elem_a_idx]\n      elem_b_idx = self._LS_BYTE(accum)\n      stable[elem_b_idx], stable[elem_a_idx] = \\\n            stable[elem_a_idx], stable[elem_b_idx]\n      swap_sum = self._LS_BYTE(stable[elem_b_idx] + stable[elem_a_idx])\n      src[k] ^= self._LS_BYTE(stable[swap_sum])\n  @staticmethod\n  def _LS_BYTE(value):\n    return 0xff & value\nif __name__ == '__main__':\n  if len(sys.argv) != 4 or sys.argv[1] not in ('-d', '-e'):\n    print \"usage: %s [-d|-e] SRC_TEXT KEY\" % sys.argv[0]\n\n```\nArbor Networks | 27\n\n\n-----\n\n```\n    sys.exit(1)\n  do_decrypt = bool(sys.argv[1] == '-d')\n  src = sys.argv[2]\n  key = sys.argv[3]\n  print \"%s: %s\" % (\"CRYPT\" if do_decrypt else \"PLAIN\", src)\n  cryptor = DarkCometCryptor(key)\n  dst = cryptor.decrypt(src) if do_decrypt else cryptor.encrypt(src)\n  print \"%s: %s\" % (\"PLAIN\" if do_decrypt else \"CRYPT\", dst)\n\n```\n**Figure 23. darkcomet.py Crypto Module**\n\nApplying our DarkComet encryption module against the observed traffic results in the following:\n```\n      C&C:\n      IDTYPE\n      Bot:\n      SERVER\n      C&C:\n      GetSIN192.10.8.64|27038511\n      Bot:\n      infoesComet|192.10.8.64 / [192.1.167.30] : 1604|SANDBOX7 /\n      Admin|27038511|29s|Windows XP Service Pack 2 [2600] 32 bit ( C:\\\n      )|x||US|C:\\WINDOWS\\system32\\cmd.exe|{16382783-b70c-71e4-11e0      28f8efc0696f-10806d6172}|127.43 MiB/256.09 MiB [128.22 MiB Free]|English\n      (United States) US / -- |10/9/2011 at 8:13:31 PM\n\n```\n**Figure 24. Decrypted version of comms from Figure 2.**\n\nLikewise, when a DarkComet C&C issues attacks command, the encrypted traffic on the wire looks like these examples:\n```\n185CB63BBE0EA3DF6D2A725936265160E391BC77F47FF46A3934CFB173AC\n\n```\nArbor Networks | 28\n\n\n-----\n\n```\n185CB63BA31EA7C967297252432E5A7CFC96B261EB7EF4742533CEBF37A9C081\n185CB63BA503B9C967297252432E5A7CFC96B261EB7EF4742533CEBF37A9C081\n\n```\nBut applying the decryption routine yields the following:\n```\nDDOSHTTPFLOOD192.168.100.254|5\nDDOSUDPFLOOD192.168.100.254:80|5\nDDOSSYNFLOOD192.168.100.254:80|5\n\n```\nWhich corresponds to ordering an HTTP flood, a UDP flood, and a TCP flood, respectively, against target\n```\n192.168.100.254, with each attack lasting for 5 seconds. Once the attacks are completed the DarkComet bot will\n\n```\nrespond with an encrypted status message such as the following:\n```\n1E4CAB2DA50FBBDB781F5336347B073DA9DCD936B46EB03B646DDAE366F7D5C76D3C0420A55906F524\n240A0F34D3A6384150\n\n```\nWhich decrypts to the following:\n```\nBTRESULTSyn Flood|Syn task finished!|Administrator\n\n```\nAs implied above, DarkComet supports three types of DDoS attacks: HTTP flooding, UDP flooding, and TCP flooding\n(mis-advertised as \"SYNFLOOD\"). The UDP and TCP volumetric floods are quite unremarkable and simply consist of\nrandom gibberish blasted at a target host and port. The HTTP flood also appears to be intended as a rudimentary GET\nflood with a minimalist HTTP request header. However, DarkComet's HTTP flood implementation happens to have not\none, but two catastrophic bugs.\n\nFirst of all, the thread procedure that implements the DDOSHTTPFLOOD attack command, SendHttp_sub_485848(),\nuses the WinSock2 library's socket(), connect(), and send() APIs to send the following hard-coded HTTP\nflooding request:\n```\nGET / HTTP/1.1\\r\\n\\r\\n\n\n```\nArbor Networks | 29\n\n\n-----\n\nAt first glance, this looks like an (almost) valid, although minimalist, HTTP request that is terminated with a double\ncarriage-return/line-feed (CRLF) combination. However, when one takes a closer look at the way DarkComet stores this\nstring, we see that the \\r and \\n characters are not actually CR (0x0D) and LF (0x0A) bytes. Instead, they are literally\ncomprised of the backslash (0x2F), letter r (0x72), and letter n (0x6E) bytes!\n\nArbor Networks | 30\n\n\n-----\n\n**Figure 25. Hard-coded HTTP request string HttpRequest_byte_485970**\n\nIf the HTTP request string had been encoded properly (ending with 0x0D0A0D0A), the length of the string would have\nbeen 18. But instead, we see that it is 22 bytes in length. Due to this, DarkComet's attempt at an application layer attack is\nnot close to a valid HTTP request per the RFCs.\n\nThe second big mistake in the implementation of DarkComet's HTTP flood attack becomes apparent further down in the\nattack thread code, just before the (buggy) HTTP request payload is sent to the target via the send() API:\n\nArbor Networks | 31\n\n\n-----\n\nArbor Networks | 32\n\n\n-----\n\n**Figure 26. Function EncryptAndSendData_sub_49393C()**\n\nUnbelievably, DarkComet bot is accidentally encrypting the (buggy) GET request string at instruction 0x00493972 via a\ncall to the already-reversed Encrypt_sub_44C34C() routine. The resulting (encrypted) HTTP request is then sent on\nits merry way to the DDoS target via the send() API call at instruction 0x0049399D.\n\nSo the target web server ends up receiving gibberish instead of a well-formed HTTP request that might exhaust resources\nat the application layer. Due to these two serious flaws, DarkComet's HTTP flood attack reduces down to nothing more\nthan a volumetric TCP flood against port 80, and a very weak one at that (a mere 22 bytes of TCP payload per flooding\npacket...) In fact, here is what the actual \"HTTP flooding\" traffic looks like:\n```\n      1B5DAD48D97ABFDB7F3612275C26342091CED63D8620\n      1B5DAD48D97ABFDB7F3612275C26342091CED63D8620\n      1B5DAD48D97ABFDB7F3612275C26342091CED63D8620\n\n```\nClearly, this is very unlikely to bring any web server to its knees!\n\n**_Acknowledgements to Arbor Networks analyst Curt Wilson for his valuable insights and assistance with this article._**\n\nArbor Networks | 33\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/akmz317h8dkapm52ksycf187rw2ylp21",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2012/2012.03.13.DarkComet_RAT/Crypto-DarkComet-Report.pdf"
    ],
    "report_names": [
        "Crypto-DarkComet-Report"
    ],
    "threat_actors": [
        {
            "id": "81bd7107-6b2d-45c9-9eea-1843d4b9b308",
            "created_at": "2022-10-25T15:50:23.320841Z",
            "updated_at": "2025-03-27T02:00:55.441723Z",
            "deleted_at": null,
            "main_name": "Gamaredon Group",
            "aliases": [
                "Gamaredon Group",
                "IRON TILDEN",
                "Primitive Bear",
                "ACTINIUM",
                "Armageddon",
                "Shuckworm",
                "DEV-0157",
                "Aqua Blizzard"
            ],
            "source_name": "MITRE:Gamaredon Group",
            "tools": [
                "QuietSieve",
                "Pteranodon",
                "PowerPunch"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "61940e18-8f90-4ecc-bc06-416c54bc60f9",
            "created_at": "2022-10-25T16:07:23.659529Z",
            "updated_at": "2025-03-27T02:02:09.912404Z",
            "deleted_at": null,
            "main_name": "Gamaredon Group",
            "aliases": [
                "Actinium",
                "Aqua Blizzard",
                "Armageddon",
                "Blue Otso",
                "BlueAlpha",
                "Callisto",
                "DEV-0157",
                "Iron Tilden",
                "Operation STEADY#URSA",
                "Primitive Bear",
                "SectorC08",
                "Shuckworm",
                "Trident Ursa",
                "UAC-0010",
                "Winterflounder"
            ],
            "source_name": "ETDA:Gamaredon Group",
            "tools": [
                "Aversome infector",
                "BoneSpy",
                "DessertDown",
                "DilongTrash",
                "DinoTrain",
                "EvilGnome",
                "FRAUDROP",
                "Gamaredon",
                "GammaDrop",
                "GammaLoad",
                "GammaSteel",
                "Gussdoor",
                "ObfuBerry",
                "ObfuMerry",
                "PlainGnome",
                "PowerPunch",
                "Pteranodon",
                "Pterodo",
                "QuietSieve",
                "Remote Manipulator System",
                "Resetter",
                "RuRAT",
                "SUBTLE-PAWS",
                "UltraVNC"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "236a8303-bf12-4787-b6d0-549b44271a19",
            "created_at": "2024-06-04T02:03:07.966137Z",
            "updated_at": "2025-03-27T02:05:17.410356Z",
            "deleted_at": null,
            "main_name": "IRON TILDEN",
            "aliases": [
                "Aqua Blizzard ",
                "Armageddon",
                "Blue Otso ",
                "BlueAlpha ",
                "Dancing Salome ",
                "Gamaredon",
                "Gamaredon Group",
                "Hive0051 ",
                "Primitive Bear ",
                "Shuckworm ",
                "Trident Ursa ",
                "UAC-0010 ",
                "UNC530 ",
                "WinterFlounder ",
                "ACTINIUM "
            ],
            "source_name": "Secureworks:IRON TILDEN",
            "tools": [
                "Pterodo"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716496,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1331824971,
    "ts_modification_date": 1331825005,
    "files": {
        "pdf": "https://archive.orkl.eu/50511389957f7c2e0127031d8633724ae05354f3.pdf",
        "text": "https://archive.orkl.eu/50511389957f7c2e0127031d8633724ae05354f3.txt",
        "img": "https://archive.orkl.eu/50511389957f7c2e0127031d8633724ae05354f3.jpg"
    }
}