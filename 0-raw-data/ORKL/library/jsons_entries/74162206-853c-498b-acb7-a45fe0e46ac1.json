{
    "id": "74162206-853c-498b-acb7-a45fe0e46ac1",
    "created_at": "2022-10-25T16:48:15.381383Z",
    "updated_at": "2025-03-27T02:08:41.393896Z",
    "deleted_at": null,
    "sha1_hash": "0945b07cb92795ead79f57242f2c9245fbf429dd",
    "title": "Microsoft Word - Hiding Behind ART.docx",
    "authors": "",
    "file_creation_date": "2015-03-27T03:15:40Z",
    "file_modification_date": "2015-03-27T03:15:40Z",
    "file_size": 601293,
    "plain_text": "# Hiding Behind ART\n\n### Abstract \r \n\n\n**Paul \r Sabanal**\nIBM \r X-­‐Force \r Advanced \r Research\npaul[dot]sabanal[at]ph[dot]ibm[dot]com\n\npv[dot]sabanal[at]gmail[dot]com\n\n@polsab\n\n\nThe \r introduction \r of \r the \r new \r Android \r Runtime \r (ART) \r brings \r several \r improvements \r in \r Android. \r But \r as \r with\nany \r new \r technology \r it \r also \r brings \r new \r ways \r to \r conduct \r or \r enhance \r malicious \r activities. \r In \r this\npresentation \r we \r will \r talk \r about \r one \r of \r those \r ways.\n\nOnce \r an \r attacker \r or \r malware \r has \r gained \r access \r to \r the \r Android \r device, \r the \r next \r step \r is \r to \r find \r ways \r to \r hide\nitself \r and \r gain \r persistence, \r and \r this \r is \r usually \r achieved \r by \r installing \r a \r rootkit. \r The \r majority \r of \r these\nrootkits \r are \r kernel \r mode \r rootkits \r and \r the \r common \r way \r of \r achieving \r persistence \r is \r by \r modifying \r files \r in\nthe \r system \r partition. \r However, \r recent \r advancements \r in \r Android \r security \r such \r as \r verified \r boot \r has \r made\nthis \r increasingly \r difficult. \r This \r presentation \r will \r demonstrate \r how \r to \r go \r around \r this \r difficulty \r by \r taking \r the\ngame \r out \r of \r kernel \r mode \r and \r out \r of \r the \r system \r partition. \r We \r will \r show \r you \r how \r to \r take \r advantage \r of \r the\nmechanisms \r of \r ART \r to \r create \r a \r user \r mode \r rootkit.\n\nWe \r will \r start \r with \r a \r discussion \r of \r past \r Android \r rootkit \r research \r and \r how \r these \r techniques \r have \r become\nincreasingly \r difficult \r to \r use \r in \r modern \r Android \r systems. \r Then \r we \r will \r go \r deep \r into \r ART \r internals \r where \r we\nwill \r discuss \r the \r file \r formats \r and \r mechanisms \r relevant \r to \r rootkit \r creation. \r After \r we \r have \r understood \r the\nmechanisms \r involved, \r we \r will \r then \r discuss \r methods \r of \r crafting \r the \r rootkit \r i.e. \r what \r to \r change, \r where \r to\nfind \r them, \r how \r to \r change \r them, \r and \r techniques \r on \r gaining \r persistence \r on \r the \r system. \r We \r will \r also \r talk\nabout \r the \r limitations \r of \r this \r approach \r and \r possible \r future \r work \r in \r this \r area.\n\nThe \r talk \r will \r conclude \r with \r a \r live \r demonstration \r of \r an \r ART \r rootkit.\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n### Introduction \r \n\nOne \r of \r the \r latest \r security \r enhancements \r added \r to \r Android \r is \r a \r feature \r called \r dm-­‐verity[1]. \r First \r introduced\nin \r Kitkat, \r this \r feature \r allows \r the \r kernel \r to \r verify \r the \r integrity \r of \r a \r partition \r upon \r boot, \r thus \r ensuring \r that\nthis \r partition \r has \r not \r been \r tampered \r with. \r It \r protects \r the \r device \r from \r rootkits \r that \r add \r or \r modify \r binaries\nin \r the \r system \r partition \r to \r maintain \r access. \r For \r an \r excellent \r explanation \r of \r this \r feature, \r please \r refer \r to \r the\narticle \r by \r Nikolay \r Elenkov[2].\n\nOne \r of \r the \r main \r motivations \r for \r this \r paper \r is \r to \r determine \r if \r an \r attacker \r who \r wants \r to \r install \r a \r rootkit \r can\ndo \r so \r without \r having \r to \r deal \r with \r the \r complications \r brought \r upon \r by \r dm-­‐verity. \r While \r at \r the \r time \r of\nwriting \r dm-­‐verity \r is \r not \r yet \r a \r default \r feature, \r it’s \r always \r good \r to \r know \r early \r on \r what \r an \r attacker \r can\npossibly \r do \r despite \r of \r the \r protections \r in \r place. \r We \r needed \r to \r see \r whether \r it \r is \r possible \r to \r conduct \r rootkit\noperations \r without \r touching \r the \r system \r partition, \r thus \r avoiding \r the \r protection \r offered \r by \r dm-­‐verity.\n\nThe \r approach \r we \r took \r in \r this \r research \r is \r to \r take \r advantage \r of \r the \r mechanisms \r of \r the \r new \r Android\nruntime \r (ART) \r to \r modify \r framework \r or \r application \r code \r with \r code \r of \r our \r own, \r without \r touching \r the\nsystem \r partition.\n\nThe \r techniques \r described \r in \r this \r paper \r assume \r that \r the \r attacker \r already \r has \r root \r shell \r access \r (“soft \r root”)\non \r the \r target \r device, \r and \r were \r conducted \r on \r a \r Nexus \r 7 \r 2012 \r Wifi \r (“grouper”) \r tablet \r with \r a \r stock \r Android\n5.1, \r unless \r otherwise \r stated.\n\n1 \r https://source.android.com/devices/tech/security/secureboot/index.html\n2 \r http://nelenkov.blogspot.com/2014/05/using-­‐kitkat-­‐verified-­‐boot.html\n2 \r http://nelenkov.blogspot.com/2014/05/using-­‐kitkat-­‐verified-­‐boot.html\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n### ART \r Overview \r \n\nBefore \r we \r discuss \r about \r rootkits \r let’s \r first \r look \r at \r a \r high-­‐level \r overview \r of \r the \r ART’s \r architecture \r and\nmechanisms. \r Keep \r in \r mind \r that \r we \r won’t \r go \r into \r the \r deeper \r details \r of \r ART’s \r compilation \r and \r code\ngeneration, \r but \r focus \r more \r on \r the \r aspects \r of \r ART \r relevant \r to \r later \r discussions. \r It \r would \r help \r if \r the \r reader\nalready \r has \r some \r familiarity \r with \r the \r Android \r operating \r system. \r Prior \r knowledge \r of \r Dalvik, \r the \r DEX \r file\nformat, \r and \r other \r concepts \r is \r helpful \r in \r understanding \r this \r section. \r We \r highly \r recommend \r the \r following\nexcellent \r references \r if \r not \r yet \r familiar \r with \r these \r concepts.\n\n1. The \r Android \r Hacker’s \r Handbook \r by \r Joshua \r Drake, \r et \r al.\n2. Android \r Internals \r by \r Jonathan \r Levin \r [3].\n3. Android \r Security \r Internals \r by \r Nikolay \r Elenkov[4].\n4. Embedded \r Android \r by \r Karim \r Yaghmour.\n5. Official \r Android \r documentation[5].\n\nAn \r experimental \r version \r of \r ART \r was \r first \r introduced \r in \r Kitkat \r back \r in \r October \r 2013, \r where \r you \r can \r choose\nwhether \r to \r use \r it \r or \r the \r Dalvik \r runtime. \r Starting \r from \r Lollipop, \r ART \r becamse \r the \r default \r runtime. \r The\nmain \r advantage \r of \r ART \r over \r Dalvik \r is \r better \r app \r performance \r due \r to \r ahead-­‐of-­‐time \r compilation.\n\n#### Ahead-­‐of-­‐time \r Compilation \r \n\nWhile \r Dalvik \r relied \r on \r interpretation \r and \r JIT \r compilation, \r ART \r pre-­‐compiles \r apps \r Dalvik \r bytecode \r into\nnative \r code.\n\nAll \r apps \r will \r be \r compiled \r every \r time \r the \r device’s \r system \r is \r upgraded, \r or \r the \r first \r time \r you \r boot \r it \r up \r after\npurchase. \r Individual \r apps \r are \r compiled \r upon \r installation.\n\nThe \r command \r responsible \r for \r compiling \r an \r application \r Into \r OAT \r is \r dex2oat, \r which \r can \r be \r found \r in\n/system/bin/dex2oat \r supports \r two \r types \r of \r compiler \r backends: \r quick \r and \r portable. \r The \r backend \r can \r be\nspecified \r through \r the \r –compiler-­‐backend \r parameter \r passed \r to \r dex2oat.\n\nThe \r default \r backend \r is \r Quick. \r It \r translates \r Dalvik \r bytecode \r (the \r medium \r level \r intermediate \r representation\nor \r MIR) \r into \r a \r low-­‐level \r IR \r (LIR) \r then \r into \r native \r code, \r doing \r some \r optimizations \r along \r the \r way.\n\nMIR LIR Native code\n\n**Figure \r 1 \r Quick \r compilation**\n\n3 \r http://newandroidbook.com/index.php\n4 \r http://nelenkov.blogspot.com/2014/10/android-­‐security-­‐internals-­‐is-­‐out.html\n5 \r https://source.android.com/devices/tech/index.html\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\nLIR\n\n\nMIR\n\n\n-----\n\nThe \r Portable \r backend, \r on \r the \r hand, \r uses \r LLVM \r as \r its \r LIR. \r Optimizations \r are \r done \r using \r the \r LLVM\noptimizer \r and \r code \r generation \r is \r done \r by \r LLVM \r backends.\n\nLLVM LLVM\nMIR LLVM Bitcode Native code\nOptimizer Backend\n\n**Figure \r 2 \r Portable \r compilation**\n\nThe \r resulting \r OAT \r file \r will \r be \r generated \r inside \r the \r /data/dalvik-­‐cache/<arch> \r folder, \r where \r arch \r is \r the\ntarget \r architecture \r of \r the \r compilation \r (i.e. \r architecture \r of \r the \r device).\n\nFor \r more \r details \r about \r ART, \r check \r out \r this \r talk \r from \r Google[6].\n\n#### ART \r Image \r File \r Format \r \n\nThe \r image \r file \r (boot.art) \r contains \r pre-­‐initialized \r classes \r and \r objects \r from \r the \r framework \r JARS. \r This \r image\nfile \r is \r placed \r right \r before \r the \r boot.oat \r in \r memory. \r Code \r in \r the \r compiled \r OATs \r directly \r links \r to \r this \r image\nto \r call \r methods \r in \r the \r framework \r or \r to \r access \r the \r pre-­‐initialized \r objects.\n\n**Image \r Header**\n\n**Field** **Type** **Description**\n**magic** ubyte[4] Magic value. “art\\n”\n**version** ubyte[4] Image version\n**image_begin** uint32 Base address of the image\n**image_size** uint32 The size of the image\n**image_bitmap_offset** uint32 Offset to a bitmap\n**image_bitmap_size** uint32 Size of the image bitmap\n**oat_checksum** uint32 Checksum \r of \r the \r linked \r boot.oat\nfile\n**oat_file_begin** uint32 Address \r of \r the \r linked \r boot.oat\nfile\n**oat_data_begin** uint32 Address \r of \r the \r linked \r boot.oat\nfile’s oatdata\n**oat_data_end** uint32 End \r address \r of \r the \r linked\nboot.oat file’s oatdata\n**oat_file_end** uint32 End \r address \r of \r the \r linked\nboot.oat file\n**patch_delta** int32 Image relocated address delta\n**image_roots** uint32 Address of an array of objects\n**compile_pic** uint32 Indicates \r if \r image \r was \r compiled\nwith \r position-­‐independent-­‐code\nenabled\n\nThe \r image \r header \r starts \r with \r the \r magic \r “art\\n” \r followed \r by \r the \r version, \r which \r is \r “012 \r “ \r at \r the \r time \r of\nwriting. \r It \r is \r then \r followed \r by \r fields \r that \r describe \r the \r linked \r OAT \r file \r (boot.oat). \r patch_delta \r is \r the \r amount\n\n6 \r https://www.youtube.com/watch?v=EBlTzQsUoOw\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\nLLVM Bitcode\n\n\nNative code\n\n\nLLVM\nBackend\n\n\n-----\n\nthe \r base \r address \r of \r the \r image \r is \r relocated \r (as \r mentioned \r in \r the \r OAT \r header \r section). \r image_roots \r is \r an\naddress \r of \r an \r array \r of \r objects \r needed \r to \r re-­‐initialized.\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n#### OAT \r File \r Format \r \n\nIn \r this \r section \r we \r will \r describe \r the \r OAT \r file \r format. \r The \r discussion \r here \r involves \r the \r ELF \r and \r DEX \r file\nformats \r as \r well, \r and \r assumes \r the \r reader \r is \r familiar \r with \r both. \r If \r not, \r you \r can \r refer \r to \r this[7] \r document \r for\nELF, \r and \r this \r document \r from \r Google[8] \r for \r DEX. \r All \r the \r information \r from \r this \r section \r can \r be \r found \r in \r the\nAOSP \r source \r code, \r under \r the \r art \r folder. \r Here \r are \r the \r files \r of \r interests:\n\n  - dex2oat/dex2oat.cc\n\n  - runtime/oat.h\n\n  - runtime/oat.cc\n\n  - runtime/oat_file.h\n\n  - runtime/oat_file.cc\n\n  - runtime/image.h\n\n  - runtime/image.cc\n\nAn \r OAT \r file \r is \r an \r ELF \r shared \r object \r file \r with \r sections \r containing \r OAT \r data. \r The \r OAT \r data \r contains \r headers\ndescribing \r the \r structure \r of \r the \r OAT \r file, \r as \r well \r as \r DEX \r code \r and \r the \r compile \r native \r code. \r The \r ELF \r file \r has\nthree \r dynamic \r symbol \r tables \r named \r oatdata, \r oatexec, \r and \r oatlastword. \r These \r entries \r tell \r us \r which\nsections \r contain \r the \r corresponding \r OAT \r data. \r Here \r is \r an \r example \r of \r the \r a \r dynamic \r symbol \r in \r .oat \r ELF \r file:\n\n7 \r http://www.skyfree.org/linux/references/ELF_Format.pdf\n8 \r https://source.android.com/devices/tech/dalvik/dex-­‐format.html\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\nThese \r sections \r contains \r the \r following:\n\n  - _oatdata \r -­‐ \r Contains \r the \r OAT \r headers \r and \r the \r embedded \r original \r DEX \r file._\n\n  - _oatexec \r -­‐ \r Contains \r the \r generated \r native \r code \r for \r the \r compiled \r methods._\n\n  - _oatlastword \r -­‐ \r Used \r as \r an \r end \r marker \r and \r contains \r the \r last \r 4 \r bytes \r of \r the \r generated \r native \r code._\n\nThe \r sym_value \r field \r of \r the \r symbol \r table \r entry \r tells \r us \r where \r to \r find \r each \r section. \r Alternatively, \r you \r can\nlocate \r the \r oatdata \r in \r the \r .rodata \r section, \r and \r oatexec \r combined \r with \r oatlastword \r in \r the \r .text \r section.\nThese \r sections \r are \r placed \r right \r after \r the \r other \r and \r are \r treated \r as \r one \r single \r blob, \r which \r for \r simplicity’s\nsake \r we \r are \r going \r to \r refer \r to \r in \r the \r rest \r of \r this \r paper \r as \r oatdata. \r All \r the \r offset \r fields \r (e.g.\n_executable_offset, \r code_offset, \r etc) \r in \r the \r headers \r described \r below \r are \r relative \r to \r the \r start \r of \r this \r blob._\n\n**OAT \r Header**\n\n**Field** **Type** **Description**\n**magic** ubyte[4] Magic value. “oat\\n”\n**version** ubyte[4] OAT version.\n**adler32_checksum** uint32 Adler-­‐32 checksum of the OAT header\n**instruction_set** uint32 Instruction set architecture\n**instruction_set_features** uint32 Bitmask \r of \r supported \r features \r per\narchitecture\n**dex_file_count** uint32 Number of DEX files in the OAT\n**executable_offset** uint32 Offset \r of \r executable \r code \r section \r from\nstart of oatdata\n**interpreter_to_interpreter_bridge_offset** uint32 offset \r from \r oatdata \r start \r to\ninterpreter_to_interpreter_bridge stub\n**interpreter_to_compiled_code_bridge_offset** uint32 offset \r from \r oatdata \r start \r to\ninterpreter_to_compiled_code_bridge\nstub\n**jni_dlsym_lookup_offset_** uint32 offset \r from \r oatdata \r start \r to\njni_dlsym_lookup stub\n**portable_imt_conflict_trampoline_offset** uint32 offset \r from \r oatdata \r start \r to\nportable_imt_conflict_trampoline stub\n**portable_resolution_trampoline_offset** uint32 offset \r from \r oatdata \r start \r to\nportable_resolution_trampoline stub\n**portable_to_interpreter_bridge_offset** uint32 offset \r from \r oatdata \r start \r to\nportable_to_interpreter_bridge stub\n**quick_generic_jni_trampoline_offset** uint32 offset \r from \r oatdata \r start \r to\nquick_generic_jni_trampoline stub\n**quick_imt_conflict_trampoline_offset** uint32 offset \r from \r oatdata \r start \r to\nquick_imt_conflict_trampoline stub\n**quick_resolution_trampoline_offset** uint32 offset \r from \r oatdata \r start \r to\nquick_resolution_trampoline stub\n**quick_to_interpreter_bridge_offset** uint32 offset \r from \r oatdata \r start \r to\nquick_to_interpreter_bridge stub\n**image_patch_delta** int32 The image relocated address delta\n**image_file_location_oat_checksum** uint32 Adler-­‐32 checksum of boot.oat’s header\n**image_file_location_oat_data_begin** uint32 The \r virtual \r address \r of \r boot.oat’s\noatdata section\n**key_value_store_size** uint32 The length of key_value_store\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n**key_value_store** ubyte[key_v A \r dictionary \r containing \r information\nalue_store_s such \r as \r the \r command \r line \r used \r to\nize] generate this oat file, the host arch, etc.\n\nThe \r OAT \r header \r describes \r the \r overall \r structure \r of \r the \r OAT \r data. \r  \r It \r starts \r with \r the \r magic \r field \r “oat\\n”\nfollowed \r by \r the \r current \r version \r of \r the \r OAT \r file \r format, \r which \r is \r at \r the \r time \r of \r writing, \r is \r “045\\0“.\n_adler32_checksum \r is \r the \r checksum \r of \r the \r fields \r in \r the \r OAT \r header. \r The \r instruction_set \r field \r indicates \r the_\ninstruction \r set \r architecture \r used \r as \r the \r target \r for \r compilation. \r The \r supported \r architectures \r are:\n\n**Instruction Set** **Value** **Description**\n**kNone** 0 Unspecified\n**kArm** 1 ARM\n**kArm64** 2 ARM 64-­‐bit\n**kThumb2** 3 Thumb-­‐2\n**kX86** 4 X86\n**X86_64** 5 X64\n**kMips** 6 MIPS\n**kMips64** 7 MIPS 64-­‐bit\n\n_dex_file_count \r is \r the \r number \r of \r DEX \r files \r in \r the \r input \r APK \r or \r JAR. \r executable_offset \r points \r to \r the_\ngenerated \r native \r code \r section \r (Same \r as \r the \r oatexec \r section \r in \r the \r ELF’s \r dynamic \r symbol \r table).\n_image_patch_delta \r is \r the \r amount \r the \r ART \r image \r (boot.art) \r is \r relocated \r relative \r to \r its \r image_begin \r field._\nThis \r field \r changes \r every \r boot \r up \r so \r that \r the \r address \r of \r the \r ART \r image \r will \r not \r be \r in \r a \r fixed \r location. \r Prior\nto \r Lollipop, \r the \r base \r address \r was \r fixed \r at \r 0x70000000, \r and \r can \r be \r possible \r used \r to \r defeat \r ASLR \r or \r have \r its\noatexec \r section, \r which \r contains \r a \r huge \r amount \r of \r native \r code, \r used \r as \r source \r for \r ROP \r gadgets[9]. \r The\n_key_value_store \r is \r a \r dictionary \r that \r stores \r metadata \r about \r the \r OAT \r file \r such \r as \r the \r parameters \r used \r in_\ndex2oat \r upon \r its \r creation. \r  \r The \r rest \r of \r the \r fields \r (*_trampoline_offset, \r *_bridge_offset, \r etc) \r are \r used \r at\nruntime, \r and \r are \r often \r set \r to \r zero.\n\n**OAT \r Dex \r File \r Header**\n\n**Field** **Type** **Description**\n**dex_file_location_size** uint32 Length \r of \r the \r original \r input \r DEX\npath\n**dex_file_location_data** ubyte[dex_file_location_size] Original path of input DEX file\n**dex_file_location_checksum** uint32 CRC32 checksum of classes.dex\n**dex_file_pointer** uint32 Offset \r of \r embedded \r input \r DEX\nfrom start of oatdata\n**classes_offsets** uint32[DEX.header.class_defs_size] List \r of \r offsets \r to\nOATClassHeaders\n\nImmediately \r after \r the \r Oat \r Header \r is \r an \r array \r of \r OatDexFileHeaders, \r with \r each \r entry \r representing \r each\nDEX \r file \r inside \r the \r target \r APK \r or \r JAR \r file. \r  \r The \r dex_file_location_data \r field \r contains \r the \r path \r of \r the \r APK\n\n9 \r http://bofh.nikhef.nl/events/HitB/hitb-­‐2014-­‐amsterdam/praatjes/D1T2-­‐State-­‐of-­‐the-­‐\n##### Art-­‐Exploring-­‐the-­‐New-­‐Android-­‐KitKat-­‐Runtime.pdf \r \n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\nthat \r this \r OAT \r file \r is \r compiled \r from. \r dex_file_location_checksum \r is \r the \r CRC32 \r checksum \r of \r the \r DEX \r file. \r It \r is\nused \r to \r verify \r that \r the \r APK \r in \r dex_file_location_data \r is \r the \r same \r DEX \r used \r for \r this \r OAT \r file. \r The \r entire\nDEX \r file \r can \r also \r be \r found \r embedded \r in \r the \r oatdata \r section \r in \r the \r offset \r pointed \r to \r by \r dex_file_pointer.\nTo \r carve \r the \r DEX \r file \r from \r the \r OAT, \r we \r can \r go \r to \r this \r location, \r get \r the \r size \r of \r the \r DEX \r file \r from\n(dex_file_pointer \r + \r 0x20), \r and \r retrieve \r it. \r classes_offsets \r is \r an \r array \r of \r offsets \r to \r OatClass \r headers\n(described \r below). \r Each \r class \r offset \r corresponds \r to \r a \r class_def_item \r in \r the \r DEX \r file, \r and \r appears \r in \r the\nsame \r order.\n\n**Oat \r Class \r Header**\n\n**Field** **Type** **Description**\n**status** uint16 State of class during compilation\n**type** uint16 Type of class\n**bitmap_size** uint32 Size \r of \r compiled \r methods \r bitmap\n(present only when type = 1)\n**bitmap** ubyte[bitmap_size] Compiled \r methods \r bitmap\n(present only when type = 1)\n**methods_offsets** uint32[variable] List \r of \r offsets \r to \r the \r native \r code\nfor each compiled method\n\nThe \r OatClass \r contains \r information \r about \r classes. \r The \r status \r field \r is \r used \r during \r compilation. \r The \r type\nfield \r is \r a \r value \r indicating \r how \r much \r of \r this \r class’s \r methods \r are \r compiled, \r as \r described \r below:\n\n**Type** **Constant Value** **Description**\n**kOatClassAllCompiled** 0 All \r methods \r in \r the \r class \r are\ncompiled.\n**kOatClassSomeCompiled** 1 Some methods are compiled.\n**kOatClassNoneCompiled** 2 No methods were compiled.\n\nThe \r bitmap \r field \r is \r a \r bitmap \r of \r length \r bitmap_size \r bytes \r where \r each \r bit \r indicates \r whether \r a \r particular\nmethod \r is \r compiled \r or \r not. \r  \r Each \r bit \r corresponds \r to \r a \r method \r in \r the \r class. \r If \r type \r is \r either\nkOatClassAllCompiled \r or \r kOatClassNoneCompiled, \r there \r will \r be \r no \r bitmap_size \r and \r bitmap \r fields \r present\nand \r type \r is \r immediately \r followed \r by \r the \r method_offsets. \r If \r type \r is \r kOatClassSomeCompiled, \r it \r means \r at\nleast \r one \r but \r not \r all \r methods \r are \r compiled. \r In \r this \r case, \r the \r method_offsets \r come \r right \r after \r the \r bitmap.\nEach \r bit \r in \r the \r bitmap, \r starting \r from \r the \r least \r significant \r bit, \r corresponds \r to \r a \r method \r in \r this \r class \r -­‐\ndirect_methods \r first, \r followed \r by \r virtual_methods. \r They \r are \r in \r the \r same \r order \r as \r they \r appear \r in \r the\n_class_data_item \r of \r this \r class. \r For \r every \r set \r bit, \r there \r will \r be \r a \r corresponding \r entry \r in \r method_offsets._\n\n_method_offsets \r is \r a \r list \r of \r offset \r that \r points \r to \r the \r generated \r native \r code \r for \r each \r compiled \r method. \r Note_\nthat \r for \r OAT \r files \r with \r OATHeader-­‐>instruction_set \r is \r kThumb2 \r (which \r the \r majority \r of \r the \r OAT \r files \r you\nwill \r encounter \r will \r likely \r be), \r the \r method \r offsets will \r have \r their \r least \r significant \r bit \r set. \r For \r instance, \r if \r the\noffset \r is \r 0x00143061, \r the \r actual \r start \r of \r the \r native \r code \r is \r at \r offset \r 0x00143060.\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n**Oat \r Quick \r Method \r Header**\n\nRight \r before \r (code_offset \r -­‐ \r 0x1c \r bytes) \r the \r method’s \r native \r code \r is \r the \r OatQuickMethod \r header, \r which \r is\ngenerated \r for \r Quick \r backend \r compiled \r code. \r It \r contains \r information \r such \r as \r the \r frame \r size \r in \r bytes \r and\nthe \r mapping \r between \r registers \r and \r instruction \r pointers \r in \r the \r native \r code \r and \r Dalvik \r bytecode. \r It \r also\ncontains \r the \r size \r in \r bytes \r of \r the \r generated \r native \r code.\n\n**Field** **Type** **Description**\n**mapping_table_offset** uint32 Offset \r from \r the \r start \r of \r the\nmapping table\n**vmap_table_offset** uint32 Offset \r form \r the \r start \r of \r the\nvmap table\n**gc_map_offset** uint32 Offset to the GC map\n**QuickMethodFrameInfo.frame_size_in_bytes** uint32 Frame \r size \r for \r this \r method\nwhen executed\n**QuickMethodFrameInfo.core_spill_mask** uint32 Bitmap \r of \r spilled \r machine\nregisters\n**QuickMethodFrameInfo.fp_spill_mask** uint32 Bitmap \r of \r spilled \r floating\npoint machine registers\n**code_size** uint32 The \r size \r of \r the \r generated\nnative code\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n### User \r Mode \r Rootkits \r \n\nThe \r approach \r we \r took \r is \r to \r use \r dex2oat \r to \r generate \r OAT \r files \r from \r modified \r versions \r of \r installed \r apps \r or\nsystem \r frameworks \r and \r replace \r the \r original \r OAT \r files \r with \r them. \r  \r We \r have \r two \r options:\n\n1. Generate \r new \r boot.art \r and \r boot.oat \r that \r contains \r our \r own \r code \r and \r replace \r the \r installed\n\nboot.oat \r with \r it.\n2. Generate \r a \r new \r OAT \r file \r that \r contains \r our \r own \r code \r for \r a \r specific \r installed \r application \r and\n\nreplace \r the \r installed \r OAT \r file.\n\nThere \r are \r several \r advantages \r to \r this \r approach. \r One \r is \r we \r don’t \r have \r to \r deal \r with \r low-­‐level \r code. \r  \r All \r our\nmodifications \r are \r done \r in \r Java \r and \r only \r runs \r in \r the \r user \r mode \r so \r there \r will \r be \r less \r potential \r problems \r to\nbe \r encountered \r compared \r to \r code \r that \r deals \r with \r low \r level \r kernel \r stuff. \r This \r approach \r is \r also \r affected\nless \r by \r variations \r in \r architecture \r and \r OS \r version. \r Because \r we \r rely \r on \r ART’s \r features \r to \r generate \r our \r code,\nthis \r approach \r requires \r almost \r no \r modifications \r regardless \r of \r the \r target’s \r architecture \r or \r OS \r version.\nLastly, \r with \r this \r approach \r we \r don’t \r have \r to \r deal \r with \r code \r signing \r since \r the \r application \r were \r already\ninstalled \r and \r verified. \r All \r we \r do \r is \r modify \r the \r app’s \r code \r that \r is \r now \r brought \r outside \r of \r the \r application’s\npackage.\n\nAlso, \r note \r that \r whichever \r technique \r we \r employ, \r our \r code \r will \r run \r under \r the \r context \r of \r the \r affected \r app.\nThis \r means \r that \r our \r code \r will \r have \r the \r same \r user \r id \r and \r app \r permissions \r as \r the \r app \r running \r our \r code. \r For\ninstance, \r if \r we \r use \r the \r app \r OAT \r replacing \r technique \r and \r replaced \r the \r OAT \r for \r the \r Settings \r app, \r our \r code\nwill \r run \r in \r the \r context \r of \r the \r system \r user, \r along \r with \r the \r app \r permissions \r of \r the \r Settings \r app.\n\nHow \r about \r persistence? \r As \r long \r as \r our \r modified \r OAT \r file \r is \r in \r use, \r our \r modification \r will \r stay \r in \r effect. \r The\nOAT \r files \r will \r only \r be \r replaced \r after \r OTA \r update \r or \r app \r update. \r Upon \r OS \r update, \r boot.art \r and \r boot.oat\nwill \r have \r to \r be \r regenerated \r and \r all \r the \r app \r OAT \r files \r will \r have \r to \r be \r recompiled \r as \r well. \r When \r an \r app \r is\nupdated \r it \r has \r to \r be \r recompiled \r as \r well. \r Keep \r in \r mind \r that \r our \r goal \r is \r not \r to \r maintain \r root \r access, \r as \r we\nare \r trying \r to \r avoid \r writing \r to \r /system \r in \r the \r first \r place. \r We \r do \r have \r the \r option \r to \r re-­‐exploit \r the \r device\nusing \r a \r system \r to \r root \r exploit \r while \r our \r code \r is \r running \r as \r system \r uid. \r How \r to \r do \r this \r is \r left \r as \r an \r exercise\nfor \r the \r reader.\n\n#### Replacing \r Boot \r OAT \r \n\nThis \r approach \r takes \r advantage \r of \r the \r fact \r that \r framework \r code \r are \r all \r compiled \r into \r a \r single \r boot.oat \r file\nthat \r we \r can \r replace \r with \r our \r own \r modified \r copy. \r The \r dex2oat \r tool \r does \r code \r generation \r for \r us, \r so \r we\ndon’t \r have \r to \r worry \r about \r messing \r something \r up \r by \r patching \r the \r binary. \r A \r matching \r boot.art \r will \r also \r be\ngenerated.\n\nBasically, \r what \r we \r are \r going \r to \r do \r is \r modify \r a \r system \r framework \r JAR \r file, \r replace \r the \r target \r code \r with \r our\nown, \r and \r use \r dex2oat \r to \r generate \r a \r new \r boot.oat \r and \r replace \r the \r original \r one.\n\nA \r typical \r rootkits \r goal \r is \r to \r hide \r our \r installed \r malicious \r application \r or \r process. \r Here \r are \r some \r examples \r of\nsuitable \r methods \r to \r modify:\n\n**What to hide** **Class** **Method** **Source** **JAR**\n**Running** ActivityManager getRunningAppProcesses /frameworks/base/core/java/androi framewo\n**processes** d/app/ActivityManager.java rk.jar\n\n**Installed \r apps** ApplicationPack getInstalledApplications /frameworks/base/core/java/androi framewo\nageManager d/app/ApplicationPackageManager.j rk.jar\n\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\nava\n**Files** File filenamesToFiles /libcore/luni/src/main/java/java/io/F core-­‐\nile.java libart.jar\n\nAs \r an \r example, \r let’s \r take \r a \r look \r at \r how \r we \r would \r modify \r a \r framework \r method \r to \r hide \r our \r running\nprocess. \r To \r do \r this, \r we \r can \r modify \r the \r getRunningAppProcesses() \r method \r of \r the \r ActivityManager \r class.\nThis \r method \r returns \r a \r list \r of \r RunningAppProcessInfo, \r which \r contains \r information \r about \r a \r running\nprocess, \r including \r its \r name. \r This \r method \r is \r used \r to \r by \r apps \r like \r the \r Settings \r app \r in \r Android \r to \r enumerate\nthe \r running \r processes \r on \r the \r device \r and \r display \r them \r on \r a \r list. \r  \r Here’s \r the \r code \r for \r this \r method, \r which\ncan \r be \r found \r in \r “/frameworks/base/core/java/android/app/ActivityManager.java”:\n\npublic \r List<RunningAppProcessInfo> \r getRunningAppProcesses() \r {\ntry \r {\nreturn \r ActivityManagerNative.getDefault().getRunningAppProcesses();\n} \r catch \r (RemoteException \r e) \r {\nreturn \r null;\n}\n}\n\nWe \r modified \r it \r to \r remove \r our \r app \r from \r the \r list \r based \r on \r its \r package \r name:\n\npublic \r List<RunningAppProcessInfo> \r getRunningAppProcesses() \r {\ntry \r {\n\nList<RunningAppProcessInfo> \r procList \r =\nActivityManagerNative.getDefault().getRunningAppProcesses();\n\nfor \r (Iterator<RunningAppProcessInfo> \r iter \r = \r procList.listIterator();\niter.hasNext();) \r {\nRunningAppProcessInfo \r p \r = \r iter.next();\nif \r (p.processName.equals(\"com.polsab.badapp\")) \r {\niter.remove();\n}\n\n}\n\nreturn \r procList;\n} \r catch \r (RemoteException \r e) \r {\nreturn \r null;\n}\n}\n\nWe \r then \r build \r this \r code \r to \r generate \r our \r modified \r version \r of \r framework.jar. \r As \r much \r as \r possible \r we\nshould \r not \r use \r this \r directly \r as \r the \r source \r JAR \r for \r dex2oat, \r as \r that \r will \r cause \r unpredictable \r errors \r due \r to\nmismatching \r with \r other \r files. \r Instead, \r we \r will \r retrieve \r the \r original \r JAR \r from \r the \r device \r and \r apply \r the\nmodifications \r we \r did \r to \r the \r code \r within \r it. \r We \r only \r use \r the \r modified \r framework.jar \r as \r a \r source \r for \r our\nmodified \r code’s \r smali.\n\nWe \r then \r use \r Apktool \r to \r decode \r this \r JAR \r into \r smali \r code, \r and \r retrieve \r the \r smali \r for \r our \r modified \r method:\n\n.method \r public \r getRunningAppProcesses()Ljava/util/List;\n.locals \r 6\n.annotation \r system \r Ldalvik/annotation/Signature;\nvalue \r = \r {\n\"()\",\n\"Ljava/util/List\",\n\"<\",\n\"Landroid/app/ActivityManager$RunningAppProcessInfo;\",\n\">;\"\n}\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n.end \r annotation\n\n.prologue\n.line \r 2223\n:try_start_0\ninvoke-­‐static \r {}, \r Landroid/app/ActivityManagerNative;-­‐\n>getDefault()Landroid/app/IActivityManager;\n\nmove-­‐result-­‐object \r v4\n\ninvoke-­‐interface \r {v4}, \r Landroid/app/IActivityManager;-­‐\n>getRunningAppProcesses()Ljava/util/List;\n\nmove-­‐result-­‐object \r v3\n\n.line \r 2224\n.local \r v3,\nprocList:Ljava/util/List;,\"Ljava/util/List<Landroid/app/ActivityManager$RunningAppProcessI\nnfo;>;\"\ninvoke-­‐interface \r {v3}, \r Ljava/util/List;-­‐>listIterator()Ljava/util/ListIterator;\n\nmove-­‐result-­‐object \r v1\n\n.local \r v1,\niter:Ljava/util/Iterator;,\"Ljava/util/Iterator<Landroid/app/ActivityManager$RunningAppProc\nessInfo;>;\"\n:cond_0\n:goto_0\ninvoke-­‐interface \r {v1}, \r Ljava/util/Iterator;-­‐>hasNext()Z\n\nmove-­‐result \r v4\n\nif-­‐eqz \r v4, \r :cond_1\n\n.line \r 2225\ninvoke-­‐interface \r {v1}, \r Ljava/util/Iterator;-­‐>next()Ljava/lang/Object;\n\nmove-­‐result-­‐object \r v2\n\ncheck-­‐cast \r v2, \r Landroid/app/ActivityManager$RunningAppProcessInfo;\n\n.line \r 2226\n.local \r v2, \r p:Landroid/app/ActivityManager$RunningAppProcessInfo;\niget-­‐object \r v4, \r v2, \r Landroid/app/ActivityManager$RunningAppProcessInfo;-­‐\n>processName:Ljava/lang/String;\n\nconst-­‐string \r v5, \r \"com.polsab.baddapp\"\n\ninvoke-­‐virtual \r {v4, \r v5}, \r Ljava/lang/String;-­‐>equals(Ljava/lang/Object;)Z\n\nmove-­‐result \r v4\n\nif-­‐eqz \r v4, \r :cond_0\n\n.line \r 2227\ninvoke-­‐interface \r {v1}, \r Ljava/util/Iterator;-­‐>remove()V\n:try_end_0\n.catch \r Landroid/os/RemoteException; \r {:try_start_0 \r .. \r :try_end_0} \r :catch_0\n\ngoto \r :goto_0\n\n.line \r 2231\n.end \r local \r v1\n#iter:Ljava/util/Iterator;,\"Ljava/util/Iterator<Landroid/app/ActivityManager$RunningAppPro\ncessInfo;>;\"\n.end local v2 #p:Landroid/app/ActivityManager$RunningAppProcessInfo;\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n.end \r local \r v3\n#procList:Ljava/util/List;,\"Ljava/util/List<Landroid/app/ActivityManager$RunningAppProcess\nInfo;>;\"\n:catch_0\nmove-­‐exception \r v0\n\n.line \r 2232\n.local \r v0, \r e:Landroid/os/RemoteException;\nconst/4 \r v3, \r 0x0\n\n.end \r local \r v0 \r  \r  \r  \r  \r  \r  \r  \r  \r  \r  \r #e:Landroid/os/RemoteException;\n:cond_1\nreturn-­‐object \r v3\n.end method\n\nWe \r then \r replace \r the \r code \r in \r the \r framework.jar \r on \r the \r device \r with \r our \r modified \r one. \r We \r retrieve \r the \r JAR\nfrom \r the \r device \r and \r use \r Apktool \r to \r decode \r this \r into \r smali \r code. \r Then \r we \r look \r for \r our \r target \r method,\nwhich \r originally \r looks \r like \r this:\n\n.method \r public \r getRunningAppProcesses()Ljava/util/List;\n.locals \r 2\n.annotation \r system \r Ldalvik/annotation/Signature;\nvalue \r = \r {\n\"()\",\n\"Ljava/util/List\",\n\"<\",\n\"Landroid/app/ActivityManager$RunningAppProcessInfo;\",\n\">;\"\n}\n.end \r annotation\n\n.prologue\n.line \r 2222\n:try_start_0\ninvoke-­‐static \r {}, \r Landroid/app/ActivityManagerNative;-­‐\n>getDefault()Landroid/app/IActivityManager;\n\nmove-­‐result-­‐object \r v1\n\ninvoke-­‐interface \r {v1}, \r Landroid/app/IActivityManager;-­‐\n>getRunningAppProcesses()Ljava/util/List;\n:try_end_0\n.catch \r Landroid/os/RemoteException; \r {:try_start_0 \r .. \r :try_end_0} \r :catch_0\n\nmove-­‐result-­‐object \r v1\n\n.line \r 2224\n:goto_0\nreturn-­‐object \r v1\n\n.line \r 2223\n:catch_0\nmove-­‐exception \r v0\n\n.line \r 2224\n.local \r v0, \r \"e\":Landroid/os/RemoteException;\nconst/4 \r v1, \r 0x0\n\ngoto \r :goto_0\n.end method\n\nThen \r we \r replace \r this \r smali \r code \r with \r our \r modified \r version \r shown \r above \r and \r rebuild \r the \r JAR \r using\nApktool.\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\nThe \r next \r step \r is \r to \r push \r the \r modified \r JAR \r into \r our \r device \r and \r use \r dex2oat \r to \r compile \r it. \r Before \r we \r do \r this\nhowever, \r we \r need \r to \r do \r something \r first. \r ART \r checks \r the \r OatDexFile \r headers \r of \r each \r included \r DEX \r file \r to\nsee \r if \r the \r dex_file_location_data \r and \r dex_file_location_checksum \r matches \r the \r JAR’s \r install \r location \r on\nthe \r device \r and \r the \r CRC32 \r of \r the \r corresponding \r DEX \r file. \r If \r the \r check \r fails, \r ART \r will \r regenerate \r the \r OAT \r file\nfrom \r the \r original \r JAR \r on \r the \r device. \r To \r get \r around \r this \r check, \r we \r need \r to \r patch \r dex_file_location_data\nand \r dex_file_location_checksum \r accordingly.\n\nAll \r this \r could \r obviously \r be \r automated, \r but \r here’s \r how \r to \r do \r it \r manually. \r It \r assumes \r you \r already \r have \r the\nmodified \r smali \r code \r of \r your \r target \r method \r at \r hand:\n\n1. Pull \r the \r original \r JAR \r from \r the \r /system/frameworks/ \r folder.\n2. Use \r apktool \r to \r decode \r the \r JAR \r and \r generate \r smali \r code.\n3. Replace \r the \r target \r method(s) \r with \r our \r modified \r version.\n4. Rebuild \r the \r JAR \r using \r apktool.\n5. Rename \r the \r JAR \r such \r that \r the \r resulting \r path \r after \r you \r have \r pushed \r it \r to \r the \r device \r is \r the \r same\n\nlength \r with \r the \r path \r of \r the \r original \r jar \r in \r the \r /system \r partition. \r For \r example, \r if \r you \r modified\n“/system/framework/framework.jar”, \r which \r is \r 31 \r characters \r long, \r rename \r the \r modified \r jar \r to,\nsay, \r 11framework.jar, \r and \r push \r it \r to \r /data/local/temp, \r making \r the \r resulting \r path\n“/data/local/tmp/11framework.jar”, \r which \r is \r exactly \r 31 \r characters \r long. \r We \r need \r to \r do \r this \r so\nthat \r when \r we \r patch \r the \r generated \r OAT \r later, \r we \r don’t \r need \r to \r worry \r about \r relocating \r offsets.\n6. Get \r the \r CRC32 \r of \r the \r classes.dex \r file \r in \r the \r original \r framework.jar. \r We \r will \r need \r this \r later.\n7. Delete \r the \r original \r boot.oat\n8. Run \r the \r dex2oat \r command \r using \r the \r exact \r commandline \r used \r in \r the \r original \r boot.oat, \r which \r you\n\ncan \r retrieve \r from \r the \r key_value_store \r field \r of \r its \r OAT \r header, \r but \r replacing \r all \r references \r to\nframework.jar \r with \r our \r modified \r framework.jar. \r Here’s \r an \r example \r of \r what \r it \r would \r look \r like:\n\n/system/bin/dex2oat \r -­‐-­‐image=/data/dalvik-­‐cache/arm/system@framework@boot.art \r -­‐-­‐dex-­‐\nfile=/system/framework/core-­‐libart.jar \r -­‐-­‐dex-­‐file=/system/framework/conscrypt.jar \r -­‐-­‐dex-­‐\nfile=/system/framework/okhttp.jar \r -­‐-­‐dex-­‐file=/system/framework/core-­‐junit.jar \r -­‐-­‐dex-­‐\nfile=/system/framework/bouncycastle.jar \r -­‐-­‐dex-­‐file=/system/framework/ext.jar \r -­‐-­‐dex-­‐\nfile=/data/local/tmp/11framework.jar \r -­‐-­‐dex-­‐file=/system/framework/telephony-­‐common.jar \r -­‐-­‐\ndex-­‐file=/system/framework/voip-­‐common.jar \r -­‐-­‐dex-­‐file=/system/framework/ims-­‐common.jar \r -­‐-­‐\ndex-­‐file=/system/framework/mms-­‐common.jar \r -­‐-­‐dex-­‐file=/system/framework/android.policy.jar\n-­‐-­‐dex-­‐file=/system/framework/apache-­‐xml.jar \r -­‐-­‐oat-­‐file=/data/dalvik-­‐\ncache/arm/system@framework@boot.oat \r -­‐-­‐instruction-­‐set=arm \r -­‐-­‐instruction-­‐set-­‐\nfeatures=default \r -­‐-­‐base=0x6f019000 \r -­‐-­‐runtime-­‐arg \r -­‐Xms64m \r -­‐-­‐runtime-­‐arg \r -­‐Xmx64m \r -­‐-­‐image-­‐\nclasses-­‐zip=/data/local/tmp/11framework.jar -­‐-­‐image-­‐classes=preloaded-­‐classes\n\n9. Once \r the \r boot.oat \r is \r generated, \r patch \r the \r dex_file_location_data \r in \r the \r OAT \r DEX \r File \r header\n\ncorresponding \r to \r the \r code \r you \r modified \r with \r the \r original \r path. \r In \r framework.jar’s \r case, \r there \r are\ntwo \r places \r where \r you \r need \r to \r do \r this. \r One \r is \r for \r the \r main \r DEX, \r and \r the \r other \r for \r the \r 2[nd] \r DEX\n(classes2.dex) \r Replace \r the \r dex_file_location_checksum, \r which \r can \r be \r found \r right \r after \r the \r path,\nwith \r the \r original \r checksum \r we \r retrieved \r in \r step \r 6.\n10. Restart \r Zygote, \r or \r restart \r the \r device:\n\nstop \r zygote\nstart zygote\n\n11. If \r all \r goes \r well, \r your \r installed \r apps \r will \r be \r recompiled \r into \r new \r OAT \r since \r boot.oat \r has \r changed,\n\nand \r the \r changes \r will \r take \r effect.\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n#### Replacing \r App \r OAT \r \n\nIn \r this \r technique, \r we \r replace \r a \r specific \r app’s \r OAT \r instead \r of \r a \r framework \r JAR. \r It \r is \r less \r intrusive, \r which\nmeans \r less \r unpredictable \r problems, \r and \r if \r ever, \r will \r happen \r only \r to \r that \r particular \r app. \r Also, \r with \r the\nprevious \r approach, \r all \r apps \r will \r be \r recompiled \r so \r it \r is \r noticeable \r to \r the \r user, \r but \r recompiling \r a \r single \r app,\nlike \r what \r will \r happen \r here, \r is \r not \r The \r downside \r is \r it \r only \r works \r on \r apps \r you \r target \r specifically \r and \r your\nmodifications \r are \r lost \r once \r the \r app \r is \r updated, \r which \r happens \r more \r frequently \r (especially \r for \r non-­‐system\napps) \r compared \r to \r the \r boot.oat \r approach, \r where \r we \r only \r have \r to \r worry \r about \r much \r less \r frequent \r system\nupdates.\n\nOne \r nice \r target \r for \r this \r technique \r is \r the \r Settings \r application \r that \r comes \r with \r Android, \r which \r can \r be \r used\nto \r view \r running \r processes \r and \r installed \r applications. \r You \r can \r find \r the \r original \r APK \r at \r “/system/priv-­‐\napp/Settings/Settings.apk”. \r The \r source \r code \r can \r also \r be \r found \r in \r the \r AOSP \r source \r tree \r under\n“packages/apps/Settings”. \r We \r can \r look \r for \r code \r that \r uses \r the \r ideal \r target \r methods \r we \r mentioned \r above\nand \r modify \r the \r code \r the \r uses \r them. \r For \r instance, \r we \r can \r look \r for \r the \r code \r that \r calls\ngetRunningAppProcesses() \r and \r modify \r the \r returned \r RunningAppProcessInfo \r list. \r Here’s \r the \r code \r from\n“packages/apps/Settings/src/com/android/settings/applications/RunningState.java”:\n\nList<ActivityManager.RunningAppProcessInfo> \r processes\n= \r am.getRunningAppProcesses();\n\nfor \r (Iterator<ActivityManager.RunningAppProcessInfo> \r iter \r =\nprocesses.listIterator(); \r iter.hasNext();) \r {\nActivityManager.RunningAppProcessInfo \r p \r = \r iter.next();\n\nif \r (p.processName.equals(\"com.polsab.badapp\")) \r {\niter.remove();\n}\n\n}\n\nWe \r can \r also \r modify \r the \r code \r that \r calls \r getInstalledApplications() \r to \r remove \r our \r target \r app \r from \r the\ninstalled \r apps \r list \r . \r This \r code \r is \r from\n“packages/apps/Settings/src/com/android/settings/applications/ApplicationState.java”:\n\nmApplications \r = \r mPm.getInstalledApplications(mRetrieveFlags);\nif \r (mApplications \r == \r null) \r {\nmApplications \r = \r new \r ArrayList<ApplicationInfo>();\n}\n\nfor \r (Iterator<ApplicationInfo> \r iter \r = \r mApplications.listIterator();\niter.hasNext();) \r {\nApplicationInfo \r a \r = \r iter.next();\n\nif \r (a.processName.equals(\"com.polsab.badapp\")) \r {\niter.remove();\n}\n\n}\n\nThe \r steps \r involved \r are \r similar \r to \r the \r previous \r one \r with \r a \r few \r differences.:\n\n1. Retrieve \r the \r original \r APK.\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n2. Use \r apktool \r to \r decode \r the \r APK \r and \r generate \r smali \r code.\n3. Modify \r the \r target \r methods.\n4. Rebuild \r the \r APK \r using \r Apktool.\n5. Rename \r the \r APK \r such \r that \r the \r resulting \r path \r after \r you \r have \r pushed \r it \r to \r the \r device \r is \r of \r the\n\nsame \r length \r as \r the \r path \r of \r the \r original \r APK \r on \r the \r device. \r For \r example, \r for \r “/system/priv-­‐\napp/Settings/Settings.apk”, \r which \r is \r 38 \r characters \r long, \r rename \r the \r modified \r APK \r to\n1111111111Settings.apk, \r and \r push \r it \r to \r /data/local/temp, \r making \r the \r resulting \r path\n“/data/local/tmp/1111111111Settings.apk”, \r which \r is \r exactly \r 38 \r characters \r long.\n6. Calculate \r the \r CRC32 \r checksum \r of \r the \r classes.dex \r in \r the \r original \r APK. \r We \r will \r need \r this \r later.\n7. Delete \r the \r original \r OAT \r file \r for \r this \r app.\n8. Run \r the \r dex2oat \r command \r with \r the \r –dex-­‐file \r parameter \r set \r to \r our \r modified \r APK’s \r path \r and \r the \r –\n\noat-­‐file \r parameter \r set \r to \r the \r original \r OAT \r file’s \r path. \r For \r example:\n\ndex2oat \r –dex-­‐file=/data/local/temp/1111111111Settings.apk \r –oat-­‐file=/data/dalvik-­‐\ncache/arm/system@priv-­‐app@Settings@Settings.apk@classes.dex\n\n9. Once \r the \r OAT \r file \r is \r generated, \r patch \r the \r dex_file_location_data \r in \r the \r OAT \r DEX \r File \r header \r with\n\nthe \r path \r of \r the \r original \r APK. \r Replace \r the \r dex_file_location_checksum, \r which \r can \r be \r found \r right\nafter \r the \r path, \r with \r the \r original \r checksum \r we \r calculated \r in \r step \r 6.\n10. Stop \r the \r app \r process \r if \r it \r is \r running:\n\n\nam force-­‐stop com.android.settings\n\n\n11. The \r changes \r will \r take \r effect \r the \r next \r time \r the \r app \r is \r run.\n\n#### Other \r Possible \r Approaches \r \n\nWhen \r we \r first \r started \r this \r research \r the \r main \r approach \r we \r attempted \r was \r to \r either \r patch \r the \r boot.oat\nbinary \r or \r attaching \r to \r the \r Zygote \r and \r patch \r boot.oat \r directly \r in \r memory. \r The \r idea \r is \r to \r hook \r the\ngenerated \r native \r code \r methods \r and \r divert \r execution \r to \r our \r own \r code. \r This \r seemed \r the \r most \r obvious\napproach \r at \r the \r time \r but \r proved \r to \r be \r rather \r difficult \r and \r lead \r to \r unstable \r results. \r However, \r we \r believe\nthese \r techniques \r still \r warrant \r further \r exploration \r and \r are \r still \r being \r actively \r researched.\n\n#### Limitations \r  \r \n\nThis \r approach \r has \r several \r limitations. \r One \r is \r that \r we \r can’t \r hide \r from \r lower-­‐level \r code \r or \r code \r that \r does\nnot \r use \r the \r system \r framework \r to \r display \r the \r things \r that \r we \r want \r to \r hide. \r Also, \r SELinux \r may \r deter \r us \r from\ndoing \r the \r above \r techniques \r if \r policies \r on \r the \r device \r prevent \r us \r from \r doing \r any \r of \r the \r steps. \r However, \r if\nwe \r can \r set \r SELinux \r to \r permissive \r mode, \r even \r temporarily \r (just \r as \r we \r are \r doing \r the \r above \r steps), \r even \r if \r it\ngoes \r back \r to \r enforcing \r mode \r after \r a \r reboot, \r our \r changes \r will \r still \r take \r effect. \r Lastly, \r even \r though \r this \r was\ncited \r as \r an \r advantage \r earlier, \r having \r to \r run \r under \r the \r context \r of \r an \r affected \r app \r also \r binds \r our \r code \r to\nthat \r app’s \r permissions. \r We \r can \r overcome \r this \r by \r using \r this \r rootkit \r solely \r for \r the \r purpose \r of \r hiding \r the\npresence \r of \r another \r malicious \r app \r that \r has \r the \r permissions \r required \r to \r do \r what \r we \r want.\n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----\n\n### Conclusion \r \n\nIn \r this \r paper, \r we \r demonstrated \r that \r it \r is \r possible \r to \r create \r user \r mode \r rootkits \r by \r replacing \r the \r ART\ngenerated \r native \r code \r with \r our \r own. \r These \r techniques \r still \r have \r limitations, \r and \r development \r on \r ART \r (as\nevidenced \r in \r the \r AOSP \r repository) \r indicates \r that \r it \r is \r actively \r being \r worked \r on, \r so \r these \r techniques \r may\nnot \r work \r in \r the \r future \r anymore. \r But \r this \r is \r also \r part \r of \r the \r challenge \r of \r doing \r security \r research, \r so \r expect\nus \r to \r continue \r doing \r research \r in \r this \r area.\n\nThere \r are \r currently \r few \r published \r security \r research \r (and \r soon \r to \r be \r published \r at \r the \r time \r of \r writing[10])\nrelated \r to \r ART, \r but \r we \r are \r looking \r forward \r for \r many \r more \r to \r come. \r We \r hope \r that \r this \r paper \r has \r helped\nthe \r reader \r in \r understanding \r ART \r and \r some \r of \r the \r security \r implications \r it \r poses, \r and \r also \r we \r hope \r that \r this\ninspires \r others \r to \r take \r a \r look \r at \r the \r possibilities \r this \r new \r runtime \r has \r bring, \r security-­‐wise.\n\nIf \r you \r have \r any \r questions, \r comments, \r or \r corrections, \r we’d \r like \r to \r hear \r from \r you \r (especially \r corrections\nJ). \r Please \r feel \r free \r to \r contact \r the \r author \r at \r the \r email \r addresses \r shown \r in \r the \r first \r page. \r Thanks \r for\nreading!\n\n10 \r http://conference.hitb.org/hitbsecconf2015ams/sessions/fuzzing-­‐objects-­‐d-­‐art-­‐\n##### runtime-­‐internals/ \r \n\nIBM\r Security\r Systems\r |\r ©2015\r IBM\r Corporation\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.blackhat.com/docs/asia-15/materials/asia-15-Sabanal-Hiding-Behind-ART-wp.pdf"
    ],
    "report_names": [
        "asia-15-Sabanal-Hiding-Behind-ART-wp.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1427426140,
    "ts_modification_date": 1427426140,
    "files": {
        "pdf": "https://archive.orkl.eu/0945b07cb92795ead79f57242f2c9245fbf429dd.pdf",
        "text": "https://archive.orkl.eu/0945b07cb92795ead79f57242f2c9245fbf429dd.txt",
        "img": "https://archive.orkl.eu/0945b07cb92795ead79f57242f2c9245fbf429dd.jpg"
    }
}