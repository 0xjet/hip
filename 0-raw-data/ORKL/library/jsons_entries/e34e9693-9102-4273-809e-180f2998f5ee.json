{
    "id": "e34e9693-9102-4273-809e-180f2998f5ee",
    "created_at": "2023-01-12T15:08:08.487037Z",
    "updated_at": "2025-03-27T02:05:29.545808Z",
    "deleted_at": null,
    "sha1_hash": "54c836a131496e32042fbec5f99dea31a94ca55e",
    "title": "2012-12-12 - Unpacking Dexter POS -Memory Dump Parsing- Malware",
    "authors": "",
    "file_creation_date": "2022-05-28T15:14:02Z",
    "file_modification_date": "2022-05-28T15:14:02Z",
    "file_size": 319401,
    "plain_text": "# Unpacking Dexter POS \"Memory Dump Parsing\" Malware\n\n**[volatility-labs.blogspot.com/2012/12/unpacking-dexter-pos-memory-dump.html](https://volatility-labs.blogspot.com/2012/12/unpacking-dexter-pos-memory-dump.html)**\n\nI'm a big fan of Dexter. As I recently mentioned during an impromptu discussion with our first\ngroup of memory analysis training attendees, if there are only a few minutes left in an\nepisode and he hasn't killed anyone yet, I start getting nervous. So when I heard there's\n[malware named dexter that has also been \"parsing memory dumps\" of specific processes on](http://blog.seculert.com/2012/12/dexter-draining-blood-out-of-point-of.html)\nPOS (Point of Sale) systems, I was excited to take a look. How exactly does this memory\ndump parsing occur? Is it scanning for .vmem files on an infected VM host? Maybe walking\ndirectories of network shares to find collections of past memory dumps taken by forensic\nteams? Perhaps acquiring a crash dump or mini-dump of the POS system itself? Turns out\n[its none of the above, and the memory dump parsing is just a ReadProcessMemory loop, but](http://msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx)\nfiguring that out was nonetheless a textbook example of how to use Volatility in a reverseengineering malware scenario.\n\nGetting started in the typical way, you can see dexter is packed. There are PE sections\nnamed .conas, .ts10, .ts20, .ts30, .ts40, and .ts50; suspiciously named exports like\nRenameHerbal, RenameFortation, and LoadMemberData; only two imported APIs GetKeyboardState and GetSystemWindowsDirectoryW; and roughly 10% of the file is\nrecognized by IDA as executable code (the rest is compressed/packed data).\n\n\n-----\n\nIf you needed further proof, you could check the strings:\n\n$ strings -a ~/Desktop/dexter.exe\n!This program cannot be run in DOS mode.\nIRich,\n.text\n`.conas\n.const\n@.data\n.ts050\n@.ts040\n@.ts030\n@.ts020\n@.ts010\niopiio\nworG\nuNqkObyOqdrSDunixUVSmOFucsNpJUJKkmpmqlUW\nFvlLutksfHVJWIzigOJfTfFRxxUmwtdRKhmgjhdiXlSq\nTZJ_QaVg_vGB\nOWMu_wWH_EHz\nSOU_GTUQ\nPSOsqo_Jk\nGetKeyboardState\nUSER32.dll\nGetSystemWindowsDirectoryW\nKERNEL32.dll\nC:\\Debugger.fgh\n\n\n-----\n\n,vr1\nrnyCsipvZnUURpjurWxiRqgauylOKfl3J\nowz{\ntjpudajfQwdBCBGAtjpcrTlenAyHMz\nnuymGmpBownDvVIErgffsrBxQskLJu\nzn|c\np}mOPSJqtFxbQlmrSPiThjdwfHxndtrP\nModuleReplace.exe\nLoadMemberData\n\nNothing too interesting there. If we're going to understand how this malware parses memory\ndumps, we'll need to unpack it first. There's the manual option of finding OEP, dumping a\nsample with OllyDbg or LordPE, and fixing imports with ImpREC (or something similar), but I\ntry to save that more time consuming and technical approach for when its really needed. In\nthe case of dexter, and a majority of malware these days, all you need to do is run it and let it\nunpack itself. Being lazy never felt so good!\n\nAfter copying the malware to a VM, it was executed and resulted in the creation of two new\nInternet Explorer processes. The code has to persist on the system in some way, so if the\nprocess (dexter.exe) doesn't stay running itself, you can bet it dissolves (i.e. injects) into\nanother process. A reasonable first guess of the targets would be the two new IE instances:\npids 1480 and 820.\n\nNow back in Volatility, working with the suspended VMs memory file, let's list processes just\nto orient ourselves with this new perspective:\n\n$ ./vol.py pslist\nVolatile Systems Volatility Framework 2.3_alpha\nOffset(V) Name        PID  PPID  Thds   Hnds Start\n---------- ---------------- ------ ------ ------ -------- -------------------0x81bcc830 System        4   0   59   190\n0x81b27020 smss.exe      380   4   3    21 2012-12-03 05:35:49\n0x81a39660 csrss.exe      604  380   11   407 2012-12-03 05:35:51\n\n\n-----\n\n0x818fbd78 winlogon.exe    640  380   18   506 2012-12-03 05:35:53\n0x818e62a0 services.exe    684  640   15   287 2012-12-03 05:35:53\n0x81889150 lsass.exe      696  640   20   353 2012-12-03 05:35:53\n0x81afd458 vmacthlp.exe    848  684   1    24 2012-12-03 05:35:54\n<snip>\n0x81783020 ProcessHacker.e  2532  424   3    79 2012-12-12 01:49:12\n**0x81b27558 IEXPLORE.EXE    1480  968   7   115 2012-12-12 01:49:21**\n\n**0x81710da0 IEXPLORE.EXE    820  1480   2    30 2012-12-12 01:49:21**\n\n[The next thing I did since code injection was suspected is run malfind on the two IE pids. It](http://code.google.com/p/volatility/wiki/CommandReferenceMal22#malfind)\nlocated two memory segments - one in each IE process, same base address in both\n(0x150000), same protection (PAGE_EXECUTE_READWRITE), and according to the\nhexdump there's an MZ header at the base of the region.\n\n$ ./vol.py malfind -p 1480,820\nVolatile Systems Volatility Framework 2.3_alpha\n\nProcess: IEXPLORE.EXE Pid: 1480 Address: 0x150000\nVad Tag: VadS Protection: PAGE_EXECUTE_READWRITE\nFlags: CommitCharge: 11, MemCommit: 1, PrivateMemory: 1, Protection: 6\n\n0x00150000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00  MZ..............\n0x00150010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  ........@.......\n0x00150020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n0x00150030 00 00 00 00 00 00 00 00 00 00 00 00 c0 00 00 00  ................\n\nProcess: IEXPLORE.EXE Pid: 820 Address: 0x150000\nVad Tag: VadS Protection: PAGE_EXECUTE_READWRITE\nFlags: CommitCharge: 11, MemCommit: 1, PrivateMemory: 1, Protection: 6\n\n0x00150000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00  MZ..............\n0x00150010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  ........@.......\n0x00150020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n0x00150030 00 00 00 00 00 00 00 00 00 00 00 00 c0 00 00 00  ................\n\nNow that we've quite effortlessly identified where the unpacked code is hiding, let's dump it\nout of memory. We'll use the [dlldump plugin for this. Although the PE at 0x15000 isn't](http://code.google.com/p/volatility/wiki/CommandReference22#dlldump)\nnecessarily a DLL, the dlldump plugin allows the extracting/rebuilding of any PE in process\nmemory if you supply the --base address (which we know).\n\n$ mkdir dexter\n\n\n-----\n\n$ ./vol.py dlldump -p 1480,820 --base=0x150000 -D dexter/\nVolatile Systems Volatility Framework 2.3_alpha\nProcess(V) Name     Module Base Name  Result\n---------- ------------- ----------- ------- -----0x81b27558 IEXPLORE.EXE 0x000150000 UNKNOWN OK:\nmodule.1480.1b27558.150000.dll\n0x81710da0 IEXPLORE.EXE 0x000150000 UNKNOWN OK:\nmodule.820.1710da0.150000.dll\n\nFor a quick understanding of how effective this approach can be in unpacking malware, take\na look at the strings now:\n\n$ strings -a dexter/module.1480.1b27558.150000.dll\n!This program cannot be run in DOS mode.\n.text\n.data\n.rsrc\nwuauclt.exe\nalg.exe\nspoolsv.exe\nlsass.exe\nwinlogon.exe\ncsrss.exe\nsmss.exe\nSystem\nexplorer.exe\niexplore.exe\nsvchost.exe\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\nSeDebugPrivilege\nNTDLL.DLL\nNtQueryInformationProcess\n/portal1/gateway.php\n11e2540739d7fbea1ab8f9aa7a107648.com\n7186343a80c6fa32811804d23765cda4.com\ne7dce8e4671f8f03a040d08bb08ec07a.com\ne7bc2d0fceee1bdfd691a80c783173b4.com\n815ad1c058df1b7ba9c0998e2aa8a7b4.com\n67b3dba8bc6778101892eb77249db32e.com\nfabcaa97871555b68aa095335975e613.com\nWindows 7\nWindows Server R2\n\n\n-----\n\nWindows Server 2008\nWindows Vista\nWindows Server 2003 R2\nWindows Home Server\nWindows Server 2003\nWindows XP Professional x64\nWindows XP\nWindows 2000\n32 Bit\n64 Bit\nhttp://%s%s\nContent-Type:application/x-www-form-urlencoded\nPOST\nMozilla/4.0(compatible; MSIE 7.0b; Windows NT 6.0)\nLowRiskFileTypes\nSoftware\\Microsoft\\Windows\\CurrentVersion\\Policies\\Associations\nrpcrt4.dll\ngdi32.dll\nwininet.dll\nurlmon.dll\nshell32.dll\nadvapi32.dll\nuser32.dll\nIsWow64Process\nWindowsResilienceServiceMutex\nSoftware\\Resilience Software\nSoftware\\Microsoft\\Windows\\CurrentVersion\\Run\n.DEFAULT\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\nUpdateMutex:\nresponse=\npage=\n&ump=\n&opt=\n&unm=\n&cnm=\n&view=\n&spec=\n&query=\n&val=\n&var=\nDetectShutdownClass\ndownload\n\n-----\n\nupdatecheckin:\nscanin:\nuninstall\n\nThe strings output shows a list of process names, which makes sense - the Seculert Blog\nmentioned that it enumerates processes. You also see it references SeDebugPrivilege, likely\nfor the ability to call OpenProcess and read/write the memory of other processes. The\nABCDEF[....] is a base64 alphabet, so you can expect it to encode some or all of the data it\nPOSTs to gateway.php on one of the randomly named .com domains. It would create the\nWindowsResilienceServiceMutex and make a run key in the Software\\Resilience Software\nregistry key.\n\nTo solve our real question - how does this malware parse memory dumps - we need to open\nthe unpacked file in IDA. Its import table is already fixed up, so aside from switching the\nImageBase value in the PE header so RVAs are interpreted correctly by IDA, we're done\nunpacking before we even really started. A quick look through the unpacked file's IAT shows\nit calls ReadProcessMemory, and cross-referencing that leads to one function, shown below:\n\nWhat you see here is the \"memory dump parsing\" function. It iterates once for each active\nprocess on the system, calling OpenProcess() to obtain a handle, then using\nVirtualQueryEx() to determine which memory ranges are accessible to the process, and\nreading them into a local buffer with ReadProcessMemory(). The data is then passed off to\ntwo scanning sub-functions which do the real work of deciding which data to steal from the\nbuffer.\n\n\n-----\n\nIn summary, though I'm slightly disappointed that the memory dump parsing function is just a\nReadProcessMemory() loop, at least I didn't waste much time getting there. Unpacking the\nmalware by leveraging Volatility was as easy as 1-2-3. Lastly, since some of our students in\nthe Windows Memory Forensics training requested videos of common ways we use Volatility,\nhere's an initial example in quicktime format showing the steps described in this blog:\n[http://www.mnin.org/dexter.mov.zip.](http://www.mnin.org/dexter.mov.zip)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2012/2012-12-12 - Unpacking Dexter POS -Memory Dump Parsing- Malware.pdf"
    ],
    "report_names": [
        "2012-12-12 - Unpacking Dexter POS -Memory Dump Parsing- Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536088,
    "ts_updated_at": 1743041129,
    "ts_creation_date": 1653750842,
    "ts_modification_date": 1653750842,
    "files": {
        "pdf": "https://archive.orkl.eu/54c836a131496e32042fbec5f99dea31a94ca55e.pdf",
        "text": "https://archive.orkl.eu/54c836a131496e32042fbec5f99dea31a94ca55e.txt",
        "img": "https://archive.orkl.eu/54c836a131496e32042fbec5f99dea31a94ca55e.jpg"
    }
}