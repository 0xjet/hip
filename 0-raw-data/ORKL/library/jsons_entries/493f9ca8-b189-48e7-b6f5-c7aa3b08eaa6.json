{
    "id": "493f9ca8-b189-48e7-b6f5-c7aa3b08eaa6",
    "created_at": "2023-02-02T02:08:10.223327Z",
    "updated_at": "2025-03-27T02:05:46.817073Z",
    "deleted_at": null,
    "sha1_hash": "8d2f07f0188acff347db8dd901b048e7f4e846cb",
    "title": "2023-01-26 - CryptBot Infostealer- Malware Analysis",
    "authors": "",
    "file_creation_date": "2023-02-01T07:54:15Z",
    "file_modification_date": "2023-02-01T07:54:15Z",
    "file_size": 3452198,
    "plain_text": "# CryptBot Infostealer: Malware Analysis\n\n**any.run/cybersecurity-blog/cryptbot-infostealer-malware-analysis/**\n\nANY.RUN January 26, 2023\n\n[HomeMalware Analysis](https://any.run/cybersecurity-blog/)\nCryptBot Infostealer: Malware Analysis\n[We recently analyzed CryptBot, an infostealer detected by the ANY.RUN online malware sandbox.](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_campaign=cryptbot&utm_content=landing)\n\nThrough our research, we collected information about MITRE ATT&CK techniques used by this malware. We also learned about how this\ninfostealer stores and encrypts its configuration information, and we wrote a Python script to extract the configuration.\n\nLet’s go over the whole process step-by-step.\n\n## Brief description of CryptBot malware\n\nCryptBot is an infostealer targeting Windows operation systems that was first discovered in the wild in 2019. It is designed to steal sensitive\ninformation from infected computers, such as credentials for browsers, cryptocurrency wallets, browser cookies, credit card information, and\nscreenshots of the infected system. It is distributed through phishing emails and cracked software.\n\n\nCryptBot malware\n\n\n## CryptBot dynamic analysis in a malware sandbox\n\nDuring the analysis we’ll take a look at the sample:\n\n\n-----\n\nMD5: 12d20a973f8cd9c6373929ae14efe123\n\nURL: [https://app.any.run/tasks/5c6e7021-f223-495c-a332-21ef1276e4cf](https://app.any.run/tasks/5c6e7021-f223-495c-a332-21ef1276e4cf?utm_source=anyrunblog&utm_medium=article&utm_campaign=cryptbot&utm_content=task)\n\nA single process (Fig. 1) is created when the malware starts, which actively uses the file system (15k+ events) and the registry (2k+ events).\n\nFig. 1 — CryptBot’s process\n\nOk, now that we got the basics out of the way, let’s break down this malware and list all of the techniques it uses. We’ll break sort the\ninformation by technique as we go from here.\n\n### Credentials from password stores: credentials from web browsers (T1555.003)\n\nCryptBot steals information from popular browsers — Chrome, Firefox, and Edge, as the “Actions looks like stealing of personal data”\nindicator (Fig. 2) and “Reads browser cookies” indicators tell us:\n\nFig. 2 — CryptBot steals Firefox data\n\nTo detect access to personal data stored in the browser, we can use the pseudo-signature:\n```\nprocess_name NOT (“chrome.exe”, ”firefox.exe”, “msedge.exe”, “opera.exe”)\n\nAND\n\nfile_access (\n\n%LOCALAPPDATA%\\\\MICROSOFT\\\\EDGE\\\\USER DATA\\\\*,\n\n%APPDATA%\\\\Roaming\\\\Mozilla\\\\Firefox\\\\*,\n\n%LOCALAPPDATA%\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\*\n\n%LOCALAPPDATA%\\\\AppData\\\\Local\\\\Opera Software\\\\Opera Stable\\*\n\n)\n\n### Software discovery (T1518)\n\n```\nCryptBot checks the presence of installed software in the system by going through the “Uninstall” registry tree (Fig. 3):\n\n\n-----\n\nFig. 3 — CryptBot searches for installed software\n\nTo detect an attempt to access the list of installed software, we can use a pseudo-signature:\n```\nreg_key is (“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall”)\n\nAND\n\noperation read\n\n### System information discovery (T1082)\n\n```\nThe malware collects system information, including operating system installation date, computer name, key, CPU information, and this\nbehavior triggers the corresponding indicators (Fig. 4):\n\nFig. 4 — CryptBot collects system information\n\nIt is possible to detect the collection of system configuration information by accessing certain registry keys. For example, reading the system\ninstallation date can be detected by the following pseudo-signature:\n```\nreg_key is (“HKLM\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION”)\n\nAND\n\nreg_name is (“INSTALLDATE”)\n\nAND\n\noperation read\n\n### Application layer protocol: web protocols (T1071.001)\n\n```\nCryptBot sends the collected OS information and personal data to the control server, which we can see in multiple connection attempts (see\nFigure 5):\n\n\n-----\n\nFig. 5 — CryptBot attempts to send data to the control server\n\nWe can detect attempts to connect to the C2 server with the following pseudo-signature:\n```\nnetwork connect\n\nAND\n\n(\n\ndomains are (“sginiv12[.]top” or “bytcox01[.]top”)\n\nOR (ip == “23[.]217.138.108” and port==80)\n\n)\n\n```\nAdditionally, we investigated the content of the network stream and detected that the data is sent through the HTTP protocol, using a POST\nrequest with an attached file (see Fig. 6). Having restarted the malware several times we found that the file name is most likely randomly\ngenerated. However, the request is always sent to the “gate.php” page.\n\nFig. 6 — Malware sends information to the control server\nPotentially malicious traffic is also detected in the results of the Suricata (see Fig. 7):\n\nFig. 7 — Potentially malicious traffic detected by the Suricata rules\nLet’s create a pseudo-signature to detect CryptBot in the traffic:\n```\nnetwork send\n\nAND\n\nhttp_verb is “POST” AND location is “gate.php”\n\nAND\n\nhttp content includes (“form data” “name=\\”files[]\\”” “filename”)\n\n```\n\n-----\n\nAnalyzing the contents of the transmitted file gives nothing of interest, since it is probably encrypted.\n\n### Data staged: local data staging (T1074.001)\n\n**1. Preventing re-runs**\n\nWhen we launch the malware for the first time in the “%APPDATA%” directory an empty directory-marker “0D445946B53E9551” is created\n(Figure 8). This directory allows the Malicious software to determine whether it has been launched before. If the CryptBot is restarted, it will\nstop working immediately.\n\n\nMarker-directory 0D445946B53E9551\n\n\nFig. 8 — Marker-directory 0D445946B53E9551\n\nLet’s make a pseudo-signature to detect the creation of the marker directory:\n```\naction create_directory\n\nAND\n\ndirectory_name is (“^%APPDATA%\\\\[A-F0-9]{16}$”)\n\n```\n**2. Storing collected data**\n\n\n-----\n\nCollected information is stored in temporary files in various formats (sqlite, binary, text) in the %TEMP% directory (Fig. 9):\n\nFig. 9 — Temporary files in the %TEMP% directory\n\nFor example, in Fig. 10 we see the content of one of the created temporary files, where information about the stolen logins and passwords is\nstored in Base64 format. Note that the data also includes a website to which each login-password pair corresponds:\n\nFig. 10 — The contents of the files with the collected information\n\nTo detect the creation of temporary files with personal data, we can, for example, apply the following pseudo-signature:\n```\nprocess_name NOT (“chrome.exe”)\n\nAND\n\nfile_create (“%TEMP\\\\*.tmp”)\n\nAND\n\nfile_content includes (\n\n*username*,\n\n*password*\n\n)\n\n### Indicator removal: file deletion (T1070.004)\n\n```\nWhen the malware is done running, it removes itself using CMD.EXE with a short delay to give the process time to finish and unblock the\nexecutable file (Fig. 11):\n\nFig. 11 — The malware self-deletes\nWe can use the following pseudo-signature in the command line for detection:\n```\nprocess_name is (“cmd.exe”)\n\nAND\n\ncommand_line includes (“timeout”, “del”)\n\n## CryptBot dynamic analysis using a debugger\n\n### Static packer check\n\n```\nIn general, it’s a best practice to check the file statically to figure out its type and if there’s a packer present, before conducting the dynamic\nanalysis. Once we do that with the DiE tool shows that the file is not packed (see fig.12):\n\n\n-----\n\nFig. 12 — Checking the malware\n\nfile statically to detect a packer\nIn this case, even though we didn’t find a packer during our static analysis, the dynamic analysis revealed that the malware uses a T1027.002\n– software packing technique.\n\n### Obfuscated files or information: software packing (T1027.002)\n\nBy analyzing the memory of a running process using Process Hacker, we stumble upon an RWX region that is not normally found in\nlegitimate programs. The beginning of the dump of this region allows you to see the header of the PE file (see Fig. 13):\n\nFig. 13 — CryptBot’s memory dump of a running process\nOn further analysis we discovered that the header of the PE file is also the beginning of the shellcode (see Fig. 14), which recovers the\nregister value, gets the ImageBase and passes control to the EntryPoint:\n\n\n-----\n\nFigure 14 — Disassembling the PE header\nUsing the x64dbg debugger we have determined that the executable memory region is allocated by the unpacker using the WinAPI’s\n**VirtualAlloc function. Next, the unpacker writes payload to it and decrypts it with an XOR operation (see Figure 15):**\n\nFig. 15 — Decrypting payload using XOR\nThe key to decrypt the payload is in the “.rdata” section of the running executable:\n\nFig. 16 — Key to decrypt the payload\n\nThus, we can see that despite the absence of features of the payload in the static analysis, using the dynamic one we have identified the\n**presence of a packer and determined the key and the encryption algorithm.**\n\n### Writing YARA rules to detect CryptBot shellcode in memory\n\nA YARA rule for detecting a CryptBot shellcode in OS memory could look like this:\n\n\n-----\n\n```\n{\n\nmeta:\n\n     author = \"Any.Run\"\n\n     SHA256 = \"183f842ce161e8f0cce88d6451b59fb681ac86bd3221ab35bfd675cb42f056ac\"\n\n     date = \"2023-01-19\"\n\n     description = \"Detect CryptBot shellcode in memory\"\n\nstrings:\n\n     $shellcode = { 4D 5A 45 52 E8 00 00 00 00 58 83 E8 09 50 05 [4] FF D0 C3 }\n\ncondition:\n\n     uint16(0) != 0x5A4D and\n\n     uint16(0) > 0 and\n\n     $shellcode in (0x20..0x50)\n\n}\n\n## Static analysis and configuration decoding\n\n### Finding and deciphering the configuration\n\n```\nThe static analysis of the payload code led us to the conclusion that the malware configuration is located in the “.data” section and encrypted\nwith an XOR operation. Moreover, the decryption key lies in plaintext just before the encrypted data (see Figure 17):\n\nFig. 17 — Key and encrypted configuration\n\nThe configuration is easily decrypted using CyberChef and the key “PU7GX2MZtl” (see Fig. 18):\n\nFigure 18 — CryptBot decrypted configuration\n\nFrom the decrypted configuration it becomes clear what information should be stolen by CryptBot. For example, the screenshot variable tells\nthe malware to take a screenshot, and ChromeExt — to steal data from Chrome extensions.\n\n### Automating configuration decryption\n\n[We have automated the CryptBot configuration extraction in Python and made the script public. You can always find it in our Git repo. The](https://github.com/anyrun/blog-scripts/blob/main/Extractors/CryptBot/CryptBot.py?utm_source=anyrunblog&utm_medium=article&utm_campaign=cryptbot&utm_content=script)\nresult of the unpacked payload script is shown in Fig 19:\n\n\n-----\n\nFig. 19 — The result of the configuration extraction script\n\n### Developing YARA Rules for detecting CryptBot configuration in memory\n\nSome strings of the decrypted CryptBot configuration can be used as part of a YARA rule to detect it in memory:\n```\nrule CryptBot_Config {\n\nmeta:\n\n     author = \"Any.Run\"\n\n     SHA256 = \"183f842ce161e8f0cce88d6451b59fb681ac86bd3221ab35bfd675cb42f056ac\"\n\n     date = \"2022-01-19\"\n\n     description = \"Detect CryptBot configuration in memory\"\n\nstrings:\n\n     $s1 = \"CookiesEdge\"\n\n     $s2 = \"ChromeDB<>_<>\"\n\n     $s3 = \"EdgeDB<>_<>\"\n\n     $s4 = \"ChromeExt<>_<>\"\n\n     $s5 = \"HistoryChrome<>_<>\"\n\n     $s6 = \"EdgeExt<>_<>\"\n\n     $s7 = \"CookiesFirefox<>_<>\"\n\n     $s8 = \"HistoryOpera<>_<>\"\n\n     $s9 = \"CookiesOpera<>_<>\"\n\n     $s10 = \"FirefoxDB<>_<>\"\n\n     $s11 = \"CookiesChrome<>_<>\"\n\n     $s12 = \"HistoryFirefox<>_<>\"\n\n     $s13 = \"HistoryEdge<>_<>\"\n\n     $s14 = \"DesktopFolder<>_<>\"\n\n     $s15 = \"ChromeDBFolder<>_<>\"\n\n     $s16 = \"ExternalDownload<>_<>\"\n\n     $s17 = \"ScreenFile<>_<>\"\n\n     $s18 = \"MessageAfterEnd<>_<>\"\n\n     $s19 = \"HistoryFile<>_<>\"\n\n     $s20 = \"FirefoxDBFolder<>_<>\"\n\n     $s21 = \"PasswordFile<>_<>\"\n\n     $s22 = \"WalletFolder<>_<>\"\n\n     $s23 = \"DeleteAfterEnd<>_<>\"\n\n     $s24 = \"EdgeDBFolder<>_<>\"\n\n     $s25 = \"InfoFile<>_<>\"\n\n     $s26 = \"CookiesFile<>\"\n\ncondition:\n\n     7 of them\n\n}\n\n```\n\n-----\n\n## Using ANY.RUN to efficiently analyze CryptBot\n\n[For your convenience, we have integrated automatic extraction of the CryptBot configuration into ANY.RUN interactive sandbox — just run](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_campaign=cryptbot&utm_content=landing)\nthe sample and get all the IOCs in seconds (Fig. 20):\n\nFig. 20 – Automatic CryptBot configuration extraction in ANY.RUN sandbox\n\n## Conclusion\n\nIn this article, we looked into CryptBoT, its techniques and behavior when contained in the ANY.RUN sandbox. We also wrote a configuration\nextractor that you can use to gather and interpret the data.\n\nFortunately, ANY.RUN is already set up to detect this malware automatically, making the relevant configuration details just a click away.\n\n[If you want to read more content like this, check out our analysis of the Raccoon Stealer, or](https://any.run/cybersecurity-blog/raccoon-stealer-v2-malware-analysis/) [Orcus RAT.](https://any.run/cybersecurity-blog/orcus-rat-malware-analysis/)\n\n## Appendix\n\n### Analyzed files\n\n**Title** **Description**\n\nName 12d20a973f8cd9c6373929ae14efe123.exe\n\nMD5 12d20a973f8cd9c6373929ae14efe123\n\nSHA1 7f277f5f8f9c2831d40a2dc415566a089a820151\n\nSHA256 183f842ce161e8f0cce88d6451b59fb681ac86bd3221ab35bfd675cb42f056ac\n\n### Extracted URLs\n\nhttp://sginiv12[.]top/gate.php\nhttp://bytcox01[.]top/gesell.dat\n\n\n-----\n\n### MITRE (ARMATTACK)\n\n**Tactics** **Techniques** **Description**\n\n\nTA0005:\n\ndefence evasion\n\nTA0006:\n\nCredential access\n\nTA0007:\n\nSoftware discovery\n\nTA0009:\n\nCollection\n\nTA0011:\n\nCommand and Control\n\n\nT1070.004:\n\nIndicator Removal:\n\nFile Deletion\n\nT1027.002:\n\nObfuscated Files\n\nor Information:\n\nSoftware Packing\n\nT1555.003:\n\nCredentials from\n\nWeb Browsers\n\nT1518:\n\nSoftware Discovery\n\nT1082:\n\nSystem Information\n\nDiscovery\n\nT1113:\n\nScreen capture\n\nT1074:\n\nData Staged\n\nT1071:\n\nApplication Layer\n\nProtocol\n\n\nSelf-deleting\n\nafter completion\n\nMalware is decrypted\n\ninto memory before\n\nit starts working\n\nSteals data from\n\ninstalled browsers\n\nSearches for installed software\n\nin the system\n\nin the “Uninstall” key\n\nCollects system data\n\nHas an option to take\n\na configuration screenshot\n\nSaving of gathered data\nin a temporary directory\n\nbefore sending;\n\nprevention of relaunch\n\nSending collected data\nto the control server\n\n\n[malware analysis](https://any.run/cybersecurity-blog/tag/malware-analysis/)\nWhat do you think about this post?\n\n16 answers\n\nAwful\nAverage\nGreat\n\nNo votes so far! Be the first to rate this post.\n\n1 comments\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-26 - CryptBot Infostealer- Malware Analysis.pdf"
    ],
    "report_names": [
        "2023-01-26 - CryptBot Infostealer- Malware Analysis.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1675303690,
    "ts_updated_at": 1743041146,
    "ts_creation_date": 1675238055,
    "ts_modification_date": 1675238055,
    "files": {
        "pdf": "https://archive.orkl.eu/8d2f07f0188acff347db8dd901b048e7f4e846cb.pdf",
        "text": "https://archive.orkl.eu/8d2f07f0188acff347db8dd901b048e7f4e846cb.txt",
        "img": "https://archive.orkl.eu/8d2f07f0188acff347db8dd901b048e7f4e846cb.jpg"
    }
}