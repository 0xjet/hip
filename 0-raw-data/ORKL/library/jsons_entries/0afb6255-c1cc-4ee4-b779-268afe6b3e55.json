{
    "id": "0afb6255-c1cc-4ee4-b779-268afe6b3e55",
    "created_at": "2023-01-12T15:07:57.717107Z",
    "updated_at": "2025-03-27T02:16:25.877126Z",
    "deleted_at": null,
    "sha1_hash": "a49b789ce17a4bfbf975594313ca0b9b51ed3470",
    "title": "2019-03-13 - N Ways to Unpack Mobile Malware",
    "authors": "",
    "file_creation_date": "2022-05-27T22:12:56Z",
    "file_modification_date": "2022-05-27T22:12:56Z",
    "file_size": 1894505,
    "plain_text": "# N Ways to Unpack Mobile Malware\n\n**pentest.blog/n-ways-to-unpack-mobile-malware/**\n\nAhmet Bilal Can March 13, 2019\n\nThis article will briefly explain methods behind the mobile malware unpacking. It will be\nfocusing on Anubis since it is the latest trending malware for almost a year now. Actors use\ndropper applications as their primary method of distribution. Droppers find their ways to\nGoogle Play store under generic names thereby infecting devices with Anubis. An example\nof a such dropper may found in the references. There were at least forty cases in Google\nPlay in the last fall targeting Turkish users. [@LukasStefanko‚Äôs twitter thread may be helpful](https://twitter.com/LukasStefanko/status/1084728042927341569)\nto get an overview of such campaigns. Anubis malware already analysed by fellows from the\nindustry in a detailed manner. Therefore readers should find it more valuable to have an\narticle focusing on packer mechanisms of Anubis.\n\nThe sample used in this article is available at the references section. I strongly recommend\ndownloading the sample and following through the article. I will be dividing this post into\nthree sections.\n\n## Packers in Android Ecosystem\n\nMobile malwares also make use of packers to hide their malicious payloads from\nresearchers and AV programs. This includes reflection, obfuscation, code-flow flattening and\ntrash codes to make unpacking process stealthy. All mechanisms mentioned are used by the\nAnubis packer and therefore will be explored in this article.\n\n\n-----\n\n**Loading classes at runtime**\n\nAndroid applications must define their used services, receivers, activity classes in\nAndroidManifest file to use them. In Anubis samples, it is clear that there are many classes\nnot defined in the Manifest file that are simply present in the source code.\n\nThis means that a file with non-defined classes should be loaded into application at run-time.\nThere are two main ways of run-time loading in Android:\n\n**From file:**\n\ndalvik.system.DexFile.loadDex depreciated after API 26\ndalvik.system.DexClassLoader\ndalvik.system.PathClassLoader\n\n**From memory:**\n\ndalvik.system.InMemoryDexClassLoader (not common in malwares)\n\nLoading from the file requires a dex/jar file to be present in file system. Anubis unpacks the\nencrypted data file and then drops the decrypted version. Later on malware proceeds loading\ndecrypted dex into the application. After loading with DexClassLoader, malware removes the\n\n\n-----\n\ndecrypted dex file. Tracing the dexClassLoader should make the loading routine clear. Since\ndexClassLoader is a class of dalvik.system package ‚Äúdalvik.system.dexClassLoader‚Äù should\nbe in the code but it is nowhere to be found.\n\n**Reflection**\n\nAnother useful method when dealing with malware is reflection. Reflection is an important\nconcept in Java which lets you to call methods/classes without knowing about them in\ncompile time. There are several classes/methods for reflection.\n\njava.lang.Class.forName\njava.lang.ClassLoader.loadClass\njava.lang.reflect.Method\njava.lang.Class.getMethods\n\nExample usage of forName\n```\ncObj = Class.forName(\"dalvik.system.dexClassLoader\");\n\n```\ncObj variable holds the class object of dexClassLoader. This enables program to call\nmethods of any given class. The problem is to find where function calls are made to\nreflection methods.\n\n## Catching packers with Frida\n\n[frida is a dynamic instrumentation toolkit supported by nearly every operating system. Frida](https://frida.re/)\nmakes it possible to inject a piece of code to manipulate target program and also to trace\nprogram calls. In this case it will be used for tracing which reflection calls are made thereby\n\n\n-----\n\nanalysing the threads. When previously mentioned function calls are made, console.log will\nbe called additionally. But before that, let‚Äôs take a quick recap on how to setup Frida on\nandroid emulator.\n\nDownload frida-server suitable with your emulator from:\n(e.g Genymotion uses x86 architecture.)\n[https://github.com/frida/frida/releases.](https://github.com/frida/frida/releases)\n```\nadb push frida-server /data/local/tmp\nadb shell\ncd /data/local/tmp\nchmod +x frida-server\n./frida-server &\n\n```\nFrida tools should be installed in host machine by running\n\n```\npip install frida-tools\n\n```\n\nAfter the setup, we can write a script to hook our target methods. We will start by defining\nvariables for classes of our methods.\n```\nvar classDef = Java.use('java.lang.Class');\nvar classLoaderDef = Java.use('java.lang.ClassLoader');\nvar loadClass = classLoaderDef.loadClass.overload('java.lang.String', 'boolean');\nvar forName = classDef.forName.overload('java.lang.String', 'boolean',\n'java.lang.ClassLoader');\nvar reflect = Java.use('java.lang.reflect.Method')\nvar member = Java.use('java.lang.reflect.Member')\nvar dalvik = Java.use(\"dalvik.system.DexFile\")\nvar dalvik2 = Java.use(\"dalvik.system.DexClassLoader\")\nvar dalvik3 = Java.use(\"dalvik.system.PathClassLoader\")\n//var dalvik4 = Java.use(\"dalvik.system.InMemoryDexClassLoader\")\nvar f = Java.use(\"java.io.File\")\nvar url = Java.use(\"java.net.URL\")\nvar obj = Java.use(\"java.lang.Object\")\nvar fo = Java.use(\"java.io.FileOutputStream\")\n\n```\nWe will be using this code snippet to change implementation of a method.\n```\nclass.targetmethod.implementation = function(){\n  console.log(\"[+] targetmethod catched !\")\n  stackTrace()\n  return this.targetmethod()\n}\nconsole.log(\"[+] {x} function catched !\") will enable us to see if the function is\n\n```\ncalled. If function takes any parameters such as a string, logging those may become helpful\nduring the analysis. Then we can get more information about the thread we are in. Frida is\nable to call any android function including `getStackTrace() . But that requires a reference`\nto the current thread object. Let‚Äôs start by getting instance of the thread class:\n\n\n-----\n\n```\nvar ThreadDef Java.use( java.lang.Thread );\nvar ThreadObj = ThreadDef.$new();\n\n```\nThreadObj holds instance of the Thread class and `currentThread() can be used to get`\n[thread according to https://developer.android.com/reference/java/lang/Thread.html.](https://developer.android.com/reference/java/lang/Thread.html)\nWe can now use `getStackTrace() and also loop through stackElements to print the call`\nstack.\n```\n  function stackTrace() {\n    console.log(\"------------START STACK---------------\")\n    var stack = ThreadObj.currentThread().getStackTrace();\n    for (var i = 0; i < stack.length; i++) {\n      console.log(i + \" => \" + stack[i].toString());\n    }\n    console.log(\"------------END STACK---------------\");\n  }\n\n```\nPrinting call stack helps to identify call graph of reflections and unpacking mechanisms. For\nexample dexClassLoader might have created with reflection. But when frida hooks into\ndexClassLoader and prints the call stack, we can see the functions before dexClassLoader is\ncalled. Unpacking routines are called at the very beginning of the application. Therefore frida\nshould be attached as soon as possible to catch the unpacking process. Fortunately -f option\nin frida enables frida to spawn target app itself. frida accepts scripts with the -l parameter.\n```\nfrida -U -f appname -l dereflect.js\n\n```\nThen frida waits input from the user to continue. `%resume will resume the process. Full`\nscript is available at my github repository.\n[https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/dereflect.js](https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/dereflect.js)\n\nOutput without the stackTrace():\n\n\n-----\n\nWith stackTrace()\n_Voila._\n\nYou can see the functions called before the write method. After tracing these interval\nfunctions, you can see RNlkfTEUX and `lqfRafMrGew are called right before them. And`\nturns out they are very important functions used in decryption of the encrypted file which we\nwill come back later on.\n\n## How to Defeat Packers\n\nWe can divide unpacking methods into two sections. Both ways lead to the decrypted file.\n\n### Dynamically\n\nBy hooking:\n\nIntercept file.delete (Java level)\nIntercept unlink syscall (system level)\nFrom memory:\n\nDump the memory with gameguardian\nDump the memory with custom tools\n\n### Statically:\n\n\n-----\n\nHands on manual unpacking\n\n**Dynamically:**\nIntercepting methods is the easiest way.\n\n**By hooking : Java Level**\nWhen I first encountered Anubis and realized it was dropping a file, my first solution was\nhooking into file.delete function.\n```\nJava.perform(function() { \n  var f = Java.use(\"java.io.File\") \n  f.delete.implementation = function(a){ \n    s = this.getAbsolutePath() \n    if(s.includes(\"jar\")){ \n     console.log(\"[+] Delete catched =>\" +this.getAbsolutePath()) \n    } \n    return true \n  } \n})\n\n```\nThis piece of code always returns true to file.delete function. After intercepting we can pull\nthe dropped jar file. ‚úî\n\nIn addition to this we can automate our job with python bindings of frida and go through the\nfolder that our target files are in. There are generally thousands of apks generated from\nthose c&c servers. Since each of them can have different IP addresses embedded, an\n[automated tool could make our life easier.](https://twitter.com/0xabc0/status/1072888987285630976)\n\n**By Hooking : System Level**\n\nBut what if malware uses native code to delete files? We can not always hook at Java level.\nWe need to get deeper. What syscall is responsible for deleting file from file system and in\nlibc?\n\nUnlink function takes one parameter, a pointer to filename. We can hook unlink with the help\nof findExportByName. Code is taken from https://www.fortinet.com/blog/threatresearch/defeating-an-android-packer-with-frida.html but I tweaked little bit so deleted file will\nbe printed.\n\n\n-----\n\n```\n                                     var unlinkPtr \n                                     Module.findExportByName(n\n                                     'unlink');\n                                     Interceptor.replace(unlin\n                                     new NativeCallback(\n                                     function (a){\n                                       console.log(\"[+]\n                                     Unlink : \" +\n                                     Memory.readUtf8String(ptr\n                                       }, 'int',\n                                     ['pointer']));\n\n```\nLet‚Äôs run the script.\n\nWe intercepted the unlink call, since our script just replaced code of original function with\nconsole.log(), file will not be deleted from the file system. ‚úî\n\n**From Memory:**\n\nEven when file is deleted from file system because file was loaded into process, we can get\ntrails of the deleted file from memory of that process. Since Android inherits from Linux, we\ncan use /proc/pid folder to give us information about memory regions of a specified process.\nLet‚Äôs look at our target with `cat /proc/pid/maps | grep dex filtering the dex.`\n\nWe have found the trails of dex files. Now we need to dump these sections.\n\n**Dump the Memory with Gameguardian:**\nFirst way is by ‚Äúcheating‚Äù üôÇ There is a tool called GameGuardian which is used in game\nhacking. You can do many interesting things with GameGuardian but we will only use dump\nmechanism for now.\n\n\n-----\n\n-----\n\n-----\n\n-----\n\nLet s start by installing and running the APK. Then launch GameGuardian and select the app\nname from left upmost button. Select right upmost button and the one underneath it. Now\nyou can see dump memory option in menu. Put the hex codes of regions or select regions by\nclicking arrow buttons and press save. Yay!\nWe can pull dumped regions with :\n\n`adb pull /storage/emulated/0/packer .` ‚úî\nThen you will see 2 files in packer folder.\n```\ncom.eqrxhpdv.cbunlkwsqtz-dfb5a000-e0080000.bin com.eqrxhpdv.cbunlkwsqtzmaps.txt\n\n```\nWhen examined with file command it detects our dex file as a data file.\nWe need to fix it by removing parts do not belong to our file.\n**Dump the Memory with Custom Tools:**\nThanks to [@theempire_h we can dump regions of memory of the target app with a C](https://twitter.com/theempire_h)\nprogram.\n[https://github.com/CyberSaxosTiGER/androidDump](https://github.com/CyberSaxosTiGER/androidDump/)\nHere is how to dump a region with androidDump.\n```\nadb push androidDump /data/local/tmp\nadb shell\ncd /data/local/tmp\nchmod +x androidDump\n./androidDump appname\n\n```\nIt dumps 3 blobs of data. ‚úî\n\nBut after dumping it, `file command still do not give us the correct type üôÅ It turns out that`\nwe should modify the file a little bit. To find magic byte of dex I wrote this script.\n```\nimport binascii\nimport sys\nfilename = sys.argv[1]\nwith open(filename, 'rb') as f:\n  content = f.read()\nh = binascii.hexlify(content).split(b'6465780a')\nh.pop(0)\nh = b'6465780a' + b''.join(h)\ndex = open(sys.argv[1][:-4]+\".dex\",\"wb\")\ndex.write(binascii.a2b_hex(h))\ndex.close()\n\n```\n[https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/deDex.py](https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/deDex.py)\nAfter running our script on the file, we open it.\n\n\n-----\n\nWe found our lost classes üôÇ\n\n\n-----\n\n**Statically:**\nHere is a blog post explaining unpacking process from a different perspective.\nhttps://sysopfb.github.io/malware,/reverse-engineering/2018/08/30/Unpacking-AnubisAPK.html\nI found rc4 key with the help of stackTrace. But apparently searching for `^ value is a very`\nefficient way to find RC4 routines for Anubis üôÇ\nTo find rc4 key easily in JADX, here is quick tip:\n\nsearch ‚Äú% length‚Äù\nright click to method you are in, press find Usage\nbArr2 will be used as rc4 key to decrypt.\n\nHere is our sample‚Äôs decryption key as bArr2 . Does it look familiar?\n\nWith bArr2, we can decrypt the encrypted file from images folder of the APK. Here is a\nsnippet for decrypting the file with bArr2 . Script takes 2 parameters, bArr2 and the encrypted\nfile. For our case it is mediumcrop. APK files can be simply unzipped to access the content\nof it. ‚úî\n\n[https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/anubis_manual.py](https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/anubis_manual.py)\n\nAfter decrypting and unzipping, we get our dex.\n\n\n-----\n\nAfter extracting the config, there is one more step to get the address of c&c server. Malware\ngets page source of the telegram address and changes Chinese characters with ASCII\nletters. It then processes the base64 string. After decoding base64, it uses `service to`\ndecrypt data that encrypted with rc4 scheme. Here is a snippet for decrypting Chinese chars\nto c&c addresses.\n\n[https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/solve_chinese.py](https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/solve_chinese.py)\n\n\n-----\n\nI managed to decrypt the Anubis payload with Androguard without running the APK in an\nemulator! After dumping the dex file, my script will find the config class printing the c2 and\nthe encryption key. Config class is in one of the `a,b or c or in` `ooooooooooooo{0,2}o`\nclasses in newer versions.\nBy checking counts of ‚Äúthis‚Äù keywords in class source code I managed to decrypt all versions\nof anubis (lazy :P). Here is output of my script to get c2 and key from an Anubis sample.\n[https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/getc2_imp.py](https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/getc2_imp.py)\n\n### Conclusion\n\nThere are many ways to unpack mobile malware and trace packing mechanisms. We might\nsee `dalvik.system.InMemoryDexClassLoader used in the future. If this is used, delete`\nhooks will not be able to catch dropped files because everything will be done in memory üôÇ\nBut dumping memory will catch these methods. Knowing different ways always helps. If you\n[have any question feel free to ask in comment section or through @0xabc0](https://twitter.com/0xabc0)\n\nCheers.\n[Special thanks to @godelx0](https://twitter.com/godelx0)\n\n\n-----\n\n### Links & References\n\nDropper sample:\n\n[3c35f97b9000d55a2854c86eb201bd467702100a314486ff1dbee9774223bf0e](https://koodous.com/apks/3c35f97b9000d55a2854c86eb201bd467702100a314486ff1dbee9774223bf0e)\n\nAnubis sample:\n\n[e01ed0befbc50eeedcde5b5c07bf8a51ab39c5b20ee6e1f5afe04e161d072f1d](https://koodous.com/apks/e01ed0befbc50eeedcde5b5c07bf8a51ab39c5b20ee6e1f5afe04e161d072f1d)\n\n[https://codeshare.frida.re/@razaina/get-a-stack-trace-in-your-hook/](https://codeshare.frida.re/@razaina/get-a-stack-trace-in-your-hook/)\n\n[https://www.fortinet.com/blog/threat-research/defeating-an-android-packer-with-frida.html](https://www.fortinet.com/blog/threat-research/defeating-an-android-packer-with-frida.html)\n\n[https://medium.com/@fs0c131y/reverse-engineering-of-the-anubis-malware-](https://medium.com/@fs0c131y/reverse-engineering-of-the-anubis-malware-part-1-741e12f5a6bd)\n\n[part-1-741e12f5a6bd3](https://medium.com/@fs0c131y/reverse-engineering-of-the-anubis-malware-part-1-741e12f5a6bd)\nAll materials:\n\n[https://github.com/eybisi/nwaystounpackmobilemalware](https://github.com/eybisi/nwaystounpackmobilemalware)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-03-13 - N Ways to Unpack Mobile Malware.pdf"
    ],
    "report_names": [
        "2019-03-13 - N Ways to Unpack Mobile Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536077,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653689576,
    "ts_modification_date": 1653689576,
    "files": {
        "pdf": "https://archive.orkl.eu/a49b789ce17a4bfbf975594313ca0b9b51ed3470.pdf",
        "text": "https://archive.orkl.eu/a49b789ce17a4bfbf975594313ca0b9b51ed3470.txt",
        "img": "https://archive.orkl.eu/a49b789ce17a4bfbf975594313ca0b9b51ed3470.jpg"
    }
}