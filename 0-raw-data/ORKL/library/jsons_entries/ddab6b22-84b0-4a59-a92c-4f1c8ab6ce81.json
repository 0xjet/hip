{
    "id": "ddab6b22-84b0-4a59-a92c-4f1c8ab6ce81",
    "created_at": "2022-10-25T16:48:12.56255Z",
    "updated_at": "2025-03-27T02:14:02.577917Z",
    "deleted_at": null,
    "sha1_hash": "70ee75103d9fc301b7638712ba13c86014b8a0ad",
    "title": "WINNTI Analysis",
    "authors": "Novetta",
    "file_creation_date": "2015-04-06T13:47:05Z",
    "file_modification_date": "2015-04-06T13:47:06Z",
    "file_size": 256583,
    "plain_text": "# WINNTI\n ANALYSIS\n\nAs part of Operation SMN, Novetta analyzed recent versions of the Winnti malware. The samples,\n\ncompiled from mid- to late 2014, exhibited minimal functional changes over the previous generations\nKaspersky reported in 2013.[1 ]What is of note, however, is the increased scrutiny found within the Winnti\ndropper component that attempts to frustrate analysis of the malware.\n\nBased on multiple active compromises by the Axiom threat group, Novetta was able to capture and\nanalyze new Winnti malware samples. It should be noted that operators of Winnti that were observed\nby Novetta leveraged existing Axiom-specific malware infections (Hikit) to move laterally and install\nWinnti in the furtherance of their objectives. It is with high confidence that we assess the operators\n\nof Winnti in these monitored environments were not the same actors who originally installed and\nleveraged Hikit.\n\nThis report will focus on three different aspects of the Winnti malware: the start-up sequence of\n\nWinnti from the initial infection to steady state, the basics of the Winnti malware, and the command\n\nand control (C2) communication protocol.\n\nFROM INSTALLATION TO EXECUTION\nThe installation process of Winnti by means of the dropper has changed very little since the Winnti\n\nversion 1.1 (as defined by Kaspersky) droppers of July 2012. The samples Novetta obtained from the\nactive Axiom infection were compiled in mid- to late 2014 and represent what Novetta is referring to\nas version 3.0 of the Winnti lineage (in order to prevent muddying the versioning scheme Kaspersky\nhas already established).\n\nThere are four distinct components within the Winnti malware’s installation to execution cycle: a\n\ndropper, a service, an engine, and a worker. The installation that Novetta observed of Winnti on\na victim’s machine requires multiple steps and depends on the dropper, service, and the loader\ncomponent in order to accomplish the steps. After a successful infection, the activation of Winnti\non a victim’s machine requires multiple steps as well as coordination between the service, engine,\nand worker components. The complexity of the installation and activation processes is significant\nand more involved than typical malware installation and activation procedures. This additional\ncomplexity ultimately does not seem to serve a significant purpose other than to perhaps frustrate\nanalysis by defenders.\n\n_1 \u0007Kaspersky. “Winnti: More than just a game”. http://kasperskycontenthub.com/wp- content/uploads/sites/43/vlpdfs/winnti-more-than-just-a-_\n\n_game-130410.pdf. 10 April 2014._\n\n\n-----\n\nINSTALLATION PHASE 1: DROPPER ACTIVITIES\nThe dropper is, as the name implies, the component responsible for dropping the Winnti malware on\n\na victim’s machine. The dropper performs the following activities (with version- specific annotation):\n\n1. \u0007 \u0007[version 3.0] The dropper verifies the existence of a single parameter on the command line and\n\nterminates if the parameter is not found. The dropper later uses this parameter as a decryption key.\n\n2.\u0007 \u0007The dropper loads CreateProcessA via a call to GetProcAddress.\n\n3. \u0007The dropper extracts an embedded data blob, decrypts the data blob, and decompresses the data\n\nblob into a heap buffer.\n\nThe data blob in step 3 begins with a header structure that describes key attributes of the data blob.\nThe format of the header is as follows:\n\n**OFFSET** **SIZE** **DESCRIPTION**\n\n0x0 8 Magic bytes “Tunnel\\0\\0”\n\n0x8 2 Unknown\n\n0xA 4 Size of the blob after decompression\n\n0xE 4 Size of the blob prior to decompression (current size in memory)\n\nIn order to decrypt the data blob, the dropper will iterate over each of the bytes that follows the header\n(up to the value specified in 0xE offset of the header), XOR the bytes by 0x36, and then perform a\n\nnibble swap, ZLib-compressed data immediately follows the header. The dropper will allocate a heap\nbuffer (with a size specified by the value in offset 0xA of the header) and call the ZLib inflate function.\n\nThe decompressed data blob contains a second header, and the blob’s header consists of the following\n\ntwo entries:\n\n**OFFSET** **SIZE** **DESCRIPTION**\n\n_0x0_ _4_ _Offset of worker component’s image (generally 0 and unused)_\n\n_0x4_ _4_ _Offset of server component’s image_\n\n4. \u0007The dropper uses the value in offset 0x4 of the decompressed data blob’s header to determine the\n\nsize of the worker component’s size and writes that many bytes of the decompressed data blob,\nstarting after the header, to a file within %TEMP%. The file has a random name, but the extension is\nalways .tmp.\n\n5. \u0007[version 3.0] The remaining bytes within the decompressed data blob are decrypted using what\n\nappears to be DES encryption and the key the attacker provided via the first argument on the\ncommand line.\n\n6. \u0007 \u0007The dropper generates another randomly named file within %TEMP% with the file extension\n\nof .tmp with the remaining bytes within the decompressed data blob. This file becomes the\nservice component.\n\n\n-----\n\nThe decryption of the service component is a new feature within the version 3.0 lineage of\n\nWinnti and provides the benefit of preventing defenders from attempting to run the dropper\n\nfor analysis purposes.\n\n7. \u0007[version 3.0] The presence of the MZ magic bytes in the first two bytes of the service component\n\nare verified to ensure that the file was properly decrypted (and by extension, to verify that the\nsupplied password was correct). If the MZ bytes are not found, the dropper quietly terminates.\n\n8. \u0007[version 3.0] The filenames and paths of the service and worker components are appended to the\n\nend of the worker component’s file in a structure 520 byte array. The irst 260 bytes contain the\nfilename and path of the worker component, and the last 260 bytes contain the filename and path\nof the service component. The entire 520 byte array is encrypted by XOR’ing each byte with 0x99.\n\n9. \u0007The service component’s file is scanned for the tag Coopre. If this tag is located, the dropper\n\ndecrypts the configuration data blob attached to the end of the dropper’s executable and\nappends the data to memory immediately followed the Coopre magic byte. The dropper will then\nappend the filenames and paths of the service and worker components to the end of the worker\ncomponent’s file in a structure 520 byte array. The first 260 bytes contain the filename and path\nof the worker component, and the last 260 bytes contain the filename and path of the service\ncomponent. The entire 520 byte array is encrypted by XOR’ing each byte with 0x99.\n\n10. \u0007The dropper instructs the service component to complete the installation by using rundll32 to\n\nactivate the service component’s Install [pre-version 3.0] or DlgProc [version 3.0] function.\n\nThe service component is self-installing when an attacker (or the dropper) activates the Install\n\nor DlgProc export functions. Install or DlgProc requires the full name and path of the dropper\ncomponent. The service component can locate the worker component based on the appended\nfilename and path strings located at the end of itself. Once the dropper calls CreateProcessA to\nactivate rundll32, the dropper’s task is complete, and it quietly terminates. At this point, it is up to\nthe service component to continue to install and, eventually, to activate the Winnti malware.\n\nINSTALLATION PHASE 2: SERVICE ACTIVITIES\nThe service component is at its core an unsophisticated scaffold whose job is to activate the engine\n\ncomponent. The distinction between pre-version 3.0 Winnti variants and version 3.0 variants is most\nevident in the versions’ service components. As a result of the larger difference in procedure between\nthe pre-version 3.0 and version 3.0 variants, the discussion on the Installation Phase 2 sequence will\nfocus on only the version 3.0 service component.\n\nThe service component has only two functions: activate the installer functionality of the engine\n\ncomponent or respond as a service DLL and activate the engine component’s malware start-up\nroutines. Both modes of the service component have a common initialization sequence:\n\n1. \u0007DllMain, upon activation, manually loads the engine binary into memory.\n\n2. \u0007The exports from the engine component (Install, DeleteF, and Workman) are loaded into a\n\nmemory structure.\n\n\n-----\n\nThe engine component exists as a data blob within the service component. The executable image\n\nof the engine component contains a stripped-down PE/COFF header that is missing several key\nattributes, such as the MZ and PE magic bytes as well as the CPU architecture identifier. These missing\npieces require the service component to manually load the engine component’s executable image into\nmemory. This includes allocating the appropriate memory, loading the sections appropriately, applying\nlocation fix-ups, and loading the necessary imports. The advantage of going to this much effort from\n_an attacker’s perspective is that the engine, which is responsible for loading the worker, never_\n_touches the disk, thus depriving analysts of a necessary component for analysis when using file-based_\n_artifact collection techniques._\n\n3. \u0007The service component determines if the host binary responsible for the service component\n\nis either svchost.exe (if run as a service) or rundll32.dll (if loaded pseudo manually or from\nthe dropper).\n\n4. \u0007If neither host executable is found, the Install function of the engine is activated. Otherwise,\n\nthe DllMain function returns with a success status.\n\n5. \u0007Within the DlgProc function, the service will verify the non-NULL status of the DeleteF function\n\npointer. If the function pointer is non-NULL, the DeleteF function (of the engine) is called.\n\n6. \u0007The DlgProc function next verifies that the Install function pointer is non-NULL and, if the\n\npointer is indeed non-NULL, calls the engine’s Install function after supplying the path of the\nservice executable.\n\nOnce the service component passes control to the engine component’s Install function, the service\ncomponent becomes little more than a placeholder. The service component will remain active only so\nlong as the Install function is active. The engine component then becomes the active component\nand will conclude the installation process.\n\nINSTALLATION PHASE 3: ENGINE ACTIVITIES\nThe engine component exists only in memory and is completely dependent on the service component\n\nremaining active in order to have a process space in which to operate. The installation functionality\nfor the version 3.0 Winnti malware variants exists within the Install export. When activated, the\nInstall export requires a full filename and path back to the service binary.\n\n1. \u0007The Install function checks if the process responsible for calling the Install function\n\nis explorer.exe. If so, the function uses a variant of the sysprep User Account Control (UAC) bypass.[2]\n\n2. \u0007The current privilege level of the process is verified to be suitable for installing additional binaries.\n\nThe test consists of determining if the operating system is newer than Windows XP and if the\n\nprocess has administrative privileges. If these conditions are met, the dropper is called again from\nexplorer.exe.\n\nThe authors went to great pains to ensure that the installation process had a suitable chance of\n\nperforming its function both undetected (by using a UAC bypass) and with suitable privileges. The use\nof the sysprep UAC bypass and the verification of process privileges indicate that the authors were at\nleast aware of the changing security environment in later versions of Windows and were adapting to\nensure the successful propagation of their tools on a victim’s machine.\n\n_2 \u0007K. Kleissner. “UAC Bypass for Windows 7 RTM, SP1/ Windows 8 DP, CP all 32-bit for admin with default UAC settings”. http://download.pureftpd._\n\n_org/pub/misc/UAC.cpp. Accessed 1 December 2014_\n\n\n-----\n\n3. \u0007The configuration information implanted at the end of the service component is extracted\n\nand decrypted.\n\nThe configuration information for the infection typically exists at the very end of the service\n\nconfiguration. The last DWORD of the file contains an offset from the end of the file to the beginning\nof the configuration. The structure of the configuration is as follows:\n\nstruct ScheduleEntry\n{\n\n__int16 wDayOfWeek;\n__int16 wStartTime;\n__int16 wEndTime;\n};\n\nstruct Config\n{\n\nchar szC2[100];\nchar szCampaignID1[32];\nchar szCampaignID2[32];\nchar szCampaignIDNumber[24];\nDWORD unknown0;\nDWORD unknown1;\nDWORD unknown2;\nDWORD dwCommMode;\nDWORD dwProxyType;\nchar szProxyServer[32];\nchar szProxyUser[32];\nchar szProxyPassword[32];\nScheduleEntry arrActivePeriods[7];\nDWORD iReconnectTime;\n};\n\nThe configuration is encrypted using a rolling XOR with the first byte of the XOR being 0x99.\nThe XOR increments one byte at a time until a wraparound occurs at 0xFF.\n\n4. \u0007The files %SYSDIR%\\wmtsk.dll and %SYSDIR%\\wmm2.dat are checked to ensure that they do not\n\nexist and that they are not directories. If either condition is not met, an INI file named %SYSDIR%\\\notfkyt.dat is generated with the UPDATE section containing File={path to service component\nDLL} and the process terminates.\n\n5. \u0007A global event named Global\\ 5164FDA21542C0EB638BA110F9F3ADAF establishes a poor man’s\n\nmutex, indicating that the installation process is currently ongoing. To give other processes time to\nread the event check, a 12-second delay is introduced before continuing the installation process.\n\n6. \u0007The service component is copied from the %TEMP% directory to %SYSDIR%\\wmtsk.dll, and the\n\nworker component is copied from the %TEMP% directory to %SYSDIR%\\wmm2.dat.\n\n7. \u0007The timestamps of both wmtsk.dll and wmm2.dat are set to match that of cmd.exe.\n\n8. \u0007The original %TEMP% instances of the worker and service DLLs are deleted.\n\n\n-----\n\n9. \u0007The configuration is appended to the wmtsk.dll file using the same rolling XOR (starting with\n\nthe value 0x99).\n\nThe bulk of the installation of Winnti is now complete. The dropped files are now in the correct\n\nlocation and ready for activation. The final steps of the installation establish the persistence model for\nthe malware and begin the activation of the malware on the victim’s system.\n\n10. \u0007A new service entry is manually added to the registry to ensure the malware will activate upon\n\nreboot of the victim’s machine. The new service is named wind0ws, with a display name of\nautomaticallyssl and the description of Monitoring of hardwares and automatically\nupdates the device drivers.\n\n11. \u0007WinExec is used to call the command net start wind0ws.\n\n12. \u0007The installation completes by returning control to the service component, which terminates quietly.\n\nThe service that the engine component installs runs under the svchost.exe executable as a netsvc.\nThe engine will directly modify the registry after using the CreateServiceA function to establish the\n\nbasics of the new service. The use of direct registry modifications to entries under the LOCAL MACHINE\n(HKLM) hive requires elevated privileges, which may explain why the authors went to such great pains\n\nto ensure the installation process occurred in a suitable process space.\n\nACTIVATION PHASE 1: SERVICE ACTIVITIES\nActivation of the Winnti malware begins whenever the service component is activated. Typically,\n\nactivation is the result of the registered service (e.g., wind0ws) being activated by either a reboot\nof the victim’s machine or by the net start command being issued during the final phase of the\ninstallation process. In either case, the DllMain function is called prior to the ServiceMainEx function\nof the service component being called by Windows, thus kicking off the activation of the Winnti\nversion\n3.0 malware.\n\n1. \u0007The DllMain function, upon activation, manually loads the engine binary into memory.\n\n2. \u0007The exports from the engine component (Install, DeleteF, and Workman) are loaded into a\n\nmemory structure.\n\n3. \u0007The service component determines if the host binary responsible for the service component\n\nis either svchost.exe (if run as a service) or rundll32.dll (if loaded pseudo-manually or from\nthe dropper).\n\n4. \u0007If neither host executable is found, the Install function of the engine is activated. Otherwise, the\n\nDllMain function returns with a success status.\n\nWith the initialization of the service component’s DLL complete, Windows calls the ServiceMainEx\n\nfunction to activate the service. The ServiceMainEx function, like the DlgProc function, is extremely\nlightweight in its functionality.\n\n5. \u0007The ServiceMainEx function registers a service handler function to respond to service status\n\ncontrol requests from Windows.\n\n6. \u0007The service is set to the Running state.\n\n\n-----\n\n7. An unnamed event is created.\n\n8. \u0007The engine’s Workmain function is called with both the path to the host executable (the service\n\nDLL) and the name of the service supplied as parameters.\n\n9. \u0007A sleep of 3 seconds occurs before the function waits indefinitely for the unnamed\n\nevent to become set.\n\nThe ServiceMainEx function does little more than establish a basic scaffold for activating the\n\nWorkmain function of the engine component. The service remains active, thus providing a process\nspace for the engine, until the unnamed event is set. The unnamed event becomes set only after the\nservice receives the SERVICE_STOP signal from Windows.\n\nAfter the service component calls the Workmain function of the engine component, the engine\n\ncomponent picks up the baton to complete the next phase of the activation sequence.\n\nACTIVATION PHASE 2: ENGINE ACTIVITIES\nThe engine component’s Workmain function, much like the service’s ServiceMainEx function, provides\n\na scaffolding for the next phase of the activation. In this case, that next phase is dependent on the\nworker component.\n\n1. \u0007The Workmain function determines if an active activation thread exists within the process. If so, the\n\nWorkmain function simply returns to avoid activating two or more concurrent instances of Winnti\nunder the same process space.\n\n2. \u0007The configuration is extracted from the service component based on the filename and path\n\nsupplied to the Workmain function from the ServiceMainEx function. If the configuration extraction\nfails, the filename and path of the service DLL is gleaned from the ServiceDLL registry value for\nthe service, and the configuration is extracted from that file.\n\n3. \u0007The path to the worker component (e.g., %SYSDIR%\\wmm2.dat) is extracted from the service\n\ncomponent’s file.\n\n4. \u0007A new thread responsible for the activation of the worker and engine components is generated.\n\n5. The Workmain function returns.\n\nWorkmain is a very simple function with a singular purpose: collect the data needed to locate the\nnecessary components for activating Winnti on the victim’s system. With the necessary information\nfound, a new thread is generated that allows the service component to decouple from the worker\ncomponent’s functionality. Had this not occurred, the service component would not be able to\nrespond to Windows status requests, and the service would have appeared to be hung, causing\nWindows to terminate the service.\n\nThe activation thread generated within the Workmain function loads the worker component,\n\nactivates the worker component, and provides a thread independent of the service’s thread under\nwhich to execute.\n\n6. \u0007The path to the worker component’s file is verified to exist. If the worker component’s file does not\n\nexist, the activation process terminates immediately.\n\n\n-----\n\n7. \u0007The worker component is loaded into memory.\n\n8. \u0007The worker component’s work_start function is called.\n\nThe worker component’s executable image is encrypted. As part of the loading process, the engine\n\nmust XOR each byte of the worker component’s file with the value 0x36 and perform a nibble swap.\nThe worker component’s executable image suffers from the same malformed PE/COFF header that the\n\nengine component’s image exhibits. As a result of the malformed PE/COFF header and the encrypted\nfile image, the engine must manually load the worker component’s image into memory in exactly the\nsame manner that the service component loaded the engine component manually into memory.\n\nThe work_start function is the true beginning of the Winnti malware. The work_start function\n\nperforms the various Remote Administration Tool (RAT) initialization functions of Winnti before\nactivating the communication subsystem of Winnti. The result of calling the work_start function\nis the completed activation of Winnti and placing the system in a steady-state mode of C2 server\nrequests and response actions. Once the work_start function initializes the Winnti malware, a new\nthread is generated to house the Winnti RAT functionality, allowing the work_start function to return\ncontrol back to the activation thread within the engine component.\n\n9. \u0007Upon completion of the work_start function, the activation thread sleeps for 30 seconds before\n\nentering an infinite loop.\n\n10. \u0007The loop begins by verifying that the global event established during the installation process\n\n(Phase 3, step 5) does not exist. If the event exists, the loop is broken, the event is set, the Winnti\n\nmalware shuts down by means of a net stop command, and the service and worker component\nfiles are deleted.\n\n11. \u0007The presence of the %SYSDIR%\\otfkty.dat file is checked, and if the file does not exist, control\n\nreturns to the top of the loop (step 10).\n\n12. \u0007The %SYSDIR%\\otfkty.dat file is read as an INI file, the filename specified by the File variable\n\nunder the UPDATE section is read, and the otfkty.dat file is deleted from disk if the file specified\nby the File variable exists and is not a directory.\n\n13. \u0007If the worker has a work_end export, the work_end function is called.\n\n14. \u0007The configuration of %SYSDIR%\\wmtsk.dll is loaded into memory.\n\n15. \u0007If %SYSDIR%\\sysprep\\cryptbase.dll exists, the file is deleted.\n\n16. \u0007The worker component’s file is deleted from disk.\n\n17. \u0007The file specified by otfkty.dat’s File variable is copied to the filename of the worker\n\ncomponent’s file.\n\n18. \u0007The timestamp of the new worker component file is set to that of cmd.exe’s timestamp.\n\n19. \u0007The file specified by otfkty.dat’s File variable is deleted.is deleted.\n\n20. \u0007After sleeping for 3 seconds, the new worker component’s image is loaded into memory, and\n\nthe new worker component’s work_start function is executed.\n\n21. \u0007Control returns to the start of the loop (step 10).\n\n\n-----\n\nThe authors of version 3.0 of Winnti use the engine’s scaffolding to allow for on-the-fly worker\n\ncomponent updating without a need to restart the service. The infinite loop listens for the\nindicator that the engine’s Install function is performing an installation (with an existing Winnti\ninstallation, this effectively becomes an update). As part of the installation process by the engine\ncomponent’s Install function, the presence of an existing service and worker component’s files\nis verified (Installation Phase 3, step 4), resulting in the generation of the %SYSDIR%\\otfkty.dat\nfile. The presence of the otfkty.dat file informs the engine’s activation thread that a new worker\ncomponent is available and should be loaded. As a result, the engine cleanly shuts down the existing\nworker component by calling its work_end function, deletes the old worker, and replaces the worker\ncomponent’s file before loading and executing the new worker component. The beauty of this\n_approach is that not only does it allow hot patching of the malware but it does so without restarting_\n_the service, which could indicate an erroneous system event to an astute systems administrator._\n\nTHE BASICS OF WINNTI’S WORKER\nThe Winnti worker component is an exercise in over engineering. As with the other components\n\nwithin the Winnti system, such as the service and the engine, the worker component is a scaffold for\nadditional functionality. Unlike the service and engine components, the scaffolding provided by the\nworker component is substantial and complex, but at its core, the worker component has two primary\nfunctions: communication interface and plugin management.\n\nThe communication subsystem of the worker module supports three communication protocols,\n\nbut the framework is developed in such a way that adding additional protocols requires little more\nthan adding a different communication mode module to the source code at compile time. The\ncommunication subsystem in the samples analyzed by Novetta includes three modes: custom TCP\nprotocol (used when Config.dwCommMode is set to 1), encapsulation within HTTP (used when Config.\ndwCommMode is set to 3), and encapsulation within HTTPS (used when Config.dwCommMode is set to\n2). To further expand the reach of the HTTP and HTTPS modes, the HTTP and HTTPS modes can\n\nutilize a proxy local (or potentially external) to the victim’s computer. In order to support a variety\nof different communication protocols and methods, the communication subsystem relies heavily on\ncallback functions. For instance, when a communication module (be it the custom TCP protocol, HTTP,\nHTTPS, or some other type) initializes, it supplies a series of callback functions to the communication\nsubsystem. The callback functions provide hooks to the communication subsystem for handing off\nimportant communication events.\n\nFigure 1 illustrates the worker component using the Connection:SetConnectivityCallbacks\nfunction to register callback functions that handle the following series of events.\n\n1. When a new connection occurs (ncOnConnect_callback)\n\n2. When data is received over the network connection (ncOnRecvData_callback)\n\n3. When the connection terminates by the socket closing (ncOnDisconnect_callback)\n\n4. \u0007When the other end of the connection disconnects, but has not closed, the connection\n\n(ncOnClientDisconnect_callback)\n\n_Figure 1: Setting Callbacks for the Custom TCP Protocol Communication Mode_\n\n\n-----\n\nBy using callbacks, it is relatively easy for the authors of the Winnti malware to add new\ncommunication protocols without making significant changes to the source code. There is, however,\nthe question as to why the authors chose to use a callback scheme for this purpose instead of a more\nmodern object-oriented approach, such as using derived classes in C++.\n\nThe callbacks within the communication subsystem cloud an important aspect of the nature of\n\nthe communication within Winnti: the communication subsystem is largely asynchronous. The\ncommunication subsystem allocates a thread solely for listening to incoming data, determining to\nwhich channel the data belongs, queuing the data in a series of network queue structures, and alerting\nthe communication subsystem that the ncOnRecvData_callback (or equivalent) callback should\nbe called to address the incoming data. This allows the sending of data from the communication\nsubsystem to decouple the receiving of data from the communication subsystem thereby providing\nasynchronous data streams. The fact that the data streams are decoupled does introduce some\ncomplexity, as it is up to the higher layers of the data stream to reassemble the data in the appropriate\nform for whatever task to which the data applies. Evidence suggests, however, that despite the fact\nthat sending and receiving data is asynchronous within the communication subsystem, in practice the\ndata follows a standard request-and-reply model in which the Winnti malware makes a request over the\nnetwork and then waits for a reply before repeating the sequence.\n\nBy itself, the worker component does very little. It does not have any built-in RAT functionality such as\nfile management, remote command shell interaction, network monitoring, or other features common to\nmalware that falls within the RAT category. Similar to the way that PoisonIvy provides only a framework\nand requires at-runtime modules to perform RAT functions, Winnti must load a plugin for each desired\nRAT (or class of RAT) feature. These modules, which internally the authors refer to as “Plus” modules,\nare basic plugins that the worker component is responsible for maintaining.\n\nIt would be a poor design for the malware to request a download of code for each RAT function\nthat an attacker wishes to use. The amount of extraneous data would be excessive and would make\nthe malware’s traffic more prone to detection, as plugins are usually a minimum of several tens of\nkilobytes each. The authors of Winnti compensate for this by caching plugin modules in memory\nand possibly on disk. Whenever a new module is loaded into the victim’s machine by virtue of a\ndownload from the C2 server, the plugin is stored, loaded into memory, and registered with the plugin\nsubsystem, which allows the communication subsystem to pass requests to the plugins from that\npoint on. Optionally, as part of the integration of the plugin into the Winnti malware, the attacker can\nrequest that a copy of the plugin be stored within the %PROGRAMFILE%\\Microsoft Shared\\MSInfo\\\nen-US\\ directory, which will allow the worker component to load the plugin automatically whenever\nthe Winnti malware restarts; however, storing a plugin is not mandatory. It is entirely possible that the\nattacker may specify that the plugin should exist in memory only as long as the malware is active. This\nprevents disk based forensics from detecting the plugins and limits the availability of data for analysis\nto determine what code may have executed on a victim’s machine.\n\nPlugins are architecture dependent, but the authors of Winnti make no special effort to ensure that\nonly 64-bit plugins run on 64-bit variants of Winnti or that only 32-bit plugins run on 32-bit variants.\nPlugins are DLLs with their PE/COFF headers manipulated (like the engine and worker components)\nto make them unloadable by standard Windows Application Programming Interface (API) functions,\ntherefore requiring that the plugin manager manually load the plugins. A plugin information header\nprecedes the modified PE/COFF header. The plugin information header (PluginEntry), as seen\nbelow, contains information defining attributes about the plugin, such as its architecture (64 or 32bit), the size of the plugin’s image, the entry point function, the version of the plugin, and, most\nimportantly, the identification number of the plugin.\n\n\n-----\n\nstruct PluginEntry\n{\n\nDWORD dwPluginID;\nDWORD Version;\nDWORD ArchitectureType;\nDWORD unknown;\nDWORD dwPluginSize;\nDWORD dwEntryFunctionNameHash;\nDWORD fLoaded;\nvoid *pPluginImage;\nint (__stdcall *pfnEntryPoint)\n(void *incomingData, int (__cdecl\n\n**pfnNetDataSend)(PacketHeader *));\n\n};\n\nThe identification number of the plugin (dwPluginID) is the value that allows the communication\n\nsubsystem to direct incoming requests to the appropriate plugin. The plugin manager itself supports\nonly the following three commands from the communication subsystem:\n\n**COMMAND ID** **DESCRIPTION**\n\n_0x12_ _Unknown purpose_\n\n_0x14_ _Send a list of plugins currently registered to the C2_\n\n_0x15_ _Add a new plugin to the active Winnti malware with an option to save the plugin to disk_\n\nIf a command coming from the communication subsystem does not match one of the plugin\nmanager’s commands, the RemoteLib:CallPlusList function is called to redirect the data packet to\nthe appropriate plugin or return an error to the C2 server.\n\nCOMMUNICATION SCHEME\nRegardless of the communication model currently active for a Winnti instance, the underlying\ncommunication remains constant. Each datagram that originates from or is destined for the C2 server\nhas the following predefined header structure:\n\nstruct PacketHeader\n{\n\nDWORD dwTickCount; WORD cmd;\nDWORD unknown;\nDWORD dwPayloadSize;\nDWORD dwStreamID;\n};\n\nThe format of the data that follows the\n\nPacketHeader is cmd dependent. The cmd field allows the communication subsystem to route the\nrequest to the appropriate plugin by using the plugin manager to match the cmd value with the\ndwPluginId value. The worker component allows a maximum datagram size of 261120 bytes. To\naccommodate data streams larger than the maximum datagram size, the stream can be chunked.\n\n\n-----\n\nThe dwStreamID value is used to reassemble the streams by appending datagrams with the same\n\ndwStreamID together. The dwPayloadSize field defines the number of bytes within the datagram.\nThe protocol that the worker component uses to transmit the PacketHeader and the optional payload\n\nof the datagrams can and will add additional complexity to the network traffic. The custom TCP\nprotocol and the HTTP and HTTPS communication modes each deliver the datagrams differently. The\nHTTP and HTTPS communication modes will generate POST requests to the C2 server (typically to /\nindex.htm) with the datagram (compressed using Zlib) as the body of the POST.\n\nThe custom TCP protocol uses a combination of encryption and compression to transfer the\n\ndatagrams. The custom TCP protocol uses a stacked approach to transforming the data. First,\nthe datagram, which makes up the payload of the custom TCP protocol, is typically compressed\nwith LZMA. The compressed payload is appended to the following header specific to the custom\nTCP protocol:\n\nstruct TCPProtocolHeader\n{\n\nDWORD magic;\nDWORD flags;\nDWORD dwXORKey;\nQWORD crc64;\nDWORD dwCompressedSize;\nDWORD dwPacketSize;\n};\n\nThe magic value is 0xACED1984. The flags value will specify if the datagram is compressed or not.\nThe dwXORKey value is initialized to zero. The crc64 value for the datagram (prior to compression)\n\nis stored in crc64. The size of the compressed payload is recorded in dwCompressedSize while the\noriginal size of the datagram is stored in dwPacketSize.\n\nThe final transformation prior to transmission for the custom TCP protocol involves encrypting the\n\nentire packet. A 32-bit value is generated (by calling GetTickCount) and used as the DWORD XOR\nkey. Each DWORD within the packet is then XOR’d with the key. Given that the dwXORKey field of\nthe TCPProtocolHeader was initialized to zero and exists on a DWORD boundary, the XOR key is\nrecorded within the dwXORKey field. A successful decryption is determined by XOR’ing the magic and\ndwXORKey fields to produce the 0xACED1984 value.\n\nCODE REUSE\nThe authors of Winnti are clearly proponents of the open-source software movement, as large chunks\n\nof the worker binary consist of open-source software packages. The authors statically linked in the\nOpenSSL library (version 0.9.8x),[3] the LZMA compression library,[4] the nedalloc memory allocation\n\nlibrary,[5] and the Zlib library (version 1.2.7).[6] As for the part of the code that generates the unique\nidentifier for the victim’s computer, the authors of the worker component lifted the code DISKID32,[7]\nwhich is an open-source utility for reading the manufacturer data from a hard drive. The DISKID32\npackage is a surprisingly obscure piece of software from a company in Texas that writes an industrial\nprocess simulator that has “over 1,000 active users.”[8]\n\n_3 ftp://ftp.openssl.org/source/old/0.9.x/openssl-0.9.8x.tar.gz. 10 May 2012._\n_4 \u0007http://sourceforge.net/projects/sevenzip/files/LZMA%20SDK/lzma922.tar.bz2/download. 18 April 2010. 5 Niall Douglas._\n\n_“nedalloc Homepage”. http://www.nedprod.com/programs/portable/nedmalloc/. 5 December 2014._\n_6 Jean-loup Gailly and Mark Adler. “zlib”. http://zlib.net/. 26 March 2014._\n_7 WinSim, Inc. “DISKID32 (FREEWARE)”. https://www.winsim.com/diskid32/diskid32.html. Accessed 1 December 2014._\n_8 WinSim, Inc. “About WinSim”. https://www.winsim.com/index.html. Accessed 1 December 2014._\n\n\n-----\n\nThe basis for the worker component is a library called RemoteLib. Some earlier variants of\n\nversion 3.0 of Winnti contain debugging output that references the RemoteLib library. RemoteLib\ndoes not appear to be a publically available piece of software but does appear to be actively\nmaintained, as evident by the gradual refinements seen between the 32-bit and 64-bit variants\nof version 3.0 of Winnti.\n\nThe compilation of the full OpenSSL library into the worker component solely for implementing HTTPS\n\nresults in a significant size increase. Approximately 60 percent of the worker component is made up of\nOpenSSL functions when only a small fraction (less than 1 percent) of the OpenSSL library is actually\nused by the worker component.\n\nDETECTION\nDetecting Winnti via standard IDS signatures or network traffic inspection is not a straightforward\nprocess whenever the malware is configured to use HTTPS or the custom TCP protocol due to the\nuse of encryption. However, more advanced network based behavioral analytic capabilities as well as\nhost-based indicators do exist that can alert a security team or systems administrator to the presence\nof Winnti.\n\nThe version 3.0 variants of Winnti attempt to install themselves as a service with the\n\nfollowing characteristics:\n\n**SERVICE NAME** WIND0WS\n\n**SERVICE**\nautomaticallyssl\n**DISPLAY NAME**\n\n**SERVICE**\nMonitoring of hardwares and automatically updates the device drivers\n**DESCRIPTION**\n\nFrom a file system perspective, it is possible to identify Winnti infections by looking for the following\nfilenames:\n\n- %SYSDIR%\\otfkty.dat\n\n- %SYSDIR%\\wmtsk.dll\n\n- %SYSDIR%\\wmm2.dat\n\nGiven that Winnti will alter the time stamp of files to match that of the victim’s cmd.exe file, looking for\nfiles with the exact same time as the victim’s cmd.exe may identify other foreign files on the victim’s\nsystem that warrant inspection and possible isolation.\n\nNovetta established the following YARA signatures for detecting the various components of version\n3.0 of the Winnti malware; administrators are advised to use these signatures to help detect and\n\nremediate active version 3.0 Winnti infections.\n\n\n-----\n\nrule Winnti_Dropper\n{\n\nmeta:\ncopyright = “Novetta Solutions”\nauthor = “Novetta Advanced Research Group”\nstrings:\n$runner = “%s\\\\rundll32.exe \\”%s\\”, DlgProc %s”\n$inflate = “Copyright 1995-2005 Mark Adler”\n\ncondition:\n$runner and $inflate\n\n}\n\nrule Winnti_service\n{\n\nmeta:\ncopyright = “Novetta Solutions”\nauthor = “Novetta Advanced Research Group”\n\nstrings:\n$newmem = “new memory failed!”\n$value = “can not find value %d\\n”\n$onevalue = “find one value %d\\n”\n$nofile = “Can not open the file (error %d)”\n\ncondition:\n3 of ($newmem, $value, $onevalue, $nofile)\n\n}\n\nrule Winnti_engine {\nmeta:\ncopyright = “Novetta Solutions”\nauthor = “Novetta Advanced Research Group”\n\nstrings:\n$api1 = “SHCreateItemFromParsingName” $datfile = “otfkty.dat”\n$workstart = “work_start”\n$workend = “work_end”\n\ncondition:\n($api1 or $datfile) and ($workstart and $workend)\n}\n\nrule Winnti_worker\n{\n\nmeta:\ncopyright = “Novetta Solutions”\nauthor = “Novetta Advanced Research Group”\n\nstrings:\n$pango = “pango-basic-win32.dll”\n$tango = “tango.dll”\n$dat = “%s\\\\%d%d.dat”\n$cryptobase = “%s\\\\sysprep\\\\cryptbase.dll”\n\ncondition:\n$pango and $tango and $dat and $cryptobase\n\n}\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        },
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "http://www.novetta.com/wp-content/uploads/2015/04/novetta_winntianalysis.pdf",
        "https://app.box.com/s/tv5rhy7awdq8ecfrugcrk1d4zcce3xnq",
        "https://www.novetta.com/wp-content/uploads/2015/04/novetta_winntianalysis.pdf"
    ],
    "report_names": [
        "novetta_winntianalysis.pdf",
        "Novetta_winntianalysis(04-07-2015)"
    ],
    "threat_actors": [
        {
            "id": "cea5ceec-0f14-4e34-bd0e-4074bc1a707d",
            "created_at": "2022-10-25T15:50:23.629983Z",
            "updated_at": "2025-03-27T02:00:55.509459Z",
            "deleted_at": null,
            "main_name": "Axiom",
            "aliases": [
                "Group 72"
            ],
            "source_name": "MITRE:Axiom",
            "tools": [
                "ZxShell",
                "gh0st RAT",
                "Zox",
                "PlugX",
                "Hikit",
                "PoisonIvy",
                "Derusbi",
                "Hydraq"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "89542ecf-606b-4913-87c5-21512f9b82b9",
            "created_at": "2022-10-25T15:50:23.681673Z",
            "updated_at": "2025-03-27T02:00:55.522794Z",
            "deleted_at": null,
            "main_name": "RTM",
            "aliases": [
                "RTM"
            ],
            "source_name": "MITRE:RTM",
            "tools": [
                "RTM"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "4b076dcb-516e-42fb-9c8f-f153902cd5e9",
            "created_at": "2022-10-25T16:07:23.708745Z",
            "updated_at": "2025-03-27T02:02:09.935617Z",
            "deleted_at": null,
            "main_name": "Hidden Lynx",
            "aliases": [
                "Aurora Panda",
                "Group 8",
                "Hidden Lynx",
                "Operation SMN"
            ],
            "source_name": "ETDA:Hidden Lynx",
            "tools": [
                "AGENT.ABQMR",
                "AGENT.AQUP.DROPPER",
                "AGENT.BMZA",
                "AGENT.GUNZ",
                "BlackCoffee",
                "HiKit",
                "MCRAT.A",
                "Mdmbot.E",
                "Moudoor",
                "Naid",
                "PNGRAT",
                "Trojan.Naid",
                "ZoxPNG",
                "gresim"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "6a99bf81-8ed4-4233-82e2-575e4f9bf282",
            "created_at": "2022-10-25T16:07:24.137248Z",
            "updated_at": "2025-03-27T02:02:10.119569Z",
            "deleted_at": null,
            "main_name": "RTM",
            "aliases": [],
            "source_name": "ETDA:RTM",
            "tools": [
                "AtNow",
                "RTM",
                "RTM Banker",
                "Redaman"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5c74936a-79d1-41b8-81eb-01d03c90a26b",
            "created_at": "2022-10-25T16:07:23.371052Z",
            "updated_at": "2025-03-27T02:02:09.766782Z",
            "deleted_at": null,
            "main_name": "Axiom",
            "aliases": [
                "Group 72",
                "Operation SMN"
            ],
            "source_name": "ETDA:Axiom",
            "tools": [
                "9002 RAT",
                "Agent.dhwf",
                "AngryRebel",
                "BlackCoffee",
                "BleDoor",
                "Chymine",
                "Darkmoon",
                "DeputyDog",
                "Derusbi",
                "Destroy RAT",
                "DestroyRAT",
                "Farfli",
                "Fexel",
                "Gen:Trojan.Heur.PT",
                "Gh0st RAT",
                "Ghost RAT",
                "Gresim",
                "HOMEUNIX",
                "HiKit",
                "HidraQ",
                "Homux",
                "Hydraq",
                "Kaba",
                "Korplug",
                "McRAT",
                "MdmBot",
                "Moudour",
                "Mydoor",
                "PCRat",
                "PNGRAT",
                "PlugX",
                "Poison Ivy",
                "RbDoor",
                "RedDelta",
                "RibDoor",
                "Roarur",
                "SPIVY",
                "Sensocode",
                "Sogu",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "Winnti",
                "Xamtrav",
                "ZXShell",
                "Zox",
                "ZoxPNG",
                "ZoxRPC",
                "gresim",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "4c68ccd0-caba-4189-9ead-86ac4c2d9b70",
            "created_at": "2024-05-01T02:03:07.930196Z",
            "updated_at": "2025-03-27T02:05:17.251237Z",
            "deleted_at": null,
            "main_name": "BRONZE ATLAS",
            "aliases": [
                "Axiom",
                "BARIUM ",
                "Blackfly ",
                "CTG-2633",
                "GREF",
                "Group 72 ",
                "Red Kelpie ",
                "TG-2633 ",
                "Wicked Panda ",
                "Winnti",
                "APT41 "
            ],
            "source_name": "Secureworks:BRONZE ATLAS",
            "tools": [
                " CCleaner v5.33 backdoor",
                " ChinaChopper",
                " Cobalt Strike",
                " Dicey MSDN",
                " ForkPlayground",
                " HUC Proxy Malware (Htran)",
                " Mimikatz",
                " PipeMon",
                " PlugX",
                " PortReuse",
                " Powershell Empire",
                " RCMD",
                " RbDoor",
                " SPEEDBOAT",
                " ShadowPad",
                " Sidewalk",
                " Speculoos",
                " TeamViewer",
                " Winnkit",
                " Winnti",
                " reg save",
                " vssadmin",
                "Acehash"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716492,
    "ts_updated_at": 1743041642,
    "ts_creation_date": 1428328025,
    "ts_modification_date": 1428328026,
    "files": {
        "pdf": "https://archive.orkl.eu/70ee75103d9fc301b7638712ba13c86014b8a0ad.pdf",
        "text": "https://archive.orkl.eu/70ee75103d9fc301b7638712ba13c86014b8a0ad.txt",
        "img": "https://archive.orkl.eu/70ee75103d9fc301b7638712ba13c86014b8a0ad.jpg"
    }
}