{
    "id": "aa55fd20-d896-49c4-ac78-d0a081de3c76",
    "created_at": "2023-01-12T15:03:53.533334Z",
    "updated_at": "2025-03-27T02:16:01.217253Z",
    "deleted_at": null,
    "sha1_hash": "e02ec7e8cdab6ad43de626c0a20a069cb8f6c23b",
    "title": "2019-12-21 - Shamoon 2012 Complete Analysis",
    "authors": "",
    "file_creation_date": "2022-05-25T14:16:57Z",
    "file_modification_date": "2022-05-25T14:16:57Z",
    "file_size": 15569274,
    "plain_text": "# Shamoon 2012 Complete Analysis\n\n**malwareindepth.com/shamoon-2012**\n\n2 years ago\n\nThe whole inspiration of this blog began when I saw the above picture.\n\n\nDecember 21, 2019\n\n\nFor those that don't know, this was ASCII art embedded within a .NET dropper that supposedly\ndropped a version of Shamoon back in December of 2018. This immediately peaked my interest and\nI began my reversing of the sample. Initially I was looking for resources around this specific sample\nbut quickly found that Shamoon has a rich history and has been utilized in some very interesting\ncampaigns. So I decided I would start at its beginning and work my way through its history. At this\npoint I have almost 40 samples for the various campaigns and have reverse engineered all of them to\nvarious degrees. These samples were relatively unorganized and I needed a way to fix that. I wrote a\ntool that could categorize the samples based on various traits. The samples broke down into a couple\nof groups and after looking into a sample from each group, I identified the following campaigns:\n\nShamoon 2012\nShamoon 2016\nShamoon 2017\nShamoon 2018 v1\nShamoon 2018 v2\nShamoon 2018 v3\n\nI will try to make a post describing the capabilities of a sample in each campaign if time permits. So\nwithout further ado, lets get into Shamoon 2012.\n\n## Research Process\n\nFor this series, I decided to focus on the following goals:\n\n1. Educate users on the timeline and history of Shamoon\n2. Share IOCs and detection mechanisms\n3. Release tools that can be used to help researchers analyze samples in the future\n\n\n-----\n\nWith these goals I decided the best plan of attack was to gather as many Shamoon samples that I\ncould find, read all the blog posts/reports that I could find and listen to podcasts about the\n[campaigns. I got my samples from various sources such as Hybrid Analysis,](https://www.hybrid-analysis.com/) [VirusTotal,](https://www.virustotal.com/gui/home)\n[Malware.one,](https://malware.one/index.php) [VirusShare,](https://virusshare.com/) [TheZoo, and other malware researchers in the field.](https://github.com/ytisf/theZoo)\n\nWith a decent set I was keen on figuring out a way to programmatically sort the samples into their\ncampaigns. After analyzing the samples I realized each sample over the years had resources that\ncould be used to determine the campaign it originated from. This led to the creation of a script that\nwould group the samples based on the resources that were contained in each sample.\n\nAll samples organized based on the unique resource names / IDs\n\n## Shamoon 2012 Overview\n\nThe first known target for the Shamoon malware was the oil company Saudi Aramco. For those that\ndon't know Saudi Aramco is the largest petroleum and natural gas company in the world and a lot of\nSaudi Arabia's economy is centered around this single company. While they are a privately held\ncompany, it is estimated that the company is worth between 1-3 trillion dollars.\n\nConsidering their worth and their ties with the Saudi government, they are a prime target for cyber\nattacks. Especially those that might not have the best relations with Saudi Arabia.\n\nIdeas of how Shamoon ended up on the Saudi Aramco's systems is unclear currently. Some reports\n[say it was via the Acunetix vulnerability scanner, a phishing email or simply even a malicious USB](https://www.acunetix.com/vulnerability-scanner/)\nthat an employee had inserted into their machine. Speculation is that the threat actor got into the\nnetwork sometime around April or May of 2012 and spent the next couple of months moving\nlaterally and trying to gain access to a Domain Controller.\n\n\n-----\n\nAll this effort led up to the events of August 15th 11:08 AM when over 80% of Saudi Aramco s\nworkstations and servers had their drives wiped due to a hard coded detonation date in the Shamoon\nmalware. Its important to note that this date is not random, some might know that for 2012 the\n[night before was a holiday known as the Night of Power or Lailat al-Qadr. It is regarded as one of](https://en.wikipedia.org/wiki/Laylat_al-Qadr)\nIslam's holiest nights of the year. Much of the Islam community shuts down to celebrate the\nrevelation of the Quran. As tradition for Saudi Aramco and most of the country, 50,000 employees\nstayed home on the 15th to celebrate the holiday and spend time with their families. This of course\nleft the company itself and the workstations in Saudi Arabia at its most vulnerable.\n\nIn addition to having the users drives wiped, the workstations were left with an the first 1024 bytes\nof an image of a burning American flag. Although most users weren't even able to view this picture\nas their master boot records had been corrupted in the process. This could be taken as a political\nstatement or a misdirection.\n\nNearly 11 hours after the detonation timestamp\nof Shamoon, a [post was shared on popular paste](https://www.pastebin.com/hqAgaQRj)\nsite pastebin.com, which stated the following.\n\nWe, behalf of an anti-oppression hacker group\nthat have been fed up of crimes and atrocities\ntaking place in various countries around the\nworld, especially in the neighboring countries\nsuch as Syria, Bahrain, Yemen, Lebanon, Egypt\nand ..., and also of dual approach of the world\ncommunity to these nations, want to hit the\nmain supporters of these disasters by this\naction.\n\nOne of the main supporters of this disasters is\nAl-Saud corrupt regime that\nsponsors such oppressive measures by using\nMuslims oil resources. Al-Saud is a partner in\ncommitting these crimes. It's hands are infected\nwith the blood of innocent children and people.\n\nIn the first step, an action was performed\nagainst Aramco company, as the largest\nfinancial source for Al-Saud regime. In this\n\nComplete image of snippet left on the workstations\n\nstep, we penetrated a system of Aramco\ncompany by using the hacked systems in\nseveral countries and then sended a malicious virus to destroy thirty thousand computers networked in\nthis company. The destruction operations began on Wednesday, Aug 15, 2012 at 11:08 AM (Local time\nin Saudi Arabia) and will be completed within a few hours.\n\n\n-----\n\nThis is a warning to the tyrants of this country and other countries that support such criminal disasters\nwith injustice and oppression. We invite all anti-tyranny hacker groups all over the world to join this\nmovement. We want them to support this movement by designing and performing such operations, if\nthey are against tyranny and oppression.\n\nCutting Sword of Justice\n\nThis post needs to be taken with a grain of salt, as there is no definitive way to tell if this is from the\nactor. Now they did have the exact detonation date which to me, is a clear sign that this is from the\nactual actor/s behind this attack. Now if we are to assume that this post is legit there are a couple\nthings we can infer: This TA needs public visibility, they have ties to countries surrounding Saudi\nArabia or are at least empathetic towards them, their major target is Al Saud which is the royal\nfamily in Saudi Arabia. Notably, this is also the first mention of the Cutting Sword of Justice.\n\nNormally when we see attacks that are targeted like this, the goal tends to be data exfiltration and\nmaintaining a low profile to reduce the risk of detection but this attack was the complete opposite.\nClearly the intent was not to steal information, as even stranger is the impact that something like\nransomware or intellectual property theft could've been, due to the amount of raw resources the\ncompany has. This all points to the idea that this attack was meant to damage perceptions in the\npublic's eye as well as weaken the resulting country.\n\nOf course all of this would cause Saudi Arabia to make determinations as to who was behind such an\nattack, which they promptly implicated Iran. The Saudi government issued an official statement\nblaming Iran for this attack. That decision could've solely been made due to their relations with Iran\nor for the fact that the PDB string of Shamoon contains the following `ArabianGulf which is highly`\ncontested zone which Iran has always claimed that is it part of their country and should be properly\nnamed the Persian Gulf. Although this could also be a attempt at misdirection shifting blame\ntowards Iran as APT groups tend to do.\n\nArabian (Persian) Gulf\n\n\n-----\n\nIn addition to making this accusation Saudi Aramco made two major actions directly after attack:\n\n1. Fly employees to computer hardware factories and purchase as many hard drives as possible\n\n(50,000 at one time)\n2. Lie about the attack, saying that operations had returned to normal when in fact they hadn't\n\nSaudi Aramco made the decision to call for external help as they didn't have the capability to handle\nan attack of this grandeur. Now Saudi Arabia didn't really have to many options for who they could\ncall as they refuse to use any devices or personnel that originate from Israel, so they decided to call\non Chris Kubecka and contract her to create a team to analyze the samples as well as setup a\nlegitimate security program.\n\nIt turns out there wasn't much identifying information in the sample and due to Pastebin's\noperations, there was no way to track the paste back to a user let alone a country. So quickly things\nbecame pretty quiet as Saudi Aramco wasn't exactly making public statements nor was there new\nevidence about the group. This didn't sit well with The Cutting Sword of Justice and they followed up\n[with a second post on Pastebin on August 29th 2012 at at 1:37 CDT.](https://pastebin.com/AtN7dLeW)\n\nmon 29th aug, good day, SHN/AMOO/lib/pr/~/reversed\n\nWe think it's funny and weird that there are no news coming out from Saudi Aramco regarding\nSaturday's night. well, we expect that but just to make it more clear and prove that we're done with we\npromised, just read the following facts -valuable ones- about the company's systems:\n\ninternet service routers are three and their info as follows:\nCore router:  SA-AR-CO-1# password (telnet): c1sc0p@ss-ar-cr-tl / (enable): c1sc0p@ss-ar-cr-bl\nBackup router: SA-AR-CO-3# password (telnet): c1sc0p@ss-ar-bk-tl / (enable): c1sc0p@ss-ar-bk-bl\nMiddle router: SA-AR-CO-2# password (telnet): c1sc0p@ss-ar-st-tl / (enable): c1sc0p@ss-ar-st-bl\n\nKhalid A. Al-Falih, CEO, email info as follows:\nKhalid.falih@aramco.com   password:kal@ram@sa1960\n\nsecurity appliances used:\nCisco ASA  #  McAfee #  FireEye : default passwords for all!!!!!!!!!!\n\nWe think and truly believe that our mission is done and we need no more time to waste. I guess it's time\nfor SA to yell and release something to the public. however, silence is no solution.\n\nI hope you enjoyed that. and wait our final paste regarding SHN/AMOO/lib/pr/~\n\nangry internet lovers\n\n#SH\n\nThey decided to dump router credentials, internal security knowledge and username and password\nfor the CEO Khalid Al-Falih (now Minister of Energy of Saudi Arabia and Chairman for Saudi\nAramco).\n\n## Technical Analysis\n\n\n-----\n\nDuring my research process I discovered 4 unique samples relating to this campaign. The samples\n[and all my public work is shared in a GitHub repo here](https://github.com/myrtus0x0/ShamoonPublicWork/tree/master/Shamoon2012)\n\n_B14299FD4D1CBFB4CC7486D978398214_\n_B128376F2D45CFDF21035D3029EF0D6C_\n_ECC2CB6ADC0F0390ADFA9936D149657B_\n_D214C717A357FE3A455610B197C390AA_\n\nFor this post I will solely be talking about B128376F2D45CFDF21035D3029EF0D6C. I always start\nmy analysis process with static properties as those can give some a high level overview of what the\n[sample might be able to do. For this, I generally use PE Studio. Looking in PE Studio we see the](https://winitor.com/)\nfollowing information\n\nPE Studio Output\n\nImmediately the entropy of the file stands out indicating some sort of encryption or packed data.\nUnder the resources tab we see the 3 resources along with some version information\n\nShamoon Resources\n\nWe can see 3 resources named PKCS12 PKCS7 and X509. The high entropy and percentage of file\nimmediately stand out as a potential payload or some form of encrypted data. This is unusual for\nstandard files executables as resources are generally used for icons or small images rather than data\nblobs with high entropy. When I see resources I will generally save them off for later analysis with\n[Resource Hacker. Although these resources do contain relatively high entropy values, they aren't](http://www.angusj.com/resourcehacker/)\n7.99 or above the 7.9 threshold, which means if they are encrypted its through some rudimentary\ntechniques rather than a well established technique like AES of RC4.\n\n\n-----\n\nThe next thing I look at is the strings. Strings can give information about actions the malware might\ntake or if you're lucky, even a C2 string or raw IOCs. Immediately we see a string that we can use as\nan IOC due to it's hardcoded name and the fact that the file name will most likely be unique across\nhosts.\n\nFile Location String\n\nScrolling down we see a couple more strings that can prove valuable in understanding the behavior\nof this malware.\n\nInteresting strings within the sample\n\nWe can see strings pointing to hardcoded file location, potential commandline execution, hardcoded\ndomains etc. Considering the magnitude and impact that this attack had, I was somewhat surprised\nto see such low effort taken obfuscate their work.\n\nCopyright string\n\nNext I found a copyright string for the company Dinkumware. This is a hardcoded string found in a\nreplacement for the C++ standard library which offers some extra features. Malware authors use\nlibraries from Dinkumware to simplify the difficulty of the code they have to write. The libraries they\nprovide offer APIs to work with vectors, lists, sets, maps, bitsets and generic algorithms.\n\nAt the end of the list of strings found were the names of the resources mentioned earlier, X509,\nPKCS7 and PKCS12. This supports the hypothesis that Shamoon will interact with those resources\nduring runtime. A large string pictured below stood out to me as there shouldn't be any reason for\nmalware to require strings of this length. This string turned out to be a description of a service\nShamoon will create.\n\n\n-----\n\nUnicode strings at the end of the file.\n\nEnables the Distributed Link Tracking Client service within the same domain to provide more reliable\nand efficient maintenance of links within the domain. If this service is disabled, any services that\nexplicitly depend on it will fail to start.\n\nSo this alone gives us an IOC. One could query all of their services and check if they have a\ndescription that matches the one above. Now that we have finished all the triage for the sample, we\ncan get into the assembly. Following is a list of IOCs we can utilize for future samples\n```\n- \\inf\\netft429.pnf\n- myimage12767\n- c:\\windows\\temp\\out17626867.txt\n- \\\\System32\\\\cmd.exe /c \\\"ping -n 30 127.0.0.1 >nul && sc config TrkSvr binpath=\nsystem32\\\\trksrv.exe && ping -n 10 127.0.0.1 >nul && sc start TrkSvr \\\"\n\n```\nConsidering the high entropy of the resources and the size of them I started looking for references to\nthose resource names as they're most likely going to be used in windows API calls to interact with\nthem further.\n\nFor my analysis of assembly I use IDA Pro but any disassembler will do.\n\nEach resource name string turns out to only have a single reference which is always an argument to\nthis function sub_401977. Viewing the function shows the following:\n\n\n-----\n\nx509 reference\n\nPKCS7 reference\n\nPKCS12 reference\n\n\n-----\n\n-----\n\nResource decryption routine\n\nAt a high level, we can assume the following actions based on the windows API calls:\n\n1. Find a resource\n2. Load the resource\n3. Lock the resource\n4. Create a file\n\n5. Write to the file\n\nAfter this we can see that its going to allocate a buffer of size var_8, which gets set when the value of\nEAX is moved after the SizeOfResource call.\n\n\n-----\n\nWrite resource\n\nIf the buffer is successfully allocated it enters the loop loc_401A6F which implements the following\npseudo code:\n\n\n-----\n\n```\nwhile i 0; i sizeOfResource; i {\n     buf[i] = resource[i] ^ key[i % len(key)];\n}\n\n```\nThis is a very common form of encryption for malware as it's simple, and highly optimized at the\nhardware level. XOR is built in instruction for the x86 assembly set, so it's something that can be\ncalculated on the CPU itself. Single and double byte XOR keys generally aren't going to thwart AV\nengines but later versions of Shamoon use extremely large XOR keys for resource decryption.\n\nSince we have now recognized this as an XOR decryption loop we need to find the key. Generally\nkeys are passed as arguments if they are created during runtime or they are referenced by static\nconstants. There are no references to static constants in this function so taking a look at the\narguments we see the following buffer being passed.\n\nLooking at the function call, we can see 6 arguments being\npassed:\n\n1. an integer\n2. a constant\n3. a resource name\n4. a ordinal value for the resource\n\n5. a buffer\n6. a filename that is generated in this current function\n\n\nLooking at the constant that is being passed we see the\nfollowing, as I was analyzing this stood out to me\nimmediately and I tested it as a decryption key.\n\nThis turned out to be correct so I knew the signature\nfor the ResourceDecryption function was the\nfollowing.\n```\nResourceDecryption(sizeOfKey int,\nresourceOrdinal int, resourceName string,\nfileBuf byte[], outputFilename string)\n\n```\n\nResource Decryption Call for PKCS12\n\nPKCS12 XOR key\n\n\nSome malware analysts will take this knowledge and create a script to dump the resources so the\npayload can be analyzed. While this is a valid decision, there is still information that we can pull out\nfrom the sample.\n\nAt this point it's important to figure out how the function gets called and what path needs to be\ntaken from the entry point to get this file dumped. Opening the function at sub_401977 and hitting\nthe button \"xrefs to current identifier\" shows a view of function calls that are taken to reach the\n**DecryptResource function. This aligns with the 3 calls to DecryptResource as there are 3**\nresources contained within Shamoon.\n\n\n-----\n\nControl flow of program\n\nThis graph shows the functions that must be called to reach this point in the program. So this graph\nwould lead up to main and would show us all of the potential checks the malware might do to\ndetermine it is running on the correct system.\n\nConsidering that the path to the resource decryption function is relatively short, we can assume that\nthere won't be too many system checks or any at all.\n\nStarting from the top with _wmain, we can see its relatively small function.\n\n\n-----\n\n_wmain graph\n\nThe first function called here I have renamed CheckWindowsDirectoryAndGetCLIArgs. This\nfunction is relatively simple in what it does. it will load a hardcoded kernel32.dll path, prepend the\nwindows directory variable value to it, and check the creation time of that file. It then parses the\ncommandline arguments passed with GetCommandLineW. Considering that eacho of the paths\nin the callgraph below, I will explain all of the funtionality there in each of the followin resource\nsection.\n\n\n-----\n\n## PKCS7 Drop and Execution\n\nLooking at the call graph above the closest call is sub_40335c which we can see from the picture\nbelow will interact with the PKCS7 resource.\n\nFollowing the call to ResourceDecryption we see a couple calls to sub_4010AF and\n**sub_401050 which seem to do some string manipulation. At the end of the sub_40335c, there is**\na call to sub_40286c. Now its important note that all of the calls happening in this picture are\nafter we have decrypted our PKCS7 resource. So with that information we can assume that its going\nto interact with the decrypted resource.\n\nDigging into sub_40286c, we can see a virtualAlloc and if it successfully allocates memory it will\ncontinue executing.\n\n\n-----\n\n-----\n\nAssembly following PKCS12 decryption\n\nvirtualAlloc within sub_40286c\n\nNow in the branch to the left we can see its going to copy some memory and pass some arguments to\na function sub_4026EE. This function is going to get the process address of a function in\nnetapi32.dll and execute it as we can see below.\n\nCall function within netapi32.dll\n\n\n-----\n\nThis is a common technique for malware authors as it allows them to load functions from libraries\nwithin references having to exist statically within the binary. So tools like PE studio wouldn't be able\nto pick up on this function call.\n\n[The function that is being loaded here is NetScheduleJobAdd which as per MS docs:](https://docs.microsoft.com/en-us/windows/win32/api/lmat/nf-lmat-netschedulejobadd)\n\nThe NetScheduleJobAdd function submits a job to run at a specified future time and date. This\nfunction requires that the schedule service be started on the computer to which the job is submitted.\n\nSo rather than directly importing netapi32.dll the actor decided to load this library during runtime.\nWhen an actor takes the time to do this there is generally a purpose behind it.\n\nNow looking back at sub_40286c we know that its going to copy memory into the newly allocated\nbuffer and start a thread to schedule a task via the netap32.dll. Looking at the next piece of the\ncontrol flow graph\n\n\n-----\n\n-----\n\nCreateProcess for PKCS12 payload\n\nNow if this operation were successful and the thread was created Shamoon will sleep for 0x17318\nmilliseconds or 95000. This converts to a minute and 35 seconds. So once the application is finished\nsleeping it will create a process with the API call CreateProcessW. Now taking a step back again this\nfunction sub_40286c previously has decrypted a resource, written it to disk and done some string\nmanipulation. So from that we can determine that this CreateProcessW will start whatever PKCS7\ndecrypts to.\n\nSo now that we have an understanding about how PKCS7 is dropped and executed we can quickly go\nover x509 and PKCS12.\n\n## x509 Drop and Execution\n\nLooking back on that call graph, sub_403491 is the function that interacts and executes the x509\nmodule. Now this is handled a little differently than the PKCS7 resource.\n\n\n-----\n\nx509 resource interaction\n\n**sub_403491 starts by making a call to sub_4017bb which when looking into it checks that the**\nsystem has the process architecture AMD64 (checks via the registry). If this check fails Shamoon will\nnot execute/drop the x509 resource. This is indicative that this resource might be performing some\n\n\n-----\n\nactivity that is reliant on this specific architecture type or targeting something specific, so definitely\nworth looking into. Following the check, this function will call OpenSCManager which establishes\na connection to the service manager.\n\nFor those that aren't aware, the service manager is an integral part of windows that will execute tasks\nat a given interval. It is also a technique that malware authors use to gain persistence in systems.\n\nIt then moves the resulting handle into EAX and checks to see if it can open a service with that\nhandle name \"TrkSvr\". OpenService will return null if it was unable to get a handle so the \"jz\nloc_40361A\" instruction will only be taken if the TrkSrv service exists.\n\nIf the service exists it will then make a call to QueryServiceConfig which returns a non-zero value\nif the call was successful. So if the function is able to get a config for the TrkSrv service it will\ncontinue executing.\n\n\n-----\n\nAssembly following x509 decryption\n\n\n-----\n\nThe calls to sub_4010AF are just string manipulation, most likely converting from ASCII to wide\ndue to the system being windows. Looking at the function sub_401D5D, we see some calls to more\nstring manipulation functions then at the end of the function we see the following:\n\n\n-----\n\n-----\n\nCreateFile wrapped with Wow64FsRedirection\n\nThe end of this function will call a wrapper function for Wow64DisableWow64FsRedirection.\nThat windows API call on 64 bit systems will change the way files are written to system32 directory.\n[Per the MSDN documentation:](https://docs.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection)\n\nThis function is useful for 32-bit applications that want to gain access to the native system32 directory.\nBy default, WOW64 file system redirection is enabled.\n\nSo we know that this function will disable system32 redirection. Then it will create a file on disk with\nthe name trksrv.exe (which is one of the strings that is manipulated in the earlier portions of the\nfunction. If the function was successful it will revert the system32 redirection and pop ESI to the\nstack which is the newly created file handle.\n\nSo now we know sub_401D5D is going to return a newly created file handle for trksrv.exe. Looking\nback at the caller sub_403491 we are at the point right before the resource decryption function is\ncalled and we have a newly created file handle.\n\n\n-----\n\nx509 write resource to disk\n\nThis process is exactly the same as the PKCS7 resource, it will decrypt based on the resource key and\nwrite the file to disk via the trksrv.exe file handle.\n\nAfter the payload is written to disk, sub_4020FA is called which sole purpose is to change the file\naccess, write and create time to the times of the initial Shamoon executable. Now that the file is\nwritten to disk and Shamoon has confirmed that there is a scheduled task for trksrv.exe it has no use\nfor the service handle so it closes it.\n\n\n-----\n\n-----\n\nSystem sleep and create process\n\nIf the handle was successfully closed, the above code block will be executed. As we can see it will do\nsome string manipulation and create a process for the cmd command above:\n```\n\\\\System32\\\\cmd.exe /c \"ping -n 30 127.0.0.1 >nul && sc config TrkSvr binpath=\nsystem32\\\\trksrv.exe && ping -n 10 127.0.0.1 >nul && sc start TrkSvr\"\n\n```\nBreaking this command down we can see a ping to localhost, changing the config value for TrkSrv,\npinging localhost again and starting the service. These pings are a common tactic by malware\nauthors to have their applications wait a certain period of time. Rather than calling a sleep which\nmight be a function that is alerted on, authors will execute a ping N number of times and wait for\nthose pings to succeed, then execute their command.\n\nIf the process was successfully created, then the function will close the handles created by the\nvarious windows API calls here the malware has now successfully dropped a secondary payload via\nthe service task TrkSvr.\n\n## PKCS12 Drop and Execution\n\nThe last resource we figure out is the PKCS12 resource. Looking back at the call graph we can see\nthat sub_4056B2 a seemingly random hard coded string an a reference to a text file in\n_\\windows\\temp called out17626867.txt. This file doesn't have any other references in the code nor_\nany of the payloads. It also loads a image called \"myimage12767\", this file would either have to be in\nthe directory where Shamoon is running or as a resource in the file itself. As neither is true it is\ndifficult to say what the purpose of this image and the text file are.\n\n\n-----\n\nEventually this function will create a random file name based on the time at that call, check if a\nprocess is already running with that filename and if there isn't one, will write the PKCS12 resource to\nthat path and execute it.\n\n\n-----\n\nWrite PKCS12 resource to disk\n\nWith that, we have covered all the payloads and its time to go into how the resources are decrypted\nand what their exact purposes are.\n\n## Call Graph Overview\n\nWith the understanding of how all the resources are dropped we have now reversed all of the\nfunctions that lead up to each of the resources being dropped. When renaming the functions to the\nappropriate actions that they perform, we get a call graph like the following.\n\n\n-----\n\nNamed call graph\n\nNow with all these functions being named, we have a clear picture of how these resources and\nexecuted. the x509 resource is used as a newly created service, PKCS12 is executed as a randomly\nnamed file, and PKCS7 is started with a CreateProcessW after it's written to disk.\n\n## Resource Decryption\n\nNow that we have covered how Shamoon executes its payloads and sets up persistence, we can take a\nlook again at how the resources are actually decrypted. This means we will be looking at function\n**sub_00401977 or as I have it renamed WriteResourceToDisk.**\n\n\n-----\n\nDecryptResource initial steps\n\nAs stated above this function will find a resource based on an ordinal, load the resource into\nmemory, create a file, decrypt the buffer and write it to disk. From the arguments to this function\ndecryption becomes very trivial. I decided to hard code the keys in my script as they're consistent\nacross all Shamoon 2012 samples.\n\n\n-----\n\n```\nWorks for 3/3 resources\n\"\"\"\nfiles = {\n  # Comms module\n  'PKCS7': [\"61E8F2AF61_Resources\\PKCS7113.bin\", \n          \"61E8F2AF61_Resources\\PKCS7113_decrypted.bin\", \n           [0x17, 0xD4, 0xBA, 0x00]\n      ],\n   # x64 variant of dropper\n  'x509': [\"61E8F2AF61_Resources\\X509116.bin\", \n        \"61E8F2AF61_Resources\\X509116_decrypted.bin\", \n        [0x5C, 0xC2, 0x1A, 0xBB]\n        ],\n  # Wiper module\n  'PKCS12': [\"61E8F2AF61_Resources\\PKCS12112.bin\", \n           \"61E8F2AF61_Resources\\PKCS12112_decrypted.bin\", \n           [0x25, 0x7F, 0x5D, 0xFB]\n        ]  \n      }\nimport os \ndef decrypt(data, key):\n  keyLength = len(key)\n  decoded = \"\"\n  for i in range(0, len(data)):\n      decoded += chr(data[i] ^ key[i % keyLength])\n  return decoded\ndef main():\n   for rname, file in files.items():\n    src_resource = file[0]\n    dst_resource = file[1]\n    xor_key = file[2]\n    print(\"[+] Decrypting resource {}\".format(rname))\n    print(\"[+] Using Decryption key: {}\\n\".format(xor_key))\n    key = bytearray(xor_key)\n    data = bytearray(open(src_resource, 'rb').read())\n    decryptedData = decrypt(data, key)\n    if len(decryptedData) == 0:\n      print(\"[!] not able to decrypt resource {}\".format(src_resource))\n    with open(dst_resource, \"wb+\") as dst:\n      dst.write(decryptedData)\nif __name__ ==\"__main__\":\n  main()\n\n```\nI dumped the resources with resource hacker, then hardcoded the paths. With successful decryption\nwe get the following results.\n\n\n-----\n\nSuccessful decryption output\n\nIf you kept the paths the same, you should have a folder in the CWD that contains the encrypted and\ndecrypted resources.\n\n## Shamoon Payload PKCS7\n\nThe first payload we will look at is the decrypted PKCS7 resource. First thing is to look at static\nproperties.\n\nPE Studio overview\n\nUnsurprisingly has a ton of hits on VirusTotal, has a file description of TCP/IP NetBios Information,\n2 resources that don't mean much and the following interesting strings.\n\n\n-----\n\n```\n                      http://%s%s?%s=%s&%s=%s&state=%d\n                        /ajax_modal/modal/data.asp\n                           \\inf\\netft429.pnf\n     Copyright (c) 1992-2004 by P.J. Plauger, licensed by Dinkumware, Ltd. ALL RIGHTS RESERVED.\n                           \\inf\\netfb318.pnf\n\n```\nInteresting strings pulled out from the payload\n\nJust judging from the strings, it's probably going to connect to a host, interact with those hard coded\nfilepaths, delete some files and we also see the Dinkumware copyright string we saw in the initial\nlook at the Shamoon sample.\n\nLooking at the sample, the function we care about is main which is sub_402B90 or as I've\nrenamed it MalwareMain.\n\n\n-----\n\nArg handling\n\n\n-----\n\nThe first thing this payload does is call sub_4020F0 or as I ve renamed it GetIPAddress. This\nfunction will set WideIPAddressString to 0 if the the result of GetIPAddress is 0. Otherwise it will set\nthe value of the pointer to WideIPAddressString in the function. It then will get the windows\ndirectory in ASCII and in wide, then will check argv[1] to see what the value is. The two arguments\nthat are processed for the payload are the ASCII \"0\" and \"1\", as seen below.\n\nArgument control flow\n\nIf you pass a 0 as the first argument to the payload, it will do a subsequent check to see if there is a\n2nd argument. if there is a second argument it will pass that to sub_402240, otherwise it will pass\n0 to sub_402240. After sub_402240 is called the program will exit.\n\nSo to summarize, what we've seen so far:\n```\npkcs7.exe 0 1 will pass 1 to sub_402240 \npkcs7.exe 0 will pass 1 to sub_402240\n\n```\nNow looking into sub_402240, the first thing it will do is create a internet handle that it will use\nfor further WinINet functions.\n\n\n-----\n\nSingular InternetOpen call\n\nThe first argument to InternetOpenW is the purpose of the handle or user-agent, and interestingly\nit sets this value to \"you\". As soon as the InternetOpenW call is made, there is a loop that begins.\n\n\n-----\n\n-----\n\n(I understand the quality of the picture is bad but I had to zoom out in IDA to take it) but the basic\nidea of this loop is to iterate over the values stored at the HomePointer, which in our case is the\nfollowing\n\nC2 array\n\nSo this loop will iterate twice, once with the string \"home\" and once with the hardcoded IP\n\"10.1.252.19\". So this loop will get the tick count, pass arguments to the format string http://%s%s?\n%s=%s&%s=%s&state=%d and make a call to InternetOpenW then delete the buffer containing\nthe built out format string. So our possibilities for this loop are.\n```\nhttp://10.1.252.19/ajax_modal/modal/data.asp?mydata=<argToFunction>&uid=\n<IPAddressAcquiredInMalwareMain>&state=CurrentMilliseconds\nhttp://home/ajax_modal/modal/data.asp?mydata=<argToFunction>&uid=\n<IPAddressAcquiredInMalwareMain>&state=CurrentMilliseconds\n\n```\nLooking at the IP address, it falls within private IP space so its communicating with a server that is\nhosted within Saudi Aramco's environment. In the second iteration it tries to communicate with a\nhost \"home\" so either this is a internal hostname set by Saudi Aramco or some host entry set per\nhost where home=10.1.252.19. The use of a hardcoded private IP address is unique and means that\nthe Cutting Sword of Justice had access to Saudi Aramco's environment before creating and\ndeploying Shamoon. So that hardcoded \"home\" and 10.1.252.19 serve as a C2 between the PKCS7\nresource and the actor.\n\nConsidering this sample is 7 years old now and uses a private IP for its C2 there is no chance we will\nbe able to properly emulate the C2 but from the control flow we can infer what the malware will do\nbased on the results.\n\nOnce it gets a handle to the C2, a call to InternetReadFile is made and the read buffer is stored\nand used to determine what actions should be taken next. There are 2 cases that can be taken\n\n\n-----\n\nControl flow based on response from C2\n\n\n**Response**\n**from C2**\n\n\n**Action Taken**\n\n\nT Create a file at \\inf\\netft429.pnf and write a new detonation time to be used by the\nother modules\n\nE Receive a base64 encoded buffer, attempt to drop it at the following location\n%WINDIR%\\Temp\\filer.exe and execute it\n\nGoing down the E path there a Sprintf call is used to generate a file path to drop the decoded base64\nfile.\n\n\n-----\n\n%s%S concatenation and usage\n\nIf you look closely you will see that its using %S in the format string which in some reports has stated\nto be invalid and a bug on the actors part. This is actually incorrect, in the context of windows, this\nwill write a wide character string rather than an ASCII string. So this call will success and write a file\nto \\\\Temp\\\\filer and execute it.\n\n## Shamoon Payload PKCS7 Conclusion\n\nThis sample serves as the communications mechanism between the actor/s and the Shamoon\nmalware. This communications module allows the actors to drop additional payloads, as well as\nreport information back to the actos. The other purpose it serves is to take a new detonation from\nthe C2 and write it into a hardcoded file path that is then used by the main Shamoon module to start\nwiping the disk.\n\n## Shamoon Payload PKCS12\n\nThe next payload we are going to cover is the PKCS12 resource.\n\nLoading the file up into PE Studio we can see it has 2 resources being the following\n\n\n-----\n\nPKCS12 resources\n\nREADONE stands out as it has a relatively large size and a high entropy. Loading the file into a hex\neditor and judging from the XOR encoding scheme used in the past, its clear it's a encrypted PE file.\nLooking at the strings we can see strings that are most likely going to be passed to _system and a\nPDB path that shows the name Shamoon just as the initial dropper.\n\nCmd strings found within PKCS12\n\nWe can see the actor searching for files and putting them in f1.inf and f2.inf. Most likely these files\nwill be exfiltrated for further analysis. Then there are strings for \"sc\" which are used to create a\nwindows service with a hardcoded path to a drdisk.sys in System32/Drivers.\n\nDigging into the assembly starting at _wmain, the first function we care about it is sub_403720.\n\n\n-----\n\nDrop drdisk sys into Drivers\\\n\n\n-----\n\nThe beginning of the function will get the windows directory and use the format string in the\nscreenshot to create `<WINDOWS DIR>\\\\System32\\\\Drivers\\drdisk.sys`. In case there is already a\nservice called drdisk, it'll attempt to stop and remove it. Once the service is stopped it'll attempt to\ndelete the driver drdisk.sys at the path created from the format string. Then a call to FindResource is\nmade for the ReadOne resource we saw earlier in PE Studio.\n\nCreate new service for drdisk.sys\n\nIf the resource was found, it will be passed to the function I've labeled\n**DecryptAndWriteEldosDriverToDisk or sub_004037E0. Based on the result of that**\nfunction, it will create and start a service of exit.\n\nWith that information I dumped the resource with Resource Hacker to decrypt the resource when we\nget to that point. Now we will be looking at the decryption routine or sub_004037E0.\n\n\n-----\n\nPKCS12 internal resource decryption\n\nThe arguments to the function are a string which is the filename for to be created file and the\nresource handle from the FindResource call. With those parameters the function will load the\nresource and lock it so that no concurrent routines can modify it. Then get the address of the\n**Wow64DisableWow64FsRedirection to ensure that the to be decrypted file is dropped at the**\nsame location every time. Scrolling down we see our first XOR loop.\n\n\n-----\n\nXOR loop for decryption\n\nThis loop will iterate over each byte of the file XORing it with the key[index & 3] and write one byte\nat a time to the newly created decrypted file handle. As soon as the index is greater that 1024 it will\ncontinue to the next XOR loop.\n\n\n-----\n\n-----\n\nOnce the initial KB has been written it then will allocate memory for the rest of the file, decrypt the\nrest of the file with the same scheme as the previous loop and then make a single call to WriteFile\nwhen it decrypts the entire buffer. The encryption key is a hardcoded value and for this sample is:\n\nPKCS12 internal resource decryption key\n\nOf course only the first 4 bytes are used as the and operation with the index will keep the ranges\nfrom 0-3. Below is the python script I used to re-implement the decryption.\n\n\n-----\n\n```\nfiles {\n  'PKCS12_Eldos': [\"PKCS12112_Resources\\wiper_encrypted.sys_\", \n          \"PKCS12112_Resources\\wiper_decrypted.sys_\", \n          [0x15, 0xAF, 0x52, 0xF0, 0xA0, 0xFF, 0xCA, 0x10]\n      ],\n    }\nimport os \ndef decrypt(data, key):\n  keyLength = len(key)\n  decoded = \"\"\n  for i in range(0, len(data)):\n    decoded += chr(data[i] ^ key[i & 3])\n  return decoded\ndef main():\n   for rname, file in files.items():\n    src_resource = file[0]\n    dst_resource = file[1]\n    xor_key = file[2]\n    print(\"[+] Decrypting resource {}\".format(rname))\n    print(\"[+] Using Decryption key: {}\\n\".format(xor_key))\n    key = bytearray(xor_key)\n    data = bytearray(open(src_resource, 'rb').read())\n    decryptedData = decrypt(data, key)\n    if len(decryptedData) == 0:\n      print(\"[!] not able to decrypt resource {}\".format(src_resource))\n    with open(dst_resource, \"wb+\") as dst:\n      dst.write(decryptedData)\nif __name__ ==\"__main__\":\n  main()\n\n```\nNow with the decryption function reversed, we can look back at sub_403720. If the decryption was\nsuccessful it will create the new drdisk service and start it.\n\nSo we can now move back to _wmain and we continue looking down the path of the resource\nsuccessfully being decrypted and created as a service.\n\n\n-----\n\nSystem calls to harvest host files\n\nThe call to CheckIfItsTimeToWipe is used to check if the file \"\\inf\\netfb318.pnf\" exists and if so,\nits used as a trigger to continue with wiping the system. Whether or not that call was successful or\nnot, the following cmd statements will be executed.\n\ndir \"C:\\Documents and Settings\\\" /s /b /a:-D 2>nul | findstr -i download 2>nul >f1.inf\"\ndir \"C:\\Documents and Settings\\\" /s /b /a:-D 2>nul | findstr -i document 2>nul >>f1.inf\"\ndir C:\\Users\\ /s /b /a:-D 2>nul | findstr -i download 2>nul >>f1.inf\"\ndir C:\\Users\\ /s /b /a:-D 2>nul | findstr -i document 2>nul >>f1.inf\"\ndir C:\\Users\\ /s /b /a:-D 2>nul | findstr -i picture 2>nul >>f1.inf\"\ndir C:\\Users\\ /s /b /a:-D 2>nul | findstr -i video 2>nul >>f1.inf\"\n\n\n-----\n\ndir C:\\Users\\ /s /b /a:-D 2>nul | findstr -i music 2>nul >>f1.inf\ndir \"C:\\Documents and Settings\\\" /s /b /a:-D 2>nul | findstr -i desktop 2>nul >f2.inf\"\ndir C:\\Users\\ /s /b /a:-D 2>nul | findstr -i desktop 2>nul >>f2.inf\"\ndir C:\\Windows\\System32\\Drivers /s /b /a:-D 2>nul >>f2.inf\"\ndir C:\\Windows\\System32\\Config /s /b /a:-D 2>nul | findstr -v -i systemprofile 2>nul\n>>f2.inf\"\ndir f1.inf /s /b 2>nul >>f1.inf\"\ndir f2.inf /s /b 2>nul >>f1.inf\"\n\nThese commands will grab filenames in those directories with various recursion depths.\n\nOnce those commands have been executed, there are 2 major if statements that each call the same\nfunction with a argument of the f1.inf or f2.inf. This function is used to check if the file exists and\ncheck permissions as well. If the file exists and is able to be read, then each file path contained\nwithin f1.inf and f2.inf will be copied to a buffer and corrupted by a following routine.\n\nf1.inf reference\n\n\n-----\n\nf2.inf reference\n\nImmediately after the payload has successfully read and processed f2.inf, it will load a hardcoded\nbuffer into memory.\n\n\n-----\n\nLoad picture buffer into memory\n\nThis will create a empty buffer of length 196608 bytes and copy the a hardcoded buffer I renamed\nDumpedPicture with a length of 1024 into the new buffer.\n\n\n-----\n\nJPG header\n\nFor those that don't know the file header for a JPEG JFIF format is FF D8 FF E0 00 10 4A 46 49 46\n00 01. Opening the extracted 1024 bytes of the JPEG we can see the following.\n\n\n-----\n\nScreenshot of dumped picture buffer\n\nSince its only a partial image we can find the original with a reverse image search.\n\nAlthough the entire image isn't held within the\nbinary, it is interesting to see such a decision\nmade by this group.\n\nIf you have taken a look yourself at _wmain\nyou will see that its quite large and contains a\nlot of functionality that really should be\nseparated out. For that reason I decided to\ncreate a diagram of the relevant actions that\noccur within this payload.\n\nReference image from Wikipedia\n\n\n-----\n\n_wmain function summary\n\n\n-----\n\nThe next piece we care about is the system information that needs to be acquired for the payload to\nsuccessfully corrupt drives. This payload will query the registry with the following keys, getting the\ndisk layout for the machine its on. The examples below are from my personal VM, but with a host\nthat contains multiple drives these values would look different.\n\n**Registry Key** **Size** **Value**\n\n\nSYSTEM\\\\CurrentControlSet\\\\Control FirmwareBootDevice\n\nSYSTEM\\\\CurrentControlSet\\\\Control SystemBootDevice\n\n\nREG_SZ multi(0)disk(0)rdisk(0)partition(2)\n\nREG_SZ multi(0)disk(0)rdisk(0)partition(4)\n\n\nWith this information the payload will iterate over the partitions and rdisk values and add them to\nan array so for my system that would result in the following array.\n```\n\\\\Device\\\\Harddisk0\n\\\\Device\\\\Harddisk1\n\\\\Device\\\\Harddisk2\n\n```\nThen once those devices are appended in an array we have a call to a function I have renamed\n**SetSystemTimeChangeNameOfPartitionAndGetHandleToPartition or sub_4033F0.**\n\n\n-----\n\nPartition iteration\n\nThe function is pretty short as its basically just a wrapper for the code that actually gets the wiper\nhandle.\n\n\n-----\n\nHardcoded license key and system time change\n\n\n-----\n\nInterestingly, it will set the system time before it returns a handle to a device. It sets the year and\nmonth to august 2012. It will pick a random value for the day and do a modulus 20 on it and add 1.\nSo the day will be some value between 1 and 20. This information doesn't seem to hold much value\nbut there is a call to ChangeNameOfPartitionAndGetHandleToPartition or sub_409660.\nThis function takes 3 arguments, a string, privilege levels that will be passed to CreateFile and\nanother string.\n```\nHANDLE ChangeNameOfPartitionAndGetHandleToPartition(char *str1, DWORD dwDesiredAccess, char\n*str2)\n\n```\nWithout going into detail for this function as its relatively straight forward, the first string is a\nfilepath that is appended to \"\\\\?\\ElRawDisk\". The only way this function executes properly is if that\nvalue starts with the characters \"\\\\\". The second argument is an access level and for this call is a\ngeneric read & write. The 3rd string passed is a license key that is required for the wiper to run. After\nthe \"\\\\\" is appended to the path, it will append a \"#\" to the filename and then the license key that is\nthe third argument. As an example if you have the following input string\n\n\\\\device\\\\harddisk1\\\\partiton0\n\nwe would get a file handle back from\n\n\\\\device\\\\harddisk\\\\partiton0#8F71FF7E2831A...\n\nThe driver requires a license key to run if you look at the implementation of it, and it will read from\nthis filepath to get a valid key. For one to acquire a license key, they must register an account with\n[Eldos. Understandably so, the company does not seem to offer the product anymore nor the free](https://www.eldos.com/)\ntrial that was used in this attack. If one were to have access to the registration information that was\nused, it could yield potentially interesting information about the actor.\n\nOnce this function returns the handle to the specific partition with the license key appended to it we\nare back to looking at _wmain.\n\n\n-----\n\nThread creation for corrupting partitions with JPG buffer\n\nThe block before this gets the handle to the partition, which is held in ESI. It will write the picture\nbuffer to the file and create a thread with the function sub_402F40. This function is arguably the\nmost delicate code of the sample as it deals with overwriting portions of the disk partitions that we\nhad seen earlier.\n\n\n-----\n\nThread function pseudo C++\n\nGenerally I am not a fan of relying on the decompiled code as a lot can be missed but considering all\nthe nested loops and byte manipulation I felt that this was a better way to display the control flow.\n\nAs you can see this function is pretty complicated but I've done my best to rename the variables to\ninformative names. The most important piece of this pseudo C is the section from line 76 to 86.\nThese 7 lines are responsible for writing the picture buffer to the path passed within this function.\nFirst it makes 2 checks to compare the path passed into the function with the DeviceString and\nDeviceHardDiskString. Then it will get a file handle, where the filename for that handle has the\nserial key for the disk wiper appended to it after a #, and if that is successful, then the handle is\npassed to SetFilePointerAndWritePicture which will write the picture buffer over spans of\nmemory for the handle being passed in.\n\nSo its clear that the purpose of this function is to take in a path, and start writing the image buffer to\nfile at that path. With that I renamed Sub_402F40 to WriteImageBufToPathThread. Now\nthat we have looked at the thread function, we have analyzed all the pieces required for the loop we\nwere just looking at in _wmain\n\n\n-----\n\n-----\n\nComplete partition corruption loop\n\nThis loop iterates over all of the partitions gathered from the registry and will write the picture\nbuffer to random sections in each of the partitions. So while the functions we looked at were\ncomplex, looking at the high level picture really sheds a light as to what the sample attempts to do.\n\nNow at the final section of _wmain we can see a call to Sub_4034B0 or as I have renamed it\n**DropElDosDiskWiperAndRestartMachine.**\n\n\n-----\n\nCorrupt partition0 and restart machine call\n\nOnce we enter this function,we can see a call to CorruptPartition0AndRestartMachine with the\nargument \\\\Device\\\\Harddisk0\\\\Partition0. If you were to look at the threads that were just\ngenerated in a debugger you can see that it won't start a thread for corrupting\nHarddisk0\\\\Partition0, this is due to the fact that partition0 is a special case and points to the entire\ncontents of Harddisk0. Where Harddisk0 is generally where the OS is installed and has to be\ncorrupted last.\n\n\n-----\n\nOnce the handle to Partition0 is acquired it writes the the picture buffer to the beginning of the\npartition and promptly closes the handle to it continuing onward. Soon after the function will\nacquire a file handle for the string global variable dword_428D2C. Generally the function used to\nget a file handle is OpenFile but CreateFile can also be used to get the handle to the file passed.\n\n\n-----\n\n-----\n\nIf the initial CreateFile call fails, it will append a string to dword_428D2C and attempt to get the\nfile handle again. If the handle is valid, we see a call again to SetFilePointerAndWritePicture\nwith the newly acquired file handle.\n\nOnce the picture buffer is written to the file handle the function checks the length of the\nDeviceHardDisk string. While string length is its own function in C wcslen, generally that function\nis inlined to others as its relatively small and removes the need to setup the function call for wcslen.\n\n\n-----\n\nThe snippet above calculates string length and checks whether the length of that\nDeviceHardDiskString is greater than 1. Assuming that the string is valid and contains the\ninformation expected, then a conditional is evaluated to check whether DeviceHardDiskString and\nDeviceStringCopy are the same value.\n\n\n-----\n\nJust as wcslen is inlined when the program is compiled so is wcscmp. This section loads the two\nstrings and checks whether they are the same values. If they are the same values, then we get into the\ncritical portion of this function.\n\n\n-----\n\nSo at this point, if the length of DeviceHardDiskString is greater than 1, and it is the same as\nDeviceStringCopy, then we get into the assembly blocks in the screenshot above. The filepath being\npassed is the DeviceHardDiskString. The file at this path will have the EldoS key license appended to\nthe filename after a \"#\" and the handle will be returned. The file handle that is returned is then\npassed to SetFilePointerAndWritePicture where the raw hard disk device will have the picture\nbuffer written to it at the beginning of the raw device.\n\n\n-----\n\nGet handle to partition0\n\nSo the previous call we saw was writing the picture buffer to DeviceHardDiskString, whereas for this\nassembly snippet it works with DeviceString. Once it has a valid handle to the device, it will write the\npicture buffer to the device pointed at DeviceString. Its interesting to note that instead of writing\nover the entirety of the disk, the actors decided to just write over the first 1024 bytes. Its much\nquicker than writing over the device and is still nearly impossible to repair.\n\n\n-----\n\nWrite picture buffer to partition0 and send control code to device\n\nWith the valid handle, the picture buffer is written to the device. If the handle is still valid, it will\npass the handle to DeviceIoControl. DeviceIoControl as described by MS does the following\n\nSends a control code directly to a specified device driver, causing the corresponding device to perform\nthe corresponding operation.\n\n\n-----\n\n[With some quick googling, the control code that is sent is used to gather information about the drive.](https://docs.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-ioctl_disk_get_partition_info_ex)\nA check is then done to make sure that the result is valid and if it has a length of 144 or more.\n\nReboot machine corrupting it entirely\n\nIf that check is successful, there is a final call to SetFilePointerAndWritePictureBuffer. This\ncall takes in the handle of the same drive that was passed to DeviceIoControl. So in this case that\nwould be the Harddisk0\\\\Partition0. This makes sense as it's the most critical portion of the system\ndue to it containing the operating system and boot information. These effects won't have any effect\n\n\n-----\n\nas a lot of the required pieces for windows to run properly are held in memory while these overwrites\nare made to the hard disk. So this will require a full reboot for the corruption to take effect. As\nexpected that call is made directly after the overwrite with a _system call to\n\nshutdown -r -f -t 2\n\nFor a breakdown of the command, the -r signifies the machine to restart, the -f forces applications\nto close without warning users, and the -t sets the time-out period to 2 seconds before the restart\nstarts.\n\nAt this point Shamoon has gone through its entire infection chain and has successfully corrupted all\nthe partitions and restarted the computer leaving the machine inoperable.\n\n## Shamoon Payload PKCS12 Conclusion\n\nThis is the final payload in Shamoon's arsenal and once completed renders the machine inoperable.\nIn conjunction with the communications module, Shamoon offers a powerful toolkit that proved by\ntime allows the actors to reuse and adapt the codebase.\n\n## Shamoon Payload x509 Analysis\n\nNow if you've been paying attention you might have realized that I haven't touched on the x509\nresource. This is due to the fact that the x509 resource is a product of the same exact code, just\ncompiled for a 64 bit architecture. So the 64 bit version only has 2 resources. 1 being the\ncommuncations module and another being the actual wiper that contains the EldoS driver and\ncorruption mechanism. Pictures of PE studio output can be found below but I feel that it is out of\nscope to dive deep into the 64 bit module as it shares almost exactly the same behavior as the 32 bit\nclient.\n\n\n-----\n\n## Conclusion\n\nI hope this overview was able to help teach some about the history of the first Shamoon campaign\nthe world has seen. This has been a work in progress for almost 6 months now and I've met a ton of\ngreat people. If there are any questions or mistakes feel free to reach out. I am a human as well and\ntherefore make tons of mistakes just like the rest of the world. Any feedback about the content,\nlength of post, or format of the post would also be greatly appreciated. I think going forward I will\ntry to keep them a tad shorter and more frequent. If there is interest I will continue going over the\nnext shamoon campaigns as there are signifcant changes to how strings are obfsucated, resources\nencrypted, and dropping techniques. Below are a couple of high level visuals and information that\nmight prove useful to some.\n\n## Shamoon 2012 Killchain\n\n\n-----\n\n## IOCs\n\n**IOC Value**\n\n\n**Rationale**\n\n\n4F02A9FCD2DEB3936EDE8FF009BD08662BDB1F365C0F4A78B3757A98C2F40400 Known\n2012\nsample\n\n61E8F2AF61F15288F2364939A30231B8915CDC57717179441468690AC32CED54 Known\n2012\nsample\n\nA37B8D77FDBD740D7D214F88521ADEC17C0D30171EC0DEE1372CB8908390C093 Known\n2012\nsample\n\nF9D94C5DE86AA170384F1E2E71D95EC373536899CB7985633D3ECFDB67AF0F72 Known\n2012\nsample\n\n\n-----\n\nhttp://10.1.252.19/ajax_modal/modal/data.asp?\nmydata=&uid=&state=CurrentMilliseconds\n\n\nURL\nscheme\nand\nhardcoded\nIP for\ninternal C2\n\n\nhttp://home/ajax_modal/modal/data.asp?mydata=&uid=&state=CurrentMilliseconds URL\nscheme\nand\nhardcoded\nIP for\ninternal C2\n\n%windir%\\inf\\netft429.pnf Hardcoded\nfile path\nfor new\ndetonation\ndate\n\n%windir%\\inf\\netfb318.pnf Hardcoded\nfile path\nfor wiping\ncompletion\nstatus\n\n%system32%\\drivers\\drdisk.sys Hardcoded\nfile path\nfor the\nEldoS\nwiping\ndriver to\nbe written\nto\n\nc:\\windows\\temp\\out17626867.txt Path\ncontained\nwithin the\nShamoon\ndropper\n\n\n\\\\System32\\\\cmd.exe /c \\\"ping -n 30 127.0.0.1 >nul && sc config TrkSvr binpath=\nsystem32\\\\trksrv.exe && ping -n 10 127.0.0.1 >nul && sc start TrkSvr \\\"\n\n\nHardcoded\ncommand\nused by\nShamoon\nto start a\nservice\n\n\ntrksrv.exe x509\ndropped\nfilename\n\n\n-----\n\n%WINDIR%\\Temp\\filer.exe File\nreceived\nand\nexecuted\nfrom the\ninternal C2\n\nf2.inf Data\ngathered\nfrom\nPKCS12\nresource\n\nf1.inf Data\ngathered\nfrom\nPKCS12\nresource\n\nNanocore\n\n## Nanocore & CypherIT\n\nTools and analysis of the Nanocore malware family as well as the CypherIT crypter.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-12-21 - Shamoon 2012 Complete Analysis.pdf"
    ],
    "report_names": [
        "2019-12-21 - Shamoon 2012 Complete Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "42a6a29d-6b98-4fd6-a742-a45a0306c7b0",
            "created_at": "2022-10-25T15:50:23.710403Z",
            "updated_at": "2025-03-27T02:00:55.531313Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "Whisper Spider"
            ],
            "source_name": "MITRE:Silence",
            "tools": [
                "Winexe",
                "SDelete"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "88e53203-891a-46f8-9ced-81d874a271c4",
            "created_at": "2022-10-25T16:07:24.191982Z",
            "updated_at": "2025-03-27T02:02:10.13692Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "ATK 86",
                "Contract Crew",
                "TAG-CR8",
                "TEMP.TruthTeller",
                "Whisper Spider"
            ],
            "source_name": "ETDA:Silence",
            "tools": [
                "EDA",
                "EmpireDNSAgent",
                "Farse",
                "Ivoke",
                "Kikothac",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Meterpreter",
                "ProxyBot",
                "ReconModule",
                "Silence.Downloader",
                "TiniMet",
                "TinyMet",
                "TrueBot",
                "xfs-disp.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "faa4a29b-254a-45bd-b412-9a1cbddbd5e3",
            "created_at": "2022-10-25T16:07:23.80111Z",
            "updated_at": "2025-03-27T02:02:09.985067Z",
            "deleted_at": null,
            "main_name": "LookBack",
            "aliases": [
                "FlowingFrog",
                "LookBack",
                "LookingFrog",
                "TA410",
                "Witchetty"
            ],
            "source_name": "ETDA:LookBack",
            "tools": [
                "FlowCloud",
                "GUP Proxy Tool",
                "SodomMain",
                "SodomMain RAT",
                "SodomNormal"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535833,
    "ts_updated_at": 1743041761,
    "ts_creation_date": 1653488217,
    "ts_modification_date": 1653488217,
    "files": {
        "pdf": "https://archive.orkl.eu/e02ec7e8cdab6ad43de626c0a20a069cb8f6c23b.pdf",
        "text": "https://archive.orkl.eu/e02ec7e8cdab6ad43de626c0a20a069cb8f6c23b.txt",
        "img": "https://archive.orkl.eu/e02ec7e8cdab6ad43de626c0a20a069cb8f6c23b.jpg"
    }
}