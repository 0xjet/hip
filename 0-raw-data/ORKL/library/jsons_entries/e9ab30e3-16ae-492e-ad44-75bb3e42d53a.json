{
    "id": "e9ab30e3-16ae-492e-ad44-75bb3e42d53a",
    "created_at": "2022-10-25T16:48:10.641177Z",
    "updated_at": "2025-03-27T02:05:49.635098Z",
    "deleted_at": null,
    "sha1_hash": "b733176571839bd9bce34d91e7c5cdbf62c7529e",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-07-15T11:42:08Z",
    "file_modification_date": "2020-07-15T11:42:08Z",
    "file_size": 2197273,
    "plain_text": "# THE FAKE CISCO \n\n## Hunting for backdoors in Counterfeit Cisco devices\n\nDmitry Janushkevich\n\n**F-Secure Consulting, Hardware Security Team**\n\nVersion 1.0, July 2020\n\n\n-----\n\n## 1 INTRODUCTION\n\nProducing counterfeit products is, and always has been, a great business if you don't mind being on the wrong\nside of the law. There’s no need to invest in a costly R&D process, and no need to select the best performing and\nlooking materials; the only criterion is the cost of manufacture. This is why we see many imitations of expensive\nproducts on the market, and are likely to continue to see them being made and sold at a fraction of original’s\nprice.\n\nNetwork hardware designed, manufactured, and sold under the Cisco brand is a perfect example of this. Having\nan excellent reputation because of their great engineering, these products sell at a premium price point.\nNaturally, this encourages some to try and produce counterfeits as it’s a way of making easy money. Stories of\nsuch exploits abound in the media: a gang reportedly exporting[1] US$ 10 million worth of gear to the US, the FBI\nseizing shipments[2] of fake hardware, and court rulings being issued[3] to stop the manufacturers. What does Cisco\ndo to combat fraud? Actually, a lot. Cisco has a dedicated Brand Protection organization whose purpose is to\ndefend against counterfeit and gray market activities. They partner with customs teams and regional\ngovernments all over the world with success. In April 2019, they seized $626,880 worth of counterfeit Cisco\nproducts in one day.[4] However, despite successful operations Cisco hasn’t been able to stop fraud fully. If there’s\nan opportunity to make a fast buck, there’ll always be someone willing to take the risk.\n\nIn fall 2019, an IT company found some network switches failing after a software upgrade. The company would\nfind out later that they had inadvertently procured suspected counterfeit Cisco equipment. Counterfeit devices\nquite often work smoothly for a long time, which makes it hard to detect them. In this particular case, the\nhardware failure initiated a wider investigation to which the F-Secure Hardware Security team was called and\nasked to analyze the suspected counterfeit Cisco Catalyst 2960-X series[5] switches. This initiated a research\nproject with the following goals:\n\n- Verify no extra functionality such as \"backdoor access\" was introduced.\n\n- Understand how and why counterfeit devices bypass the platforms authentication security control.\n\nNaturally, as it’s not easy to tell genuine and counterfeit devices apart, to verify whether any kind of \"backdoor\"\nfunctionality existed was also not easy, as it required a considerable amount of technical investigative work.\nUltimately, we concluded, with a reasonable level of confidence, that no backdoors had been introduced.\nFurthermore, we identified the full exploit chain that allowed one of the forged products to function: a\npreviously undocumented vulnerability in a security component which allowed the device’s Secure Boot\nrestrictions to be bypassed.\n\nThis paper details the process which led to this conclusion and shares the technical knowledge gained during\nthis journey.\n\n[1 https://www.pcworld.com/article/2920032/uk-gang-arrested-for-exporting-10-million-of-fake-cisco-gear-to-us.html](https://www.pcworld.com/article/2920032/uk-gang-arrested-for-exporting-10-million-of-fake-cisco-gear-to-us.html)\n\n[2 https://www.infoworld.com/article/2653167/fbi-worried-as-dod-sold-counterfeit-cisco-gear.html](https://www.infoworld.com/article/2653167/fbi-worried-as-dod-sold-counterfeit-cisco-gear.html)\n\n[3 https://www.sdxcentral.com/articles/news/cisco-wins-latest-battle-in-war-against-chinese-counterfeiters/2019/12/](https://www.sdxcentral.com/articles/news/cisco-wins-latest-battle-in-war-against-chinese-counterfeiters/2019/12/)\n\n[4 https://blogs.cisco.com/partner/perform-transform-and-protect](https://blogs.cisco.com/partner/perform-transform-and-protect)\n\n[5 https://www.cisco.com/c/en/us/support/switches/catalyst-2960-x-series-switches/series.html#~tab-documents](https://www.cisco.com/c/en/us/support/switches/catalyst-2960-x-series-switches/series.html#~tab-documents)\n\n\n-----\n\nWhile in this case no \"backdoors\" were identified, the fact the security functions were bypassed means the\nsecurity posture of the device was weakened. This could allow attackers who have already gained code\nexecution via a network-based attack, for example, an easier way to gain persistence, and therefore impact the\nsecurity of the whole organization.\n\n### 1.1 Acknowledgements\n\nThis paper is the result of a huge team effort. The author would like to acknowledge Andrea Barisani’s\ncontribution, who was the first point of contact for the team and started the initial investigative work. Thanks\nalso go to Daniele Bianco and Andrej Rosano, who worked on the initial investigation. Furthermore, the author\nwould like to thank Thierry Decroix for numerous edits and reviewing this paper.\n\n### 1.2 Disclaimer\n\nAs this work presents the results of practical research, some of the information that appears may be insufficiently\nprecise or incorrect. Please proceed at your own risk.\n\n### 1.3 Device details\n\nThe following table details the devices the team had access to. The Genuine device was procured from an\nauthorized distributor and the manufacturer confirmed it was genuine.\n\nDevice type Name SW version\n\nWS-2960X-48TS-L V05 Genuine c2960x-universalk9-mz.152-2.E7\n\nWS-2960X-48TS-L V01 Counterfeit A c2960x-universalk9-mz.150-2.EX5\n(as provided by the source)\n\nWS-2960X-48TS-L V01 Counterfeit B c2960x-universalk9-mz.152-4.E7\n(upgraded, resulting in breakage)\n\nThe devices will be referred to by their names where required.\n\n|Device type|Name|SW version|\n|---|---|---|\n|WS-2960X-48TS-L V05|Genuine|c2960x-universalk9-mz.152-2.E7|\n|WS-2960X-48TS-L V01|Counterfeit A|c2960x-universalk9-mz.150-2.EX5 (as provided by the source)|\n|WS-2960X-48TS-L V01|Counterfeit B|c2960x-universalk9-mz.152-4.E7 (upgraded, resulting in breakage)|\n\n\n-----\n\n## CONTENTS\n\n#### 1 INTRODUCTION ................................................................................. 1\n\n1.1 Acknowledgements ................................................................................................................................... 2\n\n1.2 Disclaimer .................................................................................................................................................. 2\n\n1.3 Device details ............................................................................................................................................. 2\n\n#### 2 ANALYSIS .......................................................................................... 4\n\n2.1 Symptoms .................................................................................................................................................. 4\n\n2.2 Exterior differences ................................................................................................................................... 4\n\n2.3 Board analysis ............................................................................................................................................ 5\n\n2.4 Boot log acquisition and analysis ............................................................................................................. 12\n\n2.5 Content extraction from live systems ...................................................................................................... 13\n\n2.6 Direct Flash content extraction ............................................................................................................... 15\n\n2.7 Flash content analysis .............................................................................................................................. 16\n\n2.8 Bootloader analysis .................................................................................................................................. 20\n\n2.9 HBOOT patch analysis ............................................................................................................................. 22\n\n2.10 SLIMpro analysis ...................................................................................................................................... 24\n\n#### 3 CONCLUSIONS ................................................................................. 30\n\n 4 ABOUT THE AUTHOR ....................................................................... 31\n\n 5 ABOUT F-SECURE HARDWARE SECURITY TEAM ............................... 31\n\n 6 APPENDICES .................................................................................... 32\n\n6.1 The SoC .................................................................................................................................................... 32\n\n6.2 The MZIP file format ................................................................................................................................. 35\n\n6.3 The AMCC file format .............................................................................................................................. 36\n\n6.4 Software signatures and keys ................................................................................................................... 36\n\n\n#### INTRODUCTION ................................................................................. 1\n\nAcknowledgements ................................................................................................................................... 2\n\nDisclaimer .................................................................................................................................................. 2\n\nDevice details ............................................................................................................................................. 2\n\n#### ANALYSIS .......................................................................................... 4\n\nSymptoms .................................................................................................................................................. 4\n\nExterior differences ................................................................................................................................... 4\n\nBoard analysis ............................................................................................................................................ 5\n\nBoot log acquisition and analysis ............................................................................................................. 12\n\nContent extraction from live systems ...................................................................................................... 13\n\nDirect Flash content extraction ............................................................................................................... 15\n\nFlash content analysis .............................................................................................................................. 16\n\nBootloader analysis .................................................................................................................................. 20\n\nHBOOT patch analysis ............................................................................................................................. 22\n\n2.10 SLIMpro analysis ...................................................................................................................................... 24\n\n#### CONCLUSIONS ................................................................................. 30\n\n ABOUT THE AUTHOR ....................................................................... 31\n\n ABOUT F-SECURE HARDWARE SECURITY TEAM ............................... 31\n\n APPENDICES .................................................................................... 32\n\nThe SoC .................................................................................................................................................... 32\n\nThe MZIP file format ................................................................................................................................. 35\n\nThe AMCC file format .............................................................................................................................. 36\n\nSoftware signatures and keys ................................................................................................................... 36\n\n\n-----\n\n## 2 ANALYSIS\n\n### 2.1 Symptoms\n\nThe biggest indication a 2960X device is a counterfeit is that it becomes inoperable after a software upgrade is\nperformed. This also happened to the victim company and the devices had to be replaced. During negotiating\nthe replacement with the vendor, the company found out they had unknowingly bought counterfeit devices.\nMoreover, the CISO was brought in to initiate investigations as to whether the company’s networks had been\ncompromised.\n\nWhile the device lost its primary function as a network switch when the software upgrade was installed, it could\nstill be accessed via the console. The following message was then displayed on the console during boot:\n```\n[Date Time]: %ILET-1-AUTHENTICATION_FAIL: This Switch may not have been manufactured by Cisco\nor with Cisco's authorization. This product may contain software that was copied in violation\nof Cisco's license terms. If your use of this product is the cause of a support issue, Cisco\nmay deny operation of the product, support under your warranty or under a Cisco technical\nsupport program such as Smartnet. Please contact Cisco's Technical Assistance Center for more\ninformation.\n\n```\nReverting the software version did not fix the problem, likely pointing to evidence of data being overwritten\nduring the update process.\n\n### 2.2 Exterior differences\n\nBecause clones and packaging are getting more realistic, many people don't realize they have counterfeit\nnetwork equipment until it's installed and begins acting strangely. However, it is possible to spot minor\ndifferences in the visual appearance of the suspected counterfeits through comparison with a known-genuine\ndevice. Presented below are the most prominent differences we found during our investigations.\n\n**_Figure 1. The suspected counterfeit switch (on the left) has port numbers in bright white, while the known_**\n_genuine device has them in grey. The text itself is misaligned. The triangles indicating different ports are_\n_different shapes._\n\n\n-----\n\n**_Figure 2. The mode button’s shape is slightly different. The square next to the management port is greenish_**\n_on the counterfeit switch. On the genuine device, it is bright yellow._\n\nWhile immediately recognizing such minute differences may be challenging to spot, side-by-side comparison\nclearly shows that the enclosures of counterfeit units are of a lesser quality.\n\n### 2.3 Board analysis\n\nThe main component of any modern electronics is printed circuit boards (PCBs) carrying electronic components\nsuch as integrated circuits, connectors, and passive components. By analyzing these boards, we could spot any\ndifferences and similarities between devices of the same family in the hope of gaining insight into what\nmodifications were done by the counterfeiters.\n\nThe overall board layout of the three devices was similar, with the Genuine unit and Counterfeit B sharing more\nsimilarities in appearance. When observed in detail, however, it was possible to verify modifications for forgery\npurposes, and the differences are significant.\n\nThe absence of a holographic sticker on the counterfeit units was immediately noticeable. While its presence on\nthe Genuine unit was not a guarantee of authenticity, its absence typically indicated a counterfeit.\n\n**_Figure 3. Legitimate holographic sticker which was absent on both counterfeit units._**\n\n\n-----\n\n**_Figure 4. Genuine unit, internal view._**\n\n\n-----\n\n**_Figure 5. Counterfeit A, internal view._**\n\n\n-----\n\n**_Figure 6. Counterfeit B, internal view._**\n\n\n-----\n\nThe Flash part numbers were found to be different, albeit both identifying 1Gbit parallel NOR Flash devices. The\nGenuine unit had Spansion p/n S29GL01GS11TFIV1 installed, while the counterfeit devices were installed with\nMicron/Intel p/n JS28F00AM29EWH. This could be attributed to the fact that the Genuine unit was identified\nas V5 while the counterfeits were V1. It is hard to say without comparing devices of the same version whether\nthis was an indicator. It could also be the result of the manufacturer swapping in cheaper parts.\n\n**_Figure 7. U8, an 1Gbit NOR Flash. PCB rework evidence on the Counterfeit A unit: soldering flux residue on_**\n_and around the Flash IC is present._\n\nWhat was more concerning, was the presence of PCB rework traces around the Flash IC on the Counterfeit A\nunit. While it could be the case the unit was legitimately repaired, no record of such activity was found via\navailable sources. This led us to conclude that, at some point, the Flash chip had been replaced. This may have\nbeen part of legitimate repair activities; however, it is not typical for legitimate repair shops to leave flux residues\non the board.\n\n\n-----\n\n##### 2.3.1 COUNTERFEIT A\n\nCompared to other units, the main board of the Counterfeit A unit had by far the biggest number of components\ninstalled, as well as completely different Ethernet chips. Judging by that, we recognized the possibility of a V1\nboard, as suggested by the device type sticker located on the enclosure.\n\nNo irregularities were spotted during the inspection of the top-side components, but a prominent difference\nwas identified on the bottom side.\n\n**_Figure 8. The Counterfeit A processor board had an \"extra\" component added._**\n\nThe component was connected through vias to the pins of U55 located on the top side of the board, identified\nas a 512Kbit I[2]C EEPROM. While two wires connected to power rails, two connected to pins 5 and 6 of U55,\nwhich carry the I[2]C SCL and SDA bus signals.\n\n**_Figure 9. U55, a I2C EEPROM, ST p/n M24512 marked 412R8 as found in the Counterfeit A unit._**\n\n\n-----\n\n##### 2.3.2 COUNTERFEIT B\n\nThe Counterfeit B unit was found to have one significant difference when compared to other units: the presence\nof components with their top marking removed with a laser; the components are U55 and U10006.\n\nWhereas the same U55 component is a serial EEPROM in the TSSOP-8 package in other units, the Counterfeit B\nunit sported a QFN16 package. This could be a legitimate engineering change when producing a new board\nrevision, but it is unusual for an I[2]C EEPROM to be manufactured in such a package. Furthermore, there is no\nrealistic reason to remove top marking for such a simple part.\n\n**_Figure 10. U55, an unknown component with top marking removed._**\n\nThe other component with its top marking removed was U10006, bearing a nondescript top marking even in a\ngenuine unit: 1341604/QQ2Q8/B1837. Unfortunately, this made determining the exact function of this\ncomponent very challenging.\n\n**_Figure 11. U10006, another component with top marking removed in Counterfeit B. The Genuine unit to the_**\n_right for comparison. Note silkscreen quality was lacking on the counterfeit board._\n\n\n-----\n\nNote the many similarities in via positioning; they matched almost exactly and followed almost the same routing\nfor traces connecting to the passive components on the right. However, U10006 was not only rotated, it also\nappeared to have a different pinout compared to the genuine board. Pin 1 marking was also very different both\non silkscreen and the component itself.\n\n### 2.4 Boot log acquisition and analysis\n\nAny sufficiently sophisticated device needs to have a way to provide an insight for manufacturing engineers and\nend users into its state as well as enable controlling its functioning. Such a way is usually implemented through\nsome sort of a console, allowing the operator to observe system messages as the device boots and to input\ncommands to control the boot process and device operation in general. Naturally, these messages provide a\nwealth of useful information when investigating device workings and as such are important to capture.\n\nFor example, this allowed identification of the software version installed on each device, and was instrumental\nin obtaining clean images from the vendor for further comparison.\n\nInventory information was also displayed during the boot, mainly consisting of serial numbers for various parts\ncomprising the device. This allowed us to verify the numbers against labels present on each part. While not a\ndirect indication of being counterfeit, a mismatch was indicative of the part being replaced.\n\nProbably the most interesting aspect was the analysis of the inoperable device, which failed the platform\nauthentication procedure. From the very start of the boot:\n```\nCPU rev: B\nImage passed digital signature verification\nBoard rev: 18\nTesting DataBus...\nTesting AddressBus...\nTesting Memory from 0x00000000 to 0x1fffffff.../\nUsing driver version 4 for media type 1 \n...\n\n```\nIt is worth noting that the device reported (some) digital signature verification passed, even though the boot\nprocess resulted in a non-functional device. Similarly:\n```\n...\n...done Initializing Flash.\nLoading \"flash:c2960x-universalk9-mz.152-4.E7.bin\"...Verifying image flash:c2960xuniversalk9-mz.1524.E7.bin....................................................................................\n............................................................................................\n............................................................................................\n............................................................................................\n..............Image passed digital signature verification\n@@@...@@@\nFile \"flash:c2960x-universalk9-mz.152-4.E7.bin\" uncompressed and installed, entry point:\n0x3000\nexecuting...\n\n```\nNote the two-pass loading process, with verification being performed separately.\n\n\n-----\n\nHowever:\n```\n...done Initializing flashfs.\nChecking for Bootloader upgrade..\nBoot Loader upgrade not needed(v)\nFIPS: Flash Key Check : Begin\nFIPS: Flash Key Check : End, Not Found, FIPS Mode Not Enabled\nPOST: MA BIST : Begin\nPOST: MA BIST : End, Status Passed\nPOST: TCAM BIST : Begin\nPOST: TCAM BIST : End, Status Passed\nPOST: ACT2 Authentication : Begin\nPOST: ACT2 Authentication : End, Status Failed\nextracting front_end/front_end_ucode_info (43 bytes)\nWaiting for Stack Master Election...\nPOST: Thermal, Fan Tests : Begin\nPOST: Thermal, Fan Tests : End, Status Passed\n...\n\n```\nTo summarize, the platform consisting of bootloaders, together with any potential pre-boot mechanisms\nsuccessfully authenticated the application image. However, the application then failed to authenticate the\nplatform. This seemed to correlate well with the high-level symptoms outlined before, which may have either\nmeant that the software image was patched covertly when loaded, or the patched version was already\nprovisioned; this would be easy to verify once images had been extracted from the devices.\n\n### 2.5 Content extraction from live systems\n\nThe Cisco devices implement advanced management capabilities through the serial console, allowing not only\nto change the configuration settings but also explore the available file systems. This was leveraged as a noninvasive method of extracting contents – we did not know in advance whether raw filesystem data extracted\nfrom Flash ICs could actually be used with non-Cisco systems, for example, mounted in Linux.\n\nThis stage followed directly after boot log acquisition, and leveraged the console access to explore, and tried to\ndiscover and back-up any interesting files present on the local filesystems. Unless a standard filesystem is used,\nextracting files from a raw Flash image is usually significantly harder than copying those off the device when it is\npowered on.\n\nThe devices store the application software image in a file located in the main flash: file system. Therefore, it\nwas relatively easy to obtain a copy of the software being executed on counterfeit devices. The fact that the\nunits stopped working after a software update, yet still reported the updated version during the boot, can be\nconsidered evidence that no hidden software copy was present elsewhere on the system.\n\n\n-----\n\n```\nSwitch#\nMay 11 13:25:40.493: %USBFLASH-5-CHANGE: usbflash1 has been inserted!\nSwitch#dir flash:/\nDirectory of flash:/\n  2 -rwx   1048576 Nov 26 2019 15:34:12 +00:00 test\n  3 -rwx    4120  Oct 3 2019 13:37:32 +00:00 multiple-fs\n  4 drwx     512  Jul 4 2014 02:51:46 +00:00 c2960x-universalk9-mz.150-2.EX5\n 643 drwx     512  Jul 4 2014 02:51:47 +00:00 dc_profile_dir\n122185728 bytes total (97654272 bytes free)\nSwitch#dir flash:/c2960x-universalk9-mz.150-2.EX5\nDirectory of flash:/c2960x-universalk9-mz.150-2.EX5/\n  5 -rwx     800  Jul 4 2014 02:43:35 +00:00 info\n  6 drwx    6144  Jul 4 2014 02:43:35 +00:00 html\n 642 -rwx  18229248  Jul 4 2014 02:45:34 +00:00 c2960x-universalk9-mz.150-2.EX5.bin\n122185728 bytes total (97654272 bytes free)\nSwitch#$copy flash: c2960x-universalk9-mz.150-2.EX5/mz.150-2.EX5/c2960x-universalk9-mz.1502.EX5.bin usbflash1:/\nDestination filename [c2960x-universalk9-mz.150-2.EX5.bin]? CA_c2960x-universalk9-mz.1502.EX5.bin\nCopy in\nprogress...CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\nCCCCCCCCCCCCCC\n18229248 bytes copied in 15.103 secs (1206995 bytes/sec)\nSwitch#\nMay 11 13:27:00.622: %USBFLASH-5-CHANGE: usbflash1 has been removed!\n\n```\nThe downloaded software image could then be verified from the unit by obtaining a legitimate copy of the same\nsoftware version from the manufacturer and comparing SHA256 hashes.\n```\n$ sha256sum CA_c2960x-universalk9-mz.150-2.EX5.bin \n1422575698b28bb6df41942e2147f696f0ce6be9f126cc4e308861047408a647 CA_c2960x-universalk9mz.150-2.EX5.bin\n\n```\nThe hashes were found to match; no changes were made to the software image stored on the counterfeit unit.\nThis meant it was highly likely application software was patched in memory after load.\n\nHowever, some information of potential interest is rarely stored in file systems. For example, boot loader\nprograms, or bootloaders, are rarely present there and are typically stored in \"raw\" form directly in Flash\nmemory. The only way to gain access to this code is through extraction of raw Flash memory content followed\nby analysis of whatever content was actually extracted.\n\n\n-----\n\n### 2.6 Direct Flash content extraction\n\nAs already noted, the boards sported a prominent parallel NOR Flash chip of considerable size. This made the\nchip the prime candidate for storing at least the application part of the overall software package, so was the first\none to be checked for suspicious traces.\n\nAll three devices underwent the same extraction procedure. First, the chips were removed from the boards.\nThen, Flash content extraction was performed with the Elnec BeeProg2 with 70-3170 TSOP56 adapter, using\nthe Elnec software PG4UW. Content inspection showed the chips were written with bytes swapped with 16-bit\nwords, thus requiring a quick adjustment to accommodate for that.\n\n**_Figure 12. Evident byte swapping in the extracted content. The text was intelligible but required a certain_**\n_mental strain to understand it._\n\n**_Figure 13. TSOP56 adapter used. (Image taken from the official Elnec web site)_**\n\nThree images were obtained, each 128MB in size. After content extraction, the Flash chips were installed back\non the boards to return them to an operable state.\n\n\n-----\n\n### 2.7 Flash content analysis\n\nThe main purpose behind this step was to gather intelligence on how data was stored on the physical medium,\nand whether there was anything not accounted for during the live system analysis step performed before, such\nas bootloader code, any signatures, etc.\n\nA quick content inspection using the entropy graphing feature of the binwalk tool showed us several areas of\ninterest.\n\n- The high-entropy area of about 20M bytes was probably the main software image, fitting the size and the\n\nentropy level as compressed data has high entropy\n\n- What followed were two areas of distinct entropy footprints, likely some sort of uncompressed data\n\n- The zero-entropy area is where the same 0xFF value was written and can be considered empty\n\n- At the very end, there were several small but distinct blocks of data\n\nAfter manual inspection at the very beginning of the image and direct binary comparison, we concluded that no\nbootloader code of any kind was placed there; the data looked more like a file system. Supporting that\nassumption was the difference in the composition of the blocks on the devices. Therefore, it made more sense\nto assume bootloader code was located at the end of the Flash; this was supported by the similar-looking\nentropy graph for all images towards the end.\n\n**_Figure 14. Zoomed view showing the very end of the image. The picture was very similar for all three Flash_**\n_images._\n\nIndeed, inspecting the last megabyte revealed the presence of what appeared to be two bootloader programs,\neasily identified with the help of embedded strings (examples from Counterfeit A):\n```\nC2960X Boot Loader (C2960X-BROM) Version 15.2(2r)E1, RELEASE SOFTWARE (fc1)\nCompiled Wed 23-Apr-14 02:21 by abhakat\n\n```\nand\n```\nC2960X Boot Loader (C2960X-HBOOT-M) Version 15.2(2r)E1, RELEASE SOFTWARE (fc1)\nCompiled Wed 23-Apr-14 02:21 by abhakat\n\n```\nThese boot loaders corresponded to the last two peaks on the entropy graph above.\n\n\n-----\n\n**_Figure 15. Entropy graph of the known-good Flash image obtained from the Genuine unit._**\n\n**_Figure 16. Entropy graph of the suspect Flash image obtained from the Counterfeit A unit._**\n\n\n-----\n\nThe next series of peaks of around 130 to 132MB represent data that was hard to attribute to anything that was\nknown, but the best guess was that it was related to the Flash file systems. However, one interesting piece of\ninformation at the very end stood out; it was marked with the magic string AMCC and contained what appeared\nto be file names such as ppc.bin.key and pka_fw.bin. The analysis of this file format is summarised in appendix\n6.3.\n\nThe peak around 127MB belonged to the microcode binary named `c2960x_dlpd_porter.bin. This file was`\nlocated on the ucode0 filesystem.\n\nFinally, two small peaks represented the lic0 and lic1 filesystems.\n\nThe following table summarizes the investigation of the last few megabytes of the Flash contents of the\nCounterfeit A unit.\n\nOffset Contents\n\n0x76A0000 The lic1 filesystem\n\n0x7720000 The lic0 filesystem\n\n0x78C0000 The ucode0 filesystem\n\n0x7DA0800 Block of data marked AMCC\n\n0x7DC0000 Board configuration (text based)\n\n0x7EE0000 C2960X Boot Loader (C2960X-HBOOT-M)\n\n0x7FDD800 Inventory data\n\n0x7FDDC00 Signature 1\n\n0x7FDFFFC 4 bytes, 55 AA AA 55\n\n0x7FE0000 C2960X Boot Loader (C2960X-BROM)\n\n0x7FFDC00 Signature 2\n\n0x7FFF000 Unknown; appears to be PowerPC code but no text strings to identify it\n\n0x7FFFFFC 4 bytes, 4B FF F0 02 (decodes as the ba 0xfffff000 PowerPC instruction)\n\nIt can also be assumed the main `flash filesystem started right at offset zero. While offsets of the first three`\nentries differed on other units, the overall composition was expected to be the same.\n\nWith some general understanding of what was where in the Flash, it was then possible to perform a meaningful\ncomparison of Flash contents between the genuine unit and the counterfeit one, which was not upgraded.\n\nLooking at the very end of the file, some differences stood out.\n\nBoth counterfeit units had offsets 0x7FFF800..0x7FFFFFC and 0x7FFE000..0x7FFF000 filled with apparently\nrandom noise. Given that Flash chips in the erased state had all bits set, it was unlikely this was uninitialized data.\n\n|Counterfeit A unit.|Col2|\n|---|---|\n|Offset|Contents|\n|0x76A0000|The lic1 filesystem|\n|0x7720000|The lic0 filesystem|\n|0x78C0000|The ucode0 filesystem|\n|0x7DA0800|Block of data marked AMCC|\n|0x7DC0000|Board configuration (text based)|\n|0x7EE0000|C2960X Boot Loader (C2960X-HBOOT-M)|\n|0x7FDD800|Inventory data|\n|0x7FDDC00|Signature 1|\n|0x7FDFFFC|4 bytes, 55 AA AA 55|\n|0x7FE0000|C2960X Boot Loader (C2960X-BROM)|\n|0x7FFDC00|Signature 2|\n|0x7FFF000|Unknown; appears to be PowerPC code but no text strings to identify it|\n|0x7FFFFFC|4 bytes, 4B FF F0 02 (decodes as the ba 0xfffff000 PowerPC instruction)|\n\n\n-----\n\n**_Figure 17. Differences at the very end between the Counterfeit A and Genuine units. While the last four bytes_**\n_were the same, the counterfeit unit had some extra bits and pieces, unlike the erased genuine bits._\n\nUnfortunately, further comparison was thwarted by the difference in versions of installed software and\nbootloaders. It was necessary to locate intact copies of the bootloader code in order to perform any kind of\nmeaningful differential analysis.\n\n\n-----\n\n### 2.8 Bootloader analysis\n\nFurther analysis required obtaining software images of corresponding versions from the official sources.\nHowever, first the software versions needed to be identified. This could be done via the file name of the installed\napplication image. Furthermore, the following bootloader image versions were present on the counterfeit units\nat hand:\n\n- Counterfeit A (operational):\n```\nC2960X Boot Loader (C2960X-HBOOT-M) Version 15.2(2r)E1, RELEASE SOFTWARE (fc1)\nCompiled Wed 23-Apr-14 02:21 by abhakat\nC2960X Boot Loader (C2960X-BROM) Version 15.2(2r)E1, RELEASE SOFTWARE (fc1)\nCompiled Wed 23-Apr-14 02:21 by abhakat\n\n```\n- Counterfeit B (inoperable):\n```\nC2960X Boot Loader (C2960X-HBOOT-M) Version 15.2(4r)E3, RELEASE SOFTWARE (fc4)\nCompiled Wed 04-Apr-18 10:35 by smaddasa\nC2960X Boot Loader (C2960X-BROM) Version 15.2(2r)E2, RELEASE SOFTWARE (fc1)\nCompiled Fri 05-Dec-14 01:35 by abhakat\n\n```\nThe version strings appeared unique enough to allow a search for them within the uncompressed data sections\nof the images at hand; see appendix 6.2 regarding the file format of the software image. In fact, they were\nincluded as one monolithic image, likely directly copied to Flash in parts, starting from offset 0x7EE0000, taking\ncare to preserve inventory data. Bootloader images extracted from genuine software updates could then be\ndirectly compared with their counterparts obtained from Flash content extracted directly from the units.\n\nThe `c2960x-universalk9-mz.150-2.EX5.bin software image obtained from Counterfeit A did not contain`\nembedded bootloaders, so a search was conducted by grabbing multiple official images and matching version\nnumbers found in there. The c2960x-universalk9-mz.152-2.E.bin image provided the correct versions.\n\nChecking the bootloader images obtained from Counterfeit A:\n\n- Two changes were made to HBOOT: the first one to 8 bytes inside the code section, and the second which\n\nwas considerably larger, appearing appended to the HBOOT image\n\n- Signature 1 data was intact\n\n- 12 bytes modified right before the BROM code\n\n- BROM code was intact\n\n- Signature 2 data was different\n\n- Extra data is present around the code block at 0x7FFF000, as highlighted before\n\nAt this point, the process in place for verification of each software piece was not known. However, it was evident\nthat some tampering with HBOOT had taken place. To understand these modifications and their significance\nwithin the context of the system, it is important to consider what was known about the System-on-Chip and the\nway it booted up. The collected reference data is summarized in appendix 6.1.\n\n\n-----\n\nAssuming the PowerPC core started executing at 0xFFFFFFFC, the Flash ROM could be safely placed at the upper\naddresses so that the last 4 bytes in Flash, where we assumed the unconditional branch instruction was, map\nstarting at 0xFFFFFFFC.\n\nAfter loading the last 1 megabyte or so of Flash into IDA Pro in the manner described above, we could start\nexploring the code. The assumption made above regarding Flash mapping is validated by the fact that IDA Pro\ncould explore the code and create references automatically.\n\nThe branch instruction at 0xFFFFFFFC transferred control to the small blob of PowerPC instructions at\n0xFFFFF000. This piece of code appeared to perform some basic initialization activities and passed control\nfurther to BROM.\n\nJudging by the contents of text strings included, BROM appeared to authenticate and start HBOOT and\nprovided a rudimentary set of commands to rescue the system from the state where HBOOT could be started.\nWhile we were not as interested in the details of the command system, the image authentication functionality\nwas important to understand.\n\nThis functionality could be located easily by finding references to the tell-tale string Image passed digital\n```\nsignature verification that was being printed on the serial console when image authentication succeeded.\n\n```\nThe function referencing this string together with the companion failure message took 6 parameters, most\nimportant of which were the base address of HBOOT and the signature 1 address. This meant signature 1 was in\nfact the HBOOT signature.\n\nBy repeating the search and analysis on the HBOOT image, a similar function was identified that was used for\nthe same purpose of image authentication. This function was used to authenticate the application software\nimage; the process also showed up in console output. However, another use of the same function was made to\nauthenticate BROM code when it was being copied over to the Flash memory. Careful inspection of the\nparameters being passed revealed that the BROM signature was located 0x2400 bytes before the image end,\nwhich was exactly where signature 2 was located. We could therefore conclude that signature 2 authenticated\nBROM code.\n\nFurther inspection of the signature verification implementation in both BROM and HBOOT showed the use of\nsome functions related to \"SlimPro\", as evident by corresponding error messages referenced by those functions:\n```\nWR: Timeout waiting for SlimPro response\nRD: Timeout waiting for SLimPro msg\nRD: Timeout waiting for SLimPro response\n\n```\nThe answer to the question of what this component might be came from various materials published by the\nvendor. The SLIMpro was a separate computing unit integrated into the System-on-Chip and was responsible\nfor system-related security operations. The strings presented above confirmed this information. Further\ninformation on the SoC can be found in appendix 6.1.\n\nWith a clear overview of what was verified, when, and how, a prominent question arose: how did BROM report\nsuccessful verification of the modified HBOOT code? Answering this required a review of what was already\nknown, and a deeper dive into the modifications performed on the hardware of the Counterfeit A unit. But first,\nthe changes done to HBOOT and their purpose were investigated.\n\n\n-----\n\n### 2.9 HBOOT patch analysis\n\nThe analysis required a good understanding of what HBOOT did and how. We began by observing that like\nBROM, HBOOT implemented a console with an impressive set of commands. Finding out how these commands\nwere added allowed us to spot every implemented command, and rename the corresponding handler functions.\nThis provided at least some insight into what parts were patched.\n\n**_Figure 18. List of console commands supported by HBOOT._**\n\nStarting with the first modification of two PowerPC instructions in the middle of the HBOOT code section, we\nsaw the boot command implementation was modified to include a call to the other added code fragment. The\ncall was patched in to be performed after the application image was loaded into memory and authenticated.\n\nAnalysis of the inserted code revealed this to be the first stage of a de-obfuscator (XOR-based with the key\nderived from the unit serial number), processing the \"random\" data previously discovered at the end of Flash.\nThis data is de-obfuscated into a stack-based buffer, and control was then passed there. Care was taken to verify\nthe operation was performed correctly, so the unit did not crash even when there was no obfuscated data\npresent.\n\nThat code was found to be a stage 2 de-obfuscator, with the key based on certain data from the Flash IC not\naccessible directly through conventional tools we had. Due to these circumstances, the key had to be brute\nforced. Similarly, the de-obfuscated code of stage 3 was again placed into a stack-based buffer and executed.\n\n\n-----\n\nStage 3 was found to be the actual patching code, searching for the `serialNu string and applying some`\nmodifications to the IOS image expected to be already loaded in memory. The modifications were few and\nconsisted of mainly \"return OK\" kind of patches; full details of functions being patched will not be published for\nobvious reasons. However, it appeared the only purpose of this \"added functionality\" was to circumvent\nsoftware licensing protections.\n\nIt was due to this added patching functionality that the counterfeit units could bypass platform authenticity\nverification. This also explained why units stopped working after a software update: the latest software will\nalmost certainly rewrite the patched HBOOT code, removing the work done to bypass the checks. The case of\nthe Counterfeit B unit confirmed this hypothesis.\n\nWhen the CISO of the victim company provided us the counterfeit devices for investigation one of the main\ntasks was to answer whether there were any backdoor-like functionalities being introduced. We concluded this\ndid not appear to be the case for application and HBOOT code.\n\n\n-----\n\n### 2.10 SLIMpro analysis\n\nWe had reached the point where we were ready to investigate the question posed previously with regards to\nthe bypassing of HBOOT image verification. As the SLIMpro component was responsible for authentication\nbecause PowerPC cores only initiated the process by posting a message to a \"mailbox\", it was reasonable to\nconclude that some changes were implemented, resulting in this component always reporting a successful\nauthentication. By identifying and understanding these changes we would be able to explain how the\ncounterfeiters are able to bypass the code authentication function.\n\nWhat piqued our interest in the case of Counterfeit A was the \"implant\" added in conjunction with a serial\nEEPROM chip. What was the reason for such an unusual and obvious addition? Furthermore, the same chip had\nbeen replaced with a completely different package in Counterfeit B.\n\n**_Figure 19. The implant PCB, disconnected from the unit, with the resin blob removed. As with Counterfeit B,_**\n_the top marking was erased._\n\nSince the protocol used to interface with EEPROM was relatively simple and slow, it was easy to intercept and\nrecord the communications to gain insight into the workings of this implant. Any existing tool able to decode\nI[2]C communications and export the decoded traffic could be used for this purpose. Below is a short excerpt of\nthis intercepted traffic as produced by the Logic software shipped with Saleae logic analyzer:\n```\nTime [s],Packet ID,Address,Data,Read/Write,ACK/NAK\n3.256962416666667,0,'164' (0xA4),'0' (0x00),Write,ACK\n3.257046583333334,0,'164' (0xA4),'0' (0x00),Write,ACK\n3.257230166666667,1,'164' (0xA4),'240' (0xF0),Read,ACK\n3.257315166666667,1,'164' (0xA4),'240' (0xF0),Read,ACK\n3.257400333333333,1,'164' (0xA4),'3' (0x03),Read,ACK\n3.257485416666666,1,'164' (0xA4),'18' (0x12),Read,ACK\n3.257570500000000,1,'164' (0xA4),'0' (0x00),Read,ACK\n3.257655583333333,1,'164' (0xA4),'252' (0xFC),Read,ACK\n...\n\n```\nAccording to the M24512 data sheet, random-access read operation was performed by writing two address\nbytes followed by reading multiple bytes of data. This corresponded to the observed traffic. A simple script was\n\n\n-----\n\nwritten to parse such output and to create a dump file containing the intercepted contents, as well as to provide\nsome overview on the read transactions executed.\n```\nBelow is the output of the script showing what addresses were accessed and how many bytes read\n(in hexadecimal), which is much easier to analyze compared to the raw transactions. It has\nbeen abbreviated due to its size.Start address: 0000, byte count: 0020\nStart address: 021E, byte count: 0004\nStart address: 0020, byte count: 0040\nStart address: 0060, byte count: 0040\nStart address: 0060, byte count: 0040\nStart address: 00A0, byte count: 0040\nStart address: 00E0, byte count: 0040\nStart address: 0120, byte count: 0040\nStart address: 0160, byte count: 0040\nStart address: 6320, byte count: 0400\n[SEQUENTIAL ACCESS PATTERN CONTINUES]\nStart address: 7320, byte count: 0400\nStart address: 7720, byte count: 0364\nStart address: 0060, byte count: 0040\nStart address: 0060, byte count: 0040\nStart address: 00A0, byte count: 0040\nStart address: 00E0, byte count: 0040\nStart address: 0060, byte count: 0040\nStart address: 00A0, byte count: 0040\nStart address: 00E0, byte count: 0040\nStart address: 0120, byte count: 0040\nStart address: 61A0, byte count: 0100\nStart address: 6020, byte count: 0100\nStart address: 0060, byte count: 0040\nStart address: 00A0, byte count: 0040\nStart address: 00E0, byte count: 0040\nStart address: 6020, byte count: 0100\nStart address: 0060, byte count: 0040\nStart address: 00A0, byte count: 0040\nStart address: 5EA0, byte count: 0100\nStart address: 0220, byte count: 0200\n[SEQUENTIAL ACCESS PATTERN CONTINUES]\nStart address: 5E20, byte count: 0050\nStart address: 0220, byte count: 0400\n[SEQUENTIAL ACCESS PATTERN CONTINUES]\nStart address: 5E20, byte count: 0050\n\n```\nExactly the same behavior was observed when traffic was captured on the Genuine unit.\n\nThe following could be immediately noted:\n\n- Repeating small accesses to addresses 0x60 through 0xE0 of 0x40 bytes each, followed by a significant\n\nsequential read.\n\n- Data starting at address 0x220 was read twice, but with different transaction sizes.\n\n\n-----\n\nHere is a closer look at what was being read:\n\n**_Figure 20. The beginning of the obtained EEPROM/implant dump of the Counterfeit A unit._**\n\nAfter a 32-byte block of unknown data, we could see the AMCC magic bytes, identifying the container format\ndescribed in appendix 6.3. By correlating the accesses with file offsets within the container, it was easy to identify\nwhich files from this container were being read and in what order, so a higher-level overview could be pieced\ntogether:\n\n- `pka_fw.bin`\n\n- `ipp.bin.ksg`\n\n- `ipp.bin.key`\n\n- `ipp.bin.sig`\n\n- `ipp.bin`\n\n- `ipp.bin (again)`\n\nThe fact that the `ipp.bin file was being read twice stands out. This mirrored the situation with the main`\napplication binary being read twice; first to verify the signature, then to decompress and pass control to.\nTherefore, it is easy to assume the similar situation here as well: verify, then execute.\n\nSuch an implementation, however, is vulnerable to a classic race condition called time-of-check to time-of-use\n(TOCTOU) where verified content could be manipulated after it had been verified but before its use. This\nimmediately prompted a comparison between the two reads (it was easy to truncate the I[2]C traffic dump to\nexclude the second series of transactions starting at address 0x220).\n\nQuite similarly to the HBOOT patch, two differences were detected: one small patch within the bulk of the file\nand another, larger binary blob appended to the image.\n\nAssuming this file contained software for some CPU architecture and not data, we could attempt to identify\nwhich architecture this was meant to be executed on. Unfortunately, `binwalk -A did not produce any`\nmeaningful output. However, the following facts were observed:\n\n- The beginning of the file appeared to contain a set of 32-bit little-endian integers similar in magnitude except\n\nthe very first one\n\n- The byte sequence 70 47 was encountered quite often in the file\n\nThese two facts point at the possibility of this being ARM Thumb code, with the exception vectors located at the\nbeginning as is common with ARM-based embedded systems. From there, it was easy to verify the assumption\nand guess the correct loading address with IDA Pro.\n\nIt was also possible to locate the previously observed BOOT FAIL string in this file.\n\n\n-----\n\nWith that, we concluded that the ipp.bin file contained software running on the SLIMpro SoC component.\n\nAfter loading the image in IDA Pro and spending some time marking up known library functions, we turned our\nattention to the changes made to the image by the implant. It transpired that a call to memcmp() was replaced in\na certain function with a call to another function introduced by the patch; the new function inherited the original\nsemantics. Below is the pseudocode of the replacement function:\n```\nint __fastcall ADDED_sub_xxxx(const void *a1, const void *a2, unsigned int a3)\n{\n signed int i; // r3\n int result; // r0\n // Check the conditions\n if ( (MEMORY[0x50000088] ^ MEMORY[0x5000008C]) == (MEMORY[0x2FFFFFF0] ^ MEMORY[0x2FFFFFF4])\n  || *a2 == 0x27 && *(a2 + 1) == 0x4F )\n {\n  n = 2;\n }\n // Compare the bytes\n for ( i = 0; i < n && *(a1 + i) == *(a2 + i); ++i )\n  ;\n // Report the result\n if ( i == n )\n  result = 0;\n else\n  result = -1;\n return result;\n}\n\n```\nNot having access to the SoC reference manual or other sources of information concerning the SoC memory\nmap as seen by SLIMpro, made it very challenging to understand what the first condition meant. The second\ncondition took into account the contents of one of the input buffers: it should have started with bytes 27 4F. In\nboth cases, the number of bytes to be compared was reset to two.\n\nConsidering the goal of the whole effort was to bypass signature verification checks, a reasonable guess was that\nthis function made that possible in some cases. On inspecting signatures present in the extracted Flash images,\nwe found the following BROM signature (after RSA decryption):\n\n**_Figure 21. Decrypted BROM signature._**\n\nAn immediate conclusion was that the second condition was used to circumvent the BROM signature check,\nwhile we could only assume that the first condition was somehow involved in circumventing HBOOT signature\ncheck.\n\n\n-----\n\nThe same exercise could be repeated against Counterfeit B. The integrated circuit installed on the processor\nboard appeared to have the same pinout as the one found on the implant PCB on Counterfeit A. This was\nperformed by tapping the correct vias on the board, given connecting to the pads of the QFN package footprint\nwas not feasible. Here is the list of transactions performed on the bus for this unit.\n```\nStart address: 0000, byte count: 0020\nStart address: 0020, byte count: 0100\nStart address: 0120, byte count: 0400\nStart address: 0520, byte count: 0400\nStart address: 0920, byte count: 0400\nStart address: 0D20, byte count: 0400\nStart address: 1120, byte count: 0400\nStart address: 1520, byte count: 0400\nStart address: 1920, byte count: 0400\nStart address: 1D20, byte count: 0400\nStart address: 2120, byte count: 0400\nStart address: 2520, byte count: 0400\nStart address: 2920, byte count: 0400\nStart address: 2D20, byte count: 0400\nStart address: 3120, byte count: 0400\nStart address: 3520, byte count: 0400\nStart address: 3920, byte count: 0400\nStart address: 3D20, byte count: 0400\nStart address: 4120, byte count: 0400\nStart address: 4520, byte count: 0400\nStart address: 4920, byte count: 0400\nStart address: 4D20, byte count: 0400\nStart address: 5120, byte count: 0400\nStart address: 5520, byte count: 0400\nStart address: 5920, byte count: 0400\nStart address: 5D20, byte count: 0250\n\n```\nThe differences were obvious: apart from two shorter reads at the beginning, the whole content was read in one\ngo, with no per-file read patterns as observed in Counterfeit A. Further inspection of the dumped data revealed\npseudo-random data with no discernible structure, apart from the first 0x120 bytes. The 32-byte header\ncontained the same data; however, the AMCC file structure was not found. Instead, it appeared the software\nimage starts as is. We could only conclude that the contents were encrypted in some way, and that no further\nanalysis was possible.\n\n**_Figure 22. The beginning of the obtained EEPROM/implant dump of Counterfeit B._**\n\n\n-----\n\nGiven that, there was an answer to the last question concerning the operation of Counterfeit A: a TOCTOU\nvulnerability affecting SLIMpro ROM code was exploited in the wild to bypass software signature checks against\nthe SLIMpro secure processing unit. By extension, the issue affects the Genuine unit as well. While one previously\npublished report[6] regarding issues in the Cisco Catalyst secure boot process was accessible, at the time of\nwriting this paper, no public information was available detailing this or similar issues affecting the Catalyst 2960X series. This led us to believe this was indeed a previously unknown vulnerability.\n\nIt is important to note that the comparison of EEPROM data extracted from the Genuine unit and unpatched\ndata extracted from Counterfeit A showed them to be identical. As the patches were designed to bypass\nsignature checks only, we could conclude there was no \"backdoor\" code introduced into the SLIMpro\nenvironment.\n\n6 https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190513-secureboot\n\n\nGiven that, there was an answer to the last question concerning the operation of Counterfeit A: a TOCTOU\nvulnerability affecting SLIMpro ROM code was exploited in the wild to bypass software signature checks against\nthe SLIMpro secure processing unit. By extension, the issue affects the Genuine unit as well. While one previously\nregarding issues in the Cisco Catalyst secure boot process was accessible, at the time of\nwriting this paper, no public information was available detailing this or similar issues affecting the Catalyst 2960-\nX series. This led us to believe this was indeed a previously unknown vulnerability.\n\nIt is important to note that the comparison of EEPROM data extracted from the Genuine unit and unpatched\ndata extracted from Counterfeit A showed them to be identical. As the patches were designed to bypass\nsignature checks only, we could conclude there was no \"backdoor\" code introduced into the SLIMpro\n\nhttps://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190513-secureboot\n\n\n-----\n\n## 3 CONCLUSIONS\n\nThe problem of counterfeiting is wide and raises a number of concerns. Not only does it mean a loss of trust in\nthe brand, and loss of revenue for the company whose products get copied, but counterfeit devices also pose a\nsecurity risk to the victim companies.\n\nThe two counterfeit devices provided to us for this research were detected after a software upgrade resulted in\na failure. These units were assessed from both software and hardware perspectives to investigate whether the\nvictim company’s networks had been compromised via introducing \"backdoor access”, and to understand how\nand why counterfeit devices bypassed the platform’s authentication security control.\n\nBoth units reached their goal of circumventing the implemented platform authentication checks with similar\nmeans on the software level by relying on patching the loaded and authenticated application image before\ncontrol was passed over to the application. The functionality implementing the patches was wrapped into\nmultiple layers of obfuscation. However, these authentication bypasses were performed on each boot and thus\nwere not persistent.\n\nNo further functionality was identified on the software level that could be considered as backdoors – both in\nPowerPC and SLIMpro code. This conclusion was supported by the fact that genuine software was patched onthe-fly and the patches only served to circumvent authenticity checks.\n\nOn the hardware level, the two units took quite different approaches as to circumventing boot-time software\nauthentication.\n\nCounterfeit A contained \"add-on\" circuitry which exploited a race condition in the SLIMpro ROM code to bypass\nSLIMpro software verification. It did this by intercepting EEPROM control signals, replacing certain bytes in the\nimage being loaded to modify software behavior. It appears the processor PCB in this unit was not modified.\n\nWhile Counterfeit A only received a post-manufacturing add-on circuitry, the PCB design of Counterfeit B was\nchanged to incorporate the modification of Counterfeit A and replaced the EEPROM completely with an\nunknown integrated circuit. This signified a considerable resource investment in design, manufacture, and\ntesting of such forged products compared to the more low-cost ad-hoc approach used in Counterfeit A. The\nboard layout and silkscreen similarities also suggested that the people behind this forgery might have either\nhad access to Cisco proprietary engineering documentation such as PCB design files in order to be able to\nmodify them, or they invested heavily in the complicated process of replicating the original board design files\nbased solely on genuine boards.\n\n\n-----\n\n## 4 ABOUT THE AUTHOR\n\nDmitry Janushkevich began his career as a testing- and later embedded-software engineer working on the\ndevelopment of leading-edge solid-state drive technologies. Together with a bachelor's degree in computer\nsystems design, this has given him a strong background in embedded systems design and development for\nfuture explorations in their security.\n\nAfter joining F-Secure Consulting and gaining experience in customer-facing consultancy, embedded systems\nsecurity became his primary focus. Currently a senior consultant, he has a strong track record in providing\nsecurity-related consulting for automotive, aerospace, and consumer electronics industries.\n\n## 5 ABOUT F-SECURE HARDWARE SECURITY TEAM\n\nF-Secure Consulting’s Hardware Security team provides information security consulting to the most unique,\nchallenging and critical industries in the world. It delivers industry-leading services to secure hardware, safetycritical embedded systems, software applications and IT infrastructure.\n\nIt also provides detailed and comprehensible security analysis of software and hardware systems, along with\npractical and effective mitigation and protection strategies.\n\nWith a vast breadth of experience in hardware and software design and engineering, it’s trusted by companies\nacross the globe to assess and test their products and processes. Its work safeguards products from malicious\ncompromise, and in doing so protects the safety of passengers, ensures the resilience of critical infrastructure,\nand secures company trade secrets and intellectual property.\n\n\n-----\n\n## 6 APPENDICES\n\n### 6.1 The SoC\n\nThis appendix details what little information was publicly available on the main System-on-Chip (SoC) in charge\nof the device, paying special attention to any security features.\n\n**_Figure 23. U1, the main SoC in situ in Counterfeit A. A couple of crystals and a backup Lithum battery can be_**\n_seen around._\n\nThe main SoC was marked as APM86392-CNE600T[7] made by Applied Micro Corp (now MACOM). The\nmanufacturer describes the system as based around the Dual-Core Power™465 processor. No mention of\nfeatures related to code authentication during boot could be found on the manufacturer's website. However,\nsome details can be gleaned via announcements[8] in the media[9].\n\n7 https://www.macom.com/products/product-detail/APM86392\n\n8 https://linuxdevices.org/powerpc-soc-available-with-dual-cores/\n\n9 https://www.embedded.com/applied-micro-adds-arm-core-in-cut-down-security-processor/\n\n\n-----\n\n**_Figure 24. Block diagram of APM86392. Image taken from linuxdevices.org._**\n\nAny units relating to security were of particular interest; sometimes these units were not labelled as such but\nwere given cryptic or trademarked names. Two such units stick out: \"Security Engine\" and \"SLIMpro\". The\n\"Security Engine\" was quite likely to be the one mentioned by the manufacturer as \"security subsystem\n(optional) with acceleration for IPSec, SSL/TLS, SRTP/SRTCP, Kasumi, and public-key protocols (PKA)\" on the\nproduct page. However, what is SLIMpro?\n\nThe same media source describing[10] a previous generation of the same SoC cites the manufacturer: \"…\nAppliedMicro also added its Scalable Lightweight Intelligent Management Processor (SlimPro) coprocessor,\nwhich provides advanced power management, security, and concurrency features …\" while also mentioning\nSecure Boot and namedropping \"SlimPro Trusted Management Module\" which appeared to be relevant to this\nresearch.\n\nSearching for \"AppliedMicro Trusted Management Module\" yielded a very interesting – and apparently public\n– presentation[11] documenting exactly that unit. We strongly recommended the reader to read through the\nwhole presentation, but here we note that the SLIMpro unit indeed represented the security epicentre of the\nwhole SoC.\n\n10 https://linuxdevices.org/dual-core-15ghz-soc-touted-for-power-management-concurrency/\n\n11 https://docplayer.net/995240-Appliedmicro-trusted-management-module.html\n\n\n-----\n\nSpeculatively, and in accordance with what the presentation tried to show, the SLIMpro unit booted first and\nwas responsible for authenticating and starting any code on the PowerPC cores, apart from overall system\nconfiguration tasks. This speculation was easy to verify by swapping NOR Flash chips between a counterfeit unit\nand the genuine one. The genuine unit stopped booting completely, and the message displayed over the serial\nconsole was:\n\n```\nBOOT FAIL\n\n```\n\nThe counterfeit unit, on the other hand, proceeded to start the bootloaders as expected.\n\n##### 6.1.1 THE BOOT PROCESS\n\nThere should be enough information – with some guesswork – to piece together the overall boot process from\nthe security standpoint, considering all known processing cores that participated.\n\n1. SLIMpro start up\n\na) SLIMpro was expected to perform authentication of Flash contents\nb) SLIMpro started (one?) PPC core, setting PC to 0xFFFFFFFC (most common configuration)\n\n2. PPC core ran PBL code at Flash offset 0x7FFF000 (previously unidentified)\n3. PPC core ran BROM code (by correlating console messages with BROM contents)\n\na) BROM authenticated HBOOT code\n\n4. PPC core ran HBOOT code (by correlating console messages with HBOOT contents)\n\na) HBOOT authenticated application code\n\n5. PPC core ran application code\n\na) Application code authenticated the platform\nb) Depending on the result, the unit became inoperable\n\n\n-----\n\n### 6.2 The MZIP file format\n\nCisco delivers software updates for Catalyst devices as a single binary file. This meant updates for all system\ncomponents were carried in this file, whether application software, bootloaders, or microcode. This warranted\na closer look into the format of this file.\n\nThe file format was identified with the first four bytes being \"MZIP\" and was referred to as such. Apparently, this\nwas a \"Cisco IOS MZIP compressed image\" as noted on some sources on the Internet. No specifications were\npublicly available.\n\nSome existing tools[12] were found which served as a starting point for researching the format, however no tool\nwas found which would handle unpacking of the images at hand. Naturally, the code that was responsible for\nloading MZIP files should serve as the best reference, so the already obtained genuine bootloader images could\nbe used for that purpose. Quite a lot of references to MZIP were found in the HBOOT image, so the relevant\nparts were reverse engineered.\n\nOn a very high level, the file format was very similar to what would be found in executable file formats – this\ncould easily be seen from what mziptools was intended to output: some fixed header data including an entry\npoint address as well as a collection of segments. This meant the file was simply a program image which was\nloaded and executed by the bootloader chain.\n\nSegments could also be optionally compressed with PKZIP or BZIP2. Judging by the presence of the usual\n```\nBZh91AY... signature, data in our files was indeed compressed with BZIP2. As data is BZIP2 compressed, it was\n\n```\npossible to apply usual tools such as binwalk for data carving and decompression of relevant sections. While this\ndid not add much insight into the file format, it served as the first step to understand what was contained inside.\n\nWhile provisions were present for more complicated arrangements, the contents proved to be very simple: one\ncode section and one data section.\n\nSome trailer data was also included. This contained some textual information possibly related to the build\nconfiguration and provided versioning information which we didn’t really need. Appended there, however, was\nthe image signature apparently used to authenticate the image, likely to be RSA2048 judging by the size. The\nsignature followed the same format used to authenticate both HBOOT and BROM images.\n\nTo facilitate future research, a dedicated tool was also developed to unpack and recreate MZIP files.\n\n12 https://github.com/bvanheu/linux-cisco/tree/master/mziptools\n\n\n-----\n\n### 6.3 The AMCC file format\n\nData blobs marked with the AMCC magic bytes were found in at least two places:\n\n- In the NOR Flash, U8\n\n- In the dedicated EEPROM, U55\n\nThe AMCC (a reference to Applied Micro Corp?) file format was not overly complicated: a fixed-size header\nfollowed by fixed-size file entries.\n\nThe header marked the format with the `AMCC magic bytes and then specified the entry count at offset 8. It`\nincluded three data elements, one with no known meaning and the other two being offsets in the file pointing\nat structures marked with AENV.\n\nEach file entry contained a NUL-terminated file name of up to 16 bytes, with data offset at offset 16 and size at\noffset 20.\n\nThe last 4 bytes of both the header and the file entries was likely to be a CRC32 value for integrity verification\npurposes.\n\nThe illustration below highlights the main components of this file format:\n\n**_Figure 25. AMCC file with meaningful data elements highlighted._**\n\nWhile some unknown data elements remained, it was then easy to extract the files contained within.\n\n### 6.4 Software signatures and keys\n\nNo public key data was directly identified in BROM or HBOOT, suggesting this data was loaded before control\nwas passed to BROM. So where was this key data stored? It was possible to make some educated guesses as to\nwhere the public key(s) might be stored:\n\n- In the ROM code of SLIMpro\n\n- In some other location related to SLIMpro\n\n- Somewhere on the NOR Flash\n\nThe easiest way to verify this was by browsing through the Flash images in the hope of stumbling upon the keys.\nDuring Flash analysis we already identified one possible candidate: the AMCC data blob at Flash offset\n0x7DA0800, with very conspicuous strings (file names?) like ppc.bin.key. This piece of data was the same in all\nextracted Flash images, suggesting this data to be global for at least any device within the family – as expected\nfor software signing keys.\n\n\n-----\n\nFollowing the AMCC container format description (appendix 6.3), the files inside could be extracted.\n\nThis left us with the `ppc.bin.key file (the` `ppc1.bin.key is identical) which might have contained software`\nverification keys, but its format was not immediately obvious. However, one could note that there were\nrepeating data pieces such as hex strings AB 12 34 CD and BE EF CA FE at the start and the end, and a text\nstring C2960X in the middle; all repeated 4 times. This could mean there were 4 keys contained within this file.\n\n**_Figure 26. The beginning of ppc.bin.key and the BEEFCAFE marker._**\n\nAfter spending several hours on decoding the format of these entries, we were able to provide the following\nsummary: the format loosely followed a tag-length-value (TLV) structure with 7-byte fixed header AE 02 25 AB\n\n`12 34 CD` and 4-byte fixed trailer BE EF CA FE, tags were one byte, lengths were two bytes. Tag 04 was the RSA\nmodulus, and tag 05 is the RSA public exponent (always 0x10001, a typical value).\n\nTwo unique public key moduli were extracted from this file; they are reproduced below for reference. It is\nimportant to highlight the fact these keys can only be used to verify signatures.\n```\n9f0269a7de698bfec8f57da81e51e9dd8c213134f17d07fcb83fb88d076afee659987d03d654319eb500e9902811\n67d7595d36b25dba15a269d18a1fbd8fc5c6d1daffd93697d263aed7dc57c82266edbf0a35bd2896d6496819b60b\n79ea16a0cd61fea77277361ee6bd4540cdd22149353d06659ff4ed03dad221d7b7fb7f0afcbe25c8a8dbda01270a\n88d707aa0983c7ba4c1d1b218cc582e55ef7328ac52484ca3344193754d88b65ee1067f54cde2a46260be1b0e1f1\nddff96676f5e4dacd339f677d5d96c1a1a55a9e11e6930ed864576346c37e10f15f75fb8c3ecc2f6034ed2c6b002\nde52ac78fa2e1a38acf80649fae7c193291c9b7f4018b5fc13ad\nd12bad146859bb19cb3f0962f46edef40c3249373d8ae1dc243e735825b39073b2d0a507d658e4815eb0fceccce9\n84741f2b69e8637388db967c337469001f1727201355242a60158fc5f84cce0bada77c626b33fc7334e1f8ebacfa\nde0485721bdb6df4cf5c496deb69c152eb67fa2edf0bc8531a875fc6d7b9d29662d3022e894805956d76587f624b\n0ed12cabbef4d91f4754bc1ae091070072610fb54d03d1efe7075b70e62473f914503186e550c2d5e4177cba2302\n453cd8c07b78918604eb648a5dac02d4649a5d3bdeb6c1ac5a129e553f3905226d2abc291b0293cfe7d3b260bfb1\n320c7186f6700ea4729b2f26a402cae22aedd2add7cc96ebf027\n\n```\nInvestigating the signature format, we could conclude it followed the same TLV format albeit without headers\nand trailers. Tag 0B was identified to be the RSA signature.\n\n\n-----\n\nPutting this knowledge to work, we could easily confirm whether our deductions were correct with Python:\n```\n>>> pubmod1 =\n0x9f0269a7de698bfec8f57da81e51e9dd8c213134f17d07fcb83fb88d076afee659987d03d654319eb500e99028\n1167d7595d36b25dba15a269d18a1fbd8fc5c6d1daffd93697d263aed7dc57c82266edbf0a35bd2896d6496819b6\n0b79ea16a0cd61fea77277361ee6bd4540cdd22149353d06659ff4ed03dad221d7b7fb7f0afcbe25c8a8dbda0127\n0a88d707aa0983c7ba4c1d1b218cc582e55ef7328ac52484ca3344193754d88b65ee1067f54cde2a46260be1b0e1\nf1ddff96676f5e4dacd339f677d5d96c1a1a55a9e11e6930ed864576346c37e10f15f75fb8c3ecc2f6034ed2c6b0\n02de52ac78fa2e1a38acf80649fae7c193291c9b7f4018b5fc13ad\n>>> pubmod2 =\n0xd12bad146859bb19cb3f0962f46edef40c3249373d8ae1dc243e735825b39073b2d0a507d658e4815eb0fceccc\ne984741f2b69e8637388db967c337469001f1727201355242a60158fc5f84cce0bada77c626b33fc7334e1f8ebac\nfade0485721bdb6df4cf5c496deb69c152eb67fa2edf0bc8531a875fc6d7b9d29662d3022e894805956d76587f62\n4b0ed12cabbef4d91f4754bc1ae091070072610fb54d03d1efe7075b70e62473f914503186e550c2d5e4177cba23\n02453cd8c07b78918604eb648a5dac02d4649a5d3bdeb6c1ac5a129e553f3905226d2abc291b0293cfe7d3b260bf\nb1320c7186f6700ea4729b2f26a402cae22aedd2add7cc96ebf027\n>>> pubexp = 0x10001\n>>> sig =\n0x8ec4a43c0658ea28ea529604116e56f2c5924cc865937ed4d33ad037eb95696dcce523d6f3f6f8d0724b48b6a0\n1e1a6cd21984a9325ca72cf9a6c326502a565c0e7564ac7365f1e8e62d277f7072cdc22e861a17bfbce6d57fbfa7\nba2455b88389da2667e600b0599a0e069f7300c8ca14298c12db5440dab7007fc4e24369aff9313f1b98f35f0726\nbc951f7076a12fdfa10447b93c824fae3aca57c20a6def3317a38a59936ea29a74a6d4e8696c7eb9aeab3b02f37b\n6dae9c0ab9c01db40988581799f13838b3325b1f13ffbc012b89a6f2b8f2baec554578440f7e68b0c46ce525a487\nb91f0f7fc628e7f952d8d3a8059b654d4c4b40b539b2b82e15cfab\n>>> \"%0512x\" % pow(sig, pubexp, pubmod1)\n'0001fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff003051300d0609608648016\n503040203050004408ff1850fc5313c39ef350d8c2871797c8b42c5530ae6366bc47d3ea81d1ec8cceeb5d1087e5\n6b1b330787445237a69b61730ff25d697cfe6e64ee3e77cad4489'\n\n```\nJudging by the well-formed decrypted data, we found the right software signature verification key; if the key\nwas incorrect, the decrypted data would appear random. The format appeared to fit what was defined in PKCS#1\nv1.5[13] and the data told us the hash function used was SHA-512.\n\n13 https://tools.ietf.org/html/rfc2313\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2020/2020.07.15_the_Fake_CISCO/2020-07-the-fake-cisco.pdf"
    ],
    "report_names": [
        "2020-07-the-fake-cisco"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716490,
    "ts_updated_at": 1743041149,
    "ts_creation_date": 1594813328,
    "ts_modification_date": 1594813328,
    "files": {
        "pdf": "https://archive.orkl.eu/b733176571839bd9bce34d91e7c5cdbf62c7529e.pdf",
        "text": "https://archive.orkl.eu/b733176571839bd9bce34d91e7c5cdbf62c7529e.txt",
        "img": "https://archive.orkl.eu/b733176571839bd9bce34d91e7c5cdbf62c7529e.jpg"
    }
}