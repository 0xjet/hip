{
    "id": "5b6b5219-1ab2-4aa4-a5f8-807a31a23fd2",
    "created_at": "2023-05-06T02:08:47.413275Z",
    "updated_at": "2025-03-27T02:05:56.196595Z",
    "deleted_at": null,
    "sha1_hash": "a00e87958bbec89c06b7e447359a7d14fa91d5a1",
    "title": "2022-05-08 - Bzz.. Bzz.. Bumblebee loader",
    "authors": "",
    "file_creation_date": "2023-05-05T01:47:17Z",
    "file_modification_date": "2023-05-05T01:47:17Z",
    "file_size": 243133,
    "plain_text": "# Bzz.. Bzz.. Bumblebee loader\n\n**threathunt.blog/bzz-bzz-bumblebee-loader**\n\nJouniMi May 8, 2022\n\n_Showing off my amazing graphical skills_\nQuite recently, a new loader has been popping up. This loader is likely been developed to\ncounter the Microsoft’s change to the macro behavior, as the macros will be disabled on the\ndocuments that have been downloaded from the internet. This is a very welcome change as\nmacros have been often used by the threat actors to launch the malicious code from the\nmaldocs. Now that this will be harder to the threat actors they are creating new creative ways\nto get the initial foothold after a phishing attack.\n\n[One of the new ways that has been observed in the wild is the bumblebee loader. This new](https://www.proofpoint.com/us/blog/threat-insight/bumblebee-is-still-transforming)\nloader will be delivered in format of an attachment, or a link within a phishing email. The user\nis then directed to a legitimate web service (for example, one drive) from which the user\ndownloads a password-protected ZIP file, with the password in the email body. The zip\ncontains an ISO file, which then contains two files – .lnk and .dat files. If the lnk file is started\nthe bumblebee loader will be ran from the .dat file. There are several ways how this initial\napproach could be potentially found with Defender for Endpoint. To me it sounds like that the\ninitial creation of the ISO file joined to the creation of the ZIP file by a browser could be a\ngood approach. This could be maybe joined to network connections too, however it gets a\nlittle heavy and I leave it out for now.\n\n\n-----\n\nSo the logic of this query is explained above. I do use the time based join that I ve used\nbefore on an earlier blog post. This is because the process that creates the ISO file is\ndifferent from the process that created the archive file. Depending on the environment this\ncould potentially need more joins to reduce noise. ISO files are relatively rare in some\nenvironments but much more common in the others. Also, this query is only looking for\ncreations of the ISO + archive files – this does not yet mean that anything was executed.\n```\nlet lookupWindow = 10min;\n\nlet lookupBin = lookupWindow / 2.0;\n\nDeviceFileEvents\n\n| where FileName endswith \".iso\"\n\n| where ActionType == 'FileCreated'\n\n| extend TimeKey = bin(Timestamp, lookupBin)\n\n| project DeviceName, IsoCreationTime = Timestamp, IsoCreationFileName = FileName,\nIsoCreationFolderPath = FolderPath, IsoCreationSHA1 = SHA1, TimeKey,\nIsoCreationProcessName = InitiatingProcessFileName, IsoCreationProcessCmdline =\nInitiatingProcessCommandLine, IsoCreationProcessFolderPath =\nInitiatingProcessFolderPath, IsoCreationParentName = InitiatingProcessParentFileName\n\n| join (\n\nDeviceFileEvents\n\n| extend ArchiveCreationTime = Timestamp\n\n| where FileName endswith \".zip\" or FileName endswith \".rar\" or FileName endswith\n\".7z\"\n\n| where InitiatingProcessFileName =~ \"chrome.exe\" or InitiatingProcessFileName =~\n\"firefox.exe\" or InitiatingProcessFileName =~ \"msedge.exe\" or\nInitiatingProcessFileName =~ \"iexplore.exe\"\n\n| extend TimeKey = range(bin(Timestamp-lookupWindow, lookupBin), bin(Timestamp,\nlookupBin), lookupBin)\n\n| mv-expand TimeKey to typeof(datetime)\n\n| project DeviceName, IsoCreationActionType= ActionType, ArchiveCreationTime =\nTimestamp, ArchiveCreationFileName = FileName, ArchiveCreationFolderPath =\nFolderPath, ArchiveCreationSHA1 = SHA1, TimeKey, ArchiveCreationProcessName =\nInitiatingProcessFileName, ArchiveCreationProcessCmdline =\nInitiatingProcessCommandLine, ArchiveCreationProcessFolderPath =\nInitiatingProcessFolderPath, ArchiveCreationParentName =\nInitiatingProcessParentFileName\n\n) on DeviceName, TimeKey\n\n| project DeviceName, IsoCreationTime, IsoCreationFileName, ArchiveCreationFileName,\nIsoCreationProcessName, IsoCreationActionType, IsoCreationProcessCmdline,\nIsoCreationProcessFolderPath, ArchiveCreationProcessName,\nArchiveCreationProcessCmdline, IsoCreationParentName, ArchiveCreationTime,\nArchiveCreationFolderPath, TimeKey, ArchiveCreationProcessFolderPath,\nArchiveCreationParentName, IsoCreationFolderPath, IsoCreationSHA1,\nArchiveCreationSHA1\n\n\n```\nAs you can see from the query, I like to rename some of the fields. This does make it easier\nat least for me to understand the output especially when joining the data from multiple tables\nwith different process names. I do this almost every time on my queries and I do also\nsuggest it to others as well. The archive creation query is not limited to “FileCreated” events.\nThis is because of how the modern browsers work, as they stage the files with different\n\n\n-----\n\nnames and then in the end renames the file to the final format. To test this out I created an\nempty file with the abbreviation of .ISO. Then I archived the file to a zip file and uploaded to\nOnedrive – from which I downloaded it and extracted the contents.\n\n_The query matches the iso and archive creations._\nThe query works. There are multiple matches as there are multiple actions taken on the\narchive creation query. The default inner unique join takes one random entry from the left\nand joins it to all matches on right. This could be refined further but I am quite happy with\nthis. One way to limit the results would be to limit the ActionType to “FileRenamed” on the\n[archive creation query. The great article by Proofpoint (already linked before, but again here)](https://www.proofpoint.com/us/blog/threat-insight/bumblebee-is-still-transforming)\nstates the process path after the malicious code is launched. It is basically cmd.exe ->\ncmd.exe -> rundll32.exe with certain switches. This should be easy enough.\n```\nDeviceProcessEvents\n\n| where InitiatingProcessParentFileName =~ \"cmd.exe\"\n\n| where InitiatingProcessFileName =~ \"cmd.exe\"\n\n| where InitiatingProcessCommandLine contains \"IternalJob\"\n\n| where InitiatingProcessCommandLine contains \"rundll32\"\n\n| where FileName =~ \"rundll32.exe\"\n\n| where ProcessCommandLine contains \"IternalJob\"\n\n| project Timestamp, DeviceName, InitiatingProcessParentFileName,\nInitiatingProcessFileName, InitiatingProcessCommandLine, FileName, ProcessCommandLine\n\n\n```\nTo keep the query efficient I didn’t do any joins. Unfortunately, the cmdline of the parent\nprocess is not recorded here so no filtering can be done based on that, unless joining the\ndata. The query does not produce any results in my testing environment but your mileage\nmay vary. I haven’t tested the queries in this post in any production environments yet.\n\nThese queries are relatively simple and likely will catch only partial and early versions of the\nloader, however I think they are a great start. Using these to start and then developing them\na little further can produce nice results in catching the new type of loader. This data could of\ncourse also be joined further to get less results and to get more information out of the\nactivity.\n\nAlso – someone might have noticed that I have changed the theme of the blog. I liked the old\none but I migrated to another host as the first one was quite unresponsive at least from\nEurope. While doing that I changed the theme to handle couple of things better. I think there\nmight be little bug here and there still with this but I will fix them when I get a chance.\n\nEDIT: Fixed a typo in the latter query.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-08 - Bzz.. Bzz.. Bumblebee loader.pdf"
    ],
    "report_names": [
        "2022-05-08 - Bzz.. Bzz.. Bumblebee loader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1683338927,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1683251237,
    "ts_modification_date": 1683251237,
    "files": {
        "pdf": "https://archive.orkl.eu/a00e87958bbec89c06b7e447359a7d14fa91d5a1.pdf",
        "text": "https://archive.orkl.eu/a00e87958bbec89c06b7e447359a7d14fa91d5a1.txt",
        "img": "https://archive.orkl.eu/a00e87958bbec89c06b7e447359a7d14fa91d5a1.jpg"
    }
}