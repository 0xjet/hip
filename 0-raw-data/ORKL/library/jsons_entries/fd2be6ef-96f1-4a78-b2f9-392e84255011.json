{
    "id": "fd2be6ef-96f1-4a78-b2f9-392e84255011",
    "created_at": "2023-01-12T15:09:39.769037Z",
    "updated_at": "2025-03-27T02:05:54.264538Z",
    "deleted_at": null,
    "sha1_hash": "4037ab34187d4b266111d57ee0dd3f5fb84dc38e",
    "title": "2021-10-15 - Recovering registry hives encrypted by LockBit 2.0",
    "authors": "",
    "file_creation_date": "2022-05-28T23:16:46Z",
    "file_modification_date": "2022-05-28T23:16:46Z",
    "file_size": 193983,
    "plain_text": "# Recovering some files encrypted by LockBit 2.0\n\n**skyblue.team/posts/hive-recovery-from-lockbit-2.0/**\n\nOct 15, 2021 Â· 1066 words Â· 6 minute read\n\nThe [LockBit 2.0 ransomware has been incredibly â€œproductiveâ€ these last few months: their](https://www.trendmicro.com/en_us/research/21/h/lockbit-resurfaces-with-version-2-0-ransomware-detections-in-chi.html)\ntechnique is well automated, and the list of compromised companies keeps growing every\nday.\n\nIn order to reduce the destructiveness of their payload, most ransomware operators do not\nencrypt every single file on a system; instead, they set out a set of rules, for example:\n\nOnly encrypt files with specific extensions: `.docx,` `.cpp,` `.db,` `.log`\nDonâ€™t encrypt files in `C:\\Windows\\System32, in order to keep a semi-working`\nmachine (otherwise how would the users read the ransom note?)\n\nLockBit 2.0 has a pretty interesting quirk though: as an optimization, only the first 4KiB (4096\nbytes) of each file are encrypted. This is usually enough to lock away important data and\nmake file recovery a pain. It also speeds up the encryption process.\n\nWe have also observed that the LockBit 2.0 ransomware is pretty generous in the extension\nlist it encrypts: even user hive files ( NTUSER.DAT ) are encrypted, which is a pain if we want\nto [extract useful data from it. But registry hives can be pretty big, could we maybe recover](https://github.com/airbus-cert/regrippy/)\nsome data anyway?\n\n## Registry hive structure ðŸ”—\n\nIn order to understand how we can recover the hives, we must first have a look at how\nregistry hives are stored on-disk. Willi Ballenthinâ€™s `python-registry has some good`\n[explanations, including a text file from a certain B.D. which goes over the structure of hives](https://github.com/williballenthin/python-registry/blob/master/documentation/WinReg.txt)\nfor both Windows 95 and NT. This document tells us that NT optimized hive loading by\nmaking the header the typical size of a page, 4KiB.\n\n\n-----\n\nThis means that LockBit only encrypts the header, and doesnâ€™t touch the actual data of the\nhive. Is it possible to restore the header? To answer this question, we must list everything the\nheader contains:\n\nA magic number ( regf )\nSequence numbers (used for inconsistency detection)\nModification timestamp\nVersion numbers\nHive name\nHive flags\nHeader checksum\n\nBasically, we can see that the header is mostly self-contained: thereâ€™s no reference to `hbin`\noffset, or a global hive checksum. There should be no problem restoring the header by\ncopying it from another hive of the same type ðŸ˜Š\n\n## Restoring the hive ðŸ”—\n\n\n-----\n\nSimply by copying over the first 4096 bytes from another, clear `NTUSER.DAT, we were able`\nto entirely recover all our user hives!\n```\n$ regrip.py --ntuser ./ntuser_recovered.dat userassist | wc -l\n84\n\n```\nIt works! RegRippy will be confused when trying to give you the user names when extracting\ndata from `NTUSER.DAT, because it guesses them based on the hive name, which has been`\ncopied over from a clean hive. Other than that, everything works as expected, and all data is\naccessible.\n\nIf you ever encounter this issue, hereâ€™s a script which can restore an encrypted\n```\nNTUSER.DAT hive: itâ€™s basically rebuilding the header and replacing it to create a clean hive.\n\n```\n\n-----\n\n```\n#!/usr/bin/env python3\nimport argparse\ndef main():\n  parser = argparse.ArgumentParser(description=\"Fix encrypted hives by repairing\nthe header (only for NTUSER.DAT)\")\n  parser.add_argument(\"--user\", type=str, help=\"The user name to store in the\nheader (default: JohnDoe)\", default=\"JohnDoe\")\n  parser.add_argument(\"hive_path\", type=str, help=\"Encrypted hive path\")\n  parser.add_argument(\"output\", type=str, help=\"Where to output the fixed hive\")\n  args = parser.parse_args()\n  hive_name = \"??\\\\C:\\\\Users\\\\\" + args.user + \"\\\\ntuser.dat\"\n  encoded_hive_name = hive_name.encode(\"utf-16-le\")\n  if len(encoded_hive_name) > 64:\n    encoded_hive_name = encoded_hive_name[:64]\n  else:\n    encoded_hive_name += b\"\\x00\" * (64 - len(encoded_hive_name))\n  header =\nb\"regfH\\x1E\\x00\\x00\\x48\\x1E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x0\n  header += encoded_hive_name\n  header +=\nb\"\\x43\\xBE\\x11\\x44\\xFF\\x07\\xE8\\x11\\x92\\x75\\xEA\\x28\\xA0\\xD0\\x3E\\x60\\x43\\xBE\\x11\\x44\\xFF\n  header += b\"\\x00\"*316\n  header += b\"\\xD8\\xC9\\x70\\x75\"\n  header += b\"\\x00\"*3584\n  with open(args.hive_path, \"rb\") as h1:\n    with open(args.output, \"wb\") as h2:\n      data = h1.read()\n      without_header = data[4096:]\n      h2.write(header)\n      h2.write(without_header)\n  print(\"Done! Hive written to\", args.output)\nif __name__ == \"__main__\":\n  main()\n\n## (Update) Extending the technique to other file types ðŸ”—\n\n```\n[In passing, @citronneur mentioned that EVTX files also had a 4 KiB header. Maybe they](https://twitter.com/citronneur)\ncould be reconstructed as well?\n\n\n-----\n\nWhen investigating Windows file formats, it s always a good idea to check Joachim Metz s\n```\nlibyal repositories. In that case, bingo! libevtx exists, with some very detailed\n\n```\ndocumentation.\n\n\n-----\n\nBasically, an EVTX file is composed of several chunks, and each chunk contains a number\nof records. Each record has an ID, which is unique across all chunks.\n\nWe assume the first chunk number is always 0. To get the last chunk number, we will search\nfor the signature `\"ElfChnk\\x00\" and count its occurrences. We assume chunks are`\nnumbered in increasing order, starting from zero.\n\nTo get the last record ID, we first get the last chunk (easy, because each chunk has a fixed\nsize), and parse the offset to the last record from its header. We then parse the record at this\noffset to extract its ID.\n\nThe checksum is a simple CRC32 of the first 120 bytes of the file header. With this, we are\nable to recreate all the data from the encrypted file header and read the events!\n\nAnd here is a Python script which does just that:\n\n\n-----\n\n```\n#!/usr/bin/env python3\nimport argparse\nimport binascii\nimport sys\ndef get_number_of_chunks(data):\n  count = 0\n  needle = b\"ElfChnk\\x00\"\n  for offset in range(len(data) - len(needle)):\n    if data[offset : offset + len(needle)] == needle:\n      count += 1\n  return count\ndef get_chunk(data, n):\n  data = data[4096:] # get rid of header\n  print(\"[+] Getting chunk\", n)\n  chunk = data[n * 65536 : (n + 1) * 65536]\n  assert chunk[:8] == b\"ElfChnk\\x00\"\n  return chunk\ndef get_last_record(chunk):\n  offset = int.from_bytes(chunk[44:48], byteorder=\"little\")\n  print(f\"[+] Last record offset: {offset} (0x{offset:x})\")\n  if offset == 0:\n    print(\"[!] Error: this EVTX file probably has no events\")\n    sys.exit(1)\n  record = chunk[offset:]\n  assert record[:4] == b\"\\x2a\\x2a\\x00\\x00\"\n  return record\ndef get_record_id(record):\n  i = int.from_bytes(record[8:16], byteorder=\"little\")\n  print(\"[+] Record id:\", i)\n  return i\ndef main():\n  parser = argparse.ArgumentParser(description=\"Fix LockBit2.0 EVTX file\")\n  parser.add_argument(\"file\", type=str, help=\"Path to evtx file\")\n  parser.add_argument(\"output\", type=str, help=\"Where to store the resulting file\")\n  args = parser.parse_args()\n  data = None\n  with open(args.file, \"rb\") as f:\n    data = f.read()\n  print(\"[+] Loaded\", args.file)\n\n```\n\n-----\n\n```\n  chunks = get_number_of_chunks(data)\n  print(\"[+] Number of chunks:\", chunks)\n  signature = b\"ElfFile\\x00\"\n  first_chunk_number = (0).to_bytes(8, byteorder=\"little\")\n  last_chunk_number = (chunks - 1).to_bytes(8, byteorder=\"little\")\n  next_record_id = get_record_id(get_last_record(get_chunk(data, chunks - 1))) + 1\n  next_record_id = next_record_id.to_bytes(8, byteorder=\"little\")\n  header_size = (128).to_bytes(4, byteorder=\"little\")\n  minor_version = (1).to_bytes(2, byteorder=\"little\")\n  major_version = (3).to_bytes(2, byteorder=\"little\")\n  header_block_size = (4096).to_bytes(2, byteorder=\"little\")\n  number_of_chunks = chunks.to_bytes(2, byteorder=\"little\")\n  unk1 = b\"\\x00\" * 76\n  file_flags = (0).to_bytes(4, byteorder=\"little\")\n  crc32 = -1\n  unk2 = b\"\\x00\" * 3968\n  header = (\n    signature\n    + first_chunk_number\n    + last_chunk_number\n    + next_record_id\n    + header_size\n    + minor_version\n    + major_version\n    + header_block_size\n    + number_of_chunks\n    + unk1\n    + file_flags\n  )\n  crc32 = binascii.crc32(header[:120]) & 0xFFFFFFFF\n  header += crc32.to_bytes(4, byteorder=\"little\")\n  header += unk2\n  assert (len(header)) == 4096\n  with open(args.output, \"wb\") as f:\n    f.write(header)\n    f.write(data[4096:])\nif __name__ == \"__main__\":\n  main()\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-15 - Recovering registry hives encrypted by LockBit 2.0.pdf"
    ],
    "report_names": [
        "2021-10-15 - Recovering registry hives encrypted by LockBit 2.0.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536179,
    "ts_updated_at": 1743041154,
    "ts_creation_date": 1653779806,
    "ts_modification_date": 1653779806,
    "files": {
        "pdf": "https://archive.orkl.eu/4037ab34187d4b266111d57ee0dd3f5fb84dc38e.pdf",
        "text": "https://archive.orkl.eu/4037ab34187d4b266111d57ee0dd3f5fb84dc38e.txt",
        "img": "https://archive.orkl.eu/4037ab34187d4b266111d57ee0dd3f5fb84dc38e.jpg"
    }
}