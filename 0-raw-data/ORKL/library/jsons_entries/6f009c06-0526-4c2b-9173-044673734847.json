{
    "id": "6f009c06-0526-4c2b-9173-044673734847",
    "created_at": "2022-10-25T16:48:18.664658Z",
    "updated_at": "2025-03-27T02:05:20.479035Z",
    "deleted_at": null,
    "sha1_hash": "46eeeb610662c92f39530c8641a572dcb6d14c48",
    "title": "",
    "authors": "",
    "file_creation_date": "2017-06-12T13:48:34Z",
    "file_modification_date": "2017-06-12T13:48:34Z",
    "file_size": 2577182,
    "plain_text": "##### INNOVACIÓN EN PROCESOS\n# INFORME DE MALWARE\n Evolución de Trickbot\n\n#### INFORME\n 06/2017\n\n## S2 Grupo de Innovación en\n\n### Procesos Organizativos\n\n\n-----\n\n###### ÍNDICE\n\n\n###### ÍNDICE\n\n\n**_1._** **_INTRODUCCIÓN ................................................................................................................ 3_**\n\n**_2._** **_PROCESO DE INFECCIÓN ............................................................................................. 5_**\n\n**_3._** **_CARACTERÍSTICAS TÉCNICAS ................................................................................... 6_**\n\n**_4._** **_SISTEMA DE CARGA DE MODULOS......................................................................... 13_**\n\n**_5._** **_CONEXIONES DE RED .................................................................................................. 21_**\n\n**_6._** **_MECANISMO DE CIFRADO .......................................................................................... 25_**\n\n**_7._** **_MECANISMO DE IPC (Inter-Process Communication) ......................................... 29_**\n\n**_8._** **_ARCHIVOS RELACIONADOS ...................................................................................... 32_**\n\n**_9._** **_DETECCIÓN ..................................................................................................................... 33_**\n\n**_10._** **_DESINFECCION ........................................................................................................... 35_**\n\n**_11._** **_INFORMACION DEL ATACANTE ............................................................................ 36_**\n\n**_12._** **_REFERENCIAS ............................................................................................................ 38_**\n\n**_13._** **_AUTORES ..................................................................................................................... 38_**\n\n\n-----\n\n###### 1. INTRODUCCIÓN\n\n\nEl presente documento recoge una revisión de las últimas versiones de una familia de\n\ntroyanos conocida como **[“Trickbot/TrickLoader”. Se trata de un troyano de tipo](https://blog.malwarebytes.com/threat-analysis/2016/10/trick-bot-dyrezas-successor/)**\n\nbancario que roba credenciales y datos bancarios de los usuarios infectados. Aunque\n\nsu principal objetivo y comportamiento se centra en usuarios de banca online, al ser un\n\ntroyano modular posee capacidades que los atacantes podrían utilizar con otros fines,\n\ncomo la exfiltración de documentos.\n\nSe puede encontrar gran cantidad de documentación referente a la lógica y orígenes\n\nde este malware; parte del presente informe se basa en información de algunas de\n\nellas con el fin de contrastarla con la lógica de las últimas versiones y poder observar\n\nsu evolución y funcionalidades nuevas. Todas las fuentes sobre las que se ha obtenido\n\ninformación se pueden encontrar en el apartado de referencias.\n\nEs necesario resaltar que el informe parte y se apoya principalmente en los análisis\n\nrealizados por **[@hasherezade y por](https://blog.malwarebytes.com/threat-analysis/2016/10/trick-bot-dyrezas-successor/)** **[Xiaopeng Zhang (Fortinet). A partir de dichos](https://blog.fortinet.com/2016/12/06/deep-analysis-of-the-online-banking-botnet-trickbot)**\n\nanálisis, se ha intentado contrastar si en las últimas versiones había cambiado algún\n\naspecto y profundizar en los mecanismos no descritos hasta el momento.\n\n**Resumiendo, Trickbot tiene las siguientes capacidades:**\n\nCarga el código en el sistema\n\nCrea una réplica de sí mismo en el directorio %APPDATA%\n\nAplica técnicas de persistencia\n\nRecopila información sensible del usuario\n\nInyecta código en otras aplicaciones para controlar la información que manejan\n\nExfiltra la información que obtiene a su servidor de Mando y Control\n\n\n-----\n\nDurante la realización de este informe el Laboratorio de Malware de S2 Grupo ha\n\ntrabajado con las muestras que tienen las siguientes firmas MD5:\n\n1000005_Trickbot_Loader.exe a50c5c844578e563b402daf19289f71f\n\n1000005_Trickbot_bot32.exe 28661ea73413822c3b5b7de1bef0b246\n\n1000010_Trickbot_Loader.exe 218613f0f1d2780f08e754be9e6f8c64\n\n1000010_Trickbot_bot32.exe 135e4fa98e2ba7086133690dbd631785\n\n1000014_Trickbot_Loader.exe e054eaae756d31a4f6e30cc74b2e51dd\n\n1000014_Trickbot_bot32.exe 719578c91b4985d1f955f6adb688314f\n\n1000016_Trickbot_Loader.exe 132c4338cdc46a0a286abf574d68e2e0\n\n1000016_Trickbot_bot32.exe e8e7b0a8f274cad7bdaedd5a91b5164d\n\nComo se puede ver en la imagen anterior se han analizado cuatro versiones diferentes\n\nde **Trickbot. Cada una de ellas se compone de su loader y su payload final para**\n\nsistemas de 32 bits; aunque existe también la versión 64 bits de todas, no ha sido\n\nobjeto del análisis realizado.\n\n|1000005_Trickbot_Loader.exe|a50c5c844578e563b402daf19289f71f|\n|---|---|\n|1000005_Trickbot_bot32.exe|28661ea73413822c3b5b7de1bef0b246|\n|1000010_Trickbot_Loader.exe|218613f0f1d2780f08e754be9e6f8c64|\n|1000010_Trickbot_bot32.exe|135e4fa98e2ba7086133690dbd631785|\n|1000014_Trickbot_Loader.exe|e054eaae756d31a4f6e30cc74b2e51dd|\n|1000014_Trickbot_bot32.exe|719578c91b4985d1f955f6adb688314f|\n|1000016_Trickbot_Loader.exe|132c4338cdc46a0a286abf574d68e2e0|\n|1000016_Trickbot_bot32.exe|e8e7b0a8f274cad7bdaedd5a91b5164d|\n\n\n-----\n\n###### 2. PROCESO DE INFECCIÓN\n\n\nLa principal vía de infección de este malware se produce a través de un documento de\n\nWord con macros que llega anexado en un email o a través de una vulnerabilidad\n\naprovechada por un ExploitKit.\n\nLa infección sigue el siguiente orden de ejecución:\n\nSe descarga desde un dominio comprometido una muestra de **Trickbot en la**\n\ncarpeta %APPDATA% y la ejecuta\n\nCrea una tarea programada en el sistema que le proporciona la persistencia\n\nCrea dos ficheros (\"client_id\" y \"group_tag\") en su mismo directorio, uno con un\n\nID único del host infectado y otro con el ID de la campaña de infección actual o\n\nversión de la configuración.\n\nContacta con un dominio de obtención de IP externa, entre otras cosas para\n\ntestear la conectividad y remitírsela a sus servidores de mando y control (C2 a\n\npartir de ahora).\n\nContacta con uno de sus servidores de C2 para obtener actualizaciones del\n\npropio malware, módulos que realizan la mayor parte de la lógica del malware y\n\ndistintos ficheros de configuración.\n\nTras todo esto, empieza a ejecutar o inyectar en diferentes procesos sus\n\nmódulos que se encargan de recopilar información del sistema y credenciales\n\nde navegación especialmente de banca online.\n\n\n-----\n\n###### 3. CARACTERÍSTICAS TÉCNICAS\n\n\n[El ejecutable principal de Trickbot suele ir empaquetado con un “packer”](https://en.wikipedia.org/wiki/Executable_compression) propio, con\n\nlo que se ofusca la funcionalidad del ejecutable y se evita que se puedan generar\n\nfirmas genéricas a partir del contenido del contenido del mismo, pues para cada\n\nversión el packer hace que el código varíe por completo.\n\nTras el desempaquetado se puede observar como la cantidad de funciones del\n\nejecutable se incrementa en gran medida, ya que ahora sí refleja la funcionalidad del\n\nprograma malicioso:\n\n**Packed** **Unpacked**\n\n\n-----\n\nTras el “unpack” lo que se obtiene es la primera etapa de este malware, conocida\n\ncomo “Loader”. Este ejecutable se encarga de comprobar la arquitectura del sistema y\n\ndependiendo de si se trata de un equipo de 32 o 64 bits carga de sus recursos el “bot”\n\ncorrespondiente a dicha arquitectura. El “bot” es el ejecutable que se encarga de la\n\núltima etapa de infección y contiene toda la lógica básica del malware.\n\nEn las primeras versiones, los recursos que contiene el Loader eran fácilmente\n\nreconocibles ya que traían nombres descriptivos, puesto que identificaban las dos\n\nversiones del Bot y un Loader para cargar correctamente el de 64 bits. En las últimas\n\nversiones han empezado a poner nombres que no son descriptivos para dificultar la\n\nidentificación de los mismos:\n\nV10 de Trickbot V14 de Trickbot V16 de Trickbot\n\nEstos recursos, aunque son ficheros ejecutables (PE) vienen cifrados con el algoritmo\n\nAES CBC, por lo que tras extraerlos aún necesitan ser descifrados o por otra parte\n\npueden ser extraídos de memoria tras ejecutar el Loader y esperar a que él mismo\n\nrealice el descifrado y carga en RAM del apropiado para el host.\n\nTras la carga del “bot” correspondiente, éste inicia la ejecución de la lógica principal de\n\nesta amenaza:\n\nEn primer lugar comprueba su localización en el sistema, y si no se encuentra en\n\n%APPDATA% se copia a sí mismo en esta ubicación, inicia la ejecución de su réplica\n\nen esa carpeta y termina el proceso actual.\n\nComo técnica de persistencia, utiliza tareas programadas del sistema en lugar de\n\nclaves de registro como suele ser común en otras muestras de malware. Versiones\n\nanteriores de **Trickbot, creaban en todos los casos una sola tarea programada a la**\n\nque llamaban “bot” y se aseguraba de que cada minuto éste era lanzado para\n\nmantenerse en ejecución en el sistema.\n\n|V10 de Trickbot|V14 de Trickbot|V16 de Trickbot|\n|---|---|---|\n||||\n\n\n-----\n\nEn las últimas versiones, si es ejecutado con permisos de administrador además de la\n\ntarea mencionada anteriormente, a la que ha pasado a llamar “Drives update”, crea\n\notra que lo ejecuta al iniciar sesión cualquier usuario, llamada\n\n“AplicationsCheckVersion”.\n\nSu siguiente acción consiste en comprobar si tiene todos los ficheros de configuración\n\ncon los que trabaja habitualmente:\n\nSi no da con ellos, los genera a partir de información que obtiene en el sistema y de\n\nlos recursos del “bot”, los cuales consisten en un fichero de configuración cifrado\n\n(CONFIG) y una clave para verificar la firma de la configuración y módulos (KEY).\n\nEn este caso no se han observado cambios en los nombres de estos recursos hasta la\n\nfecha, aunque es probable que en próximas iteraciones veamos cómo eliminan estos\n\nnombres al igual que en el caso de los recursos del Loader.\n\nEn la primera ejecución de Trickbot en el equipo genera un fichero llamado “client_id”\n\nque contiene un token o ID de usuario, que identifica al host actual.\n\n\n-----\n\nLa configuración de **Trickbot la obtiene o de un fichero en disco con el nombre**\n\nconfig.conf o de los resources (formato PE) del propio binario. Esta configuración\n\nestará cifrada, y tras su descifrado se puede observar que contiene la versión del\n\npropio malware, un código de campaña o versión de la configuración, las direcciones\n\nde varios de sus C2 principales, y la lista de módulos que debe descargar y ejecutar\n\nde forma automática desde alguno de sus C2.\n\nTras la obtención de estos datos crea un fichero más al que llama “group_tag” donde\n\nalmacena el código que se puede encontrar entre las etiquetas “gtag” de la\n\nconfiguración.\n\nPosteriormente comprueba la conectividad realizando una petición a un dominio\n\nexterno que le reporta la dirección IP de la víctima de entre una lista que contiene el\n\nmalware y que han ido incrementando durante las diferentes actualizaciones de\n\nversión.\n\n**Versión 7**\n\n\n-----\n\n**Versión 14**\n\nSi recibe la respuesta que espera de esta petición, empieza a contactar con los C2\n\nque ha obtenido de su configuración para empezar a reportar información de la nueva\n\nvíctima, buscar actualizaciones y recibir nuevos módulos que amplíen sus\n\ncapacidades.\n\nEn configuraciones normales, tras realizar ciertas peticiones con distintas órdenes que\n\nreportan información del host a alguno de los C2 de su configuración, obtiene la IP de\n\nun servidor concreto del cual puede descargar los módulos a través del puerto 447/tcp.\n\nTodas las descargas de configuraciones y módulos vienen cifradas con el mismo\n\nalgoritmo (AES CBC) y todos los ficheros se guardan en disco cifrados. Tras actualizar\n\ny descargar las configuraciones y módulos que tiene en la configuración, descifra y\n\nmapea en la memoria del propio proceso el primer módulo, “systeminfo”, el cual se\n\nencarga de recopilar del sistema información como la versión del SO, el tipo de CPU,\n\nla cantidad de RAM, los usuarios del sistema y la lista de programas y servicios\n\ninstalados:\n\n\n-----\n\nPosteriormente carga el módulo injectDll32 junto con sus ficheros de configuración:\n\nUna vez cargado este módulo, en el caso de que el usuario visite una de las webs\n\nlistadas en los ficheros de configuración (como por ejemplo, *cey\nebanking.com/CLKCCM/*) de este módulo, captura los datos relevantes de\n\nnavegación y los envía a sus C2:\n\n\n-----\n\nTal y como se analiza en el informe de **[DevCentral, en la versión 9 de](https://devcentral.f5.com/articles/is-xmaker-the-new-trickloader-2437)** **trickbot, le**\n\nañadieron un nuevo módulo al toolset de Trickbot llamado “mailsearcher”. Entonces\n\nen el caso de estar en la configuración también se cargará en el sistema víctima. El\n\norden en el que se cargan los módulos dependerá del fichero de configuración.\n\n“mailsearcher” se encarga de recorrer todos los ficheros de cada disco conectado al\n\nsistema y comparar las extensiones de los ficheros con la siguiente lista:\n\nEste módulo reporta por sí mismo a un C2 específico que obtiene de su propia\n\nconfiguración:\n\nLa URI de la petición es distinta a la utilizada por el “core” de Trickbot, pues en este\n\ncaso tiene la estructura “[IP]/[group_id]/[client_id]/send/” y utiliza su propio User-Agent\n\n“KEFIR!” lo que lo hace mucho más independiente que el resto de módulos\n\nencontrados hasta la fecha.\n\nLo visto en este apartado describe las acciones realizadas por **Trickbot** tras su\n\nprimera ejecución. A partir de este instante **Trickbot** entra en un bucle donde cada\n\ncierto tiempo comprueba si existe una nueva configuración y si existen nuevas\n\nversiones del malware o de alguno de los módulos. Además, dentro de ese mismo\n\nbucle realiza reportes con la información que va recopilando.\n\n\n-----\n\n###### 4. SISTEMA DE CARGA DE MODULOS\n\n\nDurante el análisis se ha observado que **Trickbot** utiliza eventos para controlar los\n\nflujos de ejecución entre el core y los módulos. Además, el core realiza la resolución\n\nde las APIs de Windows de los módulos. Vamos a ver como funciona este sistema de\n\ncomunicación del core con los módulos.\n\nEn primer lugar crea un proceso hijo svchost.exe suspendido con la función\n\nCreateProcessW:\n\nPosteriormente con la función CreateEventW, crea tres eventos que utilizará para\n\ngestionar las esperas y comunicaciones entre el ejecutable principal (Trickbot) y el\n\nproceso svchost hijo.\n\n\n-----\n\nUna vez tiene los handlers de los tres eventos, utilizando VirtualAllocEx y\n\nWriteProcessMemory inyecta en el proceso svchost suspendido 32 Bytes de datos\n\ncomo los siguientes:\n\nLos tres primeros grupos de 4 Bytes (en recuadros **rojos) representan los**\n\nidentificadores de los eventos que ha creado trickbot anteriormente y que va a utilizar\n\npara su comunicación, en este caso 4, 8 y C respectivamente.\n\nLos siguientes 5 grupos de 4 Bytes (en recuadros morados) representan los offsets en\n\nla propia memoria del proceso svchost, de las siguientes funciones de la librería\n\nkernel32.dll:\n\nSignalObjectAndWait\n\nWaitForSingleObject\n\nCloseHandle\n\nExitProcess\n\nResetEvent\n\nUtilizando el mismo método de inyección, carga una función propia en otro offset de la\n\nmemoria de svchost que se encargará de hacer de intermediaria entre **Trickbot y el**\n\ncódigo del módulo.\n\n\n-----\n\nEsta función es uno de los detalles más característicos de la gestión de módulos del\n\n\n**Trickbot.**\n\n\nSe encarga de mantenerse a la espera de órdenes del proceso principal. Éstas llegan\n\nen forma de offsets de funciones dentro de la memoria del propio proceso svchost y\n\nparámetros con los que las debe llamar; dicha información la obtiene a través de\n\nescrituras en su propia memoria por parte de Trickbot como la que se ha detallado en\n\n\nel caso anterior.\n\n\nLa mayor parte de su lógica consiste en un bucle que empieza y acaba en las zonas\n\nde código con fondo **azul; tras las primeras instrucciones, en caso de detectar algún**\n\n\n-----\n\nproblema con el proceso, entra en la zona marcada en rojo que cierra los handlers de\n\n\nlos eventos y el propio proceso.\n\n\nEn caso de que todo vaya correctamente, la zona en la que entra consiste en un\n\nswitch, marcado en verde. Dependiendo de la cantidad de parámetros que necesite la\n\n\nfunción a la que debe llamar, entra en una de las zonas en blanco.\n\n\nEn caso de la siguiente captura, si el número de parámetros (que tiene cargados en\n\nedx) coincide con 9, entra en una zona con nueve llamadas a “push edx” con las que\n\nva cargando parámetros en la pila extraídos de offsets consecutivos posteriores a eax;\n\npor último realiza una llamada a ecx, donde ha cargado el primer offset de eax en la\n\n\ncuarta instrucción de esta zona y que se corresponde con la posición de una función.\n\n\nEn la próxima captura se puede observar un ejemplo de llamada a una función como\n\nesta y el estado de los registros durante la ejecución.\n\nPara gestionar las esperas entre el proceso padre e hijo, **Trickbot utiliza los eventos**\n\n\nque crea antes de las inyecciones en los procesos.\n\n\nValiéndose de estos eventos, cuando llega a la última zona del bucle (en la captura\n\nanterior marcada con fondo en **azul) contiene dos llamadas que corresponden a un**\n\n\nResetEvent que notifica a Trickbot que ha llegado al final del bucle:\n\n\n-----\n\nY una llamada posterior a SignalObjectAndWait, al que le pasa los IDs de dos eventos.\n\nEsta función deja el proceso suspendido a la espera de que **Trickbot haga un**\n\nResetEvent del evento en este caso con ID 4, que implica que ha cargado en memoria\n\n\nlos nuevos parámetros para la próxima iteración del bucle:\n\n\nAntes de iniciar la ejecución de todo este proceso, inyecta en el Entry Point de\n\nsvchost, cuatro líneas que redirigen el flujo del hilo principal a la función anterior,\n\npasándole como parámetro, los 32 bytes de datos inyectados al principio:\n\nTras preparar todo eso, llama a ResumeThread y el proceso entra en ejecución.\n\n\n-----\n\nDurante las primeras iteraciones del bucle, Trickbot mapea uno de los módulos en la\n\nmemoria del proceso, sección a sección:\n\nEn la siguiente iteración, sirviéndose de los datos que le ha pasado el proceso padre,\n\ncarga con LoadLibrary todas las DLL que requiere el modulo recién cargado y con\n\nGetProcAddress las funciones de éstas que va a necesitar.\n\nPor último llama a una función de inicialización del propio módulo, la cual escribe en\n\nuna de las zonas de memoria editadas por Trickbot la cadena “Success” en caso de\n\nque todo esté correcto.\n\nA partir de este punto, esta última iteración queda suspendida con la llamada a\n\nSignalObjectAndWait, a la espera de que **Trickbot requiera, por ejemplo, de la**\n\ninformación de reporting de dicho módulo.\n\nDesde el lado del proceso principal, se puede observar como éste contiene una\n\nfunción para llamar a las distintas funciones que exportan cada uno de sus módulos.\n\nEstas funciones son las que exporta cada módulo, ya que los módulos son DLL’s y\n\ncomo tal exportan funciones para ser utilizadas por el core. Hasta la fecha no han\n\n\n-----\n\ncambiado estas funciones en ninguna de las versiones y estas son Start, Control,\n\nFreebuffer y Release.\n\n\n-----\n\nPara realizar la transferencia de información al módulo, tras pasar por la zona de la\n\nfunción a la que quiere llamar, realiza un WriteProcessMemory de los datos en\n\ncuestión y llama a ResetEvent para que el módulo empiece a trabajar.\n\n\n-----\n\n###### 5. CONEXIONES DE RED\n\n\nPara las comunicaciones con sus C2, este malware utiliza peticiones HTTPS, lo cual\n\ncomplica la identificación de su tráfico por medio de herramientas como NIDS al uso,\n\npuesto que dicho tráfico va cifrado.\n\nGeneralmente estas comunicaciones las realiza por el puerto 443, aunque no siempre\n\nes así, ya que a partir de las primeras versiones, empezó a utilizar el puerto 447 de\n\nalgún C2 concreto para la descarga de los módulos.\n\nUn elemento que ha resultado diferenciador de su tráfico es su User-Agent, ya que en\n\nun inicio le identificaba perfectamente: usaba la cadena TrickLoader en todas sus\n\npeticiones:\n\nEn versiones intermedias del mismo pasó a ser algo menos obvia, pero manteniendo\n\nuna estructura poco común y fácil de detectar, pasando a ser la cadena “Xmaker”:\n\nEn las últimas versiones, como otro de los cambios claramente orientados a hacer\n\neste malware menos detectable, los autores han empezado a utilizar un User-Agent\n\nmucho más genérico:\n\nLas peticiones están formadas de manera que gran cantidad de la información que\n\nreporta al C2 va en la URI, siendo la mayoría de estas peticiones de tipo GET,\n\nexceptuando envíos más extensos de información recopilada por sus módulos, que\n\nenvía por POST.\n\n\n-----\n\nEntre los datos que contienen las URI de las peticiones, se puede encontrar el\n\nidentificador de la campaña actual y el ID de usuario que guarda en los dos ficheros\n\nque genera junto al ejecutable, en las primeras etapas de su ejecución. También un\n\nnúmero que identifica la orden que le está enviando al C2 para que éste pueda\n\ndiferenciar lo que le está solicitando o reportando, y posteriormente diferentes datos\n\nextra relativos al comando en cuestión.\n\nA partir de lo que hemos analizado y de información obtenida de diferentes análisis\n\nexternos, hemos creado la siguiente tabla con un resumen de la funcionalidad de cada\n\norden que hemos identificado.\n\n|ID|Col2|Col3|\n|---|---|---|\n|0|URI|/[group_id]/[client_id]/0/[version de windows]/[idioma del sistema]/[ip externa]/[sha256]/[key de sesión]/|\n||Descripción|Reporte con información básica del cliente.|\n|1|URI|/[group_id]/[client_id]/1/[key de sesión]/|\n||Descripción|Keep alive.|\n|5|URI|/[group_id]/[client_id]/5/[modulo/configuración]/|\n||Descripción|Descarga de módulo o de configuración de un módulo.|\n|10|URI|/[group_id]/[client_id]/10/62/[key de sesión]/1/|\n||Descripción|Inicio de modulo.|\n\n\n-----\n\nTodo apunta a que se trata de un comando relacionado con el módulo\n\nDescripción mailsearcher. Lo que sí que se ha visto es que realiza peticiones POST con\n\ncontenido multipart. Por lo que apunta a ser un comando de exfiltración.\n\nDesde el código de **Trickbot, se puede observar como en una de sus funciones**\n\ncontiene el switch que se encarga de dirigir el flujo de ejecución que genera dichas\n\npeticiones dependiendo del comando. En la siguiente imagen se puede observar dicho\n\ncódigo para una de sus versiones más antiguas (Versión 1000005):\n\nAnalizando la misma función de una de las versiones más recientes (Versión\n\n1000010), podemos observar cómo han añadido una opción extra tras la última, que\n\ncorrespondía al comando con número 63, y a la que se accede con un nuevo comando\n\nnúmero 64:\n\n|14|URI|/[group_id]/[client_id]/14/[key de sesión]/[value]/0/|\n|---|---|---|\n||Descripción|Reporte con información de errores, checks y otra info|\n|23|URI|/[group_id]/[client_id]/23/[config ver]/|\n||Descripción|Actualización de configuración base|\n|25|URI|/[group_id]/[client_id]/25/[key de sesión]/|\n||Descripción|Actualización del bot|\n|60|URI|/[group_id]/[client_id]/60/|\n||Descripción|Reporte de trafico capturado por el módulo injectDll|\n|63|URI|/[group_id]/[client_id]/63/[module name]/[module command]/[result - base64]/[root tag of output XML]/|\n||Descripción|Report de systeminfo o injectDll|\n|64|URI|-|\n||Descripción|Todo apunta a que se trata de un comando relacionado con el módulo mailsearcher. Lo que sí que se ha visto es que realiza peticiones POST con contenido multipart. Por lo que apunta a ser un comando de exfiltración.|\n\n\n-----\n\nLas funciones que se ejecutan a partir de pasar por esta zona nueva de código\n\n(comando número 64) son muy parecidas a las del comando 63, por lo que es\n\nprobable que también se trate de un comando para realizar reporting. La aparición de\n\neste nuevo comando (64) coincide en el tiempo con la aparición del nuevo módulo\n\n“mailsearcher”, por lo que todo apunta a que estos están relacionados.\n\nTras la ejecución de la muestra correspondiente a la versión 14 en un entorno\n\ncontrolado, hemos analizado su flujo de tráfico que muestra buena parte del\n\ncomportamiento de la ejecución de este malware.\n\n_Se ha omitido la primera parte de las peticiones para simplificar los comandos._\n\n\n-----\n\n###### 6. MECANISMO DE CIFRADO\n\n\nEn el gran trabajo realizado por **[malwarebytes (@hasherezade) se detalla que el](https://blog.malwarebytes.com/threat-analysis/2016/10/trick-bot-dyrezas-successor/)**\n\nalgoritmo de cifrado utilizado por Trickbot es **_AES CBC 256 bits._** También en esa\n\nmisma entrada sobre este asunto nos indican que el primer DWORD se trata del\n\ntamaño de los datos. Además, **[@hasherezade](https://blog.malwarebytes.com/threat-analysis/2016/10/trick-bot-dyrezas-successor/)** ofrece recursos tras su investigación\n\npara descifrar tanto las configuraciones como los módulos, cosa que facilita entender\n\n**Trickbot y su evolución.**\n\nPartiendo de esta información y visualizando cómo se descifra el contenido es sencillo\n\nrealizar el proceso inverso y construir un script o modificar el suyo para que nos\n\nproporcione la capacidad de cifrar configuraciones modificadas por nosotros para\n\nmanipular de un modo más cómodo los flujos de ejecución de **Trickbot. La**\n\nimplementación de la función de cifrado sería tan sencilla como:\n\nPara realizar este proceso podemos partir de una configuración que obtengamos\n\ncifrada y con la herramienta de **[@hasherezade la podemos descifrar. Una vez](https://blog.malwarebytes.com/threat-analysis/2016/10/trick-bot-dyrezas-successor/)**\n\ndescifrada, la podemos modificar, como en el siguiente ejemplo donde añadimos la\n\ndirección IP local 11.11.11.1:443 (ip propia del entorno de Laboratorio) y la carga del\n\nmódulo “mailsearcher”. Con esto pretendemos que utilice la IP 11.11.11.1:443 como\n\nmando y control y que cargue el módulo “mailsearcher” que por defecto no suele\n\nvenir.\n\nTras modificarlo con un editor hexadecimal tendríamos lo siguiente:\n\n\n-----\n\nDespués de los primeros 8 bytes es cuando empiezan los datos de configuración\n\ncomo tal. En estos primeros 8 bytes, será donde **Trickbot buscará el tamaño de los**\n\ndatos que vendrán a continuación. En el caso de ejemplo eso se corresponde con el\n\nvalor **02 00 (en la imagen está al revés, 00 02), esto sería 0x200 bytes. Si**\n\nseleccionamos el conjunto de datos veremos que tiene justo el tamaño 0x200 bytes:\n\nPor tanto, después de modificar la información deberemos ajustar los primeros bytes\n\npara indicarle a **Trickbot** el tamaño exacto de los datos. Después ciframos con la\n\nfunción que hemos llamado aes_encrypt(). Con esto tendremos una nueva\n\nconfiguración que aún no acabará de estar funcional del todo.\n\nLa razón por la que no funciona es porque Trickbot después de los datos cifrados\n\ncoloca la firma del hash de los datos. Por lo tanto si modificamos el contenido de la\n\nconfiguración tenemos que calcular la firma de los datos ya que la verifica después de\n\nleer la configuración. Para calcular la firma del hash de los datos que acaba de leer\n\n\n-----\n\nutiliza la KEY que viene en los resources del binario. Vemos a continuación como\n\ncarga los key de los resources:\n\nDespués ejecutará la función LoadResource() y veremos en EAX el valor donde estará\n\nla KEY:\n\nLa clave que hay en los resources tiene el siguiente aspecto (veréis que el binario\n\npresentado no tiene el resource CONFIG típico de la versión 14 de Trickbot, esto es\n\npara obligarle a leer la configuración del fichero config.conf. Esto no es necesario pero\n\nlo hemos hecho para poderle cambiar la configuración de una forma más sencilla):\n\nY esta clave veremos que es la que importa la función BCryptImportKeyPair() cuando\n\nhace el push eax. El valor de EAX es igual a 0x004B90E8, que como vemos en la vista\n\nhexadecimal se corresponde con la clave que estaba en los resources:\n\n\n-----\n\nDespués de importar la clave utiliza la función BcryptVerifySignature() para hacer la\n\nverificación de la firma.\n\nLa otra clave que utiliza **Trickbot es como hemos comentado para descifrar la**\n\nconfiguración y los módulos, y veremos cómo la importa mediante la función del api\n\nCryptImportKey():\n\nLlegados a este punto tenemos dos opciones: o modificar el flujo de ejecución del\n\nprograma para que el proceso de verificación siempre nos diga que es correcta la\n\nfirma o replicar el proceso de firma del hash de los datos que realiza **Trickbot.**\n\nNosotros por simplicidad hemos optado por la opción de modificar el flujo de ejecución\n\ndel binario para que no haga falta que esté correctamente firmado.\n\n\n-----\n\n###### 7. MECANISMO DE IPC (Inter-Process\n\n\n###### Communication) \n\n\nUno de los aspectos interesantes de este malware es cómo recupera la información\n\ndesde los módulos. Utiliza la lectura mediante ReadProcessMemory de los procesos\n\nhijos que ha creado. A continuación vamos a ver el ejemplo donde Trickbot (el core)\n\nlee lo que devuelve el módulo systeminfo. Si nos paramos en uno de los\n\nReadProcessMemory que hemos identificado, vemos que le pasa como parámetro el\n\nhandle del proceso remoto (3D0):\n\nEn la siguiente imagen veremos mejor como el handler 3D0 se corresponde con el\n\nproceso hijo svchost.exe:\n\n\n-----\n\nPodemos ver el PID del proceso padre y el del hijo aquí:\n\nLa dirección de memoria que quiere leer (lpBaseaddress) es **0x2866f0, que como**\n\npodemos ver en el registro ECX de la imagen del ReadProcessMemory(). Como ya\n\nhemos dicho la quiere leer del proceso remoto svchost (handler 3D0) y en ese instante\n\nlo que contiene esa dirección de memoria es:\n\n\n-----\n\nVemos en 0x2866f0 (230000+566f0) que está la información recopilada por el módulo\n\ny que el core está accediendo a ella. En este caso esta información la enviará al C2\n\nmediante el comando 63. Hemos visto un ejemplo de como se han intercambiado la\n\ninformación el core de Trickbot y el módulo “systeminfo”.\n\n\n-----\n\n###### 8. ARCHIVOS RELACIONADOS\n\n\nLas muestras analizadas de **Trickbot hasta la fecha, se han instalado siempre en la**\n\ncarpeta %APPDATA% del usuario por el que es ejecutado en primer lugar. En esta\n\ncarpeta se copia a sí mismo y crea 2 ficheros:\n\n**client_id:** El cual contiene un ID del usuario infectado generado a partir de\n\ndatos del sistema.\n\n**group_tag:** Un código de la campaña el cual contiene en la configuración\n\ninterna que se puede encontrar cifrada en los recursos del ejecutable, una vez\n\ndesempaquetado, junto con la clave de descifrado.\n\nAparte de estos ficheros, si tiene conectividad, descargará en la misma carpeta una\n\nconfiguración actualizada que guardará como “config.conf” cifrada, y creará una\n\ncarpeta “Modules”.\n\nEn la carpeta llamada Modules descargará los módulos que contengan sus ficheros de\n\nconfiguración cifrados, y carpetas con los ficheros de configuración de algunos de los\n\nmódulos. Las carpetas con las configuraciones de cada módulo tendrán nombres\n\nsiguiendo el patrón: “<nombre del módulo>_config“.\n\nCuando obtiene permisos de administración, se copia a la carpeta:\n\n\nC:\\Windows\\System32\\config\\systemprofile\\AppData\\Roaming\n\n\nTras ejecutar esta acción elimina el ejecutable de la carpeta Roaming del usuario\n\ninicial, dejando los módulos y las configuraciones intactas.\n\n\n-----\n\n###### 9. DETECCIÓN\n\n\nEn primer lugar, de forma manual, se podrán encontrar los ficheros mencionados en el\n\napartado 8 en la carpeta %APPDATA%, el único caso que puede variar es el\n\nejecutable principal que se puede encontrar con distintos nombres dependiendo de su\n\norigen, pues los demás hasta la fecha no han cambiado en ningún momento.\n\nTambién se podrán encontrar, dependiendo del escenario, una o dos tareas llamadas\n\n“bot” o “Drivers update”, y “AplicationsCheckVersion”, las cuales ejecutarán una\n\naplicación en el directorio %APPDATA% cada minuto y al iniciar sesión\n\nrespectivamente.\n\nDurante su ejecución, es más fácil detectarlo entre los procesos en ejecución en\n\nequipos de 32 bits, pues en estos mantiene el nombre del ejecutable replicado en\n\n%appdata%. En cambio, en equipos de 64 bits se vale del proceso svchost.exe de\n\nMicrosoft, para ocultarse cuando es ejecutado por un usuario normal del sistema. En el\n\ncaso de ser invocado por la tarea de persistencia con permisos de SYSTEM, se\n\ncomporta igual que en sistemas 32 bits.\n\nPara la detección de forma automática, no hay reglas NIDS que lo puedan detectar a\n\ntravés de su tráfico hasta el momento, ya que el hecho de que vaya cifrado por SSL lo\n\ncomplica en más medida.\n\nSe han desarrollado reglas Yara para detectarlo en memoria, ya que el ejecutable\n\nviene empaquetado con distintos tipos de sistemas para cada campaña y versión,\n\nimpidiendo que se cree una regla común.\n\n\n-----\n\nLas reglas para su detección en memoria son las siguientes:\n\nrule MALW_trickbot_bankBot : Trojan rule MALW_systeminfo_trickbot_module :\n\nTrojan\n\nmeta: {\nauthor = \"Marc Salinas @Bondey_m\" meta:\ndescription = \"Detects Trickbot Banking author = \"Marc Salinas @Bondey_m\"\nTrojan\" description = \"Detects systeminfo\n\nmodule from Trickbot Trojan\"\n\nstrings:\n$str_trick_01 = \"moduleconfig\" strings:\n$str_trick_02 = \"Start\"\n$str_trick_03 = \"Control\" $str_systeminf_01 = \"<program>\"\n$str_trick_04 = \"FreeBuffer\" $str_systeminf_02 = \"<service>\"\n$str_trick_05 = \"Release\" $str_systeminf_03 = \"</systeminfo>\"\n\n$str_systeminf_04 =\n\ncondition: \"GetSystemInfo.pdb\"\nall of ($str_trick_*) $str_systeminf_05 = \"</autostart>\"\n\n$str_systeminf_06 = \"</moduleconfig>\"\n\ncondition:\nall of ($str_ systeminf_*)\n}\nrule MALW_dllinject_trickbot_module : Trojan rule MALW_mailsercher_trickbot_module :\n\nTrojan\n\nmeta: {\nauthor = \"Marc Salinas @Bondey_m\" meta:\ndescription = \" Detects dllinject module author = \"Marc Salinas @Bondey_m\"\nfrom Trickbot Trojan\" description = \" Detects mailsearcher\n\nmodule from Trickbot Trojan\"\n\nstrings:\n$str_dllinj_01 = \"user_pref(\" strings:\n$str_dllinj_02 = \"<ignore_mask>\" $str_mails_01 = \"mailsearcher\"\n$str_dllinj_03 = \"<require_header>\" $str_mails_02 = \"handler\"\n$str_dllinj_04 = \"</dinj>\" $str_mails_03 = \"conf\"\n\n$str_mails_04 = \"ctl\"\n\ncondition: $str_mails_05 = \"SetConf\"\nall of ($str_ dllinj_*) $str_mails_06 = \"file\"\n\n$str_mails_07 = \"needinfo\"\n$str_mails_08 = \"mailconf\"\n\ncondition:\nall of ($str_mails_*)\n}\n\n|rule MALW_trickbot_bankBot : Trojan { meta: author = \"Marc Salinas @Bondey_m\" description = \"Detects Trickbot Banking Trojan\" strings: $str_trick_01 = \"moduleconfig\" $str_trick_02 = \"Start\" $str_trick_03 = \"Control\" $str_trick_04 = \"FreeBuffer\" $str_trick_05 = \"Release\" condition: all of ($str_trick_*) }|rule MALW_systeminfo_trickbot_module : Trojan { meta: author = \"Marc Salinas @Bondey_m\" description = \"Detects systeminfo module from Trickbot Trojan\" strings: $str_systeminf_01 = \"<program>\" $str_systeminf_02 = \"<service>\" $str_systeminf_03 = \"</systeminfo>\" $str_systeminf_04 = \"GetSystemInfo.pdb\" $str_systeminf_05 = \"</autostart>\" $str_systeminf_06 = \"</moduleconfig>\" condition: all of ($str_ systeminf_*) }|\n|---|---|\n|rule MALW_dllinject_trickbot_module : Trojan { meta: author = \"Marc Salinas @Bondey_m\" description = \" Detects dllinject module from Trickbot Trojan\" strings: $str_dllinj_01 = \"user_pref(\" $str_dllinj_02 = \"<ignore_mask>\" $str_dllinj_03 = \"<require_header>\" $str_dllinj_04 = \"</dinj>\" condition: all of ($str_ dllinj_*) }|rule MALW_mailsercher_trickbot_module : Trojan { meta: author = \"Marc Salinas @Bondey_m\" description = \" Detects mailsearcher module from Trickbot Trojan\" strings: $str_mails_01 = \"mailsearcher\" $str_mails_02 = \"handler\" $str_mails_03 = \"conf\" $str_mails_04 = \"ctl\" $str_mails_05 = \"SetConf\" $str_mails_06 = \"file\" $str_mails_07 = \"needinfo\" $str_mails_08 = \"mailconf\" condition: all of ($str_mails_*) }|\n\n\n-----\n\n###### 10. DESINFECCION\n\n\nTeniendo en cuenta el proceso de detección, en caso de encontrar rastros de esta\n\namenaza en el sistema y que ninguna de nuestras medidas de protección del sistema\n\nsea capaz de detectarlo o desinfectarlo, los pasos ideales para su desinfección serían:\n\n  - Eliminación de la tarea que se ejecuta cada minuto, para que no reinicie la\n\nejecución del malware.\n\n  - Finalización del proceso de Trickbot con el administrador de tareas o con una\n\naplicación como ProcessExplorer.\n\n  - Navegación a la carpeta %APPDATA% donde se encuentra instalado, para\n\nborrar el ejecutable principal de Trickbot y posteriormente los tres ficheros\n\n(“user_id”, “group_tag” y “config.conf”) y la carpeta Modules.\n\n  - Navegación a la carpeta APPDATA del usuario SYSTEM\n\n(C:\\Windows\\System32\\config\\systemprofile\\AppData\\Roaming) para eliminar\n\nlos mismos ficheros de ésta.\n\nCon esto, habríamos eliminado por completo esta amenaza del sistema, aunque sería\n\nrecomendable revisar que no se haya repuesto la tarea de persistencia en caso de que\n\njusto en el lapso de tiempo entre que la eliminamos y cerramos el proceso, éste\n\nhubiera estado en sus primeras fases de ejecución y la hubiese repuesto, aunque no\n\nsería peligrosa pues no podría encontrar el ejecutable en el sistema.\n\nPor otra parte, en los casos en los que la infección haya sido a través de un ExploitKit,\n\nes probable que además de **Trickbot, nuestro sistema se encuentre infectado con**\n\notros tipos de malware, pues no suelen instalar solo una muestra, por lo cual se\n\nrecomendaría realizar análisis con distintas herramientas llegando al formateo en\n\ncasos sensibles.\n\n\n-----\n\n###### 11. INFORMACION DEL ATACANTE\n\n\n[Para la infraestructura de Trickbot, como mencionaba @hasherezade en su post en](https://twitter.com/hasherezade)\n\n**[el blog de Malwarebytes, las IPs de sus C2 corresponden a dispositivos como](https://blog.malwarebytes.com/threat-analysis/2016/10/trick-bot-dyrezas-successor)**\n\nRouters o Cámaras IP (todos los comprobados con procesadores ARM) repartidas por\n\ngran cantidad de países distintos y en todos los casos que hemos analizado\n\npertenecientes a ISP de cada uno de los países que veremos a continuación.\n\nEl reparto de países de los C2 (partiendo de las configuraciones recopiladas) se\n\nmuestra en la siguiente gráfica donde se puede observar como destacan Estados\n\nUnidos y China:\n\n\n-----\n\nLa mayoría de los sistemas afectados presentan una interfaz Web de acceso como las\n\nsiguientes:\n\nY en caso de acceder por https a la URL formada por uno de los comandos de\n\n**Trickbot, el certificado que nos muestra, sigue siendo el mismo que en las primeras**\n\nversiones analizadas en el post mencionado anteriormente:\n\n\n-----\n\n###### 12. REFERENCIAS\n\n\n**_https://blog.fortinet.com/2016/12/06/deep-analysis-of-the-online-banking-botnet-_**\n**_trickbot_**\n\n**_http://www.threatgeek.com/2016/10/trickbot-the-dyre-connection.html_**\n\n**_https://www.infosecurity-magazine.com/blogs/rig-ek-dropping-trickbot-trojan/_**\n\n**_https://devcentral.f5.com/articles/is-xmaker-the-new-trickloader-24372_**\n\n**_https://blog.malwarebytes.com/threat-analysis/2016/10/trick-bot-dyrezas-successor/_**\n\n**_https://fraudwatchinternational.com/malware/trickbot-malware-works/_**\n\n**_https://msdn.microsoft.com/en-_**\n**_us/library/windows/desktop/ms682425%28v=vs.85%29.aspx_**\n\n**_https://msdn.microsoft.com/en-_**\n**_us/library/windows/desktop/aa366890%28v=vs.85%29.aspx_**\n\n**_https://msdn.microsoft.com/es-_**\n**_es/library/windows/desktop/ms681674%28v=vs.85%29.aspx_**\n\n**_https://msdn.microsoft.com/es-_**\n**_es/library/windows/desktop/ms682437%28v=vs.85%29.aspx_**\n\n\n###### 13. AUTORES\n\n\n\n######  Marc Salinas\n  José Miguel Holguín\n\n\n-----\n\n-----",
    "language": "ES",
    "sources": [
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.securityartwork.es/wp-content/uploads/2017/06/Informe_Evoluci%C3%B3n_Trickbot.pdf"
    ],
    "report_names": [
        "Informe_Evoluci%C3%B3n_Trickbot.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716498,
    "ts_updated_at": 1743041120,
    "ts_creation_date": 1497275314,
    "ts_modification_date": 1497275314,
    "files": {
        "pdf": "https://archive.orkl.eu/46eeeb610662c92f39530c8641a572dcb6d14c48.pdf",
        "text": "https://archive.orkl.eu/46eeeb610662c92f39530c8641a572dcb6d14c48.txt",
        "img": "https://archive.orkl.eu/46eeeb610662c92f39530c8641a572dcb6d14c48.jpg"
    }
}