{
    "id": "eb4a24af-8019-4ba2-aef8-d3b179dad100",
    "created_at": "2023-01-12T15:05:04.685574Z",
    "updated_at": "2025-03-27T02:06:02.818448Z",
    "deleted_at": null,
    "sha1_hash": "5161df2900f9f9c33e18d2b6003363b907269872",
    "title": "2011-09-09 - Stuxnet Malware Analysis Paper",
    "authors": "",
    "file_creation_date": "2022-05-27T19:02:43Z",
    "file_modification_date": "2022-05-27T19:02:43Z",
    "file_size": 1357076,
    "plain_text": "# Stuxnet Malware Analysis Paper\n\n**[codeproject.com/articles/246545/stuxnet-malware-analysis-paper](https://www.codeproject.com/articles/246545/stuxnet-malware-analysis-paper)**\n\nAmrThabet September 6, 2011\n\n[AmrThabet](https://www.codeproject.com/script/Membership/View.aspx?mid=5879897)\nRate me:\n\nPlease [Sign up or sign in to vote.](https://www.codeproject.com/script/Membership/LogOn.aspx?rp=%2farticles%2f246545%2fstuxnet-malware-analysis-paper)\n\n4.95/5 (51 votes)\n\n[9 Sep 2011CPOL29 min read](http://www.codeproject.com/info/cpol10.aspx)\nThis article will focus on Stuxnet’s windows infection methods and spreading methods. The\ntricks were used by stuxnet and the evidences behind the criminals of stuxnet.\n\n[Download the Article in PDF - 2.17 MB](https://www.codeproject.com/KB/Articles/StuxnetMalware/Stuxnet_Malware_Analysis_Paper.pdf)\n\n## Table Of Contents\n\n 1. Introduction\n\n\n-----\n\nStuxnet is not only a new virus or worm but it s a new era of malware. This virus changed the\nmeaning of malware and their goals. You hear about a virus annoying people or stealing\nbanks or credit cards, but that's the first time you hear about virus damages buildings,\ndestroys machines or kills people and that's Stuxnet.\nStuxnet has gained a lot of attention from malware researchers and media in the last year.\nIt's created to sabotage Iran's nuclear program.\n\nThis complex threat uses up to four zero-day vulnerabilities in windows OS and includes\nmany tricks to avoid being detected by the behavioral-blocking antivirus programs. It\ndamaged the Iranian nuclear reactor and its machines by infecting the PLCs (Programmable\nLogic Controller) that control the machines there. That makes it modify the control program\nwhich changes the behavior of the machine.\n\nHere we will talk about the technical details about stuxnet and the experience that I got from\nanalyzing this malware. We will talk about how stuxnet works and the stuxnet life cycle. But\nhere we will not talk about the SCADA systems and how stuxnet infects them and we will\ntake a hint on the vulnerabilities that are used by stuxnet.\n\n## 2. Payload\n\nThis worm was created mainly to sabotage the Iranian Nuclear Program. Once installed on a\nPC, Stuxnet uses Siemens' default passwords to gain access to the systems that run the\nWinCC and PCS 7 programs which control and modify the code of the PLCs (programmable\nlogic controller) which control the machines themselves\n\nStuxnet operates in two stages after infection, according to Symantec Security Response\nSupervisor Liam O'Murchu. First it uploads configuration information about the Siemens\nsystem to a command-and-control server. Then the attackers are able to pick a target and\nactually reprogram the way it works. \"They decide how they want the PLCs to work for them,\nand then they send code to the infected machines that will change how the PLCs work,\"\nO'Murchu said.\n\nIt managed to infect facilities tied to Iran's controversial nuclear programme before reprogramming control systems to spin up high-speed centrifuges and slow them down\n\n## 3. Suspects\n\nIsrael is an obvious suspect. Israel considers a nuclear Iran to be a direct existential threat.\nBut, until now, there's no real evidence says that Israel who really creates this worm. There\nare some theories said that there are evidences on Israel as the creator depending on some\ndates and words found inside the malware and also there's an analysis from the industrial\ncontrol-systems maker \"Siemens\"� reportedly backs speculation that Iran may have been\nthe target of Stuxnet's attack and that Israel may have been involved.\n\n\n-----\n\nA report by the New York Times suggested Stuxnet was a joint US-Israeli operation that was\ntested by Israel on industrial control systems at the Dimona nuclear complex during 2008\nprior to its release a year later, around June 2009. The worm wasn't detected by anyone until\na year later, suggesting that for all its possible shortcomings the worm was effective at\nescaping detection on compromised systems.\n\nBut these evidences aren't real evidences in the court and the wormâ€˜s still a perfect crime.\n\n## 4.Technical Details\n\n### 4.1.Stuxnet Live Cycle\n\nThis is the live cycle of stuxnet virus on windows OS. We will describe every step in this\ncycle beginning by WTR4132.TMP File and that's the main dropper of stuxnet worm.\n\n### 4.2. Main Dropper (~WTR4132.TMP)\n\nThis File is a dynamic link library file loaded into Explorer.exe (we will describe the loading of\nit in the booting mechanism). It begins the execution by searching for a section in it named\n\".stub\"� section.\n\n\n-----\n\nThis section contains the main stuxnet DLL file. And this DLL contains all stuxnet's functions,\nmechanisms, files and rootkits.\n\nAnd that's the MZ File inside .stub section:\n\nThis Section (\".stub\"�) includes also the configuration data of stuxnet which is so important\non the spreading mechanism, updating mechanism and many other things.\n\nAfter finding this section, it loads stuxnet DLL file in a special way. First, it allocates a\nmemory buffer for the DLL file to be loaded. Then, it patches 6 ntdll.dll APIs with these\nnames:\n\n1. ZwMapViewOfSection\n2. ZwCreateSection\n3. ZwOpenFile\n4. ZwClose\n5. ZwQueryAttributesFile\n6. ZwQuerySection\n\nTo force these APIs to make .stub section like the file which you need to open with\nZwOpenFile and to read from this section as it's a file on the harddisk. These patches make\nLoadLibraryA load a DLL file not from the harddisk (as usual) but from a place in the\nmemory.\n\n\n-----\n\nIt calls LoadLibraryA with the DLLName like KERNEL32.DLL.ASLR.XXXX to load the Main\nDLL File as I described above and at then end, it calls to Function #15 in the Main Stuxnet\nDLL.\n\n### 4.3. Main Stuxnet DLL\n\n 4.3.1. Escalating the Privileges and Injecting Into a New Process\n\nWhen the main DLL begins the execution. It unupx itself (as the DLL is upxed) and then\nchecks the configuration data of this stuxnet sample and checks the environment to choose if\nit will continue or exit from the beginning.\n\nIt checks if the configuration data is correct and recent and then it checks the admin rights. If\nit's not running on administrator level, it uses one of two zero-day vulnerabilities to escalate\nthe privileges and run in the administrator level.\n\n_CVE-2010-2743(MS-10-073) \"“Win32K.sys Keyboard Layout Vulnerability_\n\n_CVE-xxxx-xxxx(MS-xx-xxx) \"“Windows Task Scheduler Vulnerability_\n\nThese two vulnerabilities allow the worm to escalate the privileges and run in a new process\n(\"csrss.exe\"� in case of Win32K.sys) or as a new task in the Task Scheduler case. It makes\nalso some other checks like checking on 64bits or 32bits and so on. After everything goes\nright and the environment is prepared to be infected by stuxnet, it injects itself into another\nprocess to install itself from that process. The injection begins by searching for an Antivirus\napplication installed in the machine.\n\nDepending on the antivirus application (AVP or McAfee or what?), stuxnet chooses the\nprocess to inject itself into. If there's no antivirus program it chooses \"lsass.exe\"�\n\nYou will see the processes that stuxnet could choose in this Figure:\n\n\n-----\n\nIt doesn't search for that process in the task manager to inject itself into, but it creates a new\nprocess (using CreateProcess) of the chosen application in the suspended form like that:\n\nASM\n```\nESP ==> > 0006F4F8 |ModuleFileName = \"C:\\WINDOWS\\\\system32\\\\lsass.exe\"\nESP+4  > 00000000 |CommandLine = NULL\nESP+8  > 00000000 |pProcessSecurity = NULL\nESP+C  > 00000000 |pThreadSecurity = NULL\nESP+10  > 00000001 |InheritHandles = TRUE\nESP+14  > 0800000C |CreationFlags =\nCREATE_SUSPENDED|DETACHED_PROCESS|CREATE_NO_WINDOW\nESP+18  > 00000000 |pEnvironment = NULL\nESP+1C  > 00000000 |CurrentDir = NULL\nESP+20  > 0006F13C |pStartupInfo = 0006F13C\nESP+24  > 0006F730 \\pProcessInfo = 0006F730.\n\n```\nAfter creating this process, it injects itself by a special way. This special way is to unload the\nprogram from its memory (ex. unload lsass.exe module from its memory) and load another\nPE File from stuxnet DLL resources in the same place of the previously unloaded module\n(lsass.exe for example).\n\nBefore loading this new PE File, stuxnet makes some modifications to the file by adding new\nsection (in the beginning) named \".verif\"�. This section makes the PE File's size equal to\nthe size of the previously unloaded module. And at the place of the entrypoint of the\nunloaded module, stuxnet writes a \"jmp\"� instruction to the entrypoint of this PE File.\n\n\n-----\n\nThe last step, stuxnet copies the .stub section and the main DLL to the memory of the\ninfected process and writes on .bin section the pointer to this memory buffer.\n\nAt the end, stuxnet resumes the main thread of this infected process. The PE file reloads the\nmain stuxnet DLL and calls to Function #16.\n\n### 4.3.2. Main Stuxnet DLL: Installing Stuxnet into the Infected Machine\n\nThe Function #16 begins by checking the configuration data and be sure that everything is\nready to begin the installation. And also, it checks if the there's a value in the registry with\nthis name \" NTVDM TRACE \"� in\n\n```\nSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\MS-DOS Emulation\n\n```\n\nAnd then, it checks if this value equal to \"19790509\"�. This special number seems a date\n\"May 9, 1979\"� and this date has a historical meaning (by Wikipedia) \"Habib Elghanian was\nexecuted by a firing squad in Tehran sending shock waves through the closely knit Iranian\nJewish community\"�\n\n\n-----\n\nAfter this test, Stuxnet installs itself with writing 6 files in the Windows directory 4 encrypted\nfiles:\n\n_C:\\WINDOWS\\inf\\oem7A.PNF_\n_C:\\WINDOWS\\inf\\oem6C.PNF_\n_C:\\WINDOWS\\inf\\mdmcpq3.PNF_\n_C:\\WINDOWS\\inf\\mdmeric3.PNF_\n\nAnd 2 device drivers:\n\n_C:\\WINDOWS\\system32\\Drivers\\mrxnet.sys_\n_C:\\WINDOWS\\system32\\Drivers\\mrxcls.sys_\n\nAfter that, it installs the device drivers into the registry to be sure that they will run every time\nthe computer boots.\nIt forces them to be loaded in the beginning before most of windows system applications\n(and that's will be explained later).\n\n\n-----\n\nAfter the installation, it loads the mrxnet driver by calling `ZwLoadDriver . It calls to this`\nfunction after adjusting its privileges by \" AdjustTokenPrivileges \"� to add the\n\n`SeLoadDriverPrivilege` to its privileges.\n\nAt the end, it modifies the Windows Firewall (Windows Defender) setting to avoid being\nstopped by this firewall. It some values in the key:\n```\nSOFTWARE\\Microsoft\\Windows Defender\\Real-Time Protection\n\n```\nAnd the values are:\n\n\n-----\n\n```\nServicesAndDriversAgent\n\n```\n\nIt sets them all to zero and disables the firewall for stuxnet.\n\nNow the installation ends and now we will talk about the spreading mechanisms\n\n### 4.4. Spreading Mechanism\n\n 4.4.1. The USB Drives Infection\n\nFor infecting USB Flash memory, Stuxnet creates a new hidden window \" AFX64c313 \"�\nand get notified of any new USB flash memory inserted to the computer by waiting for\n\" WM_DEVICECHANGE \"� Windows Message. After getting notified of a new drive added to\nthe computer (USB Flash Memory), stuxnet writes 6 files into the flash memory drive:\n\nCopy of Shortcut to.lnk\nCopy of Copy of Shortcut to.lnk\nCopy of Copy of Copy of Shortcut to.lnk\nCopy of Copy of Copy of Copy of Shortcut to.lnk\n\nAnd 2 executable files (DLL files):\n\n_~WTR4141.tmp_\n_~WTR4132.tmp_\n\nThese malformed shortcut files use vulnerability in Windows Shell named:\n\n_CVE-2010-2568(MS-10-046) -Windows Shell LNK Vulnerability_\n\nThis vulnerability is not a buffer-overflow vulnerability but it's due to a bad way for windows to\nload icons for LNK files which creates the vulnerability.\n\nThese shortcuts are special shortcuts for an unknown type of files named CPL Files. These\nfiles are the Control Panel applications like datetime.cpl in windows directory (you can test it)\nand many of them in windows directory.\n\nYou can create a shortcut similar to these shortcuts by choosing Control Panel then Switch to\nclassical view then right click on any application of them and click \"create shortcut\"� as\nwhat you see in the picture:\n\n\n-----\n\nIf you try to compare this shortcut with the malformed shortcut by stuxnet you will see that:\n\nThey are very similar (the white spaces are the similar places). Maybe the differences are in\nthe end of the shortcut.\n\nIf we analyze the shortcut, we will see that all shortcuts contain the following sections:\n\n**.LNK File Format**\n\n1. Header\n\n2. Shell Item Id List\n\n3. File Location Info\n\n4. Description\n\n5. Relative Path\n\n6. Working Directory\n\n7. Command Line Arguments\n\n8. Icon Filename\n\n9. Additional Info\n\nIn our Malformed Shortcut, it has only the first 2 sections. The first section is like this:\n\n\n-----\n\n**Stuxnet's Shortcut Header**\n\nMagic 4C 00 00 00\n\nGUID 01 14 02 00 00 00 00 00 C0 00 00 00 00 00 00 46\n\nShortcut flags 0x0000001 : Shell Item ID List present\n\nTarget File flags 00 00 00 00\n\nCreation Time 00 00 00 00 00 00 00 00\n\nLast access time: 00 00 00 00 00 00 00 00\n\nModified time 00 00 00 00 00 00 00 00\n\nFile length 00 00 00 00 (the target is not a file)\n\nIcon Number 00 00 00 00\n\nShow Window 01 00 00 00 == 1 (Normal Window)\n\nHot Key 00 00 00 00\n\nReserved 00 00 00 00\n\nReserved 00 00 00 00\n\nThis header is exactly the same in the CPL Shortcut that you create before. The next Section\nis the Shell Item ID List.\n\nIt's hard to explain this section but every object in windows (like a folder, a file, the control\npanel and so on) has a PIDL. I don't have any idea PIDLs but it's an ID with reference to this\nobject.\n\nThe Shell Item ID List begins by an unsigned short represent the size of the whole Section\n(in the Original CPL File the size == size_of_whole_file \"“ size_of_header).\n\nAfter that, this unsigned short followed by a size of an ID and then the ID of an item in the list\nthen the next size and item and so on until reach the end of this section. This section ends\nby an item its size equal to zero.\n\nThese IDs could represent a file like that:\n\n\n-----\n\nOr represent a virtual object like Control Panel like in this malformed shortcut.\n\nIn the malformed shortcut, this section begins with the pid of the Control Panel and then\nsome other pids until reach an item contains the path and the filename of stuxnet DLL\n( \"~WTR4141.TMP\"� )\n\nThe path is like that:\n```\n\\\\.\\STORAGE#RemovableMedia#7&364cf31c&0&RM#{53f5630d-b6bf-11d0-94f200a0c91efb8b}\\~WTR4141.tmp\n\n```\nYou will ask me, so why there are four shortcut files?\n\nBecause every file of them contains a different form of the path to wtr4141.tmp file to ensure\nthat stuxnet is compatible with all versions of windows OS that have this vulnerability\n\nThe paths are these:\n\n**Windows7:**\n```\n\\\\.\\STORAGE#Volume#_??\n_USBSTOR#Disk&Ven_____USB&Prod_FLASH_DRIVE&Rev_#12345000100000000173&0#\n{53f56307-b6bf-11d0-94f2-00a0c91efb8b}#{53f5630d-b6bf-11d0-94f200a0c91efb8b}\\~WTR4141.tmp\n\n```\n**Windows Vista:**\n```\n\\\\.\\STORAGE#Volume#1&19f7e59c&0&_??\n_USBSTOR#Disk&Ven_____USB&Prod_FLASH_DRIVE&Rev_#12345000100000000173&0#\n{53f56307-b6bf-11d0-94f2-00a0c91efb8b}#{53f5630d-b6bf-11d0-94f200a0c91efb8b}\\~WTR4141.tmp\n\n```\n**Windows XP, Windows Server 2003 and Windows 2000:**\n```\n\\\\.\\STORAGE#RemovableMedia#8&1c5235dc&0&RM#{53f5630d-b6bf-11d0-94f200a0c91efb8b}\\~WTR4141.tmp\n\n```\nThese paths force Explorer.exe to load stuxnet and execute its code.\n\nThe Explorer calls to an API named \"Shell32.LoadCPLModule\"� to load the icon for this\nshortcut which calls to LoadLibraryA API which executes the main function of wtr4141.tmp.\n\nThat's the infection mechanism for Stuxnet using this vulnerability.\n\n### 4.4.2. Spreading via Network\n\nStuxnet spreads via Network using one of vulnerabilities:\n\n\n-----\n\n_CVE-2008-4250(MS-08-067) Windows Server Service NetPathCanonicalize()_\n_Vulnerability_\n_CVE-2010-2729(MS-10-061) \"“Windows Print Spooler Service Vulnerability_\n\nThe first vulnerability is not a zero-day vulnerability, it's already known. This vulnerability was\nused before by Conficker. In this vulnerability, stuxnet looks for C$ and Admin$ shares on\nremote systems. Then, it copies itself as a file named \"DEFRAGxxxxx.TMP\" in the first\nwritable directory found on the share.\n\nAnd then, it tries to execute a command:\n```\nrundll32.exe \"DEFRAGxxxxx.TMP\",DllGetClassObjectEx\n\n```\nThe second vulnerability is a zero-day vulnerability. This vulnerability was first described by\nCarsten Kohler in Hackin9 Security Magazine 04-2009 in an article named \"Print Your\n_Shell\"�_\n\nThis vulnerability wasn't used in the wild until Stuxnet. This vulnerability allows a guest user\naccount to communicate to a machine with a shared printer and writes a file to the system\ndirectory in it.\n\nThe windows APIs for printing allows to choose the directory that you wish to copy your file\nto and with an API named \" GetSpoolFileHandle \"� you can get the file handle of the\nnewly created file in the target machine and then you can easily with ReadFile & WriteFile\nAPIs you can copy your file into the target machine.\n\nFor stuxnet, it copies 2 files into the target machine:\n\n_Windows\\System32\\winsta.exe_\n_Windows\\System32\\wbem\\mof\\sysnullevnt.mof_\n\nThe first file is the stuxnet dropper and the second is a Managed Object Format file. This file\n(under some conditions) executes winsta.exe the stuxnet dropper.\n\n### 4.5. Updating Mechanism\n\n 4.5.1. Updating via Internet\n\nStuxnet updates itself via Internet by establishing a HTTP connection to 2 malformed\nwebsites:\n\n_www.mypremierfutbol.com_\n_www.todaysfutbol.com_\n\nIt sends an encrypted data like that:\n\n\n-----\n\n_http://www.mypremierfutbol.com/index.php?data=data_to_send_\n\nThis data contains the IP, the Adaptor name and description and some other data related to\nthe infected machine and stuxnet. After that it receives the newer version of stuxnet (in an\nencrypted form) begins by the imagebase then a flag and at the last the Executable Image\n\n### 4.5.2. Updating via Peer to Peer Connection\n\nAfter Stuxnet infects a machine, it creates a RPC server and listen to any connections comes\nfrom the any PC on the Network.\n\nIn the other PCs in the network, stuxnet establish a connection with this RPC Server.\n\nThis way allows stuxnet to update itself in the isolated PCs (from the Internet) but has in its\nnetwork a PC has the ability to connect to the internet. This way is to suitable while infecting\ncompanies as there are some inside PCs haven't the ability to connect directly to the\ninternet.\n\n### 4.6. Rootkits\n\n 4.6.1. User-Mode Rootkit (~WTR4141.TMP)\n\nThis file is a DLL File. It's loaded by the LNK Vulnerability. This file not only loads the Main\nStuxnet Dropper (~WTR4132.TMP) but also it works as a user-mode rootkit to hide stuxnet\nfiles in the flash memory.\n\nIt firstly hooks the File Management APIs: ( FindFirstFileW, `FindNextFileW,`\n```\nFindFirstFileExW, ntQueryDirectoryFile, zwQueryDirectoryFile )\n\n```\nIt hooks them by modifying the import table of the main process (Explorer.exe) and all loaded\nmodules (searches for them in the TEB Thread Environment Block) by changing the address\nof these functions to the address of another functions inside the rootkit.\n\n\n-----\n\nThese functions call to the original functions (windows APIs) and then modify their outputs to\nhide stuxnet files.\n\nThey check the output if it contains .LNK files with a specific size (4171 bytes) or contains a\nfile named ~WTRabcd.TMP (as a+b+c+d = 10)\n\n\n-----\n\nThis rootkit is only used once while infecting a PC but after that stuxnet installs another\nrootkit named \"MRxNet\"� and it's a kernel-mode rootkit.\n\n### 4.6.2. Kernel-Mode Rootkit (MRxNet)\n\n_MRxNet is a simple filesystem filter created to hide the files that was created in the USB_\n_flash memory (.LNK & TMP files) like in the user-mode rootkit. I reversed this driver manually_\n_[into C++ using IDA Pro. You can download it code from My Blog: http://www.amrthabet.co.cc](http://www.amrthabet.co.cc/)_\n\n_Or from the attachment files with this article_\n\n\n-----\n\nBut this rootkit doesn t modify the addresses in the import table, but it adds itself to the driver\nchain of these drivers\n\n_\\\\FileSystem\\\\ntfs_\n_\\\\FileSystem\\\\fastfat_\n_\\\\FileSystem\\\\cdfs_\n\nThese drivers are the main drivers for handling the files and folders in your machine. When\nMRxNet adds itself to the driver chain, it receives the requests (I/O Request Packets ISPs) to\nthese drivers before these drivers receive them.\n\nReceiving these requests allows MRxNet to modify the input to these drivers. And by using\nthis trick MRxNet hides a directory named:\n```\n{58763ECF-8AC3-4a5f-9430-1A310CE4BE0A}\n\n```\nBy deleting its name from the input request (ISP) to these drivers. I don't know what this\nname represents it seems something like a GUID.\n\nBut the main goal of MRxNet is to modify the output of these drivers, so MRxNet adds to the\nrequest an IOCompletionRoutine. This routine is executed by the last driver executed in the\nchain after the result prepared (the reply to the request) and needed to be sent to the user\nagain.\n\nThis function was created by Windows to modify the output of any driver and that's what\nMRxNet does.\n\nMRxNet modifies the output like the user-mode rootkit and deletes the entries that seem\nstuxnet files as what you can see in the figure:\n\n\n-----\n\nMRxNet contains a strange string in its data (seems a debug message before):\n```\nb:\\\\myrtus\\\\src\\\\objfre_w2k_x86\\\\i386\\\\guava.pdb\n\n```\nThis strange string contains a word \"myrtus\"� and this word represents \"MyRTUs\"� or\nrepresents a Hebrew word.\n\nIt could lead to the criminals behind this attack (Israel) or it could be a false positive \"¦ but no\none know.\n\n### 4.7. Loading Mechanism\n\n 4.7.1. ~WTR4141.TMP\n\nThis file (as we said before) is loaded by LNK Vulnerability. This file loads the Main Stuxnet\nDropper by a known way. It calls to LoadLibraryA to load it and LoadLibraryA executes the\nmain Entrypoint for this dropper to load and install stuxnet.\n\n### 4.7.2. MRxCls Loader Driver\n\nMrxCls is a very complex project. It includes many features and abilities to load a program\nsecretly without the attention of any Antivirus application specially the behavioral antiviruses.\n\nThis virus seems a separate project, wasn't created by the creators of Stuxnet worm. It\nseems that it was created by another department in the organization that creates Stuxnet.\n\nThis driver wasn't modified along with the versions of stuxnet and also it contains many\nfeatures that are not used by stuxnet worm.\n\nThis organization is not only an organization for programming but also it has spies and\nthieves in other companies that make it steal some certifications from big companies like\nRealtek Semi-Conductor Co-Op. This driver is signed with Realtek as a product from this\ncompany as you can in this image.\n\n\n-----\n\nThat's what makes us sure that this virus is not a game from some virus writers but it's a\nplanned crime.\n\nHere we will talk about the technical details of the driver, how it works and the internal\nstructure of it.\n\nFirst we will talk about the input of the driver and then we will talk about how this driver deals\nwith it.\n\n### 4.7.2.1. The Input\n\nMrxCls takes the parameters from the registry from a key name:\n```\n\"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\MRxCls\"�\n\n```\nIt reads the \" Data \"� value in this key as the parameter of the driver. This data contains an\nencrypted data. After decrypting it, we found this:\n\n\n-----\n\nThis data contains the name of some system processes and filenames for stuxnet files. This\ndata tells the driver the filename of the stuxnet file and the process that stuxnet needs to\ninject its file in. This data is organized as follows:\nFirst the Header and its size is dynamic.\n\n**Header**\n\nSignature = 0 (4 bytes)\n\nPointer to The body (the end of Header) (4 bytes)\n\nReserved (4 bytes)\n\nNumber of Injections (4 bytes)\n\nAfter that there's an array of elements defined by the Number of Injections in the header.\nEvery element contains the name of the infected process, the dll file to inject into this\nprocess, the flags and the key to decrypt the virus.\n\nAll stuxnet files are encrypted but with a key equal zero\nThe structure of these elements is like that:\n\n\n-----\n\nFirst it begins with the details of the infection and then followed with the Unicode strings of\nthe process name and the stuxnet filename.\n\n**The Elements**\n\nReserved (4 bytes)\n\nThe Exported Function To call in the injected dll (2 bytes)\n\nFlags (2 bytes)\n\nKey (4 bytes)\n\nReserved (4 bytes)\n\nThen the Unicode strings like that:\n\nSize of the process name unicode string (4 bytes)\n\nProcess name (variable size)\n\nThe Size of the stuxnet filename string (4 bytes)\n\nUnicode string of the stuxnet file (variable size)\n\nAnd that's repeated for every element in the array.\n\nThe Flags in The Elements Header contain 2 bits. The first bit describes if the file (that needs\nto be injected) is encrypted or not (and always it's encrypted).\nAnd the second bit describes if the infected process will contain the decrypted stuxnet file (\nTo be loaded by a built-in PE loader) or will only contain the filename of the stuxnet file to be\nloaded by LoadLibraryW in the user-mode (and that's never used)\n\nSo, Stuxnet worm writes an input data to the driver with this structure contains this\ninformation:\n\n**services.exe:** `\\SystemRoot\\inf\\oem7A.PNF (stuxnet main dll) and call to Export 1`\n**S7tgtopx.exe:** `\\SystemRoot\\inf\\oem7A.PNF` and call to Export 2 (SCADA infection)\n**CCProjectMgr.exe:** `SystemRoot\\inf\\oem7A.PNF` and call to Export 2\n**explorer.exe: \\ SystemRoot\\inf\\oem7m.PNF** and call to Export 2\n\nStuxnet also always sets the flags equal \"11\"� or 3 and that means that the stuxnet file is\nencrypted and needs to be decrypted and that the driver must read and decrypt it and then\nallocate memory in the infected process equal the size of the file to copy the file in. after that\nin the user-mode, the file will be loaded by a built-in PE loader that's injected in the process\nmemory beside the injected file.\n\n\n-----\n\nAll the infection process will be described in the next sections but that s a brief.\n\n### 4.7.2.2. Initialization\n\nFirst, stuxnet creates a registry key and add some values to it for registering the MrxCls\ndriver to be loaded on every start.\nThis key is \" SYSTEM\\CurrentControlSet\\Services\\MRxCls \"�. It then adds the\n\" Data \"� value that contains the parameters of the driver and makes it load as a boot\ndriver and that makes it load before many service applications and drivers.\n\nWhen it loads, it begins by decrypting a part from its data with size 0x278 bytes and gets the\nfollowing data:\n```\n..................\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Ser\nvices\\MRxCls..........................................Data......\n................................................................\n.....................................0??\\Device\\MRxClsDvX.......\n................................................................\n.............??Â»\n\n```\nAfter that it gets the parameters form \"Data\"� value, decrypts it and saves it as an element\nin a generic table.\n\nAlso it checks the \" InitSafeBootMode \"� and checks for \" KdDebuggerEnabled \"�. If the\nkd debugger is enabled, it will end. And then, it creates a new device by calling\n\" IoCreateDevice \"� API and creates a new driver named \" \\Device\\MRxClsDvX \"�.\n\nIt then gets some functions like \" RtlGetVersion \"� and \" KeAreAllApcsDisabled \"�\nwith a function named \" MmGetSystemRoutineAddress \"� (not `GetProcAddress ).`\n\nAnd at the end it calls to \" PsSetLoadImageNotifyRoutine \"� to register a function to be\ncalled every time a process or a module is loaded in the memory (including services.exe and\n_kernel32.dll that will be used in the driver)._\n\nNow we will talk about the `NotifyRoutine` and the stages of injecting stuxnet files into a\nsystem process.\n\n### 4.7.2.3. Stage One : Injecting data in kernel-mode\n\nEvery time a process or a module is loaded in the memory, this process is called given three\nparameters: The name of the module, the ProcessId and the ImageInfo.\n\nIt begins by checking the loaded module with \"kernel32.dll\"� (and we will talk about it later)\nand if it's not kernel32, it parses the registry data (that's loaded and decrypted before) and\nloops on the elements of this data searching for the name of the process that needs to inject\nstuxnet file into and compare it with the loaded process's name.\n\n\n-----\n\nWhen it found a process is needed to inject stuxnet file into. It loads the stuxnet file into the\nprocess's memory and decrypts it. After that, it copies a junk of data (contains code) into the\nprocess's memory and then it writes \"MZ\"� and \"PE\"� and some other data into this junk\nof data.\n\nThis junk of data seems that it's two PE files (was created separately before) and was\ndeleted from them some common marks of a PE file (e.g. MZ, PE, 0x14C, 0xE0 and so on).\nThese bytes prove that this is a PE file so the author of MrxCls deleted them and wrote a\ncode to write them again in their places again (And that's surely a way to disguise them and\nhide the meaning of these junk data). Not only that but also he deleted the name of all\nsections.\n\nThen, the driver writes in the process's memory the pointer to this place, pointer to the\nbeginning of the MZ header (there's 0x101C bytes before it, remember that because we'll\ntalk about it again in stage three) and the size of this PE module in specific places in memory\ninside the MZ module.\n\nAfter that it jumps on the process PE module. It begins by parsing its PE and gets the\nentrypoint of the process's module and then, it checks that there's no relocables between the\nentrypoint and the entrypoint + 0xC (0xC is the size of the overwritten code at the entrypoint\nso it checks that to be sure there won't any problem on overwriting the entrypoint).\n\nThen, it searches for a snippet of code in the process \"Ntoskrnl.exe\"� or the process\n\"Ntkrnlpa.exe\"�. And this code snippet is:\n\nFor Windows 2000 or lower:\n\nASM\n```\nmov eax,77\nlea edx,dword ptr [esp+4]\nint 2E\nretn 14\n\n```\nOr in Windows XP or later:\n\nASM\n```\npush 104 \ncall loc_1\n???\nloc_1:\n     mov eax,0\n     lea edx,dword ptr [esp+4]\n     pushfd\n     push 8\n     call ZwAllocateVirtualMemory\n     retn 14\n\n```\n\n-----\n\nSo, - as you can see - these snippets of code calls to ZwAllocateVirtualMemory. So the driver\ncalls to one of them to call to ZwAllocateVirtualMemory given the parameters that change the\nmemory permissions of the process entrypoint to entrypoint+0x0C from READ_ONLY to\nCOPY_ON_WRITE (it seems a way to disguise the call to ZwAllocateVirtualMemory with\nthese parameters to avoid the antiviruses).\n\nAt the end, it creates a buffer with size equal to the size of stuxnet file plus 0x28 bytes and\nthen copy stuxnet file into this buffer (after 0x28 bytes) and writes some important data to the\nuser-mode code (stage 3) in this 0x28 bytes with the following structure:\n\n**Kernel-Mode to User-Mode Parameters**\n\nReserved (8 bytes)\n\nPointer to stuxnet file (buffer +28) (8 bytes)\n\nSize of the stuxnet file (8 bytes)\n\nthe Exported function (8 bytes)\n\n2nd bit in the flags in the data (about using a PELoader or LoadLibraryW) (8 bytes)\n\nThen, it creates a new element in the generic table with the following data (that will be\nexported to the stage 2):\n\n**The Generic Table Element**\n\nProcessId\n\nInjectedMemory at \"MZ\" + 0x2B8\n\nInjectedMemory at \"MZ\" + 0x560 (the Entrypoint of the injected buffer)\n\nAddress of Entrypoint\n\nAt last, it writes the place of this buffer (including stuxnet file) into a specific place in the\ncopied PE module (the junk of data that copied to the process's memory previously).\n\n### 4.7.2.4. Stage Two : Creating kernel32 Import and Overwriting the Entrypoint\n\nAs we said in the previous stage, the notify routine begins by checking the loaded module\nwith \"kernel32.dll\"�. If not equal, it jumps to the stage 1. But if equal kernel32.dll, it jumps to\nthe stage 2.\n\nBecause of it's the stage 2. It begins by checking that the stage 1 was passed and gets the\nresults of this stage. It searches in the generic table for an element begins with the processId\n(the prcoessId that's the kernel32 module was loaded in) to get the generic table element\n\n\n-----\n\nwith the structure that s in table 3-3-2.\n\nThen, it creates an import table for the user-mode and writes them in the place that's in the\n2nd element in the generic table element (InjectedMemory at \"MZ\" + 0x2B8). It gets 10\nfunctions ?VirtualAlloc, VirtualFree, GetProcAddress, GetModuleHandle, LoadLibraryA,\nLoadLibraryW, lstrcmp, lstrcmpi, GetVersionEx, DeviceIoControl). It gets these functions\nusing checksums written inside the driver.\n\nThen it saves the first 0xC bytes (12 bytes) after the import table by some bytes and then it\nmodifies the entrypoint with the following:\n\nASM\n```\nmov   eax, 0\ncall  eax\n\n```\nAnd then it modifies the immediate of \"mov eax,0\"� with 3rd element of the generic table\nbuffer (InjectedMemory at \"MZ\" + 0x560) and that's the entrypoint of the injected code. The\nInjectedMemory at \"MZ\" + 0x2B8 becomes like that:\n\n**InjectedMemory at \"MZ\" + 0x2B8**\n\n00: Imagebase\n\n08: VirtualAlloc\n\n10: VirtualFree\n\n\n-----\n\n18: GetProcAddress\n\n20: GetModuleHandle\n\n28: LoadLibraryA\n\n30: LoadLibraryW\n\n38: lstrcmp\n\n40: lstrcmpi\n\n48: GetVersionEx\n\n50: DeviceIoControl\n\n58: Ptr to the beginning of the memory (before 101C from MZ)\n\n60: Ptr to the InjectedMemory at MZ\n\n68: 8A0 Size\n\n70: Unknown\n\n78: The EntryPoint of the process\n\nAt the end, it exits the notify routine to begin the stage 3 of injecting stuxnet file in a process\nin the user-mode.\n\n### 4.7.2.5. Stage Three : Loading and Executing Stuxnet in The User-Mode\n\nI begin reversing this part by injecting these data (including the import table) into an\napplication (I choose windbg as the infected process with stuxnet) and begin reversing this\npart using Ollydbg.\n\nThis crafted code begins by creating a new MZ header (or writes the missing data into a\nmodified PE module) by writing the missed bytes like \"MZ\"� or \"PE\"� and so on \"¦ in the\ninjected memory at the 0x101C bytes to become the 2nd MZ Header in the injected memory.\n\nAnd then, it gets the address of some functions and creates an array with these functions like\nin the figure:\n\n\n-----\n\nThe 0xF90 is the size of the 2nd MZ Header in the injected code. Then, the crafted code\nloads both of these injected modules (with these PE headers) into new allocated memories\ninside the virtual memory of the infected process using a built-in PE Loader.\n\nThis PE loader has the ability to fix the relocables and loading the headers and the sections\nin the correct place (but it's a simple PE loader at last)\n\nAfter that it calls to the entrypoint of the 1st Module. This module begins by saving SHE and\nthen loads Stuxnet File by using LoadLibraryW or its PEloader by checking the 2nd bit in the\nflags in the data at the beginning of stuxnet buffer (in table 3-3-1).\n\nAfter Loading Stuxnet, it calls the chosen exported function in the stuxnet module (which also\nwritten in the first 28 bytes in the stuxnet buffer which described in Table 3-3-1).\n\nAt the end, it rewrites the modified entrypoint with the original code which already saved in\nmemory (check the Table 3-4-1).\n\n\n-----\n\nAt last, it calls to DeviceIoControl which sends an Io request packet to mrxcls driver to reset\nagain the permissions of the entrypoint to the entrypoint+0xC to its original state (Read-Only)\nand then calls to the entrypoint to make the process to run normally.\n\n## 5. Conclusion\n\nStuxnet takes the attention of media because of its complexity, its political goals and the\ncriminals behind it.\n\nStuxnet is the most sophisticated worm ever seen in public until now. It contain 4 zero-day\nvulnerabilities and one used before, a vulnerability in WinCC OS and not only that but also it\nhas three rootkits and the most interesting feature in it that it infects the PLC\n\nThis worm changes the meaning of malware and creates a new era for malware researchers.\n\nI hope you enjoyed from this long article. I'm waiting for your feedback.\n\n## 6. References:\n\n1.\"W32.Stuxne Dossier\"� by Symantec\n2.\"Stuxnet Under the Microscope\"� by ESET\n3.\"The MRXCLS.SYS Malware Loader\"� at http://www.geoffchappell.com/viewer.htm?\ndoc=notes/security/stuxnet/mrxcls.htm\n\n## License\n\nThis article, along with any associated source code and files, is licensed under The Code\nProject Open License (CPOL)\n\n## Share\n\n About the Author\n\n**[AmrThabet](https://www.codeproject.com/Members/AmrThabet)**\n\nSoftware Developer (Senior)\n\n\n-----\n\nIreland\n\nAmr Thabet (@Amr_Thabet) is a Malware Researcher with 5+ years experience in reversing\nmalware, researching and programming. He is the Author of many open-source tools like\nPokas Emulator and Security Research and Development Framework (SRDF).\n\nUse Ctrl+Left/Right to switch messages, Ctrl+Up/Down to switch threads,\nCtrl+Shift+Left/Right to switch pages.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2011/2011-09-09 - Stuxnet Malware Analysis Paper.pdf"
    ],
    "report_names": [
        "2011-09-09 - Stuxnet Malware Analysis Paper.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535904,
    "ts_updated_at": 1743041162,
    "ts_creation_date": 1653678163,
    "ts_modification_date": 1653678163,
    "files": {
        "pdf": "https://archive.orkl.eu/5161df2900f9f9c33e18d2b6003363b907269872.pdf",
        "text": "https://archive.orkl.eu/5161df2900f9f9c33e18d2b6003363b907269872.txt",
        "img": "https://archive.orkl.eu/5161df2900f9f9c33e18d2b6003363b907269872.jpg"
    }
}