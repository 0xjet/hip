{
    "id": "70186705-c68a-484c-b43b-c8a395a8a841",
    "created_at": "2023-01-12T15:04:42.608752Z",
    "updated_at": "2025-03-27T02:05:30.244832Z",
    "deleted_at": null,
    "sha1_hash": "f5a178ab9db3646c5e98f67f5a1c2204c69ea8d0",
    "title": "2021-05-06 - Darkside Ransomware",
    "authors": "",
    "file_creation_date": "2022-05-27T23:23:52Z",
    "file_modification_date": "2022-05-27T23:23:52Z",
    "file_size": 193144,
    "plain_text": "# Darkside Ransomware\n\n**[chuongdong.com/reverse engineering/2021/05/06/DarksideRansomware/](http://chuongdong.com/reverse%20engineering/2021/05/06/DarksideRansomware/)**\n\nChuong Dong May 6, 2021\n\n[Reverse Engineering · 06 May 2021](http://chuongdong.com/categories/#reverse%20engineering)\n\n## Overview\n\nThis is my report for one of the latest Windows samples of Darkside Ransomware v1.8.6.2!\n\nSince there is not a lot of in-depth analysis on Darkside out there, I decided to just write one myself.\n\n**Darkside uses aPLib algorithm to compress its configuration and a hybrid-cryptography scheme of**\ncustom RSA-1024 and Salsa20 to encrypt files and protect its keys.\n\nDespite using code obfuscation and sophisticated techniques for privilege escalation and encryption, the\nransomware is slower in encryption speed compared to others such as Babuk or Conti due to its recursive\nfile traversal.\n\nalt text\n\n_Figure 1: Darkside Ransomware leak site._\n\n## IOCS\n\nThis particular sample that I used for my analysis is a 32-bit .exe file.\n\nThere are a Linux version that is more enjoyable to analyze but I’m too lazy to cover both…\n\n**MD5: 9d418ecc0f3bf45029263b0944236884**\n\n**SHA256: 151fbd6c299e734f7853497bd083abfa29f8c186a9db31dbe330ace2d35660d5**\n\n**Sample:**\nhttps://bazaar.abuse.ch/sample/151fbd6c299e734f7853497bd083abfa29f8c186a9db31dbe330ace2d35660d5/\n\nalt text\n\n_Figure 2: VirusTotal information._\n\n## Ransom Note\n\nThe ransom note is encrypted and stored inside the aPLib-compressed configuration.\n\nThe GUID checksum is generated and appended to the end of each ransom note file name.\n\nalt text\n\n_Figure 3: Darkside ransom note._\n\n\n-----\n\n## Static Code Analysis\n\n### Generate KEY_BUFFER\n\nUpon execution, Darkside generates a global 256-byte buffer. This buffer is significant since it is used to\nresolve APIs and decrypt encrypted strings/buffers in memory.\n\nLet us call this buffer KEY_BUFFER. This buffer is generated using two hard-coded 16-byte keys in\nmemory.\n\nalt text\n\n_Figure 4: 16-byte keys used to generate KEY_BUFFER_\n\nHere is the function to generate KEY_BUFFER.\n\nIt first has a loop to write the 4 DWORDs from key1 into KEY_BUFFER and subtract 0x10101010 from\neach DWORD each time. Then, it has another loop to add bytes in key2 to bytes in KEY_BUFFER and\nswap them around.\n\nalt text\n\n_Figure 5: KEY_BUFFER generation algorithm._\n\nI didn’t bother to understand this fully because it’s just a simple algorithm to generate a buffer. You can find\n[my IDAPython implementation to automatically generate it here.](https://github.com/cdong1012/IDAPython-Malware-Scripts/blob/master/Darkside/darkside_parser.py)\n\n### Buffer Decryption Algorithm.\n\nAll strings and data buffers are encrypted in memory throughout the malware. Before using them, Darkside\nwill allocate a heap buffer, decrypt the target data, and write it in before using it.\n\nThe decryption consists of a simple loop with byte swappings and a single XOR operation, which uses the\ndata from the generated KEY_BUFFER.\n\nalt text\n\n_Figure 6: Darkside’s data decryption algorithm._\n\nThis function, however, is only designed to decrypt at most 255 bytes because the size of the length\nparameter is just 1 byte.\n\nTo support bigger buffers, Darkside dedicates a wrapper function that calls decrypt_buff() for\n_buffer_length / 255 times with the length parameter of 255._\n\nIn case where the buffer length is not evenly divided by 255, the malware performs a modulus operation of\n_buffer_length % 255 and uses it as the length parameter for decrypt_buff() to decrypt the rest of the_\nbytes.\n\nalt text\n\n_Figure 7: Darkside’s large data decryption algorithm._\n\n\n-----\n\n### Dynamic API Resolve\n\nThe dynamic API resolve function repeats the following operations.\n\nFirst, it uses the decrypt_large_buffer() function to decrypt a library table in memory.\n\nThis table is divided into blobs with different sizes. The size of each blob is the 4-byte value that comes\nbefore it.\n\nalt text\n\n_Figure 8: Encrypted blob layout for all encrypted buffer in memory._\n\nIn this table, each blob’s data is the encrypted version of a string, and this string can either be a DLL name\nor an API name.\n\nThe table is laid out in such a way that a blob with a DLL name comes first, and blobs with API names\nexported from that particular DLL come after.\n\nIf we perform the decryption on the entire table and eliminate the bytes representing the blobs’ size, we will\nget this.\n\nalt text\n\n_Figure 9: Decrypted library table layout_\n\nAfter decrypting a DLL name, it then calls LoadLibraryA to load that library and begin importing the\naddress into an API array in memory. The malware also wipes each decrypted string from memory\nwhenever it finishes using it.\n\nThis operation is repeated until it has gone through all libraries in the table.\n\nalt text\n\n_Figure 10: Dynamically importing APIs from the table._\n\nThe function to import the APIs for each library executes a loop that decrypts an API’s name, calls\n**GetProcAddress, and writes each API’s address into the array every time.**\n\nalt text\n\n_Figure 11: Function to import APIs from a library._\n\nAs we can see, the API array is built in a sequential order from the first to the last API blob, and it is simple\nto write a script to decrypt all APIs names and write to the API array accordingly to automatically resolve all\nAPIs.\n\n[You can view my IDAPython script to automatically import them into IDA here.](https://github.com/cdong1012/IDAPython-Malware-Scripts/blob/master/Darkside/darkside_parser.py)\n\nAfter running the script, the table will look like this, which makes static analysis much simpler.\n\nalt text\n\n_Figure 12: Before and after importing APIs._\n\n\n-----\n\n### Configuration Resolve\n\nThe encrypted configuration is stored in memory and ends with the DWORD 0xDEADBEEF. Because\ncalling decrypt_large_buffer() requires knowing the encryped buffer size, this DWORD is necessary to\niteratively find the configuration size.\n\nalt text\n\n_Figure 13: Configuration decryption._\n\nAfter calling decrypt_large_buffer(), the decrypted configuration has this specific layout.\n```\n- Offset 0x0 - 0x7F: RSA-1024 exponent\n- Offset 0x80 - 0x103: RSA-1024 modulus\n- The rest: aPLib-compressed configuration.\n\n```\nUsing the constants in comparison operations throughout the algorithm, it is quite simple to spot that\n**Darkside decompresses using the aPLib algorithm.**\n\nalt text\n\n_Figure 14: aPLib decompress constants._\n\nSince aPLib libraries are wildly available, I just grabbed a Python implementation on Github to\ndecompress and parse the configuration into a JSON file. You can get my script to generate this JSON file\n[here.](https://github.com/cdong1012/IDAPython-Malware-Scripts/blob/master/Darkside/darkside_config_extractor.py)\n\nBelow is the full configuration of this sample in JSON format.\n\n\n-----\n\n```\n{\n \"VICTIM_ID\": \"[0x30, 0x36, 0x30, 0x31, 0x30, 0x38, 0x65, 0x66, 0x62, 0x35, 0x31, 0x30, 0x63,\n0x39, 0x38, 0x0, 0xdb, 0x85, 0x9b, 0xad, 0x0, 0x38, 0xe0, 0xc4, 0xf0, 0x92, 0x9, 0xa2, 0xa3, 0xc6,\n0x14, 0xa4]\",\n \"ENCRYPTION_MODE\": \"Full\",\n \"AVOID_PROCESS_FLAG\": true,\n \"ENCRYPT_ALL_DRIVES_FLAG\": true,\n \"ENCRYPT_NET_SHARED_RESOURCE_FLAG\": true,\n \"CHECK_RUSSIAN_COMP_FLAG\": true,\n \"DELETE_SHADOW_COPIES_FLAG\": true,\n \"WIPE_RECYCLE_BIN_FLAG\": true,\n \"SELF_DELETE_FLAG\": true,\n \"UAC_ELEVATION_FLAG\": true,\n \"AdjustTokenPrivileges_FLAG\": true,\n \"LOGGING_FLAG\": false,\n \"DIRECTORY_TO_AVOID_FLAG\": true,\n \"FILE_TO_AVOID_FLAG\": true,\n \"FILE_EXTENSION_FLAG\": true,\n \"DIR_TO_REMOVE_FLAG\": true,\n \"SQL_SQL_LITE_FLAG\": true,\n \"PROCESS_TO_KILL_FLAG\": true,\n \"SERVICE_TO_KILL_FLAG\": true,\n \"THREAT_WALLPAPER_FLAG\": true,\n \"RANSOM_NOTE_FLAG\": true,\n \"CHANGE_ICON_FLAG\": true,\n \"BUILD_MUTEX_FLAG\": true,\n \"THREAD_OBJECT_FLAG\": false,\n \"C2_URL_FLAG\": true,\n \"DIRECTORY_TO_AVOID\": \"$recycle.bin, config.msi, $windows.~bt, $windows.~ws, windows, appdata,\napplication data, boot, google, mozilla, program files, program files (x86), programdata, system\nvolume information, tor browser, windows.old, intel, msocache, perflogs, x64dbg, public, all\nusers, default\",\n \"FILE_TO_AVOID\": \"autorun.inf, boot.ini, bootfont.bin, bootsect.bak, desktop.ini, iconcache.db,\nntldr, ntuser.dat, ntuser.dat.log, ntuser.ini, thumbs.db\",\n \"FILE_EXTENSION_TO_AVOID\": \"386, adv, ani, bat, bin, cab, cmd, com, cpl, cur, deskthemepack,\ndiagcab, diagcfg, diagpkg, dll, drv, exe, hlp, icl, icns, ico, ics, idx, ldf, lnk, mod, mpa, msc,\nmsp, msstyles, msu, nls, nomedia, ocx, prf, ps1, rom, rtp, scr, shs, spl, sys, theme, themepack,\nwpx, lock, key, hta, msi, pdb\",\n \"DIR_TO_REMOVE\": \"backup\",\n \"SQL_STRING\": \"sql, sqlite\",\n \"PROCESS_TO_AVOID\": \"vmcompute.exe, vmms.exe, vmwp.exe, svchost.exe, TeamViewer.exe,\nexplorer.exe\",\n \"PROCESS_TO_KILL\": \"sql, oracle, ocssd, dbsnmp, synctime, agntsvc, isqlplussvc, xfssvccon,\nmydesktopservice, ocautoupds, encsvc, firefox, tbirdconfig, mydesktopqos, ocomm, dbeng50,\nsqbcoreservice, excel, infopath, msaccess, mspub, onenote, outlook, powerpnt, steam, thebat,\nthunderbird, visio, winword, wordpad, notepad\",\n \"SERVICE_TO_KILL\": \"vss, sql, svc$, memtas, mepocs, sophos, veeam, backup, GxVss, GxBlr, GxFWD,\nGxCVD, GxCIMgr\",\n \"C2_URL\": \"securebestapp20.com, temisleyes.com\",\n \"THREAT_STRING\": \"All of your files are encrypted! \\r\\n \\r\\n Find %s and Follow Instructions!\",\n \"RANSOM_NOTE\": \"----------- [ Welcome to DarkSide ] -------------> \\r\\n \\r\\n What happend? \\r\\n\n---------------------------------------------- \\r\\n Your computers and servers are encrypted,\nbackups are deleted. We use strong encryption algorithms, so you cannot decrypt your data. \\r\\n\nBut you can restore everything by purchasing a special program from us - universal decryptor. This\nprogram will restore all your network. \\r\\n Follow our instructions below and you will recover all\nyour data. \\r\\n \\r\\n What guarantees? \\r\\n ---------------------------------------------- \\r\\n We\nvalue our reputation. If we do not do our work and liabilities, nobody will pay us. This is not in\nour interests. \\r\\n All our decryption software is perfectly tested and will decrypt your data. We\nwill also provide support in case of problems. \\r\\n We guarantee to decrypt one file for free. Go\nto the site and contact us. \\r\\n \\r\\n How to get access on website? \\r\\n --------------------------------------------- \\r\\n Using a TOR browser: \\r\\n 1) Download and install TOR browser from\nthis site: https://torproject.org/ \\r\\n 2) Open our website:\nhttp://darksidfqzcuhtk2 onion/CZEX8E0GR0AO4ASUCJE1K824OKJA1G24B8B3G0P84LJTTE7W8EC86JBE7NBXLMRT\n\n```\n\n-----\n\n```\n          y p, p g d p y\n\\r\\n\n0kZdK3HQhsAkUtvRl41QkOdpJvzcWnCrBjjgg5U4zfuWeTnZR5Ssjd3QLHpmbjxjo7uWzKbt8qPVuYN38TsDPI3bemd5I40ksem\n \\r\\n \\r\\n !!! DANGER !!! \\r\\n DO NOT MODIFY or try to RECOVER any files yourself. We WILL NOT be\nable to RESTORE them. \\r\\n !!! DANGER !!!\"\n}\n\n### Privilege Escalation\n\n```\nAfter exporting the configuration, the malware then checks if it has admin privileges by calling\n**IsUserAnAdmin. If the user is not an admin, it performs a check on the user’s token information to verify if**\ntheir token has the first subauthority value of SECURITY_BUILTIN_DOMAIN_RID and the second\nsubauthority value of DOMAIN_ALIAS_RID_ADMINS.\n\nalt text\n\n_Figure 15: Function to check token’s privileges._\n\nThis check is necessary for the next step, where Darkside performs UAC elevation to relaunch itself with\nhigher privileges. This is an old elevation trick to perform UAC bypass via ICMLuaUtil Elevated COM\n[Interface. Microsoft has great documentation for this here.](https://docs.microsoft.com/en-us/windows/win32/com/the-com-elevation-moniker)\n\nThe bypass is only performed if the UAC_ELEVATION_FLAG in the configuration is set to 1.\n\nalt text\n\n_Figure 16: CoCreateInstanceAsAdmin implementation._\n\nThis function executes CoGetObject with the object name being Elevation:Administrator!new:\n**{3E5FC7F9-9A51-4367-9063-A120244FBEC7}.**\n\nBy checking with Registry Editor, we can see that this CLSID belongs to cmstplua.dll in system32, and\n**CoGetObject will retrieve an ICMLuaUtil interface with an administrator’s credentials.**\n\nalt text\n\n_Figure 17: Registry Editor result for {3E5FC7F9-9A51-4367-9063-A120244FBEC7}._\n\nUsing this interface, Darkside calls the interface’s ShellExec function to execute the malware again with\nthe updated privileges.\n\nalt text\n\n_Figure 18: Elevated ShellExec call to relaunch the ransomware._\n\n### Adjust Token Privileges\n\nIf the AdjustTokenPrivileges_FLAG is set to 1 in the configuration, Darkside will get the current\nprocess’s token through OpenProcessToken and change the privilege to SE_PRIVILEGE_ENABLED to\nenable the token’s privilege.\n\nalt text\n\n_Figure 19: Adjust Token Privileges function._\n\n\n-----\n\n### Security Context Impersonation\n\nIf possible, Darkside tries to have its process impersonate the security context of a logged-on user on the\nsystem.\n\nFirst, it checks if the logged-on user has an account with the referenced domain name of NT AUTHORITY,\n_AUTORITE NT, or NT-AUTORITÄT. This is done by calling GetTokenInformation to retrieve the user’s_\nSID and then LookupAccountSidW to look up the referenced domain name.\n\nalt text\n\n_Figure 20: Function to check if the user’s token has NT AUTHORITY._\n\nIf the user’s token has NT AUTHORITY, Darkside then retrieves the user’s token by calling\n**WTSGetActiveConsoleSessionId and WTSQueryUserToken.**\n\nalt text\n\n_Figure 21: Function to retrieve user’s token._\n\nDarkside stores this token in memory and calls ImpersonateLoggedOnUser upon file encryption.\n\n### GUID Checksum\n\n**Darkside first has a function to perform CRC32 hashing and XOR operations. This function uses**\n**0xDEADBEEF as the first CRC32 value and performs XOR operations with the data blob in between.**\n\nalt text\n\n_Figure 22: Function to generate CRC32 checksum._\n\nTo generate the victim’s checksum using their GUID, Darkside goes through 4 rounds of this CRC32\nchecksum function on the victim’s machine GUID. It also has a function to convert the final checksum from\nbytes into hex string form.\n\nalt text\n\n_Figure 23: Function to generate GUID checksum._\n\n### File Logging\n\nIf the LOGGING_FLAG in the configuration is set to 1, the ransomware will begin logging every operation\ninto a log file.\n\nFirst, it generates the log file name by formatting the GUID checksum into LOG%s.TXT.\n\nalt text\n\n_Figure 24: Function to generate log file name._\n\nNext, Darkside creates the log file in the same folder as the malware executable using\n**GetModuleFileNameW and CreateFileW.**\n\nalt text\n\n\n-----\n\n_Figure 25: Function to create log file in current directory._\n\n### Ransom Note Readme File\n\nIf the RANSOM_NOTE_FLAG in the configuration is set to 1, the ransomware will generate a README\nfile name. This file with the ransom note inside will be dropped on every directory that it encrypts.\n\nThe README file name is generated by formatting the GUID checksum into README%s.TXT.\n\nalt text\n\n_Figure 26: Function to generate README file name._\n\n### Command Line Parameters\n\n**Darkside can take command line parameters of -path and a directory name. This can be uses to**\nspecifically encrypt the chosen directory using normal encryption.\n\nalt text\n\n_Figure 27: Darkside checking for -path parameter._\n\nIf -path is not provided but instead the parameter is a file name, the malware only encrypts that specific\nfile.\n\nalt text\n\n_Figure 28: Darkside checking for file parameter._\n\nIn the case where the folder/file path in the parameter is a link (.lnk), Darkside calls a function to find the\nfull path to the folder/file from that link.\n\nThis function uses CoCreateInstance with the CLSID of {00021401-0000-0000-C000-000000000046} to\nquery an interface from windows.storage.dll.\n\nIt probably uses IStorageFolderHandleAccess and IStorageFileHandleAccess interfaces to extract the\nfull path from the link, but I’m not too sure about this.\n\nI’m kind of terrible at COM objects, so if anyone understands how this works, please hit me up!\n\nalt text\n\n_Figure 29: Function to query interfaces from windows.storage.dll to process .link files._\n\n### Run-once Mutex\n\nIf the BUILD_MUTEX_FLAG in the configuration is set to 1, the ransomware will build a run-once mutex\nstring. By calling OpenMutex on the mutex, it can check to make sure that there is only one Darkside\ninstance running at any point in time.\n\nThe function to generate this mutex first retrieves the current malware file path and reads the file’s content\ninto a heap buffer using GetModuleFileNameW, CreateFileW, GetFileSize, and ReadFile.\n\n\n-----\n\nThe file buffer checksum is then calculated by going through one round of CRC32_checksum_generator\nfunction.\n\nThe mutex string is decrypted by decrypt_large_buffer and added into the string\n_Global\\XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX. All the “X”s in the string is then replaced with the_\nhex string of the file buffer checksum.\n\nThe Global part means that the mutex is visible in all terminal server sessions.\n\nalt text\n\n_Figure 31: Function to build mutex string._\n\n### Single File/Folder Encryption\n\nBecause the function to encrypt a single file/folder is only used when parameters are given, it is most likely\nfor testing purposes only. Therefore, this function is not too complex.\n\nFirst, it checks if CHECK_RUSSIAN_COMP_FLAG is set to 1 in the configuration. If it is, then it proceeds\nto check if the victim’s computer’s language is Russian by parsing the outputs of GetUserDefaultLangID\nand GetSystemDefaultUILanguage.\n\nIf the computer’s language is Russian, it exits immediately. I don’t think I need to go into details about why\nthis code block is here ;).\n\nalt text\n\n_Figure 31: Exiting immediately if computer’s language is Russian._\n\n**I. Encrypt UNC Server Path**\n\nNext, it checks if the file path is a path to a UNC server by calling PathIsUNCServerW. If it is, the UNC\nencryption function is called. In this function, Darkside enumerates through all network shared using\n**NetShareEnum, builds a valid UNC network path for each, and calls the main_encryption function to**\nencrypt them.\n\nalt text\n\n_Figure 32: UNC server enumeration and encryption function._\n\n**II. Encrypt Normal Path**\n\nIf a path does not lead to a UNC server, Darkside will build the valid path accordingly by checking if the\npath is a network path, a path to a mounted network drive, or just a normal path on the system.\n\nalt text\n\n_Figure 33: Building final file/folder path._\n\nHere is what goes into the log file if LOGGING_FLAG is 1.\n\nalt text\n\n_Figure 34: Encryption stats logging._\n\n\n-----\n\nBefore calling the main_encryption function to encrypt this final path, Darkside will try calling\n**ImpersonateLoggedOnUser(USER_TOKEN) if it has NT AUTHORITY to impersonate the user while**\nperforming file encryption.\n\n### Full Encryption\n\nWhen command line parameters are not provided, Darkside will perform a full encryption on the victim’s\nmachine, which includes many other operations such as contacting the C2 server, deleting shadow copies,\nterminating processes and services, …\n\nThis function also has the same code block to check for Russian language on the victim computer.\n\n**I. Connecting To C2 & Sending Victim Information**\n\nIf CONFIG_C2_URL_FLAG is set to 1 and the C2 URL is provided in the configuration, it will send the\nvictim’s OS information to the C2 server.\n\nThe function to extract user’s OS information uses functions such as GetUserNameW,\n**GetComputerNameW, MachinePreferredUILanguage to find these informations.**\n\nalt text\n\n_Figure 35: Extracting OS information._\n\nAfter having extracted everything, it will write all the datas into a string format into this JSON form.\n```\n\"os\":{\n \"lang\":\"en-US\",\n \"username\":\"cdong49\",\n \"hostname\":\"DESKTOP-739L404\",\n \"domain\":\"WORKGROUP\",\n \"os_type\":\"windows\",\n \"os_version\":\"Windows 10 Education N\",\n \"os_arch\":\"x64\",\n \"disks\":\"C:69/99\",\n \"id\":\"c46289476b8ceea97117\"\n}\n\n```\nNext, it will build a wrapper string to include the malware version and the victim’s UID with this OS\ninformation.\n\nalt text\n\n_Figure 36: Building full string for user’s information._\n\nThe final string will be in this JSON form.\n\n\n-----\n\n```\n{\n \"bot\":{\n  \"ver\":\"1.8.6.2\",\n  \"uid\":\"060108efb510c98\"\n },\n \"os\":{\n  \"lang\":\"en-US\",\n  \"username\":\"cdong49\",\n  \"hostname\":\"DESKTOP-739L404\",\n  \"domain\":\"WORKGROUP\",\n  \"os_type\":\"windows\",\n  \"os_version\":\"Windows 10 Education N\",\n  \"os_arch\":\"x64\",\n  \"disks\":\n  \"C:69/99\",\n  \"id\":\"c46289476b8ceea97117\"\n }\n}\n\n```\nThis string will be hashed by a manual hashing function. Again, I didn’t bother to understand this because\nit’s just a hashing function and does not contribute anything to my understanding of the malware. It’s just\nhere to make sure the information is not sent in plaintext.\n\nalt text\n\n_Figure 37: Network data hashing function._\n\nThe hashed information string and the victim UID are then written into this format string, which is later used\nas the network packet’s content to be sent to C2.\n```\nrandom_num1=hash(information_string)&random_num2=victim_UID\n\n```\nalt text\n\n_Figure 38: Building network packet’s content._\n\nAt this point, Darkside uses InternetOpenW and InternetConnectW to open a handle to an Firefox/80.0\nInternet application and connect to the C2 server at port 443.\n\nalt text\n\n_Figure 39: Connecting to C2._\n\nAfter a connection is established, it sends a POST request to the C2 using HttpOpenRequestW, decrypts\nthe HTTP header, sets internet options using InternetSetOptionW, and finally sends the packet with the\ngenerated content buffer above.\n\nalt text\n\n_Figure 40: Sending victim’s information to C2._\n\nFinally, Darkside calls HttpQueryInfoW to query the status code and check to see if the packet is sent\nsuccessfully.\n\n**II. Wiping Recycle Bin**\n\n\n-----\n\nIf the WIPE_RECYCLE_BIN_FLAG in the configuration is set to 1 and the current process is ran as an\nADMIN, Darkside will try to wipe all recycle bin folders that it can find in the machine’s drives.\n\nFirst, to find a recycle bin folder in a given drive path, the function iteratively calls FindFirstFileExW and\n**FindNextFileW to find a folder that contains ”*recycle*” in its name.**\n\nalt text\n\n_Figure 41: Function to find the recycle bin folder in a drive._\n\nAfter finding the path to the recycle bin, Darkside loops through each directory inside and calls a recursive\nfunction to completely empty it.\n\nalt text\n\n_Figure 42: Function to wipe the recycle bin folder._\n\nThe recursive function is pretty simple. It uses FindFirstFileExW and FindNextFileW to find files and\nfolders inside. If it finds a file, it will call DeleteFileW to delete it. If it finds a folder, it will recursively call\nitself again to delete the folder’s contents and call RemoveDirectoryW to delete it.\n\nalt text\n\n_Figure 43: Recursive function to empty a given folder._\n\n**III. Deleting Shadow Copies**\n\nIf the DELETE_SHADOW_COPIES_FLAG in the configuration is set to 1, Darkside will try to delete all\nshadow copies on the system. There are two different functions to handle this task based on the machine’s\nsystem architecture.\n\nIf the machine is an 64-bit Windows machine, it decrypts a CMD command and execute it using\n**CreateProcessW.**\n\nalt text\n\n_Figure 44: Executing a Powershell script to delete shadow copies._\n\nBelow is the decrypted CMD command.\n```\npowershell -ep bypass -c \"(0..61)|%{$s+=[char][byte]\n('0x'+'4765742D576D694F626A6563742057696E33325F536861646F77636F7079207C20466F72456163682D4F626A6563\n $s\"\n\n```\nThis command loops 61 times, extracts 2 characters at a time, converts it into a byte, and converts that\nbyte into an ASCII character.\n\nDecoding this string will produce this Powershell command, which gets each Win32_Shadowcopy object\non the system and delete it.\n```\nGet-WmiObject Win32_Shadowcopy | ForEach-Object {$_.Delete();}\n\n```\nIf the machine is an 32-bit Windows machine, things are a bit fancier.\n\n\n-----\n\nDarkside will call CoInitializeEx, CoInitializeSecurity, and CoCreateInstance to create a single object of\nthe class IWbemLocator with the specified CLSID {4590F811-1D3A-11D0-891F-00AA004B2E24} to query\nfrom wbemprox.dll.\n\nUsing the object IWbemLocator, it calls the ConnectServer function to connect to the local “root/cimv2”\nnamespace and obtains a pointer to the IWbemServices object.\n\nalt text\n\n_Figure 45: Using COM object to connect to ROOT/CIMV2._\n\nWith this IWbemServices object, Darkside executes the SQL query `SELECT * FROM`\n```\nWin32_ShadowCopy to retrieve an enumerator of all the shadow copies in the local server.\n\n```\nIt then loops through each of the shadow copy objects, gets its ID, and calls the object’s DeleteInstance\nfunction to delete itself.\n\nThis will eventually deletes all the shadow copy storage areas in the computer.\n\nalt text\n\n_Figure 46: Extracting and deleting all shadow copies._\n\n**IV. Killing Target Services**\n\nIf the SERVICE_TO_KILL_FLAG in the configuration is set to 1, Darkside will traverse through all\nservices on the machine and kill any service that is in the configuration’s SERVICE_TO_KILL list.\n\nThis is done by calling OpenSCManagerW to open the service control manager and\n**EnumServicesStatusExW to enumerate all services with SERVICE_WIN32 status.**\n\nalt text\n\n_Figure 47: Opening service control manager._\n\nDarkside iteratively loops through these services and checks if each exists in the SERVICE_TO_KILL list.\nIf it is, then the service is stopped and deleted with the ControlService and DeleteService calls.\n\nalt text\n\n_Figure 48: Looping and killing services._\n\n**IV. Killing Target Processes**\n\nIf the PROCESS_TO_KILL_FLAG in the configuration is set to 1, Darkside will traverse through all\nprocesses on the machine and terminate any process that is in the configuration’s PROCESS_TO_KILL\nlist.\n\nThis is done by calling NtQuerySystemInformation to query an array of\n**SYSTEM_PROCESS_INFORMATION structs with each containing a process name.**\n\nDarkside iteratively loops through these processes and checks if each exist in the PROCESS_TO_KILL. If\nit is, then the process is terminated using TerminateProcess.\n\n\n-----\n\nalt text\n\n_Figure 49: Looping and terminating services._\n\n**V. Encrypting All Local Drives**\n\nIf the ENCRYPT_ALL_DRIVES_FLAG in the configuration is set to 1, Darkside will loop through all drives\nwith the drive type of DRIVE_FIXED, DRIVE_REMOVABLE, or DRIVE_REMOTE on the system. It then\nbuilds the appropriate folder path for each drive and call main_encryption.\n\nalt text\n\n_Figure 50: Encrypting all fixed, removable, and remote drives on the system is initiated._\n\n**VI. Encrypting Shared Folders**\n\nIf the ENCRYPT_NET_SHARED_RESOURCE_FLAG in the configuration is set to 1, Darkside will\nattempt to get all paths to shared folders on the network and encrypt them using main_encryption.\n\nFirst, it calls a function to extract all network host addresses with two sub-functions.\n\nThe first sub-function calls GetAdaptersInfo and inet_addr to extract the addresses of other hosts on the\nnetwork. It then calls the second sub-function and provide these addresses as the parameter.\n\nalt text\n\n_Figure 51: Sub-function to find host address and call second sub-function._\n\nThe second sub-function launches threads using CreateThread to call SendARP and gethostbyaddr to\nfind other hosts’ name on the network through their addresses.\n\nalt text\n\n_Figure 52: Second sub-function to find host name._\n\nAfter finding all host names and putting them into a global array, Darkside calls NetShareEnum to\nenumerate through all network shared folders, builds the appropriate network paths, and calls\n**main_encryption to encrypt them.**\n\nalt text\n\n_Figure 53: Shared folders enumeration and encryption._\n\n**VII. Sending C2 Server Encryption Stats**\n\nAfter the encryption is finished and if the CONFIG_C2_URL_FLAG is set to 1 in the configuration,\n**Darkside will send the C2 server the final encryption stats.**\n\nFirst, it decrypts the format string for this packet and starts writing the victim ID, UID, encrypted file count,\nencryption size, skipped file count, and elapsed time into this format string.\n\nIt then uses this formatted string as the buffer to call the function documented here.\n\nalt text\n\n\n-----\n\n_Figure 54: Function to send encryption stats to C2 server._\n\n### Main Encryption\n\nWe finally come to the juiciest part of the ransomware, the main encryption function! This function is fairly\ncomplex, so I’ll divide my analysis into parts again.\n\n**I. Initial Operations**\n\nBefore the encryption takes place, the malware checks if the system has at least 0x6400000 bytes or 100\nMBs of free space. This space is necessary for dropping a ransom note in every directory and because the\nencryption also increases each file by a set ammount.\n\nalt text\n\n_Figure 55: Checking if the system has enough space prior to encryption._\n\nIf the CONFIG_C2_URL_FLAG in the configuration is set to 1, Darkside also starts recording the time that\nit begins encryption by calling GetTickCount.\n\nalt text\n\n_Figure 56: Starting time count._\n\n**II. Creating Worker Threads**\n\n**Darkside uses multithreading with I/O completion port to communicate between the main thread and the**\nworker threads and speed up encryption. This can potentially be really good, but there is unfortunately one\ndesign flaw that slows the entire process down.\n\nFirst, Darkside creates 2 I/O completion ports by calling CreateIoCompletionPort, which are used by the\nmain thread to send file data to be encrypted to worker threads.\n\nNext, it spawns a set number of threads based on the processor count of the system. It will spawn 2\nthreads for each processor count, but this maxes out at 64 threads even if there are more than 32\nprocessors.\n\nalt text\n\n_Figure 57: I/O ports and worker threads creation._\n\nIt’s best to have one thread per processor, but because the multithreading design of Darkside does not\nmaximize the system’s processing power, it doesn’t matter that much.\n\nEach of these threads is added to a global thread array to make cleaning up more organized by calling\n**WaitForMultipleObjects with the array as its parameter.**\n\n**III. Recursive Directory Traversal**\n\nThe only mistake in this ransomware is that its main thread uses a depth-first search algorithm of recursive\ntraversal, which slows down the encryption speed significantly despite the good multithreading setup.\n\n\n-----\n\nFirst, in the recursive function, the main thread calls SetEntriesInAclW and SetNamedSecurityInfoW to\naccess/audit control and security information of the directory that is being processed. Below is the hardcoded EXPLICIT_ACCESS_W struct with the new security and access information.\n\nalt text\n\n_Figure 59: the EXPLICIT_ACCESS_W struct to set access/audit control information for directories._\n\nNext, if the RANSOM_NOTE_FLAG in the configuration is set to 1, Darkside will drop a ransom note in\nthe processed directory using this function.\n\nalt text\n\n_Figure 60: Function to drop ransom note in encrypted directories._\n\nThe file/directory checks come after this. First, to begin calling FindFirstFileExW on the current directory,\nit must add the characters ”\\\\*” to the end of the directory name. As it loops through the folder to find subdirectories and files using FindNextFileW, it first checks to avoid the two directory names ”.” and *..”,\nwhich link to the current directory and parent directory. These two can cause the program to go into an\ninfinite recursion if the malware does not avoid them.\n\nIt also checks the file attribute to avoid the sub-directories/files that have the attribute\n**FILE_ATTRIBUTE_ENCRYPTED.**\n\nAfter these checks, if the current path points to a directory and the DIRECTORY_TO_AVOID_FLAG is set\nto 1, then another check is performed to make sure that the sub-folder’s name is not in the\n**DIRECTORY_TO_AVOID list.**\n\nOnce all the checks are completed, its sub-directory path is passed as the parameter to the recursive\nfunction.\n\nThe recursive function is called upon encountering a folder to traverse through all of its sub-folders.\n\nalt text\n\n_Figure 61: Checking for directories and call recursive function._\n\nIf the current path points to a file, Darkside checks the following:\n\nIf the file name is not a README file.\nIf its extension is not .TXT.\nIf its content is not the the ransom note (through compare CRC32 file hashes).\nIf FILE_TO_AVOID_FLAG is 1 and the file name is not in CONFIG_FILE_TO_AVOID.\nIf FILE_EXTENSION_TO_AVOID_FLAG is 1 and the file extension is not in\n**FILE_EXTENSION_TO_AVOID.**\n\nIf all of these are true, Darkside proceeds with processing the file.\n\nIf SQL_SQL_LITE_FLAG is 1 and the filename is in SQL_STRING, it sets the ENCRYPTION_MODE to\nFull Encryption.\n\nalt text\n\n\n-----\n\n_Figure 62: File checks._\n\nAfter the file checks, Darkside’s main thread starts processing and sends the file data to the worker\nthreads.\n\n**IV. Check If File Is Encrypted**\n\nFirst, the file path is properly fixed, and a sub-function is called to check if the file has been encrypted or\nnot. This check is done by reading the last 0x90 bytes into a heap buffer and generate a checksum for the\nfirst 0x80 bytes using CRC32_checksum_generator. This checksum is compared against the last 0x10\nbytes of the buffer, and if they match, it means the file is encrypted.\n\nThis also gives us a hint that after the encryption, a blob with the encrypted Salsa matrix as the first 0x80\nbytes and the key’s checksum as the last 0x10 bytes is appended at the end of each file.\n\nalt text\n\n_Figure 63: Function to check if a file is encrypted or not._\n\n**V. Terminate Process That Uses File**\n\nIf PROCESS_TO_AVOID_FLAG is set to 1 in the configuration, Darkside calls a function to find and close\nanother process that currently uses the file.\n\nThis function has an while loop to continuously check all processes by calling OpenProcess to get a\nprocess handle, spawn a thread to call NtQueryInformationFile to get the file owned by this process, and\ncompare that filename with the to-be-encrypted filename.\n\nalt text\n\n_Figure 64: Finding a process that is using the to-be-encrypted file._\n\nIf that process is accessing the to-be-encrypted filename, Darkside will iteratively check to make sure that\nthe process is not in the PROCESS_TO_AVOID list and terminate it once the check is done.\n\nalt text\n\n_Figure 65: Terminating the process that is accessing the to-be-encrypted file._\n\n**VI. Generate Encrypted File Name**\n\nThe filename is copied into a new buffer, and the GUID checksum is appended to the end of the filename.\nThis buffer is later used as the encrypted filename, so Darkside again tries to terminate any process that\nuses this file.\n\nalt text\n\n_Figure 66: Generating the encrypted file name._\n\n**VII. Send File Data To Worker Threads**\n\n**Darkside makes 2 calls to CreateIoCompletionPort to create I/O completion ports associated with the**\nencrypted file handle.\n\nalt text\n\n\n-----\n\n_Figure 67: Creating I/0 completion ports associated with the file handle._\n\nIt then creates a buffer to add necessary data to send to the worker threads using these I/O completion\nports.\n\nImportant data includes file-related information such as ENCRYPTION_MODE, file handle, and file size.\n\nThe buffer also includes the Salsa20 matrix, its RSA-1024 encrypted version, and the checksum of the\nencrypted key.\n\nOnce this I/O buffer is ready, it is sent to the worker threads using calls to\n**PostQueuedCompletionStatus.**\n\nalt text\n\n_Figure 68: Generating I/0 buffer and send it to worker threads._\n\n**VIII. Salsa20 & Matrix Generation**\n\n**Darkside makes multiple calls to RtlRandomEx to generate a 64-byte buffer.**\n\nalt text\n\n_Figure 69: Randomly generating Salsa20 matrix._\n\nThe reason why this buffer is not a Salsa20 key is because it is way too long (typically Salsa20 key is at\nmost 32-byte long) and because Darkside actually modifies its Salsa20 implementation to not use any\nkey.\n\nTypically, a pair of key-nonce is required to generate this Salsa20 initial state matrix.\n\nalt text\n\n_Figure 70: Randomly generating Salsa20 matrix._\n\nHowever, Darkside skips this step completely and uses the randomly generated buffer as its Salsa20\nmatrix.\n\nThis does not impact the cryptography result of Salsa20 since it’s ultimately a XOR-cipher. To decrypt the\nfile, they just need to have access to this random buffer and use it as the Salsa20 matrix.\n\n**IX. RSA-1024 Encryption**\n\n**Darkside’s custom RSA-1024 implementation is used to encrypt the Salsa20 matrix before appending it to**\nthe end of the encrypted file.\n\nThe RSA-1024 public key is embedded in Darkside encrypted configurations, and it’s divided into two\nblobs.\n\nThe first is the RSA-1024 exponent in little endian, which I’m not sure why. Since the author hand-coded\nthis RSA-1024 implementation, I guess it makes things easier for them?\n\nThe second is the RSA-1024 modulus.\n\nalt text\n\n\n-----\n\n_Figure 71: Randomly generating Salsa20 matrix._\n\nBelow is a part of the RSA-1024 encryption function.\n\nalt text\n\n_Figure 72: RSA-1024 encryption to produce cipher tex by calculating (data^exponent)%modulus._\n\nIt is quick to recognize that this is RSA-1024 encryption with the mathematic functions. Note that the RSA1024 exponent is being read from front to back with the AND operation, which tells us that it is in little\nendian.\n\nThe mathematical operations modulus of big numbers are also confusing because they perform raw\nmodulus calculation using addition and subtraction.\n\nalt text\n\n_Figure 73: Function to calculate (A*B)%N._\n\nFor multiplication, it rotates B to the left by 1 every time and add A to the result when there is no carry after\nthe rotation.\n\nFor modulus, it keeps subtracting N from the result until it gets a carry (subtraction results in a negative\nnumber), which it then adds N back into the result.\n\nThe functions to add/subtract big numbers also tell us that the result of RSA-1024 encryption is also in little\nendian since operations are performed from the lowest index to the highest one on each number.\n\nalt text\n\n_Figure 74: Result buffer is calculated in little endian format._\n\n**X. I/O Worker Threads**\n\nThe worker threads share the same functionality, each of which loops infinitely until the main thread signals\nto close them using CloseHandle.\n\nThe threads constantly call GetQueuedCompletionStatus on their own I/O completion port until they\nreceive a blob containing information about a file from the main thread.\n\nalt text\n\n_Figure 75: Worker thread calling GetQueuedCompletionStatus to receive data blob._\n\nHere is some important offset in the data blob.\n\n0x5: current file offset low\n0x6: current file offset high\n0x7: number of bytes to jump to next block depending on ENCRYPTION_MODE (0x80000 for FULL,\n-1 for FAST, and dynamically changed based on file size for AUTO)\n0x9: number of times to begin encrypting 0x80000 bytes\n0xB: File handle\n0xC: Encryption state\n0x2d: File size\n\n\n-----\n\n0xD: Random Salsa20 Matrix\n0x1D: RSA_1024(Salsa20_matrix)\n0x3d: CRC32_checksum_generator(RSA_1024(Salsa20_matrix))\n0x41: File buffer\n\nUpon receiving this, they check the byte at offet 0xC of the blob to determine between 4 encrypting states.\n\nThe pre-encryption state occurs when blob[0xc] is 0, and the thread just calls ReadFile to read 0x80000\nbytes from the current file offset into the file buffer. It then sets blob[0xc] to 1 to transition into the\nencryption state. If it reaches the EOF and the last error number is ERROR_HANDLE_EOF, the thread\nskips to post-encryption state.\n\nalt text\n\n_Figure 76: Pre-encryption code block._\n\nThe encryption state occurs when blob[0xc] is 1, and the thread will encrypt the file buffer normally using\nSalsa20. Darkside encrypts one 0x80000-byte block at a time and jumps to the next block right after. If\n**blob[0x7] is not -1, it will jump to the next blob by appending blob[0x7] to the current file offset. This is to**\nskip the encrypting portions of the file when it is too large. If blob[0x7] is -1, the encryption state is changed\nto the post-encryption state. The encrypted file buffer is then written back into the file using WriteFile and\nthe thread goes back to the pre-encryption state with the updated file offset.\n\nalt text\n\n_Figure 77: Encryption code block._\n\nThe post-encryption state occurs when blob[0xc] is 2. In this state, the encrypted Salsa20 matrix and its\nchecksum are written into the end of the file using WriteFile. After this operation, the thread enters the\ncleaning up state.\n\nalt text\n\n_Figure 78: Post-encryption code block._\n\nThe cleaning up state occurs when blob[0xc] is 4. The thread just closes the file handle and go back to\ncalling GetQueuedCompletionStatus to receive a new file blob.\n\nalt text\n\n_Figure 79: Cleaning up code block._\n\n### Self Deletion\n\nAt the end of the program, if SELF_DELETE_FLAG is set to 1 in the configuration, Darkside will execute\na command to delete itself.\n\nFirst, it gets the short path of the current malware executable by calling GetModuleFileNameW and\n**GetShortPathNameW.**\n\nIt decrypts the environment variable name “ComSpec” and uses it to get the path to CMD.EXE.\n\nFinally, it calls ShellExecuteW to execute this command:\n\n\n-----\n\n```\n           Q _ _p\n\n```\nThis CMD.EXE command executes the DEL command. The /F flag is enabling auto-completion of path\nnames entered, which is necessary to extend the short path into a full path. The /Q just turns echo off for\nstealth!\n\nalt text\n\n_Figure 80: Cleaning up code block._\n\n### Darkside Encryption Speed Discussion\n\n**Darkside uses a unique combination of multithreading and recursive file traversal to find and encrypt files.**\n\nHowever, its speed is not that impressive due to the use of recursion.\n\nalt text\n\n_Figure 81: CPU comparison between Babuk and Darkside._\n\nWe can clearly see that Darkside encryption speed is clearly lacking since it does not abuse 100% of the\nvictim’s CPU.\n\nThis is because Darkside suffers from thread starvation. Each worker thread can execute the encryption\ncode block relatively fast, but some of them are starved by the main thread and never gets a chance to do\nwork.\n\nBy design, the main thread’s job is to recursively traverse through folders in a depth-first search manner,\nso the worker threads can only encrypt what the main thread sends them.\n\nStarvation arises when the main thread can’t traverse and send files fast enough while the receiving\nthreads already finish their work. Therefore, unless the main thread has a constant throughput of 32 files\nbeing sent to I/O completion ports at any given point in time, some thread will definitely be starved, and the\nCPU will not be fully utitlized.\n\nBeside the fact that this throughput is almost impossible to obtain by a single thread, the total encryption\ntime is still skewed toward the time it takes for the main thread to finish traversing the system.\n\nThis design ultimately defeats the purpose of using multithreading and I/O completion port.\n\n## YARA rule\n\n\n-----\n\n```\n       d _ _ _ {\n meta:\n  description = \"YARA rule for Darkside v1.8.6.2\"\n  reference = \"http://chuongdong.com/reverse%20engineering/2021/05/06/DarksideRansomware/\"\n  author = \"@cPeterr\"\n  tlp = \"white\"\n strings:\n  $hash_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n  $gen_key_buff = {89 54 0E 0C 89 44 0E 08 89 5C 0E 04 89 3C 0E 81 EA 10 10 10 10 2D 10 10 10 10\n81 EB 10 10 10 10 81 EF 10 10 10 10 83 E9 10 79 D5}\n  $dyn_api_resolve = {FF 76 FC 56 E8 91 FE FF FF 56 E8 ?? 69 00 00 8B D8 FF 76 FC 56 E8 85 FB FF\nFF 8B 46 FC 8D 34 06 B9 23 00 00 00 E8 5E 02 00 00 AD}\n  $get_config_len = {81 3C 18 DE AD BE EF 75 02 EB 03 40 EB F2}\n  $RSA_1024_add_big_num = {8B 06 8B 5E 04 8B 4E 08 8B 56 0C 11 07 11 5F 04 11 4F 08 11 57 0C}\n  $CRC32_checksum = {FF 75 0C FF 75 08 68 EF BE AD DE FF 15 ?? ?? ?? 00 FF 75 0C FF 75 08 50 FF\n15 ?? ?? ?? 00 31 07 FF 75 0C FF 75 08 50 FF 15 ?? ?? ?? 00 }\n condition:\n  all of them\n}\n\n## Samples\n\n```\nI got my sample from [MalwareBazaar!](https://bazaar.abuse.ch/sample/151fbd6c299e734f7853497bd083abfa29f8c186a9db31dbe330ace2d35660d5/)\n\n[Huge shoutout to @JAMESWT_MHT for uploading the sample!](https://twitter.com/JAMESWT_MHT)\n\n## Special Thanks\n\nA special thanks to [Michael Gillespie for assisting me during the analysis and sharing his resources!](https://twitter.com/demonslay335)\n\n## References\n\nhttps://zawadidone.nl/2020/10/05/darkside-ransomware-analysis.html\n\nhttps://ghoulsec.medium.com/mal-series-13-darkside-ransomware-c13d893c36a6\n\nhttps://pastebin.com/mnvEUNaP\n\nhttps://raw.githubusercontent.com/k-vitali/Malware-Misc-RE/master/2020-12-01-darkside-ransom-1.3-vkcfg.raw\n\nhttps://github.com/snemes/aplib\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-06 - Darkside Ransomware.pdf"
    ],
    "report_names": [
        "2021-05-06 - Darkside Ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "e5ccc758-f2a5-417b-ba5c-70edf39bc048",
            "created_at": "2022-10-25T16:07:24.481513Z",
            "updated_at": "2025-03-27T02:02:10.248398Z",
            "deleted_at": null,
            "main_name": "Desorden",
            "aliases": [],
            "source_name": "ETDA:Desorden",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535882,
    "ts_updated_at": 1743041130,
    "ts_creation_date": 1653693832,
    "ts_modification_date": 1653693832,
    "files": {
        "pdf": "https://archive.orkl.eu/f5a178ab9db3646c5e98f67f5a1c2204c69ea8d0.pdf",
        "text": "https://archive.orkl.eu/f5a178ab9db3646c5e98f67f5a1c2204c69ea8d0.txt",
        "img": "https://archive.orkl.eu/f5a178ab9db3646c5e98f67f5a1c2204c69ea8d0.jpg"
    }
}