{
    "id": "d6f2208a-47db-4ed9-afa1-08ba42c1e945",
    "created_at": "2023-01-12T14:58:49.35161Z",
    "updated_at": "2025-03-27T02:16:26.385455Z",
    "deleted_at": null,
    "sha1_hash": "f32661843885247c3bc97799dd0a5739ade819bb",
    "title": "2017-06-12 - OSX-MacRansom",
    "authors": "",
    "file_creation_date": "2022-05-29T01:22:17Z",
    "file_modification_date": "2022-05-29T01:22:17Z",
    "file_size": 2463587,
    "plain_text": "# Objective-See\n\n**objective-see.com/blog/blog_0x1E.html**\n\nOSX/MacRansom\n\n› analyzing the latest ransomware to target macs\n\n6/12/2017\n\n[love these blog posts? support my tools & writing on patreon! Mahalo :)](https://www.patreon.com/objective_see)\n\nWant to play along? I've shared both the malware's binary executable ('macRansom'), which\n[can be downloaded here (password: infect3d).](https://objective-see.com/downloads/malware/macRansom.zip)\n\nPlease don't infect yourself!\n\nBackground\n\nHappy Monday! Today we've got some new macOS ransomware to blog about :)\n\nDiscovered by Fortinet researchers, the malware was originally discussed a posting titled\n[\"MacRansom: Offered as Ransomware as a Service\" (by Rommel Joven (@rommeljoven17),](https://blog.fortinet.com/2017/06/09/macransom-offered-as-ransomware-as-a-service)\n[and Wayne Chin Yick Low (@x9090). Go read their great report first...then come back here!](https://twitter.com/x9090)\n\n[Now, as I'm supposed to be working on the white paper for my VirusBulletin 2017 talk let's](https://www.virusbulletin.com/conference/vb2017/abstracts/offensive-malware-analysis-dissecting-osxfruitfly-custom-cc-server/)\ncut to the chase and jump right in, as time is of the essence.\n\n\n-----\n\nAnalysis\nOSX/MacRansom is rather lame piece of ransomware. It's not particularly advanced from a\ntechnical point of view. However, what makes it interesting is that it targets macOS and that\nit's offered 'as a service.' Honestly I'm not 100% sure what the latter means - but Fortinet\nmentions a TOR-based web portal and contacting the author (via email) in order to\ncustomize the malware. I guess that's the service the malware author provides?\n\nAnyways, on to the technical details! When the malware runs (as noted in the Fortinet\nwriteup) the malware performs various anti-debugging and anti-VM checks. All are basic and\ntrivial to pass:\n\n\n-----\n\nThe anti-debugging check occurs at address 0000000100001075. This is a done via\ncall to ptrace with the 'PT_DENY_ATTACH' flag.\n\n[This anti-debugging logic is well-known (we discussed it our last blog), and it's even](https://objective-see.com/blog/blog_0x1F.html)\ndocumented in Apple's man page for ptrace:\n\nman ptrace\n\nPTRACE(2)\nNAME\nptrace -- process tracing and debugging\n\n...\n\nPT_DENY_ATTACH\nThis request is the other operation used by the traced process; it allows a process that\nis not currently being traced to deny future traces by its parent. All other arguments\nare ignored. If the process is currently being traced, it will exit with the exit status\nof ENOTSUP; otherwise, it sets a flag that denies future traces. An attempt by the\nparent\nto trace a process which has set this flag will result in a segmentation violation in\nthe parent.\n\nIn short, PT_DENY_ATTACH (0x1F), once executed prevents a user-mode debugger\nfrom attaching to the process. However, since lldb is already attached to the process\n(thanks to the --waitfor argument),we can neatly sidestep this. How? Set a breakpoint\non pthread then simply execute a 'thread return' command.\n\nThis tells the debugger to stop executing the code within the function and execute a\nreturn command to 'exit' to the caller. Neat!\n\n- thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\nframe #0: 0x00007fffad499d80 libsystem_kernel.dylib`__ptrace\n\n(lldb) thread return\n\nWith the anti-debugging logic out of the way, we can debug to our heart's content!\n\n\n-----\n\nThe first anti-VM check occurs at 0x00000001000010BB.\n\nAfter decoding a string (string decoding routine at: 0x0000000100001F30), the code\ninvokes system to execute it, and exits if it returns a non-zero value. Specifically it\nexecutes 'sysctl hw.model|grep Mac > /dev/null':\n\n(lldb) x/s $rdi\n0x100200060: \"sysctl hw.model|grep Mac > /dev/null\"\n\n(lldb) n\nProcess 7148 stopped\n\n- thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over\n\nframe #0: 0x00000001000010bb\nmacRansom`___lldb_unnamed_symbol1$$macRansom\n-> 0x1000010bb : callq 0x1000028fe ; symbol stub for: system\n0x1000010c0 : testl %eax, %eax\n0x1000010c2 : jne 0x100001b05 ;\n0x1000010c8 : movaps 0x19f1(%rip), %xmm0\n\nIn a virtual machine (VM) will return a non-zero value, as the value for hw.model will be\nsomething like 'VMware7,1': On native hardware:\n$ sysctl hw.model\nhw.model: MacBookAir7,2\n\nOn virtualized hardware (i.e. in a VM):\n$ sysctl hw.model\nhw.model: VMware7,1\n\nTo bypass this (in a debugger), step over the call to system, then just set RAX to zero:\n\n(lldb) reg write $rax 0\n\n(lldb) reg read\nGeneral Purpose Registers:\nrax = 0x0000000000000000\nrbx = 0xfffffffffffffffe\nrcx = 0x0000010000000100\n\nThis will trick the malware so it continues to execute, as opposed to exiting.\n\n\n-----\n\nThe next anti-VM check occurs at 0x0000000100001126. Again, the malware decodes\na string, executes it via system and exits if the return value is no-zero. This check\nexecutes: 'echo $((`sysctl -n hw.logicalcpu`/`sysctl -n hw.physicalcpu`))|grep 2 >\n/dev/null' to check the number of CPUs. On a VM, it appears this value is not two, so\nthe malware will just exit to 'avoid' analysis. On native hardware:\n$ sysctl -n hw.logicalcpu\n4\n$ sysctl -n hw.physicalcpu\n2\n\nOn virtualized hardware (i.e. in a VM):\n$ sysctl -n hw.logicalcpu\n2\n$ sysctl -n hw.physicalcpu\n2\n\nAgain, if the system that the malware is executing on does not have two CPUs (which a\ndefault VM likely will not) the malware will exit. To bypass (in a debugger), again step\nover the call to system, then just set RAX to zero.\n\nOk that takes care of the anti-analysis checks. Though we bypassed them dynamically in a\ndebugger, they can also trivially permanently patched out. For example, one can simple\npatch out the JNZ instruction (that checks the return value of anti-VM checks with NOPs).\n\nAssumining all the anti-analysis checks pass, or have been thwarted, the malware then\npersists itself as a launch agent. It does this by:\n\n1. Copying itself to ~/Library/.FS_Store\n\n\n-----\n\n2. Decoding an embedded plist and writing it out to\n\n~/Library/LaunchAgents/com.apple.finder.plist:\n\ncat ~/Library/LaunchAgents/com.apple.finder.plist\n\n<plist version=\"1.0\">\n<dict>\n<key>Label</key>\n<string>com.apple.finder</string>\n<key>StartInterval</key>\n<integer>120</integer>\n<key>RunAtLoad</key>\n<true/>\n<key>ProgramArguments</key>\n<array>\n<string>bash</string>\n<string>-c</string>\n<string>! pgrep -x .FS_Store && ~/Library/.FS_Store</string>\n</array>\n</dict>\n</plist>\n\nAs the 'RunAtLoad'' key is set to 'true' the malware will be automatically started whenever the\nuser logs in. Specifically the OS will execute the value of the 'ProgramArguments' key: bash c ! pgrep -x .FS_Store && ~/Library/.FS_Store. This command will first check to make sure\nthe malware isn't already running, then will start the malware (~/Library/.FS_Store).\n\n[Lucky for Objective-See users, BlockBlock will alert you about this persistent attempt:](https://objective-see.com/products/blockblock.html)\n\nAs the malware first attempts to persist before encrypting any files, clicking 'Block' on the\nBlockBlock alert will stop the malware before it's done any damage :)\n\n\n-----\n\nFor the sake of analysis, if we allow the malware to persist itself, it will launch the copy of\nitself that it has just persisted (~/Library/.FS_Store) via:\nlaunchctl load ~/Library/LaunchAgents/com.apple.finder.plist:\n\nProcess 7148 stopped\n\n- thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over\n\nframe #0: 0x0000000100001ec6 macRansom`___lldb_unnamed_symbol1$$macRansom +\n3798\n-> 0x100001ec6 : callq 0x1000028fe ; symbol stub for: system\n0x100001ecb : movb $0x25, -0x4733(%rbp)\n0x100001ed2 : movb $0x73, -0x4732(%rbp)\n0x100001ed9 : movb $0x0, -0x4731(%rbp)\n\n(lldb) x/s $rdi\n0x7fff5fbfb960: \"launchctl load /Users/user/Library/LaunchAgents/com.apple.finder.plist\"\n\nThe orignal instance of the malware then exits, as the persistent copy is now off an running.\n\nTo continue analysis by debugging the persistent copy of the malware, execute the following\nin a secondary debugger window, before the original instance of the malware has launched\nthe persistent copy (~/Library/.FS_Store):\n\n$ sudo lldb (lldb) process attach --name .FS_Store --waitfor\n\nThis will cause the debugger to automatically attach to the persistent copy of the malware\nonce its launched:\n\n$ sudo lldb (lldb) process attach --name .FS_Store --waitfor\n\nProcess 7280 stopped\n\n- thread #1, stop reason = signal SIGSTOP\n\nframe #0: 0x000000011140e000 dyld`_dyld_start\n-> 0x11140e000 : popq %rdi\n0x11140e001 : pushq $0x0\n0x11140e003 : movq %rsp, %rbp\n0x11140e006 : andq $-0x10, %rsp\n\nExecutable module set to \"/Users/user/Library/.FS_Store\".\nArchitecture set to: x86_64h-apple-macosx.\n\nAs the persistent copy of the malware is, well, a copy, it executes the same anti-debugging\nand anti-VM logic. Then since it running in persistent state, it checks to see if it's hit a 'trigger'\n\n\n-----\n\ndate. That is, it checks if the current time is past a hard-coded value. According to the\nFortinet report, this is set by the malware author (part of the 'ransomware as a service'). If\nthe current time is before this date, the malware will not encrypt (ransom) any files, and\ninstead will exit:\n\nHowever, if the trigger date has been hit, ransoming commences! Specifically at address\n0x000000010b4eb5f5, the malware executes the following, via system to begin encrypting\nthe user's files:\n\n(lldb)\nProcess 7280 stopped\n\n- thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over\n\nframe #0: 0x000000010b4eb5f5 .FS_Store`___lldb_unnamed_symbol1$$.FS_Store + 1541\n-> 0x10b4eb5f5 : callq 0x10b4ec8fe ; symbol stub for: system\n0x10b4eb5fa : movaps 0x151f(%rip), %xmm0\n0x10b4eb601 : movaps %xmm0, -0x850(%rbp)\n0x10b4eb608 : movb $0x0, -0x840(%rbp)\n\n(lldb) x/s $rdi\n0x7fff547123e0: \"find /Volumes ~ ! -path \"/Users/user/Library/.FS_Store\" -type f -size +8c user `whoami` -perm -u=r -exec \"/Users/user/Library/.FS_Store\" {} +\"\n\nWhat does this command do?\nfind /Volumes ~ ! -path \"/Users/user/Library/.FS_Store\" -type f -size +8c -user `whoami` perm -u=r -exec \"/Users/user/Library/.FS_Store\" {} +\n\nFirst, returns a list of user files that are readable and bigger than 8 bytes. Then these files\nwill be passed (to a new instance) of the malware, in order to be encrypted! We can observe\nthis encryption via a utility such as fs_usage:\naccess (_W__) /Users/user/Desktop/pleaseDontEncryptMe.txt\nopen F=50 (RW____) /Users/user/Desktop/pleaseDontEncryptMe.txt\nWrData[AT1] D=0x018906a8 /Users/user/Desktop/pleaseDontEncryptMe.txt\n\n\n-----\n\nThe actual encryption routine of the malware begins at 0x0000000100002160. This function\nis invoked indirectly via a call to 'pthread_create()':\n\nAs noted by Fortinet, the encryption is not some RSA-based scheme, but rather uses a\nsymmetric cryptographic algorithm. Unfortunately (for users) though there is a static key\n(0x39A622DDB50B49E9), Joven and Chin Yick Low state that for each file the key is\n\"permuted with a random generated number.\" Moreover, this random permutation is not\nsaved nor conveyed to the attacker. Thus it appears that once encrypted, the files are pretty\nmuch gone for good (save for a perhaps a brute force decryption attack).\n\n[Good news, RansomWhere? can generically detect at block this attack:](https://objective-see.com/products/ransomwhere.html)\n\nAstute readers might wonder why the alert displays 'find' as the process responsible for the\nencryption (vs. the malware's .FS_Store). The reason is, 'find' invokes fork()' then 'execvp()'\nto execute the command that is specified via '-exec' option. RansomWhere? uses the\nOpenBSM auditing capabilities of macOS to track process creations - and while such\nauditing generates process events for fork(), exec() and execve(), it does not (AFAIK)\nsupport execvp(). As such, while the fork() process event it detected (and the path set to\n/usr/bin/find), the subsequent execvp() call is not audited. Thus the path stays as /usr/bin/find\n:/\n\nOne work around would be for RansomWhere? to re-query the OS later, say whenever it\ndetects the creation of an encrypted file. At this point, the process (i.e 'find') will have\nexecvp()'d and thus the 'correct' path should be returned. Or Apple could just fix the auditing\n\n\n-----\n\nsubsystem :P ... I mean, this is kinda an auditing bypass?! I ll file a radar, ...then pray.\n\nConclusions\nLuckily for users macOS malware is still rather rare. However, from a technical point of view\nthere's no reason for this. Macs are 'easy' to infect and writing a piece of code that encrypts\nuser files is trivial.\nThough unlikely, to check if you're infected, look for the following:\n\na process named '.FS_Store' (that's running out of (~/Library)\n\na plist file: '~/Library/LaunchAgents/com.apple.finder.plist\n\nIn this short blog post, we tore apart OSX/MacRansom - a basic piece of macOS new\nransomware. Luckily tools such as BlockBlock and RansomWhere? did their job - generally\ndetecting the ransomware's persistence and encryption. Kinda neat, huh? <3\n[love these blog posts? support my tools & writing on patreon! Mahalo :)](https://www.patreon.com/objective_see)\n\n© 2017 objective-see llc\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-06-12 - OSX-MacRansom.pdf"
    ],
    "report_names": [
        "2017-06-12 - OSX-MacRansom.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535529,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653787337,
    "ts_modification_date": 1653787337,
    "files": {
        "pdf": "https://archive.orkl.eu/f32661843885247c3bc97799dd0a5739ade819bb.pdf",
        "text": "https://archive.orkl.eu/f32661843885247c3bc97799dd0a5739ade819bb.txt",
        "img": "https://archive.orkl.eu/f32661843885247c3bc97799dd0a5739ade819bb.jpg"
    }
}