{
    "id": "8c1ab116-c006-41ae-a03e-ffb396ae488f",
    "created_at": "2022-10-25T16:48:21.542668Z",
    "updated_at": "2025-03-27T02:16:34.545521Z",
    "deleted_at": null,
    "sha1_hash": "36a2f04f55d02b967222faad2d629f6c1296007a",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-09-28T08:23:03Z",
    "file_modification_date": "2021-09-28T08:23:03Z",
    "file_size": 4000343,
    "plain_text": "# FoggyWeb: Targeted NOBELIUM malware leads to persistent backdoor\n\n**[microsoft.com/security/blog/2021/09/27/foggyweb-targeted-nobelium-malware-leads-to-persistent-backdoor](https://www.microsoft.com/security/blog/2021/09/27/foggyweb-targeted-nobelium-malware-leads-to-persistent-backdoor/)**\n\nSeptember 27, 2021\n\nMicrosoft continues to work with partners and customers to track and expand our knowledge of the\nthreat actor we refer to as NOBELIUM, the actor behind the SUNBURST backdoor, TEARDROP\nmalware, and related components. As we stated before, we suspect that NOBELIUM can draw from\nsignificant operational resources often showcased in their campaigns, including custom-built malware\n[and tools. In March 2021, we profiled NOBELIUM’s GoldMax, GoldFinder, and Sibot malware, which it](https://www.microsoft.com/security/blog/2021/03/04/goldmax-goldfinder-sibot-analyzing-nobelium-malware/)\nuses for layered persistence. We then followed that up with another post in May, when we analyzed the\n[actor’s early-stage toolset comprising EnvyScout, BoomBox, NativeZone, and VaporRage.](https://www.microsoft.com/security/blog/2021/05/28/breaking-down-nobeliums-latest-early-stage-toolset/)\n\nThis blog is another in-depth analysis of newly detected NOBELIUM malware: a post-exploitation\nbackdoor that Microsoft Threat Intelligence Center (MSTIC) refers to as FoggyWeb. As mentioned in\nprevious blogs, NOBELIUM employs multiple tactics to pursue credential theft with the objective of\n[gaining admin-level access to Active Directory Federation Services (AD FS) servers. Once NOBELIUM](https://docs.microsoft.com/windows-server/identity/active-directory-federation-services)\nobtains credentials and successfully compromises a server, the actor relies on that access to maintain\npersistence and deepen its infiltration using sophisticated malware and tools. NOBELIUM uses\nFoggyWeb to remotely exfiltrate the configuration database of compromised AD FS servers, decrypted\n[token-signing certificate, and token-decryption certificate, as well as to download and execute additional](https://docs.microsoft.com/windows-server/identity/ad-fs/design/token-signing-certificates)\ncomponents. Use of FoggyWeb has been observed in the wild as early as April 2021.\n\nMicrosoft has notified all customers observed being targeted or compromised by this activity. If you\nbelieve your organization has been compromised, we recommend that you\n\nAudit your on-premises and cloud infrastructure, including configuration, per-user and per-app\nsettings, forwarding rules, and other changes the actor might have made to maintain their access\nRemove user and app access, review configurations for each, and re-issue new, strong credentials\nfollowing documented industry best practices.\n[Use a hardware security module (HSM) as described in securing AD FS servers to prevent the](https://docs.microsoft.com/windows-server/identity/ad-fs/deployment/best-practices-securing-ad-fs#hardware-security-module-hsm)\nexfiltration of secrets by FoggyWeb.\n\nMicrosoft security products have implemented detections and protections against this malware.\nIndicators of compromise (IOCs), mitigation guidance, detection details, and hunting queries for Azure\nSentinel and Microsoft 365 Defender customers are provided at the end of this analysis and in the\n[product portals. Active Directory Federation Services (AD FS) servers run on-premises and customers](https://docs.microsoft.com/en-us/windows-server/identity/active-directory-federation-services)\n[can also follow detailed guidance on securing AD FS servers against attacks.](https://docs.microsoft.com/windows-server/identity/ad-fs/deployment/best-practices-securing-ad-fs)\n\n## FoggyWeb: Backdoor targeting AD FS\n\nFoggyWeb is a passive and highly targeted backdoor capable of remotely exfiltrating sensitive\ninformation from a compromised AD FS server. It can also receive additional malicious components\nfrom a command-and-control (C2) server and execute them on the compromised server.\n\nAfter compromising an AD FS server, NOBELIUM was observed dropping the following two files on the\nsystem (administrative privileges are required to write these files to the folders listed below):\n\n_%WinDir%\\ADFS\\version.dll_\n_%WinDir%\\SystemResources\\Windows.Data.TimeZones\\pris\\Windows.Data.TimeZones.zh-_\n_PH.pri_\n\n\n-----\n\nFoggyWeb is stored in the encrypted file Windows.Data.TimeZones.zh-PH.pri, while the malicious file\n_version.dll can be described as its loader. The AD FS service executable_\n_[Microsoft.IdentityServer.ServiceHost.exe loads the said DLL file via the DLL search order hijacking](https://attack.mitre.org/techniques/T1574/001/)_\ntechnique that involves the core Common Language Runtime (CLR) DLL files (described in detail in the\nFoggyWeb loader section). This loader is responsible for loading the encrypted FoggyWeb backdoor file\nand utilizing a custom Lightweight Encryption Algorithm (LEA) routine to decrypt the backdoor in\nmemory.\n\nAfter de-obfuscating the backdoor, the loader proceeds to load FoggyWeb in the execution context of the\nAD FS application. The loader, an unmanaged application, leverages the CLR hosting interfaces and APIs\nto load the backdoor, a managed DLL, in the same Application Domain within which the legitimate AD\nFS managed code is executed. This grants the backdoor access to the AD FS codebase and resources,\nincluding the AD FS configuration database (as it inherits the AD FS service account permissions\nrequired to access the configuration database).\n\nWhen loaded, the FoggyWeb backdoor (originally named Microsoft.IdentityServer.WebExtension.dll by\nits developer) functions as a passive and persistent backdoor that allows abuse of the Security Assertion\nMarkup Language (SAML) token. The backdoor configures HTTP listeners for actor-defined URIs that\nmimic the structure of the legitimate URIs used by the target’s AD FS deployment. The custom listeners\npassively monitor all incoming HTTP GET and POST requests sent to the AD FS server from the\nintranet/internet and intercept HTTP requests that match the custom URI patterns defined by the actor.\nThis version of FoggyWeb configures listeners for the following hardcoded URI patterns (which might\nvary per target):\n\nHTTP GET URI pattern:\n\n_/adfs/portal/images/theme/light01/profile.webp_\n_/adfs/portal/images/theme/light01/background.webp_\n_/adfs/portal/images/theme/light01/logo.webp_\nHTTP POST URI pattern:\n\n_/adfs/services/trust/2005/samlmixed/upload_\n\nEach HTTP GET/POST URI pattern above corresponds to a C2 command:\n\n\n-----\n\nWhen the AD FS server receives an HTTP GET request containing the URI pattern\n_/adfs/portal/images/theme/light01/profile.webp, the backdoor retrieves the token signing_\n**_certificate of the compromised AD FS server and then obfuscates and returns the certificate to_**\nthe issuer of the request.\nSimilarly, when the AD FS server receives an HTTP GET request containing the URI pattern\n_/adfs/portal/images/theme/light01/background.webp, the backdoor retrieves the token_\n**_decryption certificate of the compromised AD FS server and then obfuscates and returns the_**\ncertificate to the issuer of the request.\nWhen the AD FS server receives an HTTP GET request containing the URI pattern\n_/adfs/portal/images/theme/light01/logo.webp, the backdoor retrieves the AD FS configuration_\ndata of the compromised server, obfuscates the data, and returns the obfuscated data to the issuer\nof the request.\nWhen the AD FS server receives an HTTP POST request containing the URI pattern\n_/adfs/services/trust/2005/samlmixed/upload, the backdoor treats the obfuscated and_\ncompressed POST data as either .NET assembly or source code. If assembly, the backdoor executes\nthe assembly in the execution context of the AD FS process. If source code, the backdoor\ndynamically compiles the source code and proceeds to execute the resulting memory-resident\nassembly in the execution context of the AD FS process.\n\nThe diagram below illustrates the methodology used by the actor to communicate with the FoggyWeb\nbackdoor located on a compromised internet-facing AD FS server.\n\nSince FoggyWeb runs in the context of the main AD FS process, it inherits the AD FS service account\npermissions required to access the AD FS configuration database. This contrasts with tools such as\n_ADFSDump that must be executed under the user context of the AD FS service account. Also, because_\nFoggyWeb is loaded into the same application domain as the AD FS managed code, it gains\nprogrammatical access to the legitimate AD FS classes, methods, properties, fields, objects, and\ncomponents that are subsequently leveraged by FoggyWeb to facilitate its malicious operations. For\nexample, this allows FoggyWeb to gain access to the AD FS configuration data without connecting to the\nWID named pipe or manually running SQL queries to retrieve configuration information (for example, to\nobtain the EncryptedPfx blob from the configuration data). FoggyWeb is also AD FS version-agnostic; it\ndoes not need to keep track of legacy versus modern configuration table names and schemas, named pipe\nnames, and other version-dependent properties of AD FS.\n\n### FoggyWeb loader\n\n\n-----\n\nThe file version.dll is a malicious loader responsible for loading an encrypted backdoor file from the file\nsystem, decrypting the backdoor file, and loading it in memory. This malicious DLL, which shares a\nname with a legitimate Windows DLL located in the %WinDir%\\System32\\ folder, is meant to be placed\nin the main AD FS folder %WinDir%\\ADFS\\, where the AD FS service executable\n_Microsoft.IdentityServer.ServiceHost.exe is located (for reasons described later in this section)._\n\nWhen the AD FS service (adfssrv) is started, the service executable\n_Microsoft.IdentityServer.ServiceHost.exe gets executed. As a .NET-based managed application,_\n_Microsoft.IdentityServer.ServiceHost.exe imports an unmanaged Windows DLL named mscoree.dll._\n\nThe file mscoree.dll dynamically loads another unmanaged Windows/CLR DLL named mscoreei.dll. As\nshown below, mscoreei.dll has a delay load import (Delay Import) named version.dll.\n\nNOBELIUM, with existing administrative permissions, was observed to drop a malicious loader named\n_version.dll in the %WinDir%\\ADFS\\ folder where the AD FS service executable_\n_Microsoft.IdentityServer.ServiceHost.exe is located. Once the system or the AD FS service is restarted,_\n_Microsoft.IdentityServer.ServiceHost.exe loads mscoree.dll, which in turn loads mscoreei.dll. As_\nmentioned above, mscoreei.dll has a delay load import named version.dll. Once loaded, instead of\nloading the legitimate version.dll from the %WinDir%\\System32\\ folder mscoreei.dll loads the\nmalicious version.dll planted by the attacker in %WinDir%\\ADFS\\ folder (referred to as DLL search\norder hijacking), as shown in the call stack below.\n\n\n-----\n\nThe malicious loader version.dll behaves as a proxy for all legitimate version.dll export function calls. As\nshown below, it exports the same 17 function names as the legitimate version of version.dll.\n\n\n-----\n\nThe export functions of the malicious version.dll are all short stubs that call a single trampoline function\nlabeled TrampolineFunction, as seen in the screenshot below.\n\nBelow is a pseudocode for the trampoline function.\n\nThis trampoline function is responsible for the following:\n\nCalling a function (labeled as LoadDecryptExecuteBackdoor() by the analyst) to load a backdoor\nfile from the file system, and then decrypting and executing the file in memory\nTransferring execution to the initially called target function from the legitimate version of\n_version.dll._\n\nThe trampoline function preserves the value of the arguments/registers intended for the function from\nthe legitimate version of version.dll by saving the value of certain CPU registers. It first pushes them\nonto the stack before calling the LoadDecryptExecuteBackdoor() function above and then restoring\nthem before transferring execution to the function from the legitimate version of version.dll.\n\n\n-----\n\nWhen called, LoadDecryptExecuteBackdoor() attempts to\ncreate a Windows event named {2783c149-77a7-5e51_0d83-ac0566daff96} to ensure that only one copy of the_\nloader is actively running on the system. In a new thread, it\nthen checks if the following file is present (hardcoded path\nstring):\n\n_C:\\Windows\\SystemResources\\Windows.Data.TimeZones\\pris\\Windows.Data.TimeZones.zh-PH.pri_\n\n_Windows.Data.TimeZones.zh-PH.pri is an encrypted backdoor file that is placed in the folder above._\nMSTIC refers to this backdoor file as FoggyWeb, and our analysis is in the next section.\n\n_Microsoft.IdentityServer.ServiceHost.exe in and of itself is an unmanaged Windows executable that is_\ngenerated when the high-level AD FS managed code is compiled. When executed, the unmanaged code\ninside Microsoft.IdentityServer.ServiceHost.exe leverages Common Language Runtime (CLR) to run the\nmanaged AD FS code within a virtual runtime environment. This virtual runtime environment is\ncomprised of one or more application domains, which provide a unit of isolation for the runtime\nenvironment and allow different applications to run inside separate containers within a process. The\nmanaged AD FS code is executed within an application domain inside the virtual runtime environment.\n\nThe FoggyWeb backdoor (also a managed DLL) is intended to run alongside the legitimate AD FS code\n(that is, within the same application domain). This means that for the FoggyWeb loader to load the\nbackdoor alongside the AD FS code, it needs to gain access to the same application domain that the AD\nFS code is executed within. Since the FoggyWeb loader version.dll is an unmanaged application, it\ncannot directly access the virtual runtime environment that the managed AD FS code is executed within.\nThe loader overcomes this limitation and loads the backdoor alongside the AD FS code by leveraging the\nCLR hosting interfaces and APIs to access the virtual runtime environment within which the AD FS code\nis executed.\n\nThe loader performs the following high-level actions:\n\nEnumerate all CLRs loaded in the AD FS process Microsoft.IdentityServer.ServiceHost.exe\nFor each CLR, enumerate all running application domains and perform the following actions for\neach domain:\n\nRead the contents of the following encrypted FoggyWeb backdoor file into memory:\n_C:\\Windows\\SystemResources\\Windows.Data.TimeZones\\pris\\Windows.Data.TimeZones.zh-_\n_PH.pri_\nDecrypt the encrypted FoggyWeb backdoor file using the Lightweight Encryption Algorithm\n(LEA). The LEA-128 key schedule uses the following hardcoded master key to generate the\nround keys:\n\n\n-----\n\nAfter decrypting each 16-byte cipher block, the loader uses the following XOR key to decode each\nindividual decrypted/plaintext block:\n\nThis is equivalent to first LEA decrypting the entire file and then XOR decoding the decrypted data\n(instead of decrypting and XOR decoding each individual 16-byte block).\n\nCreate a Safe Array and copy the decrypted FoggyWeb backdoor bytes to the array. It then\ncalls the Load() function for the current application domain to load the FoggyWeb DLL into\nthe application domain. After the FoggyWeb DLL is loaded into the current application\ndomain, the loader invokes the following method from the DLL:\n_Microsoft.IdentityServer.WebExtension.WebHost._\n\nAt this point in the execution cycle, the FoggyWeb DLL is loaded into one or more application domains\nwhere the legitimate AD FS code is running. This means the backdoor code runs alongside the AD FS\ncode with the same access and permissions as the AD FS application. Because the backdoor is loaded in\nthe same application domain as the AD FS code, it gains programmatical access to the legitimate classes,\nmethods, properties, fields, objects, and components used by various AD FS modules to carry out their\nlegitimate functionality. Such access allows the FoggyWeb backdoor to directly interact with the AD FS\ncodebase (that is, not an external disk-resident tool) and selectively invoke native AD FS methods\nneeded to facilitate its malicious operations.\n\n### FoggyWeb backdoor\n\nThis malicious memory-resident DLL (originally named Microsoft.IdentityServer.WebExtension.dll by\nits developer) functions as a backdoor targeting AD FS. It is loaded by the main AD FS service process\n_Microsoft.IdentityServer.ServiceHost.exe through a malicious loader component._\n\nWhen loaded, the backdoor starts an HTTP listener that listens for HTTP GET and POST requests\ncontaining the following URI patterns:\n\nHTTP GET URI pattern: /adfs/portal/images/theme/light01/\nHTTP POST URI pattern: /adfs/services/trust/2005/samlmixed/upload\n\nAs shown below, the URI patterns are hardcoded in the backdoor and mimic the structure of the\nlegitimate URIs used by the target’s AD FS deployment.\n\nOnce the backdoor receives an HTTP request that contains one of the URI patterns above, the listener\nproceeds to handle the request using either an HTTP GET or HTTP POST callback/handler method\n(ProcessGetRequest() and ProcessGetRequest(), respectively).\n\n\n-----\n\n**HTTP GET handler**\n\nThe incoming HTTP GET requests that contain the URI pattern /adfs/portal/images/theme/light01/\nare handled by backdoor’s ProcessGetRequest() method.\n\nIf an incoming HTTP GET request is issued for a file/resource with the file extension of .webp, the\n_ProcessGetRequest() method proceeds to handle the request. Otherwise, the request is ignored by the_\nbackdoor. Also, if the requested file name matches one of the three hardcoded names below, the\nbackdoor treats the request as a C2 command issued by the attacker.\n\nThe following URL patterns are treated as C2 commands:\n\n_/adfs/portal/images/theme/light01/profile.webp_\n_/adfs/portal/images/theme/light01/background.webp_\n_/adfs/portal/images/theme/light01/logo.webp_\n\n\n-----\n\nThe first two C2 commands, profile.webp and background.webp (UrlGetFileNames[0] and\n_UrlGetFileNames[1] in the screenshot above), are handled by calling the backdoor’s_\n_Service.GetCertificate() method._\n\nAs the name suggests, this method is responsible for retrieving an AD FS certificate (either the tokensigning or the token encryption certificate, depending on the value of the certificateType parameter\npassed to the method) from the AD FS service configuration database.\n\n**_Analyst note: Refer to the Appendix for an in-depth analysis of the Service.GetCertificate() method_**\n_and how it obtains and decrypts either the token signing or encryption certificate._\n\nAs shown in the screenshot above, when the C2 command profile.webp (UrlGetFileNames[0]) is issued\nto the backdoor (by issuing an HTTP GET request for the URI\n_/adfs/portal/images/theme/light01/profile.webp), the backdoor retrieves the token-signing_\n**_certificate of the compromised AD FS server. Similarly, when the C2 command background.webp_**\n(UrlGetFileNames[1]) is issued to the backdoor (by issuing an HTTP GET request for the URI\n_/adfs/portal/images/theme/light01/background.webp), the backdoor retrieves the token encryption_\n**_certificate of the compromised AD FS server._**\n\nThe third C2 command, logo.webp (UrlGetFileNames[2]), is triggered by sending an HTTP GET request\nto the following URI: /adfs/portal/images/theme/light01/logo.webp. The C2 command is handled by\ncalling the backdoor’s GetInfo() method.\n\nThe GetInfo() method is responsible for dumping the AD FS service configuration data of the\ncompromised server.\n\nAs shown above, the AD FS service configuration data is obtained via the ServiceSettingsData property,\nwhich retrieves the data from the AD FS service configuration database, Windows Internal Database\n(WID).\n\nBefore returning the output of the C2 commands (that is, the token-signing certificate, the token\nencryption certificate, or the AD FS service configuration data) to the C2 in an HTTP 200 response, the\nbackdoor first obfuscates the output by calling its method named GetWebpImage().\n\n\n-----\n\nThe GetWebpImage() method is in charge of masquerading the output of the C2 commands as a\nlegitimate WebP file (by adding appropriate RIFF/WebP file header magic/fields) and encoding the\nresulting WebP file.\n\n_GetWebpImage() uses the following helper methods to create and encode the fake WebP file that_\ncontains the C2 command output:\n\n_GetWebpImage() first invokes the Webp.GetFrame() method, which is responsible for_\ncompressing the output of the C2 command and copying the compressed version to a new array (0\npadded to a multiple of 32 bytes). The length of the compressed data is added as the first four bytes\nof the new array.\n\nTo compress the data, GetFrame() invokes the Common.Compress() method, which is used to compress\nthe data by leveraging the C# GZipStream compression class.\n\n\n-----\n\nFor demonstration purposes, assume the C2 command yields the following data (a 256-byte pseudorandomly generated byte array).\n\nGiven the data above (that is, sample C2 command output), GetFrame() returns the following byte array.\n\nNext, GetWebpImage() invokes the Webp.GetWebpHeader() method, passing in the size of the\nbyte array returned by GetFrame() in the step above. GetWebpHeader() is responsible for creating\nand returning an array containing custom RIFF WebP file magic/header bytes.\n\n\n-----\n\nThe array variable above contains the following 32-byte hardcoded RIFF/WebP header bytes.\n\nIf the size of the array passed to GetWebpHeader() (returned by GetFrame()) exceeds 8,192 bytes, the\nbytes at index 26 and 28 of the header bytes (initially set to 0x00) are replaced with 0x80. Otherwise, the\nbytes at index 26 and 28 are replaced with 0x40, as shown below.\n\n_GetWebpHeader() then returns the custom RIFF/WebP header above to GetWebpImage()._\n\nNext, GetWebpImage() creates a new array by appending the custom RIFF/WebP header bytes\nreturned by GetWebpHeader() to the array returned by GetFrame() (the array containing the\ncompressed version of the C2 command output).\n\n\n-----\n\n_GetWebpImage() calls the Common.ProtectData() method of the backdoor to encode the portion of the_\nnew array that contains the compressed bytes (that is, it does not encode the custom RIFF/WebP\nheader). As the second argument, GetWebpImage() passes the offset of the first compressed byte to\n_ProtectData() (as shown in the table above, 0x20 or 32 is the offset of the first compressed byte in this_\ncase). ProtectData() uses a dynamic XOR key and a custom XOR methodology to XOR encode the\ncompressed data.\n\nInitially, the 12-byte hardcoded XOR key array contains the following (seed) bytes.\n\nAs shown in the screenshot above, each byte of compressed data is XOR’d with a byte from the XOR key\narray. The first byte of the compressed data (0x17) is XOR’d with the XOR key byte located at offset 8 of\nthe key array (0x77).\n\nAfter XOR’ing the first byte of the compressed data with the XOR key byte located at offset 8 of the key\narray, the XOR key byte itself gets overwritten with a new value.\n\nFor example, the XOR key byte located at offset 8 of the XOR key array (0x77) gets overwritten with\n0xEE via the following operations.\n\n\n-----\n\nThe second byte of the compressed data (0x01) is XOR’d with the XOR key byte located at offset 9 of the\nkey array (33 % 12 = 9) and so on until the key rolls to the first byte of the XOR array (as mentioned\nabove, the XOR key bytes get overwritten after each encoding operation). Below is the XOR encoded\nversion of the sample compressed array.\n\nAfter the steps outlined above, GetWebpImage() returns the following sample data to the method that\ninvokes it to obfuscate and conceal the output of each C2 command (ProcessGetRequest()).\n\nAs previously mentioned, ProcessGetRequest() returns the fake RIFF/WebP file generated above\n(containing stolen token-signing certificate, token encryption certificate, or the AD FS service\nconfiguration data) to the C2 in an HTTP 200 response.\n\nIf the backdoor cannot execute a C2 command successfully, it returns an HTTP 404 response to the C2\ninstead.\n\n**HTTP POST handler**\n\nIncoming HTTP POST requests that match the URI pattern\n_/adfs/services/trust/2005/samlmixed/upload are handled by the ProcessPostRequest() method._\n\n\n-----\n\nThis method ensures that the ContentType value of an incoming HTTP POST request ends with “xml”\n(case-insensitive), and the HTTP POST data contains two XML elements named X509Certificate and\n_SignatureValue (for example, a blob that starts with the string “<X509Certificate>” and ends with the_\nstring “</X509Certificate>”).\n\nIf the XML data contains the two elements, the backdoor performs the following actions:\n\nDecode the values of the SignatureValue and X509Certificate elements by first decoding the values\nusing Base64 and then calling the Common.UprotectData() method on each decoded value.\n\nThe UprotectData() method treats the first two bytes of the Base64 decoded value as a two-byte XOR\nkey. It invokes the Common.ProtectData() method (covered in the previous section) on the rest of the\ndata (that is, third byte on) and then uses the two-byte XOR key to XOR decode the data returned by\n\n\n-----\n\n_Common.ProtectData(). In other words, UprotectData() leverages Common.ProtectData() to remove_\nthe first layer of XOR encoding and then another XOR routine to remove the second layer of XOR\nencoding applied to the data.\n\nInvoke the Service.ExecuteAssembly() method to handle the decoded SignatureValue and\n_X509Certificate values. As shown below, the decoded X509Certificate value is the first GZip_\ndecompressed/inflated by calling the Common.Decompress() method.\n\nIn a new thread, Service.ExecuteAssembly() calls Service.ExecuteAssemblyRoutine() method to handle\nthe data.\n\n_ExecuteAssemblyRoutine() checks if the decoded X509Certificate value starts with “MZ” (or the_\nbytes 0x4D 0x5A, the hexadecimal representation of the decimal numbers 77 and 90, as seen in the\nscreenshot below).\n\n\n-----\n\nIf the decoded X509Certificate value starts with “MZ,” the backdoor treats the decoded data as a\n.NET-based assembly/payload and proceeds to call its Service.ExecuteBinary() method to load and\nexecute the DLL payload in memory. After loading the DLL in memory, ExecuteBinary() proceeds\nto invoke a specific method from the loaded DLL. The method name and parameters needed to\ninvoke the method are supplied to the backdoor within the decoded SignatureValue data.\n\nIf the decoded X509Certificate value does not start with MZ, the backdoor treats the decoded\n_X509Certificate value as source code for a C#-based payload and calls its Service.ExecuteSource()_\nmethod to dynamically compile and execute the payload in memory.\n\nAfter handling the HTTP POST request containing the XML elements X509Certificate and\n_SignatureValue, the backdoor responds to the request with an HTTP 204 response code. If the HTTP_\nPOST does not have the elements mentioned above, the backdoor responds to the request with an HTTP\n404 response code.\n\n## Appendix: Obtaining and decrypting AD FS tokens\n\nAs the name suggests, the Service.GetCertificate() method is responsible for retrieving an AD FS\ncertificate (either the token- signing or the token encryption certificate, depending on the value of the\n_certificateType parameter passed to the method) from the AD FS service configuration database._\n\nThe method performs the following actions to retrieve the desired certificate:\n\n\n-----\n\nInvoke another one of its methods named GetServiceSettingsDataProvider() to create an instance\nof type Microsoft.IdentityServer.PolicyModel.Configuration.ServiceSettingsDataProvider from\nthe already loaded assembly Microsoft.IdentityServer.\n\nInvoke the GetServiceSettings() member/method of the above ServiceSettingsDataProvider\ninstance to obtain the AD FS service configuration settings.\n\nObtain the value of the AD FS service settings (from the SecurityTokenService property), extract\nthe value of the EncryptedPfx blob from the service settings, and decode the blob using Base64.\n\nInvoke another method named GetAssemblyByName() to enumerate all loaded assemblies by\nname and locate the already loaded assembly Microsoft.IdentityServer.Service. This method\nretrieves the value of two fields named _state and _certificateProtector from an object of type\n_Microsoft.IdentityServer.Service.Configuration.AdministrationServiceState (from the_\n_Microsoft.IdentityServer.Service assembly)._\n\nThe AdministrationServiceState class/object contains configuration information necessary for the\nexecution and handling of client requests. The field _state is used to maintain the current state of the\n_AdministrationServiceState class/object (screenshot from Microsoft.IdentityServer.Service.dll)._\n\nThe AdministrationServiceState object (stored in the _state field) contains another field named\n__certificateProtector._\n\n\n-----\n\nThe field _certificateProtector stores an instance of the Data Protector class DkmDataProtector for\nDistributed Key Management (DKM). The DkmDataProtector class implements a method named\n_Unprotect(), which ultimately calls the Unprotect() method of DKM/IDKM (screenshot from_\n_Microsoft.IdentityServer.dll)._\n\nThe DKM Unprotect() method inherits a method named Unprotect() from\n_Microsoft.IdentityServer.Dkm.DKMBase (screenshot from Microsoft.IdentityServer.Dkm.dll)._\n\nThe Unprotect() method from Microsoft.IdentityServer.Dkm.DKMBase (shown above) provides the\nfunctionality to decrypt the encrypted certificate (a PKCS12 object) stored in the EncryptedPfx blob.\n\nArmed with the knowledge about the availability of the Unprotect() method accessible via the\n__certificateProtector field, the backdoor invokes the Unprotect() method to decrypt the encrypted_\ncertificate stored in the EncryptedPfx blob of the desired certificate type (either the AD FS token signing\nor encryption certificate).\n\nA variant of the technique described in this Appendix was publicly presented by Douglas Bienstock and\nAustin Baker at the TROOPERS conference in 2019 (I am AD FS and so can you: Attacking Active\nDirectory Federated Services). However, the method used by FoggyWeb differs from the publicly\npresented method, in that FoggyWeb leverages the _state and _certificateProtector fields from the\n_AdministrationServiceState class/object to facilitate access to the Data Protector class_\n_DkmDataProtector (used to gain access to and invoke the Unprotect() method)._\n\n\n-----\n\n## Indicators of compromise (IOCs)\n\n\n**Type** **Threat**\n**Name**\n\n\n**Threat**\n**Type**\n\n\n**Indicator**\n\n\nMD5 FoggyWeb Loader 5d5a1b4fafaf0451151d552d8eeb73ec\n\n\nSHA1\n\nSHA256\n\n\nFoggyWeb Loader c896ece073dd01191cbc1d462bc2f47161828a83\n\nFoggyWeb Loader 231b5517b583de102cde59630c3bf938155d17037162f663874e4662af2481b1\n\n\nMD5 FoggyWeb Backdoor\n(encrypted)\n\n\nSHA1\n\nSHA256\n\n\nFoggyWeb Backdoor\n(encrypted)\n\nFoggyWeb Backdoor\n(encrypted)\n\n\nMD5 FoggyWeb Backdoor\n(decrypted)\n\n\nSHA1\n\nSHA256\n\n\nFoggyWeb Backdoor\n(decrypted)\n\nFoggyWeb Backdoor\n(decrypted)\n\n\n9ff9401315d0f7258a9fcde0cfdef02b\n\n4597431f26424cb814c917168fa8d74d01ab7cd1\n\nda0be762bb785085d36aec80ef1697e25fb15414514768b3bcaf798dd9c9b169\n\ne9671d294ce41fe6dbb9637dc0157a88\n\n85cfeccbb48fd9f498d24711c66e458e0a80cc90\n\n568392bd815de9b677788addfc4fa4b0a5847464b9208d2093a8623bbecd81e6\n\n\n## Mitigations\n\nCustomers should review their AD FS Server configuration and implement changes to secure these\nsystems from attacks:\n\n[Best Practices for securing AD FS and Web Application Proxy](https://docs.microsoft.com/windows-server/identity/ad-fs/deployment/best-practices-securing-ad-fs)\n\nWe strongly recommend for organizations to harden and secure AD FS deployments through the\nfollowing best practices:\n\nEnsure only Active Directory Admins and AD FS Admins have admin rights to the AD FS system.\nReduce local Administrators’ group membership on all AD FS servers.\nRequire all cloud admins to use multi-factor authentication (MFA).\nEnsure minimal administration capability via agents.\nLimit on-network access via host firewall.\nEnsure AD FS Admins use Admin Workstations to protect their credentials.\nPlace AD FS server computer objects in a top-level OU that doesn’t also host other servers.\nEnsure that all GPOs that apply to AD FS servers apply only to them and not to any other servers.\nThis limits potential privilege escalation through GPO modification.\nEnsure that the installed certificates are protected against theft. Don’t store these on a share on the\nnetwork and set a calendar reminder to ensure they get renewed before expiring (expired certificate\nbreaks federation auth). Additionally, we recommend protecting signing keys or certificates in a\n[hardware security module (HSM) attached to AD FS.](https://docs.microsoft.com/windows-server/identity/ad-fs/deployment/best-practices-securing-ad-fs#hardware-security-module-hsm)\nSet logging to the highest level and send the AD FS (and security) logs to a SIEM to correlate with\nAD authentication as well as Azure AD (or similar).\n\n\n-----\n\nRemove unnecessary protocols and Windows features.\nUse a long (>25 characters) and complex password for the AD FS service account. We recommend\n[using a Group Managed Service Account (gMSA) as the service account, as it removes the need for](https://docs.microsoft.com/windows-server/security/group-managed-service-accounts/group-managed-service-accounts-overview)\nmanaging the service account password over time by managing it automatically.\nUpdate to the latest AD FS version for security and logging improvements (as always, test first).\n[When federated with Azure AD follow the best practices for securing and monitoring the AD FS](https://docs.microsoft.com/azure/active-directory/hybrid/how-to-connect-install-prerequisites#harden-your-azure-ad-connect-server)\ntrust with Azure AD.\n\n## Detections\n\nProtecting AD FS servers is key to mitigating NOBELIUM attacks. Detecting and blocking malware,\nattacker activity, and other malicious artifacts on AD FS servers can break critical steps in known\nNOBELIUM attack chains. Microsoft Defender Antivirus detects the new NOBELIUM components\ndiscussed in this blog as the following malware:\n\n**Loader: Trojan:Win32/FoggyWeb.A!dha**\n**Backdoor: Trojan:MSIL/FoggyWeb.A!dha**\n\n### Microsoft 365 Defender\n\nEndpoint detection and response (EDR) capabilities in Microsoft Defender for Endpoint detect malicious\nbehavior related to this malware which is surfaced as alerts with the following titles:\n\nA suspicious DLL was loaded by the ADFS service\nSuspicious service launched\nSuspicious file dropped\n\n### Azure AD Identity Protection\n\nThis kind of attack can also be detected in the cloud using Azure AD Identity Protection. It is\n[recommended that you monitor the Azure AD Identity Protection Risk detections report for the “Token](https://docs.microsoft.com/azure/active-directory/identity-protection/overview-identity-protection)\nIssuer Anomaly” detection. This detection looks for anomalies in the SAML token presented to the Azure\n\n\n-----\n\nAD tenant.\n\n## Advanced hunting queries\n\n### Microsoft Defender for Endpoint\n\nTo locate related activity, run the following advanced hunting queries in Microsoft 365 Defender:\n\n```\nDeviceImageLoadEvents\n\n```\n```\n| where FolderPath has @\"C:\\Windows\\ADFS\"\n\n```\n```\n| where FileName has @\"version.dll\"\n\n```\n\n### Azure Sentinel\n\nAzure Sentinel customers can use the following detection queries to look for this activity:\n\nDetection query: https://github.com/Azure/AzureSentinel/tree/master/Detections/MultipleDataSources/Nobelium_FoggyWeb.yaml\n\nIndicator file: https://github.com/Azure/AzureSentinel/tree/master/Sample%20Data/Feeds/FoggyWebIOC.csv\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2021/2021.09.27.FoggyWeb/FoggyWeb_%20Targeted%20NOBELIUM%20malware%20leads%20to%20persistent%20backdoor%20_%20Microsoft%20Security%20Blog.pdf"
    ],
    "report_names": [
        "FoggyWeb_ Targeted NOBELIUM malware leads to persistent backdoor _ Microsoft Security Blog"
    ],
    "threat_actors": [
        {
            "id": "b43e5ea9-d8c8-4efa-b5bf-f1efb37174ba",
            "created_at": "2022-10-25T16:07:24.36191Z",
            "updated_at": "2025-03-27T02:02:10.1909Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "Dark Halo",
                "Nobelium",
                "SolarStorm",
                "StellarParticle",
                "UNC2452"
            ],
            "source_name": "ETDA:UNC2452",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "70872c3a-e788-4b55-a7d6-b2df52001ad0",
            "created_at": "2023-01-06T13:46:39.18401Z",
            "updated_at": "2025-03-27T02:00:03.01553Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "DarkHalo",
                "StellarParticle",
                "NOBELIUM",
                "Solar Phoenix",
                "Midnight Blizzard"
            ],
            "source_name": "MISPGALAXY:UNC2452",
            "tools": [
                "SNOWYAMBER",
                "HALFRIG",
                "QUARTERRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1d3f9dec-b033-48a5-8b1e-f67a29429e89",
            "created_at": "2022-10-25T15:50:23.739197Z",
            "updated_at": "2025-03-27T02:00:55.536417Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "UNC2452",
                "NOBELIUM",
                "StellarParticle",
                "Dark Halo"
            ],
            "source_name": "MITRE:UNC2452",
            "tools": [
                "Sibot",
                "Mimikatz",
                "Cobalt Strike",
                "AdFind",
                "GoldMax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "a241a1ca-2bc9-450b-a07b-aae747ee2710",
            "created_at": "2024-06-19T02:03:08.150052Z",
            "updated_at": "2025-03-27T02:05:17.409596Z",
            "deleted_at": null,
            "main_name": "IRON RITUAL",
            "aliases": [
                "Blue Dev 5 ",
                "BlueBravo ",
                "Cloaked Ursa ",
                "CozyLarch ",
                "Dark Halo ",
                "Midnight Blizzard ",
                "NOBELIUM ",
                "StellarParticle ",
                "UNC2452 ",
                "APT29"
            ],
            "source_name": "Secureworks:IRON RITUAL",
            "tools": [
                " Cobalt Strike",
                " EnvyScout",
                " GoldFinder",
                " GoldMax",
                " NativeZone",
                " RAINDROP",
                " SUNBURST",
                " Sibot",
                " TEARDROP",
                " VaporRage",
                "Brute Ratel C4"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "20d3a08a-3b97-4b2f-90b8-92a89089a57a",
            "created_at": "2022-10-25T15:50:23.548494Z",
            "updated_at": "2025-03-27T02:00:55.49688Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "APT29",
                "IRON RITUAL",
                "IRON HEMLOCK",
                "NobleBaron",
                "Dark Halo",
                "NOBELIUM",
                "UNC2452",
                "YTTRIUM",
                "The Dukes",
                "Cozy Bear",
                "CozyDuke",
                "SolarStorm",
                "Blue Kitsune",
                "UNC3524",
                "Midnight Blizzard"
            ],
            "source_name": "MITRE:APT29",
            "tools": [
                "PinchDuke",
                "ROADTools",
                "WellMail",
                "CozyCar",
                "Mimikatz",
                "Tasklist",
                "OnionDuke",
                "FatDuke",
                "POSHSPY",
                "EnvyScout",
                "SoreFang",
                "GeminiDuke",
                "GoldMax",
                "FoggyWeb",
                "SDelete",
                "PolyglotDuke",
                "AADInternals",
                "MiniDuke",
                "SeaDuke",
                "Sibot",
                "RegDuke",
                "CloudDuke",
                "GoldFinder",
                "AdFind",
                "PsExec",
                "NativeZone",
                "Systeminfo",
                "ipconfig",
                "Impacket",
                "Cobalt Strike",
                "PowerDuke",
                "QUIETEXIT",
                "HAMMERTOSS",
                "BoomBox",
                "CosmicDuke",
                "WellMess",
                "VaporRage",
                "LiteDuke"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "46b3c0fc-fa0c-4d63-a38a-b33a524561fb",
            "created_at": "2023-01-06T13:46:38.393409Z",
            "updated_at": "2025-03-27T02:00:02.822155Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "The Dukes",
                "Minidionis",
                "Grizzly Steppe",
                "G0016",
                "Blue Kitsune",
                "BlueBravo",
                "SeaDuke",
                "Cloaked Ursa",
                "YTTRIUM",
                "ATK7",
                "Nobelium",
                "UAC-0029",
                "Group 100",
                "COZY BEAR",
                "IRON HEMLOCK",
                "TA421",
                "ITG11"
            ],
            "source_name": "MISPGALAXY:APT29",
            "tools": [
                "QUARTERRIG",
                "SNOWYAMBER",
                "HALFRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f27790ff-4ee0-40a5-9c84-2b523a9d3270",
            "created_at": "2022-10-25T16:07:23.341684Z",
            "updated_at": "2025-03-27T02:02:09.74554Z",
            "deleted_at": null,
            "main_name": "APT 29",
            "aliases": [
                "APT 29",
                "ATK 7",
                "Blue Dev 5",
                "BlueBravo",
                "Cloaked Ursa",
                "CloudLook",
                "Cozy Bear",
                "Dark Halo",
                "Earth Koshchei",
                "Grizzly Steppe",
                "Group 100",
                "ITG11",
                "Iron Hemlock",
                "Iron Ritual",
                "Midnight Blizzard",
                "Minidionis",
                "Nobelium",
                "NobleBaron",
                "Operation Ghost",
                "Operation Office monkeys",
                "Operation StellarParticle",
                "SilverFish",
                "Solar Phoenix",
                "SolarStorm",
                "StellarParticle",
                "TEMP.Monkeys",
                "The Dukes",
                "UNC2452",
                "UNC3524",
                "Yttrium"
            ],
            "source_name": "ETDA:APT 29",
            "tools": [
                "7-Zip",
                "ATI-Agent",
                "AdFind",
                "Agentemis",
                "AtNow",
                "BEATDROP",
                "BotgenStudios",
                "CEELOADER",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobalt Strike",
                "CobaltStrike",
                "CosmicDuke",
                "Cozer",
                "CozyBear",
                "CozyCar",
                "CozyDuke",
                "Danfuan",
                "EnvyScout",
                "EuroAPT",
                "FatDuke",
                "FoggyWeb",
                "GeminiDuke",
                "Geppei",
                "GoldFinder",
                "GoldMax",
                "GraphDrop",
                "GraphicalNeutrino",
                "GraphicalProton",
                "HAMMERTOSS",
                "HammerDuke",
                "LOLBAS",
                "LOLBins",
                "LiteDuke",
                "Living off the Land",
                "MagicWeb",
                "Mimikatz",
                "MiniDionis",
                "MiniDuke",
                "NemesisGemina",
                "NetDuke",
                "OnionDuke",
                "POSHSPY",
                "PinchDuke",
                "PolyglotDuke",
                "PowerDuke",
                "QUIETEXIT",
                "ROOTSAW",
                "RegDuke",
                "Rubeus",
                "SNOWYAMBER",
                "SPICYBEAT",
                "SUNSHUTTLE",
                "SeaDaddy",
                "SeaDask",
                "SeaDesk",
                "SeaDuke",
                "Sharp-SMBExec",
                "SharpView",
                "Sibot",
                "Solorigate",
                "SoreFang",
                "TinyBaron",
                "WINELOADER",
                "WellMail",
                "WellMess",
                "cobeacon",
                "elf.wellmess",
                "reGeorg",
                "tDiscoverer"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716501,
    "ts_updated_at": 1743041794,
    "ts_creation_date": 1632817383,
    "ts_modification_date": 1632817383,
    "files": {
        "pdf": "https://archive.orkl.eu/36a2f04f55d02b967222faad2d629f6c1296007a.pdf",
        "text": "https://archive.orkl.eu/36a2f04f55d02b967222faad2d629f6c1296007a.txt",
        "img": "https://archive.orkl.eu/36a2f04f55d02b967222faad2d629f6c1296007a.jpg"
    }
}