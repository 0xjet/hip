{
    "id": "7eaa4d5c-8091-452e-a75a-95dbde0b0961",
    "created_at": "2023-01-12T15:10:06.541366Z",
    "updated_at": "2025-03-27T02:09:46.916275Z",
    "deleted_at": null,
    "sha1_hash": "9b97ad23e6a16b4d681feb41ebcdd31ceb820c7c",
    "title": "2020-06-10 - FlowCloud Version 4.1.3 Malware Analysis",
    "authors": "",
    "file_creation_date": "2022-05-28T19:11:21Z",
    "file_modification_date": "2022-05-28T19:11:21Z",
    "file_size": 1711141,
    "plain_text": "# FlowCloud Version 4.1.3 Malware Analysis\n\n**[proofpoint.com/us/blog/threat-insight/flowcloud-version-413-malware-analysis](https://www.proofpoint.com/us/blog/threat-insight/flowcloud-version-413-malware-analysis)**\n\n\nJune 10, 2020\n\n\n-----\n\n[Blog](https://www.proofpoint.com/us/blog)\n[Threat Insight](https://www.proofpoint.com/us/blog/threat-insight)\nFlowCloud Version 4.1.3 Malware Analysis\n\n\n-----\n\nJune 10, 2020 Dennis Schwarz\n\nProofpoint researchers are continuing to track the threat actor TA410’s use of [FlowCloud, a](https://www.proofpoint.com/us/blog/threat-insight/ta410-group-behind-lookback-attacks-against-us-utilities-sector-returns-new)\nremote access trojan (RAT). Below is a new in-depth analysis of another version of the\nFlowCloud RAT, version 4.1.3. While we do not have many campaign details or targeting\ninformation on this particular sample, this is another version of FlowCloud in the wild. Earlier\n[this week we provided an analysis of version 5.0.1, which was used during the targeting of](https://www.proofpoint.com/us/blog/threat-insight/ta410-group-behind-lookback-attacks-against-us-utilities-sector-returns-new)\ncritical U.S. utility providers last year.\n\nIt is currently unclear which of the versions is the “newer one” or if there are distinct variants\nof FlowCloud being used for different purposes. The version we previously detailed had an\nolder compilation date (December 15, 2018 – it is unclear whether the date is forged), but a\nnewer internal version (5.0.1) than the sample discussed here.\n\nOne major difference between the two is that version 5.0.1 is written in C++ using extensive\nobject-oriented programing, Boost library, and a C++ implementation of Protocol buffers—\nversion 4.1.3 was written in C without any object-oriented techniques and used a C\n[implementation of Protocol buffers. Version 5.0.1 also makes use of SHA512, a modified (or](https://github.com/protobuf-c/protobuf-c)\nbroken) AES, and TEA algorithms instead of the MD5 and RC4 as described below. In\ngeneral, version 5.0.1 was a larger and more difficult malware to reverse engineer.\n\nFlowCloud has typical RAT functionality such as access to the filesystem, processes,\nand services, screenshots, keylogging, command shell, and added functionality via plugins. It\nalso includes port mapping and Nmap port scanning to help facilitate lateral\nmovement. Although the additional functionality was not implemented in the analyzed sample\nbelow, there are indicators in the code and configuration data that suggests support for audio\nrecording, clipboard stealing, and exfiltrating files based on specific search criteria such as\nfile type and name pattern. These might be implemented\nvia FlowCloud’s plugin mechanism or may be present in other versions of the malware.\n\nIn this blog post we will analyze the following FlowCloud sample:\n\n\n-----\n\nSHA256 b75e1391fcb558e42cc05399fa716829114323e1d01aa284445955548302d71f\n\nPer its metadata, it is version 4.1.3 and was compiled on March 21, 2019 (it is unclear\n[whether the date is forged). It was recently uploaded to VirusTotal on May 12, 2020 by a](https://www.virustotal.com/gui/file/b75e1391fcb558e42cc05399fa716829114323e1d01aa284445955548302d71f/)\nsubmitter from Taiwan. At the time of research, the command and control (C&C)\nserver (114.55.109[.]199) was still active.\n\n**Naming**\n\nThe name “FlowCloud” comes from a debugging string left in one of the earlier samples we\nfound:\n\n_g:\\FlowCloud\\trunk\\Dev\\src\\fcClient\\Release\\fcClientDll.pdb_\n\nThe name was also used in the configuration data of the sample analyzed for\nthis blog post as the “product_name”:\n\n_1 (product_name): \"flowcloud\"_\n\n_2 (product_version): \"v4.1.3\"_\n\n**Protocol Buffers**\n\nFlowCloud makes extensive use of a data structure known as Protocol\nbuffers (“protobufs”) in its configuration and C&C communications. “Protocol buffers are\nGoogle's language-neutral, platform-neutral, extensible mechanism for serializing structured\n[data – think XML, but smaller, faster, and simpler. You define how you want your data to be](https://developers.google.com/protocol-buffers)\nstructured once, then you can use special generated source code to easily write and read\nyour structured data to and from a variety of data streams and using a variety of languages.”\n\nAs an example, in the analyzed sample, FlowCloud stores its configuration data as a 3344byte serialized protobuf as shown in Figure 1:\n\n\n-----\n\nFigure 1 Configuration data serialized as a protobuf\n\nUsing the Protocol buffer compiler (“protoc”), the serialized data can be deserialized into a\nmore human-readable format as shown in Figure 2:\n\n\n-----\n\nFigure 2 Configuration data that has been deserialized (truncated for readability)\n\nTo recover the names of the fields, the\n[associated ProtobufCMessageDescriptor and](https://sjiang1.github.io/autoiodocu/protobuf-c_doc/structProtobufCMessageDescriptor.html) [ProtobufCFieldDescriptor structures can](https://sjiang1.github.io/autoiodocu/protobuf-c_doc/structProtobufCFieldDescriptor.html)\nbe identified as shown in Figure 3:\n\nFigure 3 Configuration data’s associated ProtobufCMessageDescriptor\n\n\n-----\n\n[We have included an IDA Pro Python script on our GitHub that can be used to parse and](https://github.com/EmergingThreats/threatresearch/blob/master/flowcloud/ida_protobufc.py)\ndisplay some of the important fields of these structures as shown in Figure 4:\n\nFigure 4 Parsed ProtobufCMessageDescriptor and ProtobufCFieldDescriptor (truncated for\nreadability)\n\nThe “id” numbers from the structures can be matched with the deserialized data for labeling\nas shown in Figure 5:\n\n\n-----\n\nFigure 5 Labeled protobuf for configuration data (truncated for readability)\n\nThe ProtobufCMessageDescriptor structure also starts with magic bytes (e.g. 0x28aaeef9),\nso these can be used to identify all the protobufs compiled into the malware. In the analyzed\nsample there were 78 protobufs included.\n\n**Configuration**\n\nIn the analyzed sample, a working directory was setup in:\n\n_C:\\Windows\\Fonts\\zitbee.fon\\_\n\n[The fully labeled configuration data is available on our GitHub . Most of its fields are self-](https://github.com/EmergingThreats/threatresearch/blob/master/flowcloud/flowcloud_config)\nidentifying and include things such as:\n\nC&C addresses (e.g. “exchange_server”)\nC&C ports (e.g. “exchange_server_port”)\nEncryption keys (e.g. “xchg_server_key”)\nVarious installation options (e.g. “install_config”)\nVarious command options (e.g. “keyboard_policy”)\n\n\n-----\n\nThe configuration data is also stored as a serialized protobuf and encrypted in a winver.dat\nfile. It is encrypted using a basic XOR and addition algorithm. We have included a Python\n[script that can be used to decrypt this config file on our GitHub .](https://github.com/EmergingThreats/threatresearch/blob/master/flowcloud/decrypt_config.py)\n\n**Dependencies**\n\nFlowCloud uses HTTP to download some dependencies from its C&C server\n(“exchange_server: exchange_server_port+1” from the config). Figure 6 shows an example:\n\nFigure 6 Example dependency download\n\nThe URIs are hardcoded into the sample. The response data starts with an encrypted 16byte header:\n\nHeader key (DWORD)\nCRC32 checksum (DWORD)\nDecrypted/decompressed data length (DWORD)\nEncrypted/compressed data length (DWORD)\n\nThe header key is used with some XOR and ROR operations to decrypt the remaining bytes\nof the header.\n\nAfter the header there is RC4 encrypted data. The RC4 key is generated by taking a\nhardcoded string (e.g. “y983nfdicu3j2dcn09wur9*^&(y4r3inf;'fdskaf'SKF”) and hashing its hex\ndigest 1000 times with MD5.\n\nThe decrypted data starts with another 16-byte header as described above. The data that\nfollows this inner header is ZLIB compressed and once decompressed contains a PE file.\n\nThe downloaded dependencies include:\n\n/SL3716/S8437AEB.DAT - SQLite\n/WC413/21FB9FCF DAT - Nmap\n\n\n-----\n\n/WC413/6EE2EFF7.DAT - Packet.dll (used with Nmap)\n/WC413/67B1B02F.DAT - wpcap.dll (used with Nmap)\n\n[We have included a Python script on our GitHub that can be used to decrypt these](https://github.com/EmergingThreats/threatresearch/blob/master/flowcloud/decrypt_dependency.py)\ndependencies.\n\n**Command and Control**\n\nC&C uses a binary protocol over TCP to “exchange_server:exchange_server_port” from the\nconfig. An example exchange is shown in Figure 7:\n\nFigure 7 Example C&C exchange\n\nBoth requests and responses are structured similarly. They start with a 28-byte header called\n“HHDR”:\n\nHeader key (DWORD)\nCRC32 checksum (DWORD)\n\n\n-----\n\nHHDR (DWORD)\nUnknown counter (DWORD)\nUnknown hardcoded 1 (DWORD)\nData length (DWORD)\nUnknown hardcoded 1 (BYTE)\nHash type (BYTE)\n\n1 is MD5\nCompression type (BYTE)\n\n1 is ZLIB\nCrypto type (BYTE)\n\n2 is RC4\n\nThe header key is used with some XOR and ROR operations to decrypt the remaining bytes\nof the header.\n\nFollowing “HHDR” is a 24-byte header called “HCMD”:\n\nHeader key (DWORD)\nCRC32 checksum (DWORD)\n“HCMD” (DWORD)\nCommand (DWORD)\nSubcommand (DWORD)\nData length (DWORD)\n\nThe header key is used with some XOR and ROR operations to decrypt the remaining bytes\nof the header.\n\nFollowing the “HCMD” header is a 16-byte header as described above in the “Dependencies”\nsection.\n\nAfter the third header there is RC4 encrypted data. The RC4 key for this data is generated by\ntaking the “xchg_server_key” from the config and hashing its hex digest one time with MD5.\n\nOnce the data is decrypted there is a final 16-byte header and ZLIB compressed data (see\nthe “Dependencies” section above).\n\n[We have included a Python script on our GitHub that can be used to decrypt these requests](https://github.com/EmergingThreats/threatresearch/blob/master/flowcloud/decrypt_comms.py)\nor responses. Figure 8 is an example output of our script:\n\n\n-----\n\nFigure 8 Example parsing of a C&C request\n\nThe decrypted data is a serialized protobuf. For example, the names of\nthe protobufs involved with command 1 subcommand 2 are:\n\nFcNet__MsgUsr\nFcNet__MsgUsr__System\nFcNet__MsgUsr__System__Adapter\n\nThis command is used to send various system information to the C&C server as shown in\nFigure 9:\n\n\n-----\n\nFigure 9 Labeled protobuf for command 1 subcommand 2 (edited for privacy)\n\n**C&C Commands**\n\nWe have identified the following commands that can be executed via C&C command polls:\n\n\n-----\n\nCommand 2 – filesystem related\n\nSubcommand 0 - get drive information\n1 - get directory listing\n2 - create directory\n3 - rename directory\n4 - write file\n5 - read file\n6 - remove directory\n7 - get file attributes\n8 - set file attributes and times\n9 - add file to \"filemgr\" list (see below)\n10 - search directory for files with a given file name pattern\n11 - ShellExecute \"open\" file with arguments\n12 - add directory to \"folderimage\" list (see below)\n3 – take a screenshot\n5 – Exfiltrate data related (see below)\n\n0 - get exfiltrate data size\n1 - get exfiltrate data file count\n2 - get exfiltrate data item list\n3 - change status of exfiltrate data\n6 – process related\n\n0 - get process list\n1 - kill process\n7 – service related\n\n0 - get service list\n1 - start service\n2 - stop service\n3 - delete service\n4 - set service start type\n9 – system related\n\n0 - get installed software\n4097 – reboot\n4098 – reboot\n4099 – NtRaiseHardError\n4100 – copy %SYSTEM%\\winver.exe to %WIN%\\System\\winver.exe\nthen NtRaiseHardError\n10 – cmd.exe command shell\n\n4097 – write command to shell\n\n\n-----\n\n11 – lateral movement related\n\n[4097 - setup port mapping using https://github.com/windworst/LCX](https://github.com/windworst/LCX)\n4098 - remove port mapping\n4099 - get port mappings\n8193 - start Nmap scan\n8194 - replies with \"Unsupported yet.\"\n8195 - get Nmap scan results\n\n**Data Exfiltration Managers**\n\nIn addition to the C&C commands, FlowCloud has some additional functionality organized as\n“data exfiltration managers\" that include:\n\n“filemgr” – exfiltrate files as specified by a C&C command\n“folderimage” – exfiltrate directories as specified by a C&C command\n“screen” - exfiltrate screenshots\n“keylog” - exfiltrate keylogging data\n\nKeylogging data is gathered by an external program and sent to FlowCloud via a\nnamed pipe (e.g. “\\\\.\\pipe\\namedpipe_keymousespy_english”)\n“audio” - possibly audio recording\n\nThe config and code hint at this functionality, but it is not implemented in the\nanalyzed sample\n“smtfile” - possibly search for and exfiltrate files based on file types and name patterns\n\nThe config and code hint at this functionality, but it is not implemented in the\nanalyzed sample\n“plugin” - download and execute additional plugins\n\nPE file exports associated with plugins:\n\n“pluginInfo”\n“startModule”\n“setOtherInterface2”\n“clipboard” - possibly steal clipboard contents\n\nThe config and code hint at this functionality, but it is not implemented in the\nanalyzed sample\n\nThese exfiltration managers run in their own execution threads and some are controlled by\n“policies” in the config. They store their data in various SQLite databases and then another\nexecution thread will eventually exfiltrate the data to the C&C server.\n\nAs an example, the “screen” exfiltration manager takes continuous screenshots according to\nits “screen_policy”:\n\nstate – is policy active\ncycle_time – sleep time between screenshots\ncache_count – maximum number of screenshots waiting to be exfiltrated\n\n\n-----\n\nbit_depth – bit depth of screenshot\n\nA screenshot is taken. Depending on its size, the data may be broken up into chunks. The\ndata is then compressed with ZLIB and encrypted with RC4 (uses “file_key” from config). As\ndescribed above, 16-byte encrypted headers are attached to the compressed and encrypted\ndata.\n\nTwo additional headers are prepended to the compressed and encrypted data. They are\nencrypted similarly to the 16-byte, 28-byte, and 24-byte headers above. The first header is\n96-bytes:\n\nHeader key (DWORD)\nCRC32 checksum of header (DWORD)\nCRC32 checksum of data (DWORD)\nProduct name (16-bytes)\nProduct version (16-bytes)\nUnknown hardcoded 1 (DWORD)\nTimestamp (QWORD)\nFile attributes (DWORD)\nData length (QWORD)\nCreation time (QWORD)\nLast access time (QWORD)\nLast write time (QWORD)\nLength of the next header (DWORD)\n\nThe second header is at least 24-bytes, but its length depends on the number of data\nchunks and length of a filename:\n\nHeader key (DWORD)\nCRC32 checksum of header (DWORD)\nHeader length (DWORD)\nOffset to end of chunk list (DWORD)\nOffset to start of chunk list (DWORD)\nNumber of chunks (DWORD)\nFile name and chunk list (variable length)\n\nThe encrypted screenshot data is then saved to a SQLite database. In the analyzed sample\nthis was stored in the file “data\\E70EEF62”. We have included an example of the schema\n[used on our GitHub, but it basically consists of a “file” table to store metadata about the data](https://github.com/EmergingThreats/threatresearch/blob/master/flowcloud/screen_schema)\nto exfiltrate and a “file_data” table that stores the data.\n\nPeriodically a separate execution thread will go through the SQLite databases created by the\nexfiltration managers and send the data to the C&C server. It uses the same C&C protocol\nas described above, but using the “file_server,” “file_server_port,” and “file_server_key”\n\n\n-----\n\nvalues from the config.\n\nThe Proofpoint threat research team analyzed and performed reverse engineering on a\nrecently discovered version (4.1.3) of the FlowCloud RAT. While the version that we analyzed\nis for Windows only, we believe that there may be additional variants. One piece of evidence\nthat may support the theory that there are additional FlowCloud variants, is the “plateform”\n(sic) field detailed in Figure 9 above. This is an enumerated data type that can have the\nfollowing values:\n\nFC_NET__USR_LIST__USR__SYSTEM__PLATEFORM_TYPE__WINDOWS\nFC_NET__USR_LIST__USR__SYSTEM__PLATEFORM_TYPE__LINUX\nFC_NET__USR_LIST__USR__SYSTEM__PLATEFORM_TYPE__MAC\nFC_NET__USR_LIST__USR__SYSTEM__PLATEFORM_TYPE__ANDROID\n\nWhile we have only seen versions of FlowCloud for Windows, this implies there may be other\nimplementations of FlowCloud for other operating systems.\n\n**ET and ETPRO Suricata/SNORT Signatures**\n\n**2842895 - ETPRO MALWARE FlowCloud Dependency Download M1**\n\n**2842896 - ETPRO MALWARE FlowCloud Dependency Download M2**\n\n**2842897 - ETPRO MALWARE FlowCloud Dependency Download M3**\n\n**2842898 - ETPRO MALWARE FlowCloud Dependency Download M4**\n\nSubscribe to the Proofpoint Blog\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-10 - FlowCloud Version 4.1.3 Malware Analysis.pdf"
    ],
    "report_names": [
        "2020-06-10 - FlowCloud Version 4.1.3 Malware Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "faa4a29b-254a-45bd-b412-9a1cbddbd5e3",
            "created_at": "2022-10-25T16:07:23.80111Z",
            "updated_at": "2025-03-27T02:02:09.985067Z",
            "deleted_at": null,
            "main_name": "LookBack",
            "aliases": [
                "FlowingFrog",
                "LookBack",
                "LookingFrog",
                "TA410",
                "Witchetty"
            ],
            "source_name": "ETDA:LookBack",
            "tools": [
                "FlowCloud",
                "GUP Proxy Tool",
                "SodomMain",
                "SodomMain RAT",
                "SodomNormal"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9ffcbb0c-7a0f-419f-a174-f18a02ce47f1",
            "created_at": "2023-01-06T13:46:39.059774Z",
            "updated_at": "2025-03-27T02:00:02.98747Z",
            "deleted_at": null,
            "main_name": "TA410",
            "aliases": [],
            "source_name": "MISPGALAXY:TA410",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536206,
    "ts_updated_at": 1743041386,
    "ts_creation_date": 1653765081,
    "ts_modification_date": 1653765081,
    "files": {
        "pdf": "https://archive.orkl.eu/9b97ad23e6a16b4d681feb41ebcdd31ceb820c7c.pdf",
        "text": "https://archive.orkl.eu/9b97ad23e6a16b4d681feb41ebcdd31ceb820c7c.txt",
        "img": "https://archive.orkl.eu/9b97ad23e6a16b4d681feb41ebcdd31ceb820c7c.jpg"
    }
}