{
    "id": "f12cb571-14cc-40bb-b3dd-b813197f65d9",
    "created_at": "2023-01-12T15:03:04.293311Z",
    "updated_at": "2025-03-27T02:06:01.225024Z",
    "deleted_at": null,
    "sha1_hash": "236d11aa6485f04d62dabc1a7e081a352ae96586",
    "title": "2020-04-04 - Nanocore & CypherIT",
    "authors": "",
    "file_creation_date": "2022-05-25T14:17:26Z",
    "file_modification_date": "2022-05-25T14:17:26Z",
    "file_size": 1901263,
    "plain_text": "# Nanocore & CypherIT\n\n**malwareindepth.com/defeating-nanocore-and-cypherit**\n\n2 years ago\n\n\nApril 4, 2020\n\n\nHello everyone! Its been a while since I've posted. There's been some changes in my life that\nhave distracted me from my malware temporarily. One of those updates is a career change. I\nwill officially be working as a security researcher and in preparation of that I felt that I\nneeded to keep my reverse engineering skills sharp. So I went to any.runs malware trends\n[page, and randomly picked a sample. I ended up picking a Nanocore sample to analyze.](https://any.run/malware-trends/)\nNanocore has been around for many years and is one of the simpler and cheaper malware\nfamilieis out there but I never had the availability during work to look at it. Since I generally\nfocus on targeted malware, I knew this was going to be a good change of pace. The sample\n[can be found here if you wish to follow along.](https://app.any.run/tasks/ba38899e-779b-4f6e-b38b-53f6bfec801b/)\n\n## Technical Analysis\n\nFirst step as usual, is opening the sample in PE studio for a quick triage.\n\n\n-----\n\nFrom the output here you can see its a Cpp application with a rather high entropy of 7.5. So\nthere is definitely some encrypted or compressed content here. You can also see that there is\nan embedded resource within the application. Immediately the AutoIT caught my eye as\nthat's not something I have dealt with before.\n\nEven more suspicious is that its almost 53% of the file, and a maximum entropy value of 8.\nSeeing the large resource immediately leads me to look for resource related calls such as\nLockResource, SizeOfResource, LoadResource etc.\n\n\n-----\n\nFindResource is only called within this function so if we assume that the AutoIT script is part\nof the malware, this function becomes increasingly important. This function will load the\nresource make some calls and load the resource data within [ebp+var_4].\n\n\n-----\n\nLooking at the call graph shows this is a leaf node for the call graph, which can potentially\nmean that execution will continue outside of the scope of this application or all the\ninformation for this chain of calls was acquired. Looking at the parent function it opens a file\npassed as an argument.\n\n\n-----\n\nLooking at calls to this function, there are references to various AutoIT strings.\n\nJumping to the Main function it calls sub_403B3A which has a anti-debugger check. It calls\nIsDebuggerPresent and if it is, opens a message box and the process terminates\n\n\n-----\n\nFollowing sub_408667, eventually the resource will be loaded from memory, and compared\nagainst a the compiled AutoIT header\n\nExecution only continues if the header is correct, so we can assume it's going to load an\nAutoIT script. This coupled with the fact that it quits if you try to debug the executable, I'm\ncomfortable in assuming this executable is going to load and run the compiled AutoIT script\nfrom its resource section.\n\n## AutoIT Script\n\nNow that we know the binary file we have been looking at is just a runtime environment for\nthe AutoIT script resource we can take a look at the script itself. Extracting the resource with\nResource Hacker and throwing it in a hex editor shows that it's a compiled script. Now there\n[are a couple tools out there used to decompile AutoIT scripts. There is Exe2Aut which is what](http://domoticx.com/autoit3-decompiler-exe2aut/)\nI went with to handle this compiled script. Although running this script through the\napplication gave the following error...\n\n\n-----\n\nAut2Exe Error\n\n[Googling around for this I found Hexacorn's post about this exact issue! Following his post](http://www.hexacorn.com/blog/2015/01/08/decompiling-compiled-autoit-scripts-64-bit-take-two/)\nwe append our compiled script to the 32 bit stub and we get a valid decompilation of the\nscript!\n\n\n-----\n\nCopying the contents to a new file in VSCode and giving it a look over immediately shows\nsomething interesting. This script is 10901 lines long. The majority of the file looks like the\nfollowing.\n\n\n-----\n\nAt the end of the file there is a large data blob that spans 3500 lines just on its own. Generally\nthis means it's some sort of payload. Loading this data blob into CyberChef shows that it is\nmost likely either compressed or encrypted. This rules simpler techniques such as XOR\nencryption.\n\n\n-----\n\nWith this information I knew I'd have to give the script a good hard look. After some googling\n[about AutoIT crypters I came across CypherIT. CypherIT is a AutoIT crypter that is sold at 5](https://cypherit.org/)\nseparate tiers. the first tier is 33$ for 1 month, 57$ for 2 months and 74$ for 3 months, 175$\nfor FUD for 2 weeks and finally a 340$ lifetime model.\n\n\n-----\n\nInterestingly enough they even have a discord server that users can join for troubleshooting\nand getting updates on new versions.\n\nGoing back to the script.... After the large data blob is finished being initialized, it is passed to\na function called skpekamgyg. This function takes the large data blob, a random string and a\nnumber as a string.\n\nThere is way too much to go into here for the crypter but these are the basic characteristics of\nit:\n\n\n-----\n\n1. unused variables\n2. unused functions\n3. string decryption\n\nI ended up writing a golang based script that can handle those 3 above cases! For this sample\nit turned the the 10901 line script into a 6600 line one. There is some more analysis that can\nhappen to remove function calls that aren't actually called by the main payload decryption\nroutine, but that would require actual function call analysis and that is out of scope for this\n[article. The script can be found here](https://github.com/myrtus0x0/DecypherIT-Nanocore/blob/master/deCypherIT.go)\n\n### String Decryption\n\nFor decrypting the strings there are a couple pieces to it.\n\n\n-----\n\n```\nfunc decryptStrings(lines []string) ([]string) {\n     var re = regexp.MustCompile(`(?m)\"\\b[0-9A-F]{2,}\\b\"`)\n     modLines := []string{}\n     for i, line := range lines {\n          matched := false\n          tempLine := \"\"\n          tempLine += line\n          for _, match := range re.FindAllString(line, -1) {\n              matched = true\n              cleaned := strings.Replace(match, \"\\\"\", \"\", -1)\n              dec, err := hex.DecodeString(cleaned)\n              if err != nil {\n                   modLines = append(modLines, tempLine)\n                   break\n              }\n              decodedStr, err := xorBrute(dec)\n              if err != nil {\n                   modLines = append(modLines, tempLine)\n                   break\n              }\n              if len(decodedStr) < 2 {\n                   modLines = append(modLines, tempLine)\n                   break\n              }\n              if decodedStr[0:2] == \"0x\" {\n                   temp, err :=\nhex.DecodeString(strings.Replace(decodedStr, \"0x\", \"\", -1))\n                   if err != nil {\n                        modLines = append(modLines, tempLine)\n                        break\n                   }\n                   decodedStr = string(temp)\n              }\n              if isASCII(decodedStr) {\n                   tempLine += \" ;\" + decodedStr\n                   fmt.Printf(\"[+] decoded string at line %d: %s\\n\", i,\ndecodedStr)\n              } else {\n                   tempLine += \" ;\" + \"BINARYCONTENT\"\n              }\n              modLines = append(modLines, tempLine)\n              break\n          }\n          if !matched {\n              modLines = append(modLines, tempLine)\n          }\n     }\n\n```\n\n-----\n\n```\n     return modLines\n}\n\n```\nI look for hex encoded strings with a regex. Then I clean the string removing extraneous\ncharacters. Once we have a valid hex string like\n307832343639373037393643363836353...33303330333033303232 we pass it to a the\nfunction xorBrute.\n```\nfunc xor(enc []byte, key byte) (string, error) {\n     ret := []byte{}\n     for i := 0; i < len(enc); i++ {\n          temp := enc[i] ^ key\n          ret = append(ret, temp)\n     }\n     return string(ret), nil\n}\nfunc xorBrute(encodedStr []byte) (string, error) {\n     switch string(encodedStr[0]) {\n     case \"0\":\n          // lazy\n          return xor(encodedStr, 0)\n     case \"1\":\n          return xor(encodedStr, 1)\n     case \"2\":\n          return xor(encodedStr, 2)\n     case \"3\":\n          return xor(encodedStr, 3)\n     case \"4\":\n          return xor(encodedStr, 4)\n     }\n     return \"\", errors.New(\"not a valid nanocore encoding\")\n}\n\n```\nA neat little property I found about this is that the first character must decode to 0 since the\nactual string must start with 0x for it to be processed properly. Now in the AutoIT script the\nfunction that decodes these hex strings takes 2 arguments, a large hex string and a single\ncharacter that is some number between 0 and 4 which is the XOR key. Since the value we are\nlooking for here with the first character is 0, we can use the fact that anything XOR'd with\nitself is 0. So while the second argument is being passed we can figure out the 1 byte key with\nthe switch statement.\n\nOnce we have the decoded string as a large hex value we do a check on the size to make sure\nwe aren't dealing with a single byte value that the regex might've picked up. Followed by a\ncheck to make sure it starts with 0x, if all those conditions are met we decode the hex value\ninto ASCII and add it as a comment to the script.\n\n\n-----\n\n### Variable Cleaning\n\nConsidering that these CypherIT scripts generally have thousands of lines, it's pretty clear\nthey have unused variables. My technique for removing variables is simplistic but effective. I\nhave a loop that can extract all of the variable names via a regex\n```\ngetVarName := regexp.MustCompile(`(?m)(Dim|Local|Global Const|Global)\\s\\$(?\nP<Name>\\w+)\\s`)\n\n```\nIf I get a variable if the \"Name\" regex group I scan every line for that name. In the script itself\nIve done this step after decoding the strings so that all variable names are in the clear.\n```\n// count the number of occurences\noccurences := 0\nfor _, secondLine := range lines {\n     if strings.Contains(secondLine, result[\"Name\"]) {\n          occurences++\n     }\n}\n// if the variable is used multiple times keep it\nif occurences > 1 {\n     modLines = append(modLines, line)\n}\n\n### Function Cleaning\n\n```\nRemoving functions were a bit more in depth than variables as you need to be able to find the\nstart and end of a function. Functions also have the added complexity that if you are\nremoving a function that isn't being called anywhere else, you might've isolated another\nfunction that isn't going to reached either. So this is function that works the best when you\ncall it multiple times. To get started, we define our regex.\n```\nvar getFuncName = regexp.MustCompile(`(?m)Func\\s(?P<Name>\\w+)`)\n\n```\nThen for every function name we extract, we check if it's being called anywhere else in the\nscript. If it's not being called anywhere else we add it to a list that contains all functions we\nare going to remove.\n\n\n-----\n\n```\nfor i, line : range lines {\n     // If it is a func declaration get the func name\n     match := getFuncName.FindStringSubmatch(line)\n     if len(match) == 0 {\n          continue\n     }\n     result := make(map[string]string)\n     // turn the regex groups into a map\n     for k, name := range getFuncName.SubexpNames() {\n          if i != 0 && name != \"\" {\n              result[name] = match[k]\n          }\n     }\n     // count the number of occurences in the new file\n     occurences := 0\n     for _, secondLine := range lines {\n          if strings.Contains(secondLine, result[\"Name\"]) {\n              occurences++\n          }\n     }\n     // if the function is just used once, find it and dont write it to the file \n     if occurences == 1 {\n          unusedFuncs = append(unusedFuncs, result[\"Name\"])\n     }\n}\n\n```\nOnce we have this list we iterate over it and find the function start with 2 string.Contains and\nwe iterate over the lines from that point until we find the EndFunc keyword.\n```\n// now that we have all of the unused functions, we need to remove them\nfor i := 0; i < len(lines); i++ {\n     for _, unusedFunc := range unusedFuncs {\n          if strings.Contains(lines[i], unusedFunc) &&\nstrings.Contains(lines[i], \"Func\") {\n              for j, secondLine := range lines[i:] {\n                   if strings.Contains(secondLine, \"EndFunc\") {\n                        i = i + j + 1\n                        break\n                   }\n              }\n          }\n     }\n     modLines = append(modLines, lines[i])\n}\n\n```\nAfter running the script against the crypter we have reduced it from 10901 lines to 6195 lines.\nThis function needs to ran a couple of times to catch code branches that do have child\nfunction calls but aren't reachable from the main function. Results will vary from script to\n\n\n-----\n\nscript, but I now have a script that only contains used functions, used variables and\ndecrypted strings.\n\n### The Final CypherIT Script\n\nThese were the high level concepts I used to simplify my CypherIT crypters, the actual script\n[itself will be listed here.](https://github.com/myrtus0x0/DecypherIT-Nanocore)\n\n### The Bad News\n\nSadly, even with all of this analysis and development work that made this crypter a lot easier\nto look at, reconstructing the shellcode itself that will AES decrypt the actual Nanocore\n[sample is out of scope for this project... Luckily the wonderful people over at Unpac.me](https://www.unpac.me/)\nmaintain a incredible service that was actually able to get the payload for me! If you haven't\nchecked out their service I'd definitely give it a try with some difficult crypters.\n\nAs you can see there is the unpacked Nanocore sample! Onto the actual analysis of the\nsample.\n\n### Nanocore Payload Analysis\n\nSo going ahead with the analysis of\n80bbde2b38dc19d13d45831e293e009ae71301b67e08b26f9445ad27df2b8ffd, Nanocore is\n[written in .NET so dnSpy will be our tool of choice. Loading it up in dnSpy shows that the](https://github.com/0xd4d/dnSpy)\ninternal classes are obfuscated.\n\n\n-----\n\nOne of the first steps I take when I see any sort of obfuscation in .NET malware is run it\n[through de4dot. De4dot is a .NET deobfuscator for many well known .NET obfuscators.](https://github.com/0xd4d/de4dot)\n\nOutput shows that de4dot was able to identify the obfuscator used, Eazfuscator. This\nobfuscator can be found free to use here. Now that we have a cleaned version of the Nanocore\nsample we are ready to actually analyze it.\n\n\n-----\n\n### Static Config Decryption\n\nLooking at PE Studio results though there is yet another encrypted resource that we need to\ndeal with.\n\nSearching for function calls within our .NET application that handle resources leads us to the\nfollowing\n\n\n-----\n\nPretty standard loading of a resource and checking the xrefs to this function we find\n\n\n-----\n\nNow we are at the the point where we can recreate this code assuming that its going to\ndecrypt the encrypted resource. As you can already see I've annotated a lot of the code\nalready to make this blog post a tad shorter.\n```\nbyte[] byte_ = binaryReader.ReadBytes(binaryReader.ReadInt32());\n\n```\nThis is the first line that we have to pay attention to. This line will read a 32bit integer from\nthe encrypted resource. Then get the GUID of the .NET application and pass it to a function\nthat is going to return a Decryptor object for us\n\nThis function starts off initializing a Rfc2898DeriveBytes object with the GUID as the\npassword and the salt. That will return a Key and IV that is then used in Rijndael in CBC\nmode to create the next piece in this chain. This function will decrypt the first 8 bytes on the\nresource and pass that back. Immediately after the 8 bytes is returned, its passed to this\nfunction below where a DES decryptor is created. These 8 bytes and then used as the Key and\nIV for the DES decryptor that will decrypt the rest of the contents of the resource.\n\nAfter this function is called, all we have is a initialized decryptor, and our content is still\nencrypted. Although a couple lines after our init function this function below is called.\n\n\n-----\n\n```\nbyte_0 = AESCrypto.icryptoTransform_1.TransformFinalBlock(byte_0, 0, byte_0.Length);\n\n```\nThis line will decrypt all the contents. Now as soon as that's finished a boolean is read from\nthe start of the decrypted contents. If the boolean is true, the rest of the contents has to be\nzlib decompressed. In total this breaks down to the following python code to re-implement.\nNow the GUID has to be changed and since I was working with a single sample I didn't write\nany code to handle the boolean being read to decompress or not, so that will have to be\nmodified as well.\n\n\n-----\n\n```\ndef decrypt_config(coded_config, key):\n     data = coded_config[24:]\n     decrypt_key = key[:8]\n     cipher = DES.new(decrypt_key, DES.MODE_CBC, decrypt_key)\n     raw_config = cipher.decrypt(data)\n     new_data = raw_config[5:]\n     decompressed_config = zlib.decompress(new_data, -15)\n     return decompressed_config\ndef derive_pbkdf2(key, salt, iv_length, key_length, iterations):\n     generator = PBKDF2(key, salt, iterations)\n     derived_iv = generator.read(iv_length)\n     derived_key = generator.read(key_length)\n     return derived_iv, derived_key\n# get guid of binary\nguid_str = 'a60da4cd-c8b2-44b8-8f62-b12ca6e1251a'\nguid = uuid.UUID(guid_str).bytes_le\n# AES encrypted key\nencrypted_key = raw_config_data[4:20]\n# rfc2898 derive IV and key\ndiv, dkey = derive_pbkdf2(guid, guid, 16, 16, 8)\n# init new rijndael cipher\nrjn = new(dkey, MODE_CBC, div, blocksize=len(encrypted_key))\n# decrypt the config encryption key\nfinal_key = rjn.decrypt(encrypted_key)\n# decrypt the config\ndecrypted_conf = decrypt_config(raw_config_data, final_key)\n\n```\nLoading the decrypted contents in a hex editor does show in fact that we have a valid\ndecrypted blob.\n\nThis blob contains various PE files being the plugins loaded as well as standard config\ninformation below\n\n\n-----\n\n-----\n\n### Config Parsing\n\nNow that our config blob is properly decrypted, we need to parse it. Running binwalk on our\noutput contents shows some interesting results.\n\n\n-----\n\nIn between the zlib compressed contents and the PNGs there are valid PE files. Now\nNanocore is a modular RAT as I had mentioned earlier. These PE files are the plugins that\nare loaded immediately after config decryption. With the following snippet I was able to\ndump each individual PE file that Nanocore is going to load.\n```\nplugins = decrypted_conf.split(\"\\x00\\x00\\x4D\\x5A\")\n# remove first snippet as its junk code\nplugins = plugins[1:]\n# Add the MZ header back cuz python is hard\n# remove the config struct at the end of the file\nwhile i < len(plugins):\n     plugins[i] = '\\x4D\\x5A' + plugins[i]\n     if \"\\x07\\x3E\\x00\\x00\\x00\" in plugins[i] and i == len(plugins)-1:\n          plugins[i] = plugins[i].split(\"\\x07\\x3E\\x00\\x00\\x00\")[0]\n     i += 1\n\n```\nHere we iterate over the config blob that's split by 2 null bytes and the MZ header. With\nNanocore's config being at the end of the file that means the last element in our list from the\nsplit is going to contain the config data when it shouldn't. The config data itself starts with\n0x07 0x3E followed by 3 null bytes. Splitting on that when we're at the last plugin and\nselecting the first element keeps the last plugin intact. Once they are split and dumped to a\ndirectory we get 8 plugins to analyze.\n\n\n-----\n\nFor the config values of the sample, each field starts with a 0x0c, a null byte, the field name,\nanother null byte then the value of the field name. In the script I search for the hardcoded\nfield names in this specific format.\n```\nlogging_rule = re.search(\"\\x0c.KeyboardLogging(?P<logging>.*?)\\x0c\", decrypted_conf)\n     logging = logging_rule.group('logging')\n     if ord(logging[1]):\n          config_dict['KeyboardLogging'] = True\n     else:\n          config_dict['KeyboardLogging'] = False\n\n```\nAfter doing this for each configuration field of the sample we can get a clear picture of this\nsample.\n\n\n-----\n\nSome of the fields aren't parsed properly but that is mainly due to lack of time. The values are\nall correct they just need to be interpreted correctly.\n\nNanocore as malware is pretty straightforward to analyze and hasn't changed much so I'll be\nskipping the analysis of the plugins. If there is demand I can write a follow up on the plugins\nas well as flaws within Nanocore's network comms.\n\nIn an effort to keep this post short, I'm going to end the analysis here but there is more work\nto be done on Nanocore and the CypherIT crypter. If anyone would like to collaborate and\nmake a true unpacker for CypherIT, please reach out.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-04-04 - Nanocore & CypherIT.pdf"
    ],
    "report_names": [
        "2020-04-04 - Nanocore & CypherIT.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535784,
    "ts_updated_at": 1743041161,
    "ts_creation_date": 1653488246,
    "ts_modification_date": 1653488246,
    "files": {
        "pdf": "https://archive.orkl.eu/236d11aa6485f04d62dabc1a7e081a352ae96586.pdf",
        "text": "https://archive.orkl.eu/236d11aa6485f04d62dabc1a7e081a352ae96586.txt",
        "img": "https://archive.orkl.eu/236d11aa6485f04d62dabc1a7e081a352ae96586.jpg"
    }
}