{
    "id": "20c23cd5-9d67-4ca3-97be-47a8afdd48da",
    "created_at": "2023-01-12T15:00:09.651966Z",
    "updated_at": "2025-03-27T02:09:00.927043Z",
    "deleted_at": null,
    "sha1_hash": "75019423015f9e3da1e6aaf1938890e5ed5e8ac2",
    "title": "2021-08-04 - See Ya Sharp- A Loader’s Tale",
    "authors": "",
    "file_creation_date": "2022-05-28T03:50:59Z",
    "file_modification_date": "2022-05-28T03:50:59Z",
    "file_size": 1338160,
    "plain_text": "# See Ya Sharp: A Loader’s Tale\n\n**[mcafee.com/blogs/enterprise/mcafee-enterprise-atr/see-ya-sharp-a-loaders-tale/](https://www.mcafee.com/blogs/enterprise/mcafee-enterprise-atr/see-ya-sharp-a-loaders-tale/)**\n\nBy [Max Kersten on Aug 04, 2021](https://www.mcafee.com/blogs/author/max-kersten/)\n\n## Introduction\n\n\nAugust 4, 2021\n\n\nThe DotNet based CyaX-Sharp loader, also known as ReZer0, is known to spread commodity malware, such as AgentTesla.\nIn recent years, this loader has been referenced numerous times, as it was used in campaigns across the globe. The tale of\nCyaX-Sharp is interesting, as the takeaways provide insight into the way actors prefer to use the loader. Additionally, it shines\na light onto a spot that is not often illuminated: the inner workings of loaders.\n\nThis blog is split up into several segments, starting with a brief preface regarding the coverage of loaders in reports. After that,\nthe origin of the loader’s name is explored. Next, the loader’s capabilities are discussed, as well as the automatic extraction of\nthe embedded payload from the loader. Lastly, the bulk analysis of 513 unique loader samples is discussed.\n\n## Loaders and their Coverage in Blogs\n\nTo conceal the malware, actors often use a loader. The purpose of a loader is, as its name implies, to load and launch its\npayload, thereby starting the next stage in the process. There can be multiple loaders that are executed sequentially, much\nlike a Russian Matryoshka doll in which the smallest doll, which is hidden inside numerous others, is the final payload. The\n\n\n-----\n\nsmallest doll generally contains the malware s main capabilities, such as stealing credentials, encrypting files, or providing\nremote access to the actor.\n\nWhile there is a lot of research into the actions of the final payload, the earlier stages are just as interesting and relevant.\nEven though the earlier stages do not contain the capabilities of the malware that is eventually loaded, they provide insight as\nto what steps are taken to conceal the malware. Blogs generally mention the capabilities of a loader briefly, if at all. The\ndownside here lies in the potential detection rules that others can create with the blog, as the focus is on the final step in the\nprocess, whereas the detection should start as soon as possible.\n\nPer best security practices, organizations should protect themselves at every step along the way, rather than only focusing on\nthe outside perimeter. These threat models are often referred to as the, respectively, onion and egg model. The egg’s hard\nshell is tough to break, but once inside, an attacker has free roam. The onion model opposes the attacker every step of the\nway, due to its layered approach. Knowing the behavior of the final payload is helpful to detect and block malware although,\nideally, the malware would be detected as early on as possible.\n\nThis blog focuses on one specific loader family, but the takeaways are valid in a broader sense. The preferred configurations\nof the actors are useful to understand how loaders can be used in a variety of attacks.\n\n## Confusing Family Names\n\nA recent [blog by G Data’s Karsten Hahn provides a more in-depth look into malware families ambiguous naming schemes.](https://www.gdatasoftware.com/blog/malware-family-naming-hell)\nThis loader’s name is also ambiguous, as it is known by several names. Samples are often named based on distinctive\ncharacteristics in them. The name CyaX-Sharp is based upon the recurring string in samples. This is, however, exactly why it\nwas also named ReZer0.\n\nWhen looking at the most used names within the 513 obtained samples, 92 use CyaX-Sharp, whereas 215 use ReZer0. This\nwould make it likely that the loader would be dubbed ReZer0, rather than CyaX-Sharp. However, when looking at the sample\nnames over time, as can be seen in the graph below, the reason why CyaX-Sharp was chosen becomes apparent: the name\nReZer0 was only introduced 8 months after the first CyaX-Sharp sample was discovered. Based on this, McAfee refers to this\nloader as CyaX-Sharp.\n\nWithin the settings, one will find V2 or V4. This is not a reference of the loader’s version, but rather the targeted DotNet\nFramework version. Within the sample set, 62% of the samples are compiled to run on V4, leaving 38% to run on V2.\n\n## The Loader’s Capabilities\n\nEach version of the loader contains all core capabilities, which may or may not be executed during runtime, based on the\nloader’s configuration. The raw configurations are stored in a string, using two pipes as the delimiting value. The string is then\nconverted into a string array using said delimiter. Based on the values at specific indices, certain capabilities are enabled. The\nscreenshots below show, respectively, the raw configuration value, and some of the used indices in a sample (SHA-256:\na15be1bd758d3cb61928ced6cdb1b9fa39643d2db272909037d5426748f3e7a4).\n\n\n-----\n\nThe loader can delay its execution by sleeping for a certain number of seconds, use a mutex to ensure it is not already\nrunning, display a message box with a custom message, persist itself as a scheduled task, and/or execute a given payload in\nseveral ways. The payload can be downloaded from an external location, after which it is started. Alternatively, or additionally,\nthe embedded payload within the loader can be launched. This can be done directly from the loader’s memory with the help of\nreflective calls, or by hollowing a newly created process. The flowchart below visualizes the process. Note that the dotted line\nmeans the linked step can be skipped, depending on the loader’s configuration.\n\n### Process Hollowing\n\nThe newly created process is one of the following: MSBuild.exe, vbc.exe, RegSvcs.exe, or a new instance of the loader. The\n[process hollowing code segment seems to be taken from NYAN-x-CAT’s GitHub, as the for-loop to start the process hollowing](https://github.com/NYAN-x-CAT/CSharp-RunPE/blob/master/RunPE/RunPE.cs)\nmethod is present in both the loader and the linked repository. The way an error is handled is not a standardized method,\n\n\n-----\n\nmaking the link between the publicly available code very likely. The first image below shows the original code from the\nrepository, whereas the second image shows the code from the loader (SHA-256:\na15be1bd758d3cb61928ced6cdb1b9fa39643d2db272909037d5426748f3e7a4)\n\nThe loop calls the process hollowing function several times to more easily handle exceptions. In the case of an exception\nduring the process hollowing, the targeted process is killed and the function returns. To try several times, a loop is used.\n\n### Changes Over Time\n\nEven though the loader has changed over time, it maintained the same core structure. Later versions introduced minor\nchanges to existing features. Below, different loader versions will be described, where the length of the string array that\ncontains the loader’s configuration is used to identify different versions. The graph shows the rise and fall for each of the\nversions.\n\nThere are two notable differences in versions where the config array’s size is larger than 29. Some specific samples have\nslightly different code when compared with others, but I did not consider these differences sizable enough to warrant a new\nversion.\n\n\n-----\n\nFirstly, the ability to enable or disable the delayed execution of a sample. If enabled, the execution is delayed by sleeping for a\npredefined number of seconds. In config_29, the delay functionality is always enabled. The duration of the delay is based on\nthe `System.Random object, which is instantiated using the default seed. The given lower and upper limits are 45,000 and`\n60,000, resulting in a value between these limits, which equals in the number of milliseconds the execution should be delayed.\n\nSecondly, the feature to display a custom message in a prompt has been added. The config file contains the message box’\ntitle, text, button style, and icon style. Prompts can be used to display a fake error message to the victim, which will appear to\nbe legitimate e.g. 43d334c125968f73b71f3e9f15f96911a94e590c80955e0612a297c4a792ca07, which uses “You do not have\nthe proper software to view this document” as its message.\n\n## Payload and Configuration Extraction\n\nTo automatically extract the payload and configuration of a given loader, one can recreate the decryption mechanism in a\nlanguage of choice, get the encrypted data from the loader, and decrypt it. The downside here is the need for an exact copy of\nthe decryption mechanism. If the key were to change, or a slightly different algorithm were to be used, the copy would also\nneed to reflect those changes. To avoid dealing with the decryption method, a different approach can be taken.\n\nThis loader mistakenly uses static variables to store the decrypted payload and configuration in. In short, these variables are\ninitialized prior to the execution of the main function of the loader. As such, it is possible to reflectively obtain the value of the\n[two variables in question. A detailed how-to guide can be found on my personal website. The data that was extracted from the](https://maxkersten.nl/binary-analysis-course/analysis-scripts/automatic-rezer0-payload-and-configuration-extraction/)\n513 samples in the set is discussed in the next section.\n\n## Bulk Analysis Results\n\n[The complete set consists of 513 samples, all of which were found using a single Yara rule. The rule focuses on the](https://github.com/advanced-threat-research/Yara-Rules/blob/master/malware/MAL_cyax_sharp_loader.yar)\nembedded resource which is used to persist the loader as a scheduled task on the victim’s system. In some cases, the Yara\nrule will not match a sample, as the embedded resource is obfuscated using ConfuserEx (one example being SHA-256\n0427ebb4d26dfc456351aab28040a244c883077145b7b529b93621636663a812). To deobfuscate, one can use ViRb3’s\n[de4dot-cex fork of](https://github.com/ViRb3/de4dot-cex) [de4dot. The Yara rule will match with the deobfuscated binary. The graph below shows the number of](https://github.com/de4dot/de4dot)\nunique samples over time.\n\nThe dates are based on VirusTotal’s first seen date. Granted, this date does not need to represent the day the malware was\nfirst distributed. However, when talking about commodity malware that is distributed in bulk, the date is reliable enough.\n\nThe sample set that was used is smaller than the total amount of loaders that have been used in the wild. This loader is often\nnot the first stage, but rather an in-memory stage launched by another loader. Practically, the sample set is sizable enough for\nthis research, but it should be noted that there are more unique loader samples in the wild for the given date range than are\nused in this report.\n\n\n-----\n\nIt is useful to know what the capabilities of a single sample are, but the main area of interest of this research is based upon\nthe analysis of all samples in the set. Several features will be discussed, along with thoughts on them. In this section, all\npercentages refer to the total of 513 unless otherwise specified.\n\n### Widespread Usage\n\nThe loader’s usage is widespread, without a direct correlation towards a specific group or geographical region. Even though\nsome reports mention a specific actor using or creating this loader, the fact that at least one builder has leaked makes\nattribution to one or more actors difficult. Coupled with the wide variety of targeted industries, as well as the broad geographic\ntargeted areas, it looks like several actors utilise this loader. The goal of this research is not to dig into the actors who utilise\nthis loader, but rather to look at the sample set in general. Appendix A provides a non-exhaustive list of public articles that (at\nleast) mention this loader, in descending chronological order.\n\n### Execution Methods\n\nThe two options to launch a payload, either reflectively or via process hollowing, are widely apart in usage: 90% of all loaders\nuses process hollowing, whereas only 10% of the samples are launched via reflection. Older versions of the loader sometimes\nused to reflectively load a decrypted stager from the loader’s resources, which would then launch the loader’s payload via\nprocess hollowing. The metrics below do not reflect this, meaning the actual percentage of direct launches might be slightly\nlower than is currently stated. The details can be viewed in the graph below.\n\nNote that the reflective loading mechanism will default to the process hollowing of a new instance of the loader if any\nexception is thrown. Only DotNet based files can be loaded reflectively, meaning that other files that are executed this way will\nbe loaded using a hollowed instance of the loader.\n\n### Persistence and Mutexes\n\nThe persistence method, which uses a scheduled task to start the loader once the computer boots, is used by 54% of the\nloaders. This does not mean that the other 46% of the samples are not persisted on the victim’s machine, as a different stage\ncould provide persistence as well. Notable is the date within the scheduled task, which equals 2014-10-25T14:27:44.8929027.\nThis date is, at the time of writing, nearly 2500 days ago. If any of the systems in an organization encounter a scheduled task\nwith this exact date, it is wise to verify its origin, as well as the executable that it points to.\n\nA third of all loaders are configured to avoid running when an instance is already active using a mutex. Similar to the\npersistence mechanism, a mutex could be present in a different stage, though this is not necessarily the case. The observed\nmutexes seem to consist of only unaccented alphabetical letters, or `[a-zA-Z]+ when written as a regular expression.`\n\n\n-----\n\n### Delayed Execution\n\nDelayed execution is used by nearly 37% of the samples, roughly half of which are config_29, meaning this setting was not\nconfigurable when creating the sample. The samples where the delayed execution was configurable, equal nearly 19% of the\ntotal. On average, a 4 second delay is used. The highest observed delay is 600 seconds. The graph below shows the duration\nof the delay, and the frequency.\n\nNote that one loader was configured to have a delay of 0 seconds, essentially not delaying the execution. In most cases, the\ndelayed time is a value that can be divided by five, which is often seen as a round number by humans.\n\n### Environmental Awareness\n\nPrior to launching the payload, the loader can perform several checks. A virtual environment can be detected, as well as a\nsandbox. Roughly 10% of the samples check for the presence of a virtual machine, whereas roughly 11% check if it is\nexecuted in a sandbox. Roughly 8% of the 513 samples check for the presence of both, prior to continuing their execution. In\nother words, 88% of the samples that try to detect a virtual machine, also attempted to detect a sandbox. Vice versa, 74% of\nthe samples that attempted to detect the sandbox, attempted to detect if they were executed on a virtual machine.\n\nThe option to disable Windows Defender was mainly present in the earlier samples, which is why only 15% of the set attempts\nto disable it.\n\n### Payload Families\n\nThe loader’s final goal is to execute the next stage on the victim’s machine. Knowing what kind of malware families are often\ndropped can help to find the biggest pain points in your organization’s additional defensive measures. The chart below\nprovides insight into the families that were observed the most. The segment named other contains all samples that would\notherwise clutter the overview due to the few occurrences per family, such as the RedLine stealer, Azorult, or the lesser known\nMrFireMan keylogger.\n\n\n-----\n\nThe percentages in the graph are based on 447 total payloads, as 66 payloads were duplicates. In other words, 66 of the\nunique loaders dropped a non-unique payload. Of all families, AgentTesla is the most notable, both in terms of frequency and\nin terms of duplicate count. Of the 66 duplicates, 48 were related to AgentTesla.\n\n### Barely Utilized Capabilities\n\nTwo functions of the loader that are barely used are the message box and the download of a remote payload. The usage of\nboth is, respectively, 1.3% and 0.8%. All of the remote payloads also contained an embedded payload, although one of the\nfour remotely fetching loaders does not contain a URL to download the remote payload from. The external file can be used as\nan additional module for a next stage, a separate malicious payload, or it can be used to disable certain defense mechanisms\non the victim’s device.\n\n## Conclusion\n\nCompanies using the aforementioned onion security model benefit greatly from the dissection of such a loader, as their\ninternal detection rules can be improved with the provided details. This stops the malware’s execution in its tracks, as is\nshown in the sequential diagram of McAfee’s detection below.\n\n\n-----\n\nThe techniques that this loader uses are commonly abused, meaning that the detection of a technique such as process\nhollowing will also prevent the successful execution of numerous other malware families. McAfee’s Endpoint Security (ENS)\nand Endpoint Detection & Response (EDR) detect the CyaX-Sharp loader every step of the way, including the common\ntechniques it uses. As such, customers are protected against a multitude of families based on a program’s heuristics.\n\n## Appendix A – Mentions of CyaX-Sharp and ReZer0\n\nBelow, a non-exhaustive chronologically descending list of relevant articles is given. Some articles contain information on the\ntargeted industries and/or target geographical area.\n\nOn the 12 of January 2021, ESETth [mentioned the loader in its Operation Spalax blog](https://www.welivesecurity.com/2021/01/12/operation-spalax-targeted-malware-attacks-colombia/)\n[On the 7 of December 2020, ProofPoint wrote about the decryption mechanisms of several known .NET based packersth](https://www.proofpoint.com/us/blog/threat-insight/commodity-net-packers-use-embedded-images-hide-payloads)\n[On the 5 of November 2020, Morphisec mentioned a packer that looks a lot like this loaderth](https://blog.morphisec.com/agent-tesla-a-day-in-a-life-of-ir)\nOn the 6 of October 2020, G Datath [mentioned the packer (or a modified version)](https://www.gdatasoftware.com/blog/2020/06/36129-harmful-logging-diving-into-masslogger)\n[On the 29 of September 2020, ZScaler mentioned the packerth](https://www.zscaler.com/blogs/security-research/targeted-attacks-oil-and-gas-supply-chain-industries-middle-east)\nOn the 17 of September 2020, Ith [wrote about the automatic payload and config extraction of the loader](https://maxkersten.nl/binary-analysis-course/analysis-scripts/automatic-rezer0-payload-and-configuration-extraction/)\nOn the 16 of September 2020, the Taiwanese CERTth [mentioned the loader in a digital COVID-19 threat case study](https://blog.apnic.net/2020/09/16/how-covid-19-changed-the-cyber-threat-landscape-in-taiwan/)\nOn the 23 of July 2020, ClamAVrd [mentioned the loader in a blog](https://blog.clamav.net/2020/07/writing-clamav-signature-for-masslogger.html)\n[On the 14 of May 2020, Security firm 360TotalSecurity links the loader to the threat actor Vendettath](https://blog.360totalsecurity.com/en/vendetta-new-threat-actor-from-europe/)\n[On the 21 of April 2020, Fortinet provided insight into the loader’s inner workingsst](https://www.fortinet.com/blog/threat-research/deconstructing-an-evasive-formbook-campaign-leveraging-covid-19-themes)\nOn the 1 of March 2020, RVSEC0Nst [mentioned the loader](https://rvsec0n.wordpress.com/2020/03/01/study-notes-of-wmi/)\n[On the 4 of December 2019, Trend Micro provided a backstory to CyaX-Sharpth](https://www.trendmicro.com/en_nl/research/19/l/obfuscation-tools-found-in-the-capesand-exploit-kit-possibly-used-in-kurdishcoder-campaign.html)\n[On the 22nd of March 2019, 360TotalSecurity gave insight into some of the loader’s features](https://blog.360totalsecurity.com/en/analysis-of-serominer-trojan-combine-multiple-anti-analytic-techniques/)\n\n\n## Appendix B – Hashes\n\nThe hashes that are mentioned in this blog are listed below, in order of occurrence. The SHA-1 and SSDeep hashes are also\n[included. A full list of hashes for all 513 samples and their payloads can be found here.](https://github.com/advanced-threat-research/IOCs/tree/master/2021/2021-07-27-see-ya-sharp)\n\n**Sample 1**\n\nSHA-256: a15be1bd758d3cb61928ced6cdb1b9fa39643d2db272909037d5426748f3e7a4\n\nSHA-1: 14b1a50c94c2751901f0584ec9953277c91c8fff\n\n\n-----\n\nSSDeep: 12288:sT2BzlxlBrB7d1THL1KEZ0M4p b6m0yn1MX8Xs1ax XdjD3ka:O2zBrB7dlHxv0M4p b50yn6MXsSovUa\n\n**Sample 2**\n\nSHA-256: 43d334c125968f73b71f3e9f15f96911a94e590c80955e0612a297c4a792ca07\n\nSHA-1: d6dae3588a2a6ff124f693d9e23393c1c6bcef05\n\nSSDeep:\n24576:EyOxMKD09DLjhXKCfJIS7fGVZsjUDoX4h/Xh6EkRlVMd3P4eEL8PrZzgo0AqKx/6:EyycPJvTGVijUDlhfEEIUvEL8PrZx0AQ\n\n**Sample 3**\n\nSHA-256: 0427ebb4d26dfc456351aab28040a244c883077145b7b529b93621636663a812\n\nSHA-1: 8d0bfb0026505e551a1d9e7409d01f42e7c8bf40\n\nSSDeep: 12288:pOIcEfbJ4Fg9ELYTd24xkODnya1QFHWV5zSVPjgXSGHmI:EEj9E/va\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-08-04 - See Ya Sharp- A Loader’s Tale.pdf"
    ],
    "report_names": [
        "2021-08-04 - See Ya Sharp- A Loader’s Tale.pdf"
    ],
    "threat_actors": [
        {
            "id": "64d750e4-67db-4461-bae2-6e75bfced852",
            "created_at": "2022-10-25T16:07:24.01415Z",
            "updated_at": "2025-03-27T02:02:10.077988Z",
            "deleted_at": null,
            "main_name": "Operation Spalax",
            "aliases": [],
            "source_name": "ETDA:Operation Spalax",
            "tools": [
                "AsyncRAT",
                "Bladabindi",
                "Jorik",
                "Remcos",
                "RemcosRAT",
                "Remvio",
                "Socmer",
                "njRAT"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "3a0cfbbc-2acf-4cc8-afe1-1859679c522c",
            "created_at": "2022-10-25T16:07:24.373716Z",
            "updated_at": "2025-03-27T02:02:10.198532Z",
            "deleted_at": null,
            "main_name": "Vendetta",
            "aliases": [
                "TA2719"
            ],
            "source_name": "ETDA:Vendetta",
            "tools": [
                "AsyncRAT",
                "Atros2.CKPN",
                "Nancrat",
                "NanoCore",
                "NanoCore RAT",
                "ReZer0",
                "Remcos",
                "RemcosRAT",
                "Remvio",
                "RoboSki",
                "Socmer",
                "Zurten"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535609,
    "ts_updated_at": 1743041340,
    "ts_creation_date": 1653709859,
    "ts_modification_date": 1653709859,
    "files": {
        "pdf": "https://archive.orkl.eu/75019423015f9e3da1e6aaf1938890e5ed5e8ac2.pdf",
        "text": "https://archive.orkl.eu/75019423015f9e3da1e6aaf1938890e5ed5e8ac2.txt",
        "img": "https://archive.orkl.eu/75019423015f9e3da1e6aaf1938890e5ed5e8ac2.jpg"
    }
}