{
    "id": "f9a0d323-2956-4f37-a009-ad2ce5c58549",
    "created_at": "2023-01-12T15:09:30.968077Z",
    "updated_at": "2025-03-27T02:06:11.159278Z",
    "deleted_at": null,
    "sha1_hash": "99dcc94e7bcb55719445950302a924517c4a11a3",
    "title": "2022-04-07 - Looking Inside Pandora’s Box",
    "authors": "",
    "file_creation_date": "2022-05-28T18:21:25Z",
    "file_modification_date": "2022-05-28T18:21:25Z",
    "file_size": 274377,
    "plain_text": "# Looking Inside Pandora’s Box\n\n**[fortinet.com/blog/threat-research/looking-inside-pandoras-box](https://www.fortinet.com/blog/threat-research/looking-inside-pandoras-box)**\n\nApril 7, 2022\n\nIn Greek mythology, opening of the infamous Pandora’s box (jar) introduced terrible things to\nthe world. That can also be said about today’s ransomware. The newly emerged Pandora\nransomware that crowned the name is no exception. It steals data from the victim’s network,\nencrypts the victim’s files, and unleashes the stolen data if the victim opts not to pay. The\nGreek myth says hope was left in the box. Does that hold true for Pandora ransomware, an\nemerging malware that shows all techniques used by modern ransomware? In this blog we\nare taking a hammer and crowbar to look inside today’s Pandora’s box to find out what\nmysteries it holds. We will discuss:\n\nHow this ransomware tries to evade detection\nThe numerous obfuscation and anti-analysis techniques that are used to hinder\nanalysts\nHow multi-threading is used to speed up processing\nHow the filesystem is processed\n\n\n-----\n\nHow and which files are encrypted.\n\n**Affected Platforms: Windows**\n**Impacted Users: Windows users**\n**Impact: Most files on the compromised machines are encrypted**\n**Severity Level: Medium**\n\n## Pandora Group\n\nThe Pandora ransomware group emerged into the already crowded ransomware field as\nearly as in mid-February 2022 and targets corporate networks for financial gain. The group\ngot recent publicity after they announced that they acquired data from an international\nsupplier in the automotive industry. The incident came as surprise as the attack came two\nweeks after another automotive supplier was reportedly hit with unknown ransomware, which\nresulted in one of the world’s biggest car manufacturers suspending factory operations. The\nthreat group uses the double extortion method to increase pressure on the victim. This\nmeans that they not only encrypt the victim’s files, but also exfiltrate them and threaten to\nrelease the data if the victim does not pay.\n\nThe Pandora Group has a leak site in the Dark Web (TOR network), where they publicly\nannounce their victims and threaten them with the data leak. There are currently three\nvictims listed on the leak site (see Figure 1), a U.S.-based real estate agency, a Japanese\ntechnology company, and a U.S. law firm.\n\nFigure 1 - Pandora's leak site\n\n## Malware Analysis\n\nWe analyzed the sample with the SHA-256 hash\n5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b, which is a\n64-bit Windows PE file. It is the ransomware itself, so by the time this file is executed during\nan attack, the attackers probably already had extensive access to the victim’s network, and\nthey had already exfiltrated the data they will use for the extortion. This sample does not\nhave the capability to communicate with the threat actors. Its sole purpose is to find and\nencrypt files. However, it does this in an interesting and complex manner.\n\nIn the following sections these interesting aspects of the malware will be discussed.\n\n### Execution Flow\n\nThe sample goes through the following steps:\n\nNote that “T” followed by numbers within brackets refers to MITRE ATT&CK technique ID,\nwhich are summarized at the end of the post.\n\n\n-----\n\n1) Unpacking: The sample is packed with a modified UPX packer (T1027.002), so the first\nstep is to unpack the real content to memory and jump to it. This will be discussed later.\n\n2) Mutex: It creates a mutex called ThisIsMutexa.\n\n3) Disable Security Features: It can delete Windows shadow copies (T1490), bypass AMSI\n(T1562.001), and disable Event Logging (T1562.002). More on these features later.\n\n4) Collects system information: GetSystemInfo()is used to collect information about the\nlocal system.\n\n5) Loads Hardcoded Public Key: A public key is hardcoded in the malware sample. This is\nused to set up the cryptography for encryption.\n\n6) Store Private and Public Keys in Registry: A private key is generated, and both the\nhardcoded public key and the newly generated private key are stored in the registry\n(T1112).\n\n7) Search Drives: It searches for unmounted drives on the system and mounts them to\nencrypt them as well (T1005).\n\n8) Setup Multi-Threading: The sample uses worker threads to distribute the encryption\nprocess. More on this later.\n\n9) Enumerate Filesystem: The worker threads start to enumerate the filesystems of the\nidentified drives (T1083).\n\n10) Drop Ransom Note: The ransom note is dropped in every folder in\nRestore_My_Files.txt.\n\n11) Check File Name Blacklist: For every file and folder a blacklist of file/folder names is\nchecked. If the file/folder is on the blacklist it will not be encrypted. More on this later.\n\n12) Check File Extension Blacklist: Each file is checked against a file extension blacklist. If\nthe extension is on the list, it will not be encrypted.\n\n13) Unlock File: If the file is locked by a running process, the sample will try to unlock it\nusing the Windows Restart Manager(T1489).\n\n14) Encrypt File: The worker threads will encrypt(T1486) the file and write it back to the\noriginal file.\n\n15) Rename File: Once the encryption is finished the file is renamed\nto[original_filename].pandora.\n\n## Anti-Reverse Engineering Techniques\n\n\n-----\n\nOne of the most significant aspect of the Pandora ransomware is the extensive use of antireverse-engineering techniques. This is not new for malware, but Pandora lies on the\nextreme side of how much is invested in slowing analysis down. In this section we will go\nthrough the different techniques that were identified.\n\n### Packed\n\nThe sample is packed with a modified UPX packer, which can be easily detected with Detect\nIt Easy (see Figure 2).\n\nFigure 2: Detect It Easy can identify UPX\n\nHowever, the standard UPX unpacker does not work, which indicates that the packer was\nmodified to make sure that off-the-shelf tools cannot be used to unpack it.\n\nUnpacking is still relatively easy, by scrolling down from the entry point to the end of the code\nin a debugger. The code will end with a jump (Figure 3). This is typical with packers, that\nafter unpacking the original code somewhere in memory they will jump there, instead of\nreturning from the main function.\n\nFigure 3: Tail jump at the end of the unpacking\n\nBy putting a breakpoint to the tail jump we can dump the PE file from memory including the\nunpacked code. With the dumped file we can analyze the ransomware statically as well.\n\n### Control-Flow Flattening\n\nControl-Flow Flattening is an obfuscation technique that can hide the structure of the\nprogram by modifying the control-flow. In the simplest case, it replaces the normal control\nflow of each function with a state machine, thus it makes harder for an analyst to quickly\nunderstand how each function works. Pandora uses a more complex control-flow flattening\ncombined with opaque predicates, to complicate the control flow even further.\n\nFigure 4: Graph view of main()\n\nFigure 4 shows the graph view of the main function in the unpacked code. We can see that it\ndoes not resemble a normal function’s control flow. It looks like a huge switch-case\nstatement, which is the result of the control-flow flattening that implements a state machine.\nHowever, in Pandora’s case most of the basic blocks are not connected at all. This is the\nresult of the opaque predicates. Most of the jumps between basic blocks are calculated at\nruntime, as shown in Figure 5.\n\nFigure 5: Calculating the address for the jmp in runtime\n\n\n-----\n\nThe first cmp instruction checks the current state of the state machine and depending on that\ncalculates the value of the rdx register for the jmp at the end of the basic block. Because of\nthis static analysis tools, such as IDA Pro cannot understand where the control flow will\ncontinue, and thus cannot connect the basic blocks in Figure 4.\n\nEmulation can be used to understand the control flow to a limited degree but debugging had\nto be applied extensively to be sure how the execution flows.\n\n### String Encoding\n\nSome strings can be found in the unpacked binary, but most of them are from the statically\nlinked libraries. However, the strings that would help us understand what is happening in the\ncode are encoded. Figure 6 shows how one of the string decryption functions is called.\n\nFigure 6: Calling one of the string decryption functions\n\nBoth the address of the decryption function, which is called through rax, and the address of\nthe encoded string, are calculated at runtime. This way, when looking at this code statically,\nthere is no way to know what is happening here. The comment on the right side is the result\nof an IDAPython script that uses the [flare-emu project to emulate the code and calculate the](https://github.com/mandiant/flare-emu)\naddresses of the function call, as well as emulate the decryption function. This solution was\nvery effective in recovering the encoded strings in the binary. The decryption function\nimplements an XOR decoding. The decryption keys are stored together with each encoded\nstring. As a bonus, the malware uses multiple decryption functions. We identified 14\nseparate functions that are used for string decoding.\n\n### Function Call Obfuscation\n\nIt was already mentioned in the previous section that most function calls are not calling a\ndirect address, but a register. Its value is calculated at runtime.\n\nIf we use Figure 6 as an example the address in rax is calculated like this:\n\nrax = *(*address_table_base + 638300900) - 1426601284)\n\nAs mentioned, this was solved using emulation. By emulating the execution of a function, we\ncould calculate the register values at CALL instructions. This allowed us to resolve function\ncalls at scale.\n\n### Windows API Call Obfuscation\n\nContrary to other malware, the Windows API function names are not encoded, but another\nobfuscation technique is used to hide their usage. As shown in Figure 7, the Windows API\nfunctions are organized in a jump table. At each address there is a jmp instruction that\nredirects to the library function.\n\n\n-----\n\nFigure 7: Windows API function jump table\n\nResolving the API functions was implemented in the same flare-emu IDAPython script that\nresolves the function calls. Whenever a CALL [register] points to a jmp instruction (see\nFigure 8), instead of the beginning of a function, then we assumed that it points to the API\nfunction jump table. So we took the name of the operand of the jump and used that to\ngenerate the comments for the function call (see Figure 9).\n\nFigure 8: Recovering API function name in the emulation script\n\nFigure 9: The script recovered that this is a function call to OpenMutexA\n\n## Multi-Threading\n\nPandora uses multiple threads to speed up the encryption process. For that it uses\nWindows’s [IO Completion Ports concept. This allows threads to wait for a file/network handle](https://docs.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports)\nto appear in the IO Completion Port queue and process them. Pandora uses unassociated\nIO Completion Ports and sends any data through it using the OVERLAPPED structure. In\nthis case drives and file paths will be passed to threads to process (enumerate or encrypt)\nthem. The IO Completion Port is set up using the CreateIOCompletionPort() API function as\nshown in Figure 10. By passing INVALID_HANDLE_VALUE as the first parameter (rcx =\n0xFFFFFFFFFFFFFFFF) and NULL as the second (rdx = 0x0) an unassociated IO\nCompletion Port is created. The fourth parameter is the NumberOfConcurrentThreads, which\nis set to 4 (r9 = 0x4), defines that maximum 4 threads are allowed to work with this IO\nCompletion Port.\n\nFigure 10: Initializing an IO Completion Port\n\nAfter this, the main function will start the new threads. The communication between the\nthreads is done using the GetQueuedCompletionStatus() and PostQueuedCompletionStatus\nAPI functions. Figure 11 shows how a discovered file (pydisas.py) is put in the queue with\nPostQueuedCompletionStatus(). Another thread will pick up this task with\nGetQueuedCompletionStatus(), and since it receives a full path to a file it will encrypt and\nrename it.\n\nFigure 11: Posting the file path to the IO Completion Port's queue\n\n## Restart Manager\n\nThe Restart Manager is a Windows feature to reduce the number of restarts needed during\ninstallation and updates. The reason for a restart is usually because a file that needs to be\nupdated is locked by a running process. The Restart Manager can save the state and stop\n\n\n-----\n\nthe locking process to unlock the target file. Once the update is finished, it can restore the\nlocking process again. Pandora uses the Restart Manager to make sure that even files that\nare currently locked will be encrypted. For each file the following process is executed:\n\n1)   Create Restart Manager session with RmStartSession()\n\n2)   Register the target file as a resource with RmRegisterResource()\n\n3)   Check if the target file is locked by any process with RmGetList()\n\n4)   If so, terminate locking processes\n\n5)   End Restart Manager session with RmEndSession()\n\n## Encryption\n\nBefore a file is encrypted, Pandora does the following checks to make sure that it does\nnot render the machine inoperable. Each target file is checked against the following\nblacklist of file and folder names. If the target file is on the list, Pandora will not encrypt\nit.\n\n\nAppData\n\nBoot\n\nWindows\n\nWindows.old\n\nTor Browser\n\nInternet Explorer\n\nGoogle\n\nOpera\n\nOpera Software\n\nMozilla\n\nMozilla Firefox\n\n\n$Recycle.Bin\n\nProgramData\n\nAll Users\n\nautorun.inf\n\nboot.ini\n\nbootfont.bin\n\nbootsect.bak\n\nbootmgr\n\nbootmgr.efi\n\nbootmgfw.efi\n\ndesktop.ini\n\n\niconcache.db\n\nntldr\n\nntuser.dat\n\nntuser.dat.log\n\nntuser.ini\n\nthumbs.db\n\nProgram Files\n\nProgram Files (x86)\n\n#recycle\n\n..\n\n.\n\n\nEach target file is compared to the following list of file extensions. If the file’s extension\nis on the list, the file will not be encrypted:\n\n.hta .exe .dll .cpl .ini .cab .cur .drv .hlp .icl .icns .ico .idx .sys .spl .ocx\n\n\n-----\n\nThe ransom note, shown in Figure 12, promises an RSA-2048 encryption. The fact that\nmalware is shipped with a hardcoded RSA-2048 public key (Figure 13) confirms this claim.\n\nFigure 12: Ransom note\n\nFigure 13: Hardcoded RSA public key\n\nA private key is also generated and both of these keys are stored in the registry under\nHKCU\\SOFTWARE\\[Private,Public] (see Figure 14).\n\nFigure 14: Cryptographic keys are stored in the Registry\n\n[The unpacked binary contains the Mbed TLS cryptographic library statically linked.](https://github.com/ARMmbed/mbedtls)\n\nOnce a file is encrypted in memory, it is written to disk. After that the file is renamed to have\nthe .pandora extension.\n\n## Disabling Security Features\n\nThe Pandora ransomware has the capabilities to disable some of the security measures on\nthe target machine.\n\n### Deleting Shadow Copies\n\nLike a lot of other ransomware, Pandora deletes the Windows Shadow Copies, which could\nhelp the operator restore the machine to a state before the infection. Figure 15 shows the\ncall to ShellExecuteW() with the parameters from runtime(T1059). We can see that it uses\nthe vssadmin.exe.\n\nFigure 15: Deleting shadow copies with ShellExecuteW\n\n### AMSI Bypass\n\nThe Antimalware Scan Interface (AMSI) allows security products to integrate better with\nWindows to be able to scan all kinds of different objects, such as PowerShell scripts,\nJavaScript, VBScript, etc. By bypassing AMSI, the malware can take away significant\ncapabilities from the security products running on the machine. Pandora bypasses AMSI by\npatching the AmsiScanBuffer() function in the amsi.dll in memory.\n\n### Disable Event Log\n\nSimilar to the AMSI bypass, Pandora disables the Event Tracing for Windows (ETW) feature,\nby patching the EtwEventWrite() function in the Windows kernel (ntdll.dll). Figure 16 shows\nthat the first byte of the function is replaced with 0xC3, which is the ret instruction. This\nrenders the EtwEventWrite() function useless, because after every call it return immediately\nwithout logging the event.\n\n\n-----\n\nFigure 16: Patching the EtwEventWrite function to return immediately\n\n## Conclusion\n\nThe Pandora ransomware contains all of the most important features that state-of-the-art\nransomware samples usually contain. The level of obfuscation to slow down analysis is more\nadvanced than average malware. The threat actor also paid attention to unlock files to\nguarantee the maximum encryption coverage, while still allowing the machine to run. We can\nalready see anti-security product features. We can expect the threat actor to develop these\ncapabilities further. There is currently no proof that Pandora operates as Ransomware-as-aService (RaaS), but the time investment in the complexity of the malware might indicate that\nthey are moving in that direction in the long term. The current attacks and leaks might be a\nway to make their name in the ransomware field, which they could capitalize on if they adopt\nthe RaaS model later. It is worth tracking the threat actor to monitor how their malware\nchanges.\n\n### Fortinet Protection\n\nThe analyzed Pandora ransomware sample is detected by the following (AV) signature:\n\nW64/Filecoder.EGYTYFD!tr.ransom\n\nFortiEDR also detects and mitigates execution of Pandora ransomware through the\ncombination of behavioral analysis, and integration with machine learning and threat\nintelligence feeds. Execution of the Pandora sample analyzed as part of this blog triggers\nseven rules resulting in nine security events. Triggered rules were a result of pre-execution\nanalysis and post-execution behaviors. These security events can be observed below in\nFigure 16.\n\nFigure 16. FortiEDR security events generated following execution of Pandora ransomware\nsample. Note that during this execution FortiEDR was set to only log events rather than\nmitigate to properly demonstrate detections post-execution.\n\nPre-execution detections included; identifying the malicious file (hash based), detection of a\nsuspicious packer and presence of writeable code. Post-execution detections included;\ndetection of each file encryption attempt, detection of encrypted file rename attempt,\ndropping of the ransom-note and attempts to access SMB shares.\n\nIn Protect mode FortiEDR will detect and mitigate detected behavior. In the case of Pandora\nthis will prevent execution of the ransomware, mitigating malicious activity before it occurs,\nand will prevent subsequent file encryption attempts if the adversary is able to execute the\nsample. The post exploitation detections are not dependent on signature meaning they will\neffectively mitigate this activity for newer Pandora variants even with no prior knowledge of\nthe samples.\n\n\n-----\n\n## IOCs:\n\nMutex: ThisIsMutexa\nRansom note: Restore_My_Files.txt\nSHA256 hash of hardcoded public key:\n7b2c21eea03a370737d2fe7c108a3ed822be848cce07da2ddc66a30bc558af6b\nSHA256 hash of sample:\n5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b\n\n## ATT&CK TTPs\n\n**TTP Name** **TTP ID** **Description**\n\n\nObfuscated Files or Information:\nSoftware Packing\n\nImpair Defenses: Disable Windows\nEvent Logging\n\nImpair Defenses: Disable or Modify\nTools\n\n\nT1027.002 Modified UPX packer\n\nT1562.002 Disable Event Logging\n\nT1562.001 Bypass AMSI\n\n\nData from Local System T1005 Searches unmounted drives and\npartitions\n\nModify Registry T1112 Cryptographic keys are stored in\nthe registry\n\nData Encrypted for Impact T1486 As a ransomware it encrypts files\n\nCommand and Scripting Interpreter T1059 Uses cmd.exe to remove the\nshadow copies\n\nSystem Information Discovery T1082 Collects system information with\nGetSystemInfo()\n\nFile and Directory Discovery T1083 Discovers drives and enumerates\nfilesystems\n\n\n-----\n\nInhibit System Recovery T1490 Deletes shadow copies\n\nService Stop T1489 Terminates processes if they lock a\nfile\n\n_Learn more about Fortinet’s_ _[FortiGuard Labs threat research and intelligence organization](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)_\n_[and the FortiGuard Security Subscriptions and Services portfolio.](https://www.fortinet.com/fortiguard/labs?tab=security-bundles&utm_source=blog&utm_campaign=security-bundles)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-07 - Looking Inside Pandora’s Box.pdf"
    ],
    "report_names": [
        "2022-04-07 - Looking Inside Pandora’s Box.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536170,
    "ts_updated_at": 1743041171,
    "ts_creation_date": 1653762085,
    "ts_modification_date": 1653762085,
    "files": {
        "pdf": "https://archive.orkl.eu/99dcc94e7bcb55719445950302a924517c4a11a3.pdf",
        "text": "https://archive.orkl.eu/99dcc94e7bcb55719445950302a924517c4a11a3.txt",
        "img": "https://archive.orkl.eu/99dcc94e7bcb55719445950302a924517c4a11a3.jpg"
    }
}