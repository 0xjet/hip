{
    "id": "07b18255-e9d1-4080-90bb-3267b2d220e5",
    "created_at": "2023-01-12T15:02:57.383812Z",
    "updated_at": "2025-03-27T02:09:18.793193Z",
    "deleted_at": null,
    "sha1_hash": "187a5248d161c624373e02b7bb6c9eccee06e5e3",
    "title": "2021-04-20 - How attackers abuse Access Token Manipulation (ATT&CK T1134)",
    "authors": "",
    "file_creation_date": "2022-05-27T22:05:06Z",
    "file_modification_date": "2022-05-27T22:05:06Z",
    "file_size": 1690896,
    "plain_text": "# How attackers abuse Access Token Manipulation (ATT&CK T1134)\n\n**[elastic.co/blog/how-attackers-abuse-access-token-manipulation](https://www.elastic.co/blog/how-attackers-abuse-access-token-manipulation)**\n\nApril 20, 2021\n\n[In our previous blog post on Windows access tokens for security practitioners, we covered:](https://www.elastic.co/blog/introduction-to-windows-tokens-for-security-practitioners)\n\nThe relationship between logon sessions and access tokens\nHow network authentication works in Windows environments\n\nHaving covered some of the key concepts in Windows security, we will now build on this\nknowledge and start to look at how attackers can abuse legitimate Windows functionality to\nmove laterally and compromise Active Directory domains.\n\n\nThis blog has deliberately attempted to abstract away the workings of specific Windows\nnetwork authentication protocols (e.g., NTLM and Kerberos) where possible. As a\nconsequence, there may be instances where behaviour unique to these protocols differs with\nthe behavior described below. It also assumes some basic understanding of the Kerberos\nauthentication protocol .1\n\nAdditionally, the material covered in this blog series was used for a BlackHat 2020\n[presentation, “Detecting Access Token Manipulation”. The presentation can be found here](https://www.youtube.com/watch?v=RMVyYvt0bLY)\n[and the slides here.](https://i.blackhat.com/USA-20/Thursday/us-20-Burgess-Detecting-Access-Token-Manipulation.pdf)\n\n\n-----\n\n## Access Token Manipulation (ATT&CK technique: T1134)\n\nHaving explained the basic principles of how logon sessions and access tokens work in our\nprevious blog post, both locally and for distributed applications, this section will explain how\nattackers can abuse access tokens and target the fundamental trust relationships in\nWindows domains to compromise entire networks. The aim of this section is to describe\n[access token manipulation techniques used by attackers within the context of a simulated](https://attack.mitre.org/techniques/T1134/)\ncompromise.\n\nAs a note, there is already an extensive body of excellent research on access token\nmanipulation (which will be linked to liberally throughout this post). This blog attempts to\nbuild on this body of knowledge via considering access token manipulation from a different\napproach, namely through the relationship between access tokens, logon sessions and\ncached credentials. In the author's opinion, any description of token manipulation without\nconsidering these relationships represents only the tip of the iceberg. As a consequence, this\nblog’s definition of access token manipulation is perhaps much broader than commonly\nunderstood.\n\n## Initial compromise\n\nIn the event that an attacker obtains a foothold in a network via spear phishing, they will\ntypically end up with a shell running in the security context of the compromised user. This\ncould be achieved via spawning a new process or injecting directly into memory (depending\non the payload), but the end result is the same: the attacker’s code is running in a process\nwhich has an access token belonging to the compromised user.\n\nThis means that any local access checks will use the compromised user’s access token\nand any remote authentication attempts will use the compromised user’s cached\ncredentials . Hence, the attacker can, both locally and across the network, perform 2 _all the_\nactions that the compromised user can. For example, if any internal web applications use\nWindows SSO, an attacker will be able to access them as if they were the user.\n\n## Token Manipulation: The ‘Art of the possible’\n\n\nTypically, an attacker will want to move from the compromised endpoint to another host as\n_quickly as possible . When considering 3_ **lateral movement from a token manipulation**\nperspective, the attacker effectively has three options, each of which is constrained by the4\nfundamental relationship between access tokens, logon sessions, and cached credentials,\nas illustrated below:\n\n\n-----\n\nFigure 1 - The relationship between access tokens, logon sessions and cached credentials\n\nIf an attacker wants to move laterally via Windows SSO then all of these three links must be\nin place (e.g., they have a handle to a token which is linked to a logon session backed by\ntheir target credentials). Otherwise, an attacker’s freedom of movement relies on either\n**creating new links (e.g., new logon sessions) or modifying existing ones (e.g., changing**\ncached credentials or the logon session that their access token points to). These constraints\nare discussed in more detail in the three options below:\n\n### 1. Steal the token of an already logged-on privileged user (non-network logon)\n\nIf another privileged user is already logged on to the compromised host, an attacker can\nescalate their privileges and obtain a handle to an access token representing this user.\nIrrespective of whether the attacker impersonates the stolen token or starts a new process, if\nthat token is linked to a non-network logon session, it will have cached credentials, and\nhence the attacker can auth off the box to another host . Hence, this technique allows an5\nattacker to use another user’s credentials to access remote hosts across the network (via\nWindows SSO), and therefore pivot without needing to dump credentials . 6\n\n\nAs a note, token manipulation attacks generally relate to two distinct objectives: moving\nlaterally (which this blog is concerned with) and local privilege escalation . Token theft 7 _tends_\nto be associated with the latter (e.g., stealing/impersonating a token for the purpose of\nbypassing local access checks, rather than for the purpose of using the cached credentials\nfor remote authentication) and so this blog will not discuss it in any further detail, but the\nfollowing resources are useful further reading:\n\n### 2. Create a new logon session with stolen credentials and impersonate the returned token or spawn a new process with it\n\n\n-----\n\nIn this case, there is no privileged user already logged on (and hence no corresponding\n**useful access token/logon session), but the attacker still needs to find a way to change their**\n_security context._\n\nHence, the attacker must find credentials elsewhere and use these stolen credentials to\ncreate a new logon session as the compromised user. As Windows will automatically cache\ncredentials for certain logon types, the attacker can now obtain a newly minted access token\nwhich is backed up by the stolen credentials. Once the attacker has a handle to a token\nrepresenting the compromised user, they can authenticate off the box making use of the\nstandard Windows SSO process.\n\n[Typically, plain text credentials are found by attackers via either Kerberoasting or searching](https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1)\nfor unsecured plain text credentials across all accessible resources, such as network shares,\nSharepoint, internal wikis, enterprise GitHub, Zendesk, etc.8\n\n### 3. Change the cached credentials associated with their current access token to stolen credentials (e.g., legitimately via an API or “illegitimately” by directly modifying lsass memory)\n\nIn this scenario, rather than create a new logon session, the attacker modifies the cached\ncredentials associated with their current access token (and hence logon session). As we\n[shall see, many Windows Security Support Providers (SSPs) provide native ways to do this](https://docs.microsoft.com/en-us/windows/win32/rpc/security-support-providers-ssps-)\n(and which do notrequire elevated privileges).\n\nAlternatively, attackers can go the “direct” route and manually modify cached credentials\nstored in lsass. This requires elevated privileges in order to obtain a write handle (e.g.,\n[PROCESS_VM_WRITE) to lsass via](https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights) [OpenProcess. This is typical of pass-the-hash type](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)\nattacks as we shall cover later on.\n\n## Access Token Manipulation attacks\n\nThis blog post will look at four common techniques used by attackers (all of which can be\nclassified as variations of option 3 above):\n\nThe NETONLY flag\nPass-The-Ticket\nPass-The-Hash\nOverpass-The-Hash\n\n### 1. The NETONLY flag\n\n\n[The Windows API provides the LogonUser function to create a new logon session for a given](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-logonuserw)\nuser (or principal) :9\n\n\n-----\n\n```\nBOOL LogonUserW(\n LPCWSTR lpszUsername,\n LPCWSTR lpszDomain,\n LPCWSTR lpszPassword,\n DWORD  dwLogonType,\n DWORD  dwLogonProvider,\n PHANDLE phToken\n);\n\n```\nThe key parameter to take note of here is the dwLogonType, which specifies the type of\nlogon to perform. For example, in the case of a user physically logging into their workstation,\nit will be set to LOGON32_LOGON_INTERACTIVE. The logon type specified will determine\nthe type and privileges of the token returned.\n\nFor example, in the case of an interactive logon, LogonUserW will return a primary access\ntoken, and, if UAC is enabled, this token will be a filtered token (meaning it will be medium\n[integrity and unelevated). This has one exception: if the user is a local administrator account](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works)\n(e.g., a *-500 [SID) Windows will automatically return an elevated token10.](https://support.microsoft.com/en-gb/help/243330/well-known-security-identifiers-in-windows-operating-systems)\n\n\nIn the case of a network logon (LOGON32_LOGON_NETWORK), an impersonation token is\nreturned (as typically this would be used by a server to perform work on the remote clients\nbehalf). Furthermore, if the user is in the local administrators group, the token is elevated\nand has all privileges enabled . 11\n\nThese permutations of LogonUser are captured in the table below:\n\n\ndwLogonType Token\nreturned\n\n\nCache\ncredentials?\n\n\nIs returned token\nelevated? (if\nadmin)\n\n\nInteractive\n(LOGON32_LOGON_INTERACTIVE)\n\nInteractive (Local admin account, e.g.,\nrid-500)\n\nNetwork\n(LOGON32_LOGON_NETWORK)\n\nNetwork (Local admin account, e.g.,\nrid-500\n\n\nPrimary Yes No (UAC applies)\n\nPrimary Yes Yes\n\nImpersonation No12 Yes (+ all\nprivileges\nenabled)\n\n\nImpersonation No Depends on\nremote UAC\nsettings13\n\n\nTable 1 - The permutations of LogonUser for the corresponding dwLogonType\n\n\n-----\n\nThe key point is that LogonUser returns a handle to a newly minted token, which can now\nbe used for impersonation.\n\nIf the token returned is a primary token it must first be converted in to an impersonation\n[token via DuplicateTokenEx by passing a](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex) [TokenType of TokenImpersonate14:](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-token_type)\n```\nBOOL DuplicateTokenEx(\n HANDLE            hExistingToken,\n DWORD            dwDesiredAccess,\n LPSECURITY_ATTRIBUTES    lpTokenAttributes,\n SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,\n TOKEN_TYPE          TokenType,\n PHANDLE           phNewToken\n);\n\n```\nThe [SetThreadToken function can then be used to assign the returned impersonation token](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadtoken)\nto the current thread:\n```\nBOOL SetThreadToken(\n PHANDLE Thread,\n HANDLE Token\n);\n\n```\n[Alternatively, the Windows API provides the ImpersonateLoggedOnUser function, which will](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser)\nallow the calling thread to impersonate the security context of the user represented by the\ntoken passed:\n```\nBOOL ImpersonateLoggedOnUser(\n HANDLE hToken\n);\n\n```\n\nImpersonateLoggedOnUser has the added benefit that it will automatically check the type of\n[the token passed and convert it to an impersonation token (via NtDuplicateToken) if a](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntduplicatetoken)\nprimary token was passed (as this token typecannotbe used by a thread to impersonate)15.\n\nNote that from a defense evasion perspective, both these impersonation APIs are lightweight\n[wrappers over the undocumented syscall NtSetInformationThread (e.g., called with a](http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/NT%20Objects/Thread/NtSetInformationThread.html)\n[ThreadInformationClass of](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ps/psquery/class.htm) [ThreadImpersonationToken). Therefore, they are a good target](http://undocumented.ntinternals.net/index.html?page=UserMode/Undocumented%20Functions/NT%20Objects/Thread/THREAD_INFORMATION_CLASS.html)\nfor attackers to use direct syscalls to bypass user-mode hooks via techniques such as\n[https://github.com/jthuraisamy/SysWhispers.](https://github.com/jthuraisamy/SysWhispers)\n\nFurthermore, it is important to stress that Windows has strict rules around impersonation.\n[These are listed below and taken from the MSDN page for ImpersonateLoggedOnUser:](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser)\n\n\n-----\n\n```\nAll impersonate functions, including ImpersonateLoggedOnUser allow the requested\nimpersonation if one of the following is true:\n  - The requested impersonation level of the token is less than\nSecurityImpersonation, such as SecurityIdentification or SecurityAnonymous\n  - The caller has the SeImpersonatePrivilege privilege.\n  - A process (or another process in the caller’s logon session) created the token\nusing explicit credentials through LogonUser or LsaLogonUser function.\nThe authenticated identity is the same as the caller\n\n```\nAdditionally, the impersonated token’s integrity level must also be less or equal to the calling\nprocess’s integrity level or else the impersonation call will also fail16. Therefore, assuming an\n**unelevated attacker logs on an admin user interactively via stolen credentials, and UAC is**\nenabled, they will receive an unelevated (e.g., filtered) token back and hence will have no\nissues impersonating the returned user and moving laterally, etc.\n\n\n**“The curious /NETONLY flag”17**\n\nAn attacker may find however that attempting to log on a user with stolen credentials fails.\nThis may be due to a multitude of reasons, such as the credentials are valid, but the account\ndoes not have permissions to log onto that specific workstation / they’re only valid in a\ndifferent domain, etc.Furthermore,the attacker may also want to avoid logging in a highly\nprivileged account entirely, as this may appear highly anomalous in certain contexts (e.g., a\ndomain admin logging on to a low privileged business user’s host should be incredibly\nsuspicious).18\n\n\nIn this scenario the LOGON32_LOGON_NEW_CREDENTIALS flag comes to the attacker’s\nrescue. If an attacker calls the LogonUserW function with this flag and passes a valid set of\ncredentials (say found from sniffing around on file shares), Windows will enable the caller to\nduplicate their current token but make it point to a new logon session, referred to as a New\nCredentials logon session, which caches the stolen credentials. As a result, the user still has\nthe same security context locally (e.g., they still have a copy of the same access token; it just\npoints to a new logon session), however, any attempts to authenticate remotely will supply\nthe new credentials passed in the call to LogonUserW19. This is illustrated in the diagram\nbelow:\n\n\n-----\n\nFigure 2 - How the LOGON32_LOGON_NEW_CREDENTIALS flag works under the hood\n\nHence, the LOGON32_LOGON_NEW_CREDENTIALS flag provides a native mechanism to\nmake your current access token point to a different logon session and hence different\ncredentials.20\n\nNote, that calling LogonUserW with the LOGON32_LOGON_NEW_CREDENTIALS flag\n**does not validate the credentials when the call is made (they can be complete junk), but are**\nonly validated by a Domain Controller at the time of any remote authentication requests.\n\n[As a further example, a quick review of the code for the ‘MakeToken’ task from the open](https://github.com/cobbr/Covenant/blob/5b90f203c2e42c0f0e5607653c71f6fc452adaab/Covenant/Data/Tasks/SharpSploit.Credentials.yaml#L13-L48)\nsource .NET C2 framework Covenant reveals exactly the same approach: it takes a\nusername/password combination and creates a new logon session/token with them via\npassing the LOGON32_LOGON_NEW_CREDENTIALS flag before proceeding to\nimpersonate the returned token.\n\n\n[Furthermore, you can replicate the exact same behaviour with CreateProcessWithLogonW](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithlogonw)\nby passing a dwLogonFlags of LOGON_NETCREDENTIALS_ONLY.21\n\n\n-----\n\n```\nBOOL CreateProcessWithLogonW( \n LPCWSTR        lpUsername,\n LPCWSTR        lpDomain,\n LPCWSTR        lpPassword,\n DWORD         dwLogonFlags,\n LPCWSTR        lpApplicationName,\n LPWSTR        lpCommandLine,\n DWORD         dwCreationFlags,\n LPVOID        lpEnvironment,\n LPCWSTR        lpCurrentDirectory,\n LPSTARTUPINFOW    lpStartupInfo,\n LPPROCESS_INFORMATION lpProcessInformation\n);\n\n```\nThe key difference is that this involves spawning a new process with the returned token, as\nopposed to the intra process impersonation discussed previously. In fact, the built in\nWindows utility, runas, is a simple wrapper around CreateProcessWithLogonW and the\n**/NETONLY flag provides a native way to spawn a new process with different network-only**\ncredentials, as demonstrated below:\n\nFigure 3 - Example of using the runas /NETONLY flag to spawn a new process as the user\nastro\\cosmo but with different cached credentials.\n\nIn exactly the same way as previously described, the new command prompt appears locally\nto be running as the same user (i.e., the attributes cached in the token are the same for any\n**local access checks; hence whoami returns ‘astro\\cosmo’), but any remote authentication**\nattempts will be performed using the stolen credentials for the ‘ASTRO\\Administrator’ user.\n\n\n-----\n\n[These logon sessions can be viewed using SysInternals LogonSessions tool. Logon](https://docs.microsoft.com/en-us/sysinternals/downloads/logonsessions)\nsessions that were created with the NewCredentials flag can be determined by the Logon\ntype field as shown below:\n\nFigure 4 - Example of a NewCredentials logon session which is typically generated by the\nNETONLY flag\n\nFurthermore, anomalous NewCredentials logon sessions (e.g., produced via the NETONLY\ngadget) leave artifacts in the Windows event logs. These can be identified via the event id\n4642 and a LogonType of 9. An example is shown in the image below:\n\n\n-----\n\nFigure 5 - Example of a Windows Event Log for Event ID 4624 which is typically generated\nby the NETONLY flag\n\nNote that the original user is shown by the SubjectUserName field and the specified network\nonly credentials (e.g., the credentials passed) are displayed in the\nTargetOutboundUser/DomainName fields.22\n\n**Auto-elevation**\n\nOne further quirk from a local privilege escalation perspective is that for rid-500 accounts,\n[CreateProcessWithLogonW will automatically elevate the returned token for interactive](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithlogonw)\n[logons (e.g. it will ignore UAC). Therefore, CreateProcessWithLogonW can be passed a](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithlogonw)\nlocal/domain admin account in order to execute an elevated process from a\n**medium/unelevated context.**\n\nThis behavior can be verified using runas. For example, when runas is used to spawn a\nprocess using a local admin account (e.g., `runas /user:\"Administrator\" cmd.exe ), the`\nresulting process will be elevated (e.g., high integrity). However, when a non rid-500 account\nis used (but which is still in the local administrators group) the resulting process will be\nunelevated (e.g., it will be a filtered token / medium integrity).\n\nNotice that this behaviour is consistent with the permutations listed for LogonUserW in Table\n1. Therefore, an unelevated attacker could also log on a (non rid-500) admin user as a\nnetwork logon and receive an elevated token with all privileges enabled.\n\n\nHowever, as per the impersonation rules previously outlined, the attacker should not actually\nbe able to do anything with this token as any attempts to impersonate the elevated token\nshould fail, as it has a higher integrity level than the caller. Nevertheless, it is actually\npossible to duplicate the elevated token, lower the integrity level of the copied token to\nmedium (NB ‘isElevated’ is still true)23, and start impersonating the elevated token from an\nunelevated/medium integrity context24. Hence, from an impersonation token perspective, you\ncan bypass the default Windows behaviour of only elevating certain accounts and\nimpersonate an elevated token irrespective of whether the account is a rid-500 account or\nnot.\n\n**Process creation**\n\n\nNote, that by default, when you create a child process it inherits your primary token even if\nyou are currently impersonating another security context25. For example, if you are\n[impersonating a SYSTEM token and you call CreateProcess(), it will still inherit a copy of the](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa)\nprimary process token (rather than inheriting the SYSTEM security context of the thread).26\n\nTherefore, if an attacker wishes to spawn a new process in a different security context, they\nmust either:\n\n\n-----\n\nUse CreateProcessWithLogonW with explicit credentials (as previously discussed)\n[Call either CreateProcessWithTokenW or](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw) [CreateProcessAsUserW and pass a handle](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw)\nto a token (e.g., with the token returned from LogonUser or more commonly via a\nstolen token)\n\nBoth of these functions can be passed a handle to a token which represents the security\ncontext of the new process.27\n```\nBOOL CreateProcessWithTokenW(\n HANDLE        hToken,\n DWORD         dwLogonFlags,\n LPCWSTR        lpApplicationName,\n LPWSTR        lpCommandLine,\n DWORD         dwCreationFlags,\n LPVOID        lpEnvironment,\n LPCWSTR        lpCurrentDirectory,\n LPSTARTUPINFOW    lpStartupInfo,\n LPPROCESS_INFORMATION lpProcessInformation\n);\nBOOL CreateProcessAsUserW(\n HANDLE        hToken,\n LPCWSTR        lpApplicationName,\n LPWSTR        lpCommandLine,\n LPSECURITY_ATTRIBUTES lpProcessAttributes,\n LPSECURITY_ATTRIBUTES lpThreadAttributes,\n BOOL         bInheritHandles,\n DWORD         dwCreationFlags,\n LPVOID        lpEnvironment,\n LPCWSTR        lpCurrentDirectory,\n LPSTARTUPINFOW    lpStartupInfo,\n LPPROCESS_INFORMATION lpProcessInformation\n);\n\n```\n\nFor example, CreateProcessAsUserW is typically used by the operating system itself to\nspawn the user’s shell following a successful logon (it is also used by the Secondary Logon\nservice when a user calls creatProcessWithLogonW). In this sense, it allows a user to “inject\na process into the logon session of their choice”28. As a note, both of these APIs are\n[wrappers around CreateProcessInternalW (located in KernelBase.dll).](https://doxygen.reactos.org/d9/dd7/dll_2win32_2kernel32_2client_2proc_8c.html#a13a0f94b43874ed5a678909bc39cc1ab)\n\nThe key difference here is that the caller must have certain privileges to call these two\nAPIs29. From an attackers perspective though the goal here is the same; obtain code\nexecution in the security context of the target user for the purposes of moving laterally.\n\nOne interesting quirk is that the PowerShell Empire framework was forced to take this\nprocess spawning approach (which is arguably much noisier from a detection perspective)\ndue to limitations with how PowerShell handles impersonation and multi-threading, as the\nnotes [here explain in more detail.](https://github.com/PowerShellMafia/PowerSploit/blob/c7985c9bc31e92bb6243c177d7d1d7e68b6f1816/Exfiltration/Invoke-TokenManipulation.ps1#L10-L17)\n\n\n-----\n\nIn any case, the workflow for using process spawning token manipulation techniques\nremains the same. Once the attacker has obtained a handle to the token (via\n[OpenProcess/OpenProcessToken if primary token, or](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess) [OpenThread/OpenThreadToken in the](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread)\ncase of a thread impersonating) the attacker must call DuplicateTokenEx to create a local\n(primary) copy of the target token, and then supply this copy to either the\nCreateProcessWithTokenW or CreateProcessAsUserW functions.\n\nNote that again in this case, attackers are only interested in privileged logon sessions which\nare non network logins, as network logins do not cache credentials and so\n**cannotauthenticate to other hosts.**\n\n### 2. Pass-The-Ticket\n\nWindows provides a native method to perform a very similar technique to the NETONLY flag\nusing [Kerberos30. This technique is even more powerful in the sense that it doesn’t require](https://docs.microsoft.com/en-us/windows/win32/secauthn/kerberos-ssp-ap)\nan attacker to create a new logon session, but rather arbitrarily change the cached Kerberos\ncredentials (e.g., TGT) associated with their logon session (and hence current access token),\nas demonstrated below:\n\nFigure 6 - How the Pass-the-ticket attack works under the hood. In this example, the user,\nASTRO\\cosmo, applies the stolen TGT of the ASTRO\\Administrator user to their current\nlogon session.\n\nIn order to start interacting with the Kerberos SSP and manage the Kerberos ticket cache, a\n[process can call LsaCallAuthenticationPackage (located in Sspicl.dll):](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-lsacallauthenticationpackage)\n\n\n-----\n\n```\nNTSTATUS LsaCallAuthenticationPackage( \n HANDLE  LsaHandle,\n ULONG   AuthenticationPackage,\n PVOID   ProtocolSubmitBuffer,\n ULONG   SubmitBufferLength,\n PVOID   *ProtocolReturnBuffer,\n PULONG  ReturnBufferLength,\n PNTSTATUS ProtocolStatus\n);\n\n```\n[Note that the user will need to have previously called LsaConnectUntrusted in order to obtain](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-lsaconnectuntrusted)\n[a connection handle to the LSA server and LsaLookupAuthenticationPackage to find the id of](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-lsalookupauthenticationpackage)\nthe kerberos package (MICROSOFT_KERBEROS_NAME_A). Additionally, inspection of\nthese functions in IDA (again they can be located in Sspicl.dll) will reveal that they are\nconnecting to the Lsa via RPC.31.\n\n\nThrough LsaCallAuthenticationPackage, a user can make a number of sensitive requests,\nalthough the exact requests available to the user depend on whether they are elevated or\nnot. For example, an unelevated user can perform basic ticket management actions32, such\nas enumerating their current active tickets, purging the ticket cache, and applying arbitrary\n**tickets to their current logon session33. Hence, this effectively enables a user to change**\nthe credentials cached with their current logon session and therefore specify arbitrary\n**_network only credentials._**\n\nAdditionally, from an elevated context34 an attacker can enumerate and dump tickets (e.g.,\ncredentials) belonging to other users, therefore providing similar functionality to mimikatz\nwithoutneeding to open a handle to lsass35.\n\n\nA full list of the types of messages that can be sent to the Kerberos authentication package\n[can be found here. In order to change the current TGT associated with a given logon](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/ne-ntsecapi-kerb_protocol_message_type)\nsession, the KerbSubmitTicketMessage can be passed, which uses the following message\nstruct:\n```\nTypedef struct _KERB_SUBMIT_TKT_REQUEST {\n  KERB_PROTOCOL_MESSAGE_TYPE MessageType;\n  LUID LogonId;\n  ULONG Flags;\n  KERB_CRYPTO_KEY32 Key;\n  ULONG KerbCredSize;\n  ULONG KerbCredOffset;\n} KERB_SUBMIT_TKT_REQUEST, *PKERB_SUBMIT_TKT_REQUEST\n\n```\nTherefore, for a KerbSubmitTicketMessage, the ProtocolSubmitBuffer parameter simply\npoints to a block of memory consisting of a KERB_SUBMIT_TKT_REQUEST struct followed\n[immediately by an ASN encoded Kerberos ticket (which is the ticket to be applied to the](https://www.ietf.org/rfc/rfc4120.txt)\nspecified logon session). The relevant code in mimikatz for submitting\n[KerbSubmitTicketMessage requests can be found here and in Rubeus here.](https://github.com/gentilkiwi/mimikatz/blob/fe4e98405589e96ed6de5e05ce3c872f8108c0a0/mimikatz/modules/kerberos/kuhl_m_kerberos.c#L100-L127)\n\n\n-----\n\nFollowing the call to LsaCallAuthenticationPackage, the user s TGT has now been updated\nto the stolen ticket. From this point forward, any attempts to access network resources by\nany process/thread which is linked to the user’s access token/interactive logon session will\n**automatically authenticate over Kerberos using the stolen TGT (e.g., by requesting different**\nservice tickets/TGS for resources across the domain).\n\nNote, that a user can only have one TGT associated with their current logon session. Hence,\napplying a new ticket will wipe the user’s previous ticket. What if an attacker would like to\npreserve their current TGT? In this case, once again the NETONLY flag comes to the rescue\n\n[- an attacker can create a “sacrificial” NETONLY process via CreateProcessWithLogonW](https://github.com/GhostPack/Rubeus#asktgt)\nwith arbitrary/junk credentials. This will create a new dummy process and, most importantly,\na new logon session (and hence access token) to which a stolen TGT can be applied (and\nhence preserve the user’s current ticket)36.\n\nOne important conclusion to draw from this technique for defense practitioners, is that as all\nthe activity is performed via LsaCallAuthenticationPackage (and hence over RPC), it does\nnot require any direct interaction with lsass (N.B. direct here refers to opening a handle to\nlsass via OpenProcess). Furthermore, for this specific use case (ptt), all the activity is via\nlocal RPC until an attacker attempts to authenticate to a remote host (which will generate\nnew logons).\n\n[As a further example, the README for Rubeus includes the following statement:](https://github.com/GhostPack/Rubeus#example-credential-extraction)\n\n“Rubeus doesn't have any code to touch LSASS (and none is intended), so its functionality is\nlimited to extracting Kerberos tickets through use of the LsaCallAuthenticationPackage()\nAPI”\n\nTherefore, any detection logic which is predicated on handle access to lsass (e.g. via a\n[ObjectPreCallback kernel routine for a specified process or thread handle operation, or a](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-pob_pre_operation_callback)\nuser mode hook on OpenProcess/NtOpenProcess) could miss this activity. Hence, it is a\npotential blind spot for, say, defenders relying on Sysmon process access events to alert on\nsuspicious process handle access.\n\n### 3. Pass-the-hash (PtH)\n\nThe last two techniques this blog will cover are examples of an attacker changing the cached\ncredentials associated with their current access token/logon session “illegitimately” by\n**directly** **modifying lsass memory. In the PtH scenario, the attacker’s access token is**\nunchanged and points to the same logon session, however the associated cached\ncredentials are directly overwritten to a stolen hash. From this point, any remote\nauthentication attempts will use the stolen hash, as demonstrated below:\n\n\n-----\n\nFigure 7 - How the PtH attack works under the hood. In this example, the legitimate hash of\nthe user, ASTRO\\cosmo, is overwritten in-memory with the NTLM hash belonging to the\nASTRO\\Administrator user.\n\nIn this sense, both PtH and OPtH can be thought as functionally identical to the NETONLY\ntechnique previously discussed.\n\nThe typical workflow of a PtH attack is:\n\n[Open a write handle to lsass (e.g. via OpenProcess/NtOpenProcess with a desired](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)\naccess of [PROCESS_VM_WRITE)](https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights)\nEnumerate the linked list of logon sessions\nLocate the logon session of interest and identify the required authentication package\n(In the case of PtH/NTLM this is the [MSV1_0 authentication package)](https://docs.microsoft.com/en-us/windows/win32/secauthn/msv1-0-authentication-package)\nUpdate the associated cached credentials\n\nNote that these techniques often rely on parsing and modifying undocumented Windows\nstructures. This is not something that will be covered in this blog, but more information on\n[how this is performed can be found here and](https://www.slideshare.net/rootedcon/hernan-ochoa-wce-internals-rootedcon-2011) [here.](https://blog.xpnsec.com/exploring-mimikatz-part-1/)\n\nHence, once the cached credentials are updated in memory, they will automatically be used\nto authenticate remotely, as per the usual Windows SSO design, when any process/thread\nrunning as that token attempts to access a remote resource.\n\n\n-----\n\nNote, that in this simple case, there have been no additional logon session / access tokens\ncreated. However, in a similar fashion to pass-the-ticket attacks, these tools will also\nfrequently need to create new junk NETONLY processes/logon sessions in order to preserve\nexisting credentials or to apply stolen credentials to.\n\nAs a note, in order to obtain a write handle to lsass, malware will typically take two\napproaches:\n\nAcquire SeDebugPrivilege37\nSteal and impersonate a SYSTEM token\n\nThe first approach was discussed in part one of this blog series, however the latter approach\nis a typical example of stealing/impersonating a token for the purpose of bypassing local\n**access checks (e.g.** [stealing a SYSTEM token with a specific privilege enabled e.g.](https://github.com/GhostPack/Rubeus/blob/4c9145752395d48a73faf326c4ae57d2c565be7f/Rubeus/lib/Helpers.cs#L55-L107)\nSeTcbPrivilege). A SYSTEM token is commonly obtained via stealing the primary token from\nwinlogon.\n\n### 4. Overpass-the-hash (OPtH)\n\nThe Overpass-the-hash technique applies the same concept as pass-the-hash with one key\ndifference: it converts a hash into a fully fledged TGT ticket.\n\n\nWhen a user first logs on to a Windows workstation, as part of the Kerberos authentication\nprocess, the user’s password hash is used to encrypt a timestamp in order to validate the\nuser’s identity to the Domain Controller / Key Distribution Center (KDC) and receive a TGT.\nOverpass-the-hash modifies these cached hashes38 in memory and then kicks off the normal\nKerberos authentication protocol (AS-REQ/AS_REP etc.) in order to obtain a fully fledged\n**TGT for a stolen hash.39**\n\nThis technique can be performed via mimikatz’ pth command (which is misleadingly labelled\npth when it is actually performing overpass-the-hash under the hood):\n```\nmimikatz # sekurlsa::pth /user:Administrator /domain:ASTRO.testlab /ntlm:\nc0f969f35beb20e8f09ce86ef42ccd51\n\n```\n\nThis essentially performs the same steps as PtH, except it targets the Kerberos SSP (and\nhence kerberos.dll).40\n\n\n-----\n\nFigure 8 - How the OPtH attack works under the hood. In this example, the legitimate hash of\nthe user, ASTRO\\cosmo, is overwritten in-memory with the hash belonging to the\nASTRO\\Administrator user, kicking off the normal Kerberos authentication process.\n\nAs this technique once again involves wiping the current TGT associated with the user’s\nlogon session, an attacker can use a NETONLY process (with an associated dummy logon\n[session) to preserve their current TGT, which is exactly how mimikatz performs overpass-](https://github.com/gentilkiwi/mimikatz/blob/72b83acb297f50758b0ce1de33f722e70f476250/mimikatz/modules/sekurlsa/kuhl_m_sekurlsa.c#L947-L961)\nthe-hash by default.\n\nFirstly, it spawns a new process in a suspended state via CreateProcessWithLogonW with\nthe LOGON_NETCREDENTIALS_ONLY flag. It then obtains a handle to the primary token of\nthis suspended process and retrieves the authentication id for the new dummy logon session\nvia [GetTokenInformation. This function is used to query information cached in the token via](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation)\nthe [TOKEN_INFORMATION_CLASS enum, which in this case is TokenStatistics.](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-token_information_class)\n\nHaving obtained the authentication id, mimikatz can now start enumerating the linked list of\nlogon sessions within lsass, looking for the newly created logon session. Once it has found\nthe target logon session (via the authentication id), it can then proceed to update the\nKerberos credentials associated with it. Once the credentials are updated, the token (whose\ncorresponding logon session is now linked to the stolen hash) can be converted to an\nimpersonation token via DuplicateTokenEx and impersonated via SetThreadToken as we\nhave seen previously.\n\n\n-----\n\nOnce again at this stage, any attempts an attacker makes to access resources across the\nnetwork will use the domain\\user and password hash combination provided as arguments to\nmimikatz for authentication. Therefore, all remote interactions will be performed with the\naccess and privileges of the stolen credentials.\n\n## Conclusion\n\nThe purpose of this two-part blog series was to explain how fundamental concepts in\nWindows Security work under the hood and to show how attackers abuse these features in\norder to compromise Windows domains. This blog has demonstrated that irrespective of\nwhat tools or what authentication provider is abused, attackers act under a set of constraints\nthat result in the same anomalous signals for access token manipulation (e.g., anomalous\nnetwork only logins). These constraints are determined by the fundamental relationship\nbetween access tokens, logon sessions and cached credentials.\n[Ready for holistic data protection with Elastic Security? Try it free today, or experience our](https://www.elastic.co/security)\n[latest version on Elasticsearch Service on Elastic Cloud. And take advantage of our Quick](https://www.elastic.co/elasticsearch/service)\nStart training to set yourself up for success.\n\n## References\n\n1.  For a recap of how Kerberos authentication works see Programming Windows Security,\nKeith Brown or [https://posts.specterops.io/kerberosity-killed-the.... Additionally, Rubeus,](https://posts.specterops.io/kerberosity-killed-the-domain-an-offensive-kerberos-overview-eb04b1402c61)\n[which is a toolkit for interacting with Kerberos, has an extremely informative readme, which is](https://github.com/GhostPack/Rubeus#readme)\nrecommended for further reading.\n\n2. Remember, Windows will automatically authenticate with the credentials cached in the\nlogon session whenever a user attempts to access a network resource as per the Windows\nSSO mechanism. Cached credentials here can refer to any authentication provider (e.g.\nNTLM hashes or Kerberos tickets). NB this assumes the user is interactively logged in (nonnetwork).\n\n3. This is typically to avoid losing a foothold due to incident response or host isolation.\n\n4. This is obviously only applicable to attacker activity on a compromised host, as opposed\n[to an attacker executing code from another source e.g. remotely via impacket.](https://github.com/SecureAuthCorp/impacket)\n\n5. [https://clymb3r.wordpress.com/2013/11/03/powershel...](https://clymb3r.wordpress.com/2013/11/03/powershell-and-token-impersonation/)\n\n6. See the ‘steal_token’ command from Cobalt Strike as an example of this technique:\n[https://www.cobaltstrike.com/help-beacon](https://www.cobaltstrike.com/help-beacon)\n\n\n-----\n\n7. [This comment from the archived PowerSploit framework should also provide further](https://github.com/PowerShellMafia/PowerSploit/blob/c7985c9bc31e92bb6243c177d7d1d7e68b6f1816/Exfiltration/Invoke-TokenManipulation.ps1#L31-L44)\nclarification on this distinction between token theft for local privilege escalation vs lateral\nmovement.\n\n8. Alternatively, attackers can also go the password spraying route or attempt to use NTLM\n[sniffing/replaying attacks via tools such as responder.](https://github.com/SpiderLabs/Responder)\n\n[9. Note that both LogonUserA/W are simple wrappers around LogonUserExExW in](https://docs.microsoft.com/en-us/windows/win32/secauthn/logonuserexexw)\nSspiCli.dll\n\n10. In exactly the same way, [CreateProcessWithLogonW can be passed a local admin](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithlogonw)\naccount (rid-500) to execute an elevated process from a medium/unelevated context.\n\n[11. There are remote UAC registry options which can modify this behaviour.](https://support.microsoft.com/en-gb/help/951016/description-of-user-account-control-and-remote-restrictions-in-windows)\n\n12. There is an additional logon type, LOGON32_LOGON_NETWORK_CLEARTEXT, which\nis essentially a network logon but with cached credentials. See Programming Windows\nSecurity, Keith Brown for more information.\n\n13. See for more info:\n\n[https://blueteamer.blogspot.com/2018/12/disabling-...](https://blueteamer.blogspot.com/2018/12/disabling-uac-remote-restrictions-to.html)\n[https://support.microsoft.com/en-gb/help/951016/de...](https://support.microsoft.com/en-gb/help/951016/description-of-user-account-control-and-remote-restrictions-in-windows)\n[https://labs.f-secure.com/blog/enumerating-remote-...](https://labs.f-secure.com/blog/enumerating-remote-access-policies-through-gpo/)\n[14. NB there is also a DuplicateToken function but this only returns an impersonation token.](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetoken)\n\n15. This can be verified by examining the function in IDA. Alternatively, check [here on](https://doxygen.reactos.org/d1/d72/dll_2win32_2advapi32_2sec_2misc_8c.html#aed5dfd166fea98c3ac188fbbc8f88190)\nReactOS.\n\n16. This summary is a slight simplification of impersonation security. For a more thorough\noverview see James Forshaw’s “Introduction to Logical Privilege Escalation on Windows”\n[slides (p26): https://conference.hitb.org/hitbsecconf2017ams/mat...](https://conference.hitb.org/hitbsecconf2017ams/materials/D2T3%20-%20James%20Forshaw%20-%20Introduction%20to%20Logical%20Privilege%20Escalation%20on%20Windows.pdf)\n\n17. This title is taken from an excellent blog by Raphael Mudge: Windows Access Tokens\nand Alternate Credentials.\n\n18. This is typically the main reason why option 2 is not commonly used by attackers.\n\n19. Hence, running ‘whoami’ will still show the same user (as the token is still the same),\ndespite the duplicated token having different network credentials. This is a common source\nof confusion when using Cobalt Strike’s [make_token command (which performs the same](https://www.cobaltstrike.com/help-beacon)\ntechnique as described under the hood).\n\n20. The Windows RPC/COM APIs also enable a user to specify network-only credentials.\n[For example, this can be achieved for RPC by calling RpcBindingSetAuthInfoExW and](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfoexw)\npassing a SEC_WINNT_AUTH_IDENTITY structure via the AuthIdentity parameter. For\n\n\n-----\n\nmore information see Programming Windows Security, Keith Brown and\n[https://docs.microsoft.com/en-us/windows/win32/wmisdk/setting-authentication-using-c-.](https://docs.microsoft.com/en-us/windows/win32/wmisdk/setting-authentication-using-c-)\n\n21. While the two flags have different names, their meaning is the same; these credentials\nare only to be used on the network.\n\n22. Note there are still [ways around creating suspicious event logs for anomalous logon](https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-CredentialInjection.ps1#L77-L82)\nsessions.\n\n23. This is a James Forshaw trick - see the following blog for more detail:\n[https://www.tiraniddo.dev/2017/05/reading-your-way.... Additionally,](https://www.tiraniddo.dev/2017/05/reading-your-way-around-uac-part-3.html) [TokenViewer is an](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools)\nexcellent tool for experimenting with this type of technique.\n\n24. With this resulting impersonation token it is possible to write a file to System32 etc.\n\n25. There still may be legitimate reasons for impersonating prior to calling an API though,\nsuch as to obtain a privilege you don’t currently have before calling an API which requires it\n(although note some APIs do automatically enable privileges).\n\n26. There are a few ways around this. For example, you can spawn a process as the child of\na SYSTEM process by obtaining a handle to a SYSTEM process via OpenProcess with the\n[PROCESS_CREATE_PROCESS access right. This HANDLE can then be passed to](https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights)\n[NtCreateProcess as the ParentProcess parameter. This can also be achieved via the](https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FProcess%2FNtCreateProcess.html)\nPROC_THREAD_ATTRIBUTE_PARENT_PROCESS parameter and CreateProcess:\n[https://gist.github.com/xpn/a057a26ec81e736518ee50...](https://gist.github.com/xpn/a057a26ec81e736518ee50848b9c2cd6)\n\n27. Bizarrely, CreateProcessWithTokenW takes a dwLogonFlags argument despite also\nrequiring a handle to an existing token, which by definition, should already have a\ncorresponding logon session. It seems likely that this is something to do with loading the\nuser profile.\n\n28. Programming Windows Security, Keith Brown\n\n29. Specifically, SE_IMPERSONATE_NAME for CreateProcessWithTokenW and\nSE_INCREASE_QUOTA_NAME (&) SE_ASSIGNPRIMARYTOKEN_NAME (if token is not\nassignable) for CreateProcessAsUserW\n\n[30. A recap of Kerberos authentication can be found here and see the following for more](https://posts.specterops.io/kerberosity-killed-the-domain-an-offensive-kerberos-overview-eb04b1402c61)\ninformation on kerberos related attacks: https://www.blackhat.com/docs/us-14/materials/us1...,\n\n\n-----\n\nWatch Video At:\n\nhttps://youtu.be/lJQn06QLwEw\n\n, [https://github.com/GhostPack/Rubeus#readme](https://github.com/GhostPack/Rubeus#readme)\n\n31. [https://googleprojectzero.blogspot.com/2019/12/cal...](https://googleprojectzero.blogspot.com/2019/12/calling-local-windows-rpc-servers-from.html)\n\n32. E.g. the native Windows tool [klist offers similar functionality and is clearly a wrapper](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/klist)\naround LsaCallAuthenticationPackage.\n\n33. Note that an unelevated user can only apply tickets to their own logon session; elevated\nprivileges are needed to apply a TGT to a different logon session.\n\n34. There are some caveats/subtleties to this statement which are better answered by the\n[Rubeus readme. In short though, the caller needs to register an LSA connection via](https://github.com/GhostPack/Rubeus#example-credential-extraction)\n[LsaRegisterLsaProcess which requires the SeTcbPrivilege privilege (i.e. the caller is part of](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-lsaregisterlogonprocess)\nthe trusted computing base).\n\n35. As an observation, you can also talk to the msv1_0 authentication package via\nLsaCallAuthenticationPackage and send the following message types:\n[https://docs.microsoft.com/en-us/windows/win32/api..., although I have not investigated](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/ne-ntsecapi-msv1_0_protocol_message_type)\nwhether it is also possible to retrieve NTLM credentials through this interface.\n\n[36. For more information see the Rubeus github repository readme, which has a fantastic](https://github.com/GhostPack/Rubeus)\nwrite up of lots of kerberos related functionality and opsec considerations.\n\n37. See [here for an example of enabling a privilege](https://docs.microsoft.com/en-us/windows/win32/secauthz/enabling-and-disabling-privileges-in-c--)\n\n\n-----\n\n38. This can be verified by looking at PsOpenProcess/Thread in IDA and looking for a call to\nSePrivilegeCheck.\n\n39. Note, that acquiring SeDebugPrivilege tends to be very noisy from a detection logic\nperspective.\n\n40. Note the hash/key can be rc4_hmac (e.g. NTLM), aes128_hmac, aes256_hmac etc..\nsee [here for more.](https://www.slideshare.net/gentilkiwi/abusing-microsoft-kerberos-sorry-you-guys-dont-get-it/18)\n\n[41. See for more detail: https://www.blackhat.com/docs/us-14/materials/us-1...](https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don%27t-Get-It.pdf)\n\n[42. As a note, Rubeus’ asktgt functionality performs a variant of overpass-the-hash via](https://github.com/GhostPack/Rubeus#asktgt)\nbuilding raw AS-REQ traffic for a given hash from an unelevated context and without needing\nto touch lsass.\n\n**We're hiring**\n\nWork for a global, distributed team where finding someone like you is just a Zoom\nmeeting away. Flexible work with impact? Development opportunities from the start?\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-20 - How attackers abuse Access Token Manipulation (ATT&CK T1134).pdf"
    ],
    "report_names": [
        "2021-04-20 - How attackers abuse Access Token Manipulation (ATT&CK T1134).pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535777,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653689106,
    "ts_modification_date": 1653689106,
    "files": {
        "pdf": "https://archive.orkl.eu/187a5248d161c624373e02b7bb6c9eccee06e5e3.pdf",
        "text": "https://archive.orkl.eu/187a5248d161c624373e02b7bb6c9eccee06e5e3.txt",
        "img": "https://archive.orkl.eu/187a5248d161c624373e02b7bb6c9eccee06e5e3.jpg"
    }
}