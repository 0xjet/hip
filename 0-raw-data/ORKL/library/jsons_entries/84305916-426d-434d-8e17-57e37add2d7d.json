{
    "id": "84305916-426d-434d-8e17-57e37add2d7d",
    "created_at": "2023-01-12T15:10:09.026079Z",
    "updated_at": "2025-03-27T02:16:21.020463Z",
    "deleted_at": null,
    "sha1_hash": "e5c731104962831eefc27e18efb8402005a64c6a",
    "title": "2019-07-08 - Analyzing KSL0T Turlas Keylogger Part 2",
    "authors": "",
    "file_creation_date": "2022-05-25T14:15:31Z",
    "file_modification_date": "2022-05-25T14:15:31Z",
    "file_size": 1655279,
    "plain_text": "# Analyzing KSL0T (Turla’s Keylogger), Part 2 – Reupload\n\n**[0ffset.net/reverse-engineering/malware-analysis/analyzing-turlas-keylogger-2](https://www.0ffset.net/reverse-engineering/malware-analysis/analyzing-turlas-keylogger-2/)**\n\n8 July 2019\n\n[0verfl0w_](https://www.0ffset.net/author/dan489400/)\n8th July 2019\nNo Comments\n\n(This post is a reupload from my old site which is no longer available – you may have seen it\nbefore)\n\n[If you haven’t read the first post, go check it out here. You can download this keylogger off](https://www.0ffset.net/reverse-engineering/malware-analysis/analyzing-turlas-keylogger-1/)\n[of VirusBay. So far we have decrypted a whole lot of text using a simple XOR method,](https://beta.virusbay.io/)\nwhich revealed information on how different keys could be logged, file names in which the\ndata could be logged to, and a possible name for the keylogger: KSL0T. If you’ve got no\nclue what I’m talking about, you should most definitely check out the last post. Anyway, let’s\ngo further down the rabbit hole.\n\nMD5: 59b57bdabee2ce1fb566de51dd92ec94\n\nIf you’re following along with this analysis, make sure you rename the decryption function,\nso it confuses things less. After the return of the decryption\nfunction, GetModuleHandleW and GetProcAddress are called, using the recently\ndecrypted values, which are the last two strings to be decrypted. These values\nare kernel32.dll and GetProcAddress.\n\n\n-----\n\nThe return value of GetProcAddress will be stored in the rax register, which is then moved\ninto the location [rsp+48h+var_28], so to simplify matters, we can\nrename var_28 to GetProcessAddress, so whenever it is moved into another register (as\nlong as it hasn’t been changed), we can identify what is happening if that register is called by\nthe program. Sure enough, it is moved into the rdx register, just before a handle\nto kernel32.dll gets moved into the rcx register – and then a function\nat 0x1800039C0 is called.\n\n\n-----\n\nWe can easily identify the arguments passed to this function, as it is using\nthe mov operation again. We already know rcx contains a handle to kernel32.dll,\nand rdx contains the GetProcAddress function, and it seems r8 contains an address to\nan empty region of memory: 0x1800105A0, which is filled with zeroes.\n\n\n-----\n\nIf you are viewing the function in graph mode, you’ll be able to see that the flow is simply\none long “line”, with no if’s or for statements until the end. You can also see that there are\na lot of variables that are declared before the arguments are filled – as we are analyzing this\nbinary using static analysis, this function alone will require a lot of work to understand\n(because it is a possible anti-static analysis method used by Turla to prevent easy analysis).\nHint: It’s more data decryption, except this time, the encrypted data is loaded during\nruntime – hence why there are so many mov operations in a row. Due to this, we will have\nto manually extract those bytes, figure out how they are decrypted, and find a way to decrypt\nthem, through automation or writing a script. Let’s get stuck into it!\n\n\n-----\n\nThere is most definitely a better way to decrypt the data, although I am unaware of it, so I\ntook the long route. Highlight the mov instructions and copy it to a file. We will be\nstripping this down so it only contains the second argument to the instruction – the\nencrypted data.\n\n\n-----\n\nNow we need to parse the data and format it correctly, so that we only have the value being\nmoved into the destination. Below is a script that removes everything but the digit,\nincluding the h specifying the hexadecimal format. For singular digits, a zero is prepended\nonto the value, to make an understandable hex value.\n\n\n-----\n\n```\ndef main():\nf = open(\"data.txt\", \"r\")\ndata = f.readlines()\nf.close()\nf = open(\"data_2.txt\", \"w\")\nfor lines in data:\n  lines = lines.split(\"], \")[1]\n  if \"h\" in lines:\n    lines = lines.split(\"h\")[0]\n    lines = lines + \" \"\n  else:\n    lines = \"0\" + lines\n    lines = lines.split(\"\\n\")[0]\n    lines = lines + \" \"\n  f.write(lines)\nf.close()\nif name == “main”:\nmain()\n\n```\nAfter executing the script, we get this output in data_2.txt. This is the extracted encrypted\ndata, so we need to identify the decryption method used, to understand what it is encrypted\nwith.\n\nBack to the assembly, after the individual bytes have been moved into the correct locations,\na function at 0x180001000 is called repeatedly in a similar fashion to the first decryption\nfunction, except this time with 2 arguments.\n\n\n-----\n\nAs you’ve probably guessed, this is another algorithm, although it is a lot less complex than\nthe last one – this is due to the fact that each section of data is XORed using 0x55, meaning\nwe don’t need to write some sort of decryption script, and we can simply put it\ninto CyberChef and perform a basic XOR decryption, and then convert it from\n[hexadecimal format. If you haven’t used CyberChef before, you should check it out, as it is](https://gchq.github.io/CyberChef/)\nextremely useful in situations like these.\n\n\n-----\n\nAs you can see, the data contains multiple API calls and DLL’s that are loaded during\nruntime – in this function. As we scroll down the graph, there are several calls to\nGetProcAddress, as well as calls to variables, such as var_290. There are two ways we can\napproach this to figure out what is being stored in variable 290 – using a debugger, or in\nthis case through static analysis (the more complex method). To do so, we need to trace\nbackwards. We can see that the value in rax is stored in var_290, just after\na GetProcAddress call, and as one of the arguments is kernel32.dll, the other must be\nthe function that is called – this is stored in var_58.\n\n\n-----\n\nJust above the GetProcAddress, the decryption function is used to decrypt 13 bytes of\ndata at var_58, so lets go to the x-ref of var_58 in this function, and count out 13 bytes\nof data: var_58 -> var_4C.\n\n\n-----\n\nCopy those bytes and put them into CyberChef, and XOR with 0x55. You should\nget LoadLibraryA.\n\n\n-----\n\nFrom then on, only GetProcAddress and LoadLibraryA are called by this function –\nand we can assume that each of the API functions in the decrypted text are imported.\nObviously we could do that all manually, but if you have access to a debugger it would be\nmuch quicker.\n\n\n-----\n\nAs all of the imports have been resolved, we can move on, out of the function, where the\nprogram calls GetUserNameExW twice. In my case, the call will return Reversing\\RE –\nthe domain name and username. The malware then moves it to a different location\nusing wcscat, and checks to see if there is a backslash in the returned value, using wcsstr.\nIf there is, a pointer to it will be returned. The backslash is then replaced with a full stop,\nleaving us with Reversing.RE. The formatted string is used to create a mutex. The\nprogram first checks to see if a mutex has been created under that value by\ncalling OpenMutexW, and if it hasn’t been created, CreateMutexW is called. We are\nable to double check that this mutex is created by using a tool called SysAnalyzer, which is\nuseful for analyzing malicious programs whilst performing dynamic analysis.\n\n\n-----\n\nOnce a mutex has been created, a function at 0x180003960 is called, which creates a new\nthread pointing to 0x180001B70. When the created thread exits, the malware exits as\nwell.\n\n\n-----\n\nSo, let’s take a look at the newly created thread. It seems that immediately after the thread\nexecutes, a function located at 0x180001B00 is called, containing the ‘meat’ of the\nkeylogger. I have labelled this as Set_Hooks, based off of the method used by the\nkeylogger.\n\n\n-----\n\nThe two most common Windows API calls used in malware and ‘legitimate’ software to\nperform keylogging is GetAsyncKeyState or SetWindowsHookEx. Due to the number\nof issues with using GetAsyncKeyState, most keyloggers\nutilize SetWindowsHookEx nowadays. In this case, SetWindowsHookEx is used to\ncapture keystrokes. Whilst we are unable to use the pseudo code function in IDA, we can use\nMSDN to understand what is being called and how.\n```\nHHOOK SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD\ndwThreadId);\n\n```\nWhen we input all of the arguments into the function, we get:\n```\nHHOOK SetWindowsHookExA(13, 0x1800022C0, 0x180010720, 0);\nHHOOK SetWindowsHookExA(WH_KEYBOARD_LL, LowLevelKeyboardProc, DLL_Handle, NULL);\n\n```\n\n-----\n\nSo a hook is installed that _monitors low level keyboard input events, allowing the malware_\nto gather each keystroke. After, the function returns back to the previous function, where\na Get, Translateand DispatchMessage loop is created. While the program is\nkeylogging, GetMessage will gather each key press and pass it to TranslateMessage,\nwhich translates virtual key messages into character messages. This is then passed\nto DispatchMessage, and this redirects it to another window procedure. If you want to\n[learn more about the inner workings of keylogging, check out this site here, it goes into the](https://securelist.com/keyloggers-how-they-work-and-how-to-detect-them-part-1/36138/)\nvery low levels of keystroke logging.\n\nNow lets take a look at the function called by SetWindowsHookExA, located\nat 0x1800022C0. As you can see from the graph overview, this function is a huge mess.\nThe section at the bottom of the graph is in fact a switch statement – we can see there are\nmultiple case values, and a default value as well. Furthermore, IDA also tells us this is a\n[switch statement. Here is an overview of switch statements in C. To sum it up, it is another](https://www.tutorialspoint.com/cprogramming/switch_statement_in_c.htm)\nmethod of comparing one variable to several different variables, instead of using\nmultiple if statements.\n\n\n-----\n\nIn order to find the values of the case variables, we need to perform some simple addition.\nLooking at each box, there is a lea rdx, Encrypted_Keys and then add rdx, …h, where\nthe … indicates a certain hexadecimal value. In one particular case, the value 13C is being\nadded to the memory address of the Encrypted Keys, which is 0x18000F2F0. After adding\nthem together, we get 0x18000F42C, which points to ‘<‘. The next instruction after\nthe add, a value is moved into r8d. This indicates the size of the string, which is 4.\nTherefore, the 3 bytes after 0x18000F42C are also included, meaning the full value\nis <r0>.\n\nTo speed up the process, I wrote a simple script to *automate* the process, so all you have to\ndo is input the addition value and the string length, and the corresponding key is output to\n[the terminal. I have uploaded it to pastebin and you can view it here.](https://pastebin.com/7EyK8mHA)\n\n\n-----\n\nThis value is concatenated, using wcsncat, into the address 0x1800115B0. We can\nrename this to Captured_Char, as that is what it is. If the captured keystroke does not\nequal any of the hardcoded values, the default case is used, however they all lead to the\nsame logging function. Before examining the rest of this function, lets take a look at how the\ndata is logged.\n\n\n-----\n\nSo this function is quite long, although we just need to see the WriteFile part, to see if the\ndata is encrypted or not when being stored – which is right at the bottom of the function.\n\n\n-----\n\nAs assumed, the data is encrypted before being written to the file. As you can see, there is\na for loop, where on one side data is being written using WriteFile, and on the other side\ndata is being XORed using the original XOR keys. First, it seems that the value in var_34 is\nbeing compared to the value in var_20. We can deduce that var_34 is the length of the\ndata to be XORed, due to it being the third argument in the WriteFile call:\n```\nWriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten,\nlpOverlapped)\n\n```\nTherefore, we can rename that to NumberOfBytesToWrite. While doing so, we can also\nrename the other variables used in the call, so it is easier to understand the function. You\nmight also have noticed that var_20 is being incremented each loop as well, so we can\nsimply rename that as i. So, lets take a look at the actual XOR part.\n\n\n-----\n\nSo the value in i is moved into rcx, and the value in the Buffer (highly likely the captured\nkeystrokes plus any additional data) is moved into rax. Once again – similar to both\ndecryption routines – the first character that will be encrypted is found by adding the value\nin i to the address of the Buffer. This is moved into edi, and then div is called. If you\nremember the first post on the keylogger, div divides the value in rax with the passed\noperand, which is rcx. The value in rcx is 100 (0x64), and therefore rax will be divided by\n100. The question is, what is the value in rax? We can see dword_180010738 is being\nmoved into the register – but it is empty. We have to locate the section where a value is\nmoved into the dword.\n\nSearching for xrefs, there is only one mention of this variable before the encryption\nroutine, which is at 0x1800013F1. It seems that the malware gets the file size of the file\nwhich the keystrokes will be logged to, and then performs another div operation, with the\nremainder being stored in the dword. Let’s imagine that the file size is 0, as the logger has\njust started up. 0 is then divided by 100, which is obviously 0. This means that the value\nin edx is 0, and therefore the value in the dword is, you guessed it, also 0. So we can jump\nback to the encryption routine and work through the rest.\n\nIn order to get a byte from the key to XOR the data with, rdx and rax are used. The value\nin rdx on the first loop is zero – this is the result of the div using the value\nin dword_180010738. The address of the original XOR key is moved into rax, and a byte\nis stored in eax using the same byte ptr [rax+rdx] used throughout. edi (the keystroke\ndata) is moved into edx, which is XORedby eax (the key). The encrypted character is used\n\n\n-----\n\nto overwrite the character in the keystroke data, based off of the value in i. Next, the value\nof dword_180010738 is incremented by 1, meaning the key used to XOR the first\ncharacter of the buffer is different to the key used to XOR the second character of the buffer.\nFinally, i is also incremented by 1, and the loop continues until the buffer is completely\noverwritten.\n\nThe data is then written to the file, the buffer is freed, the file handle is closed, and the\nfunction returns.\n\nNow we have cracked the algorithm, we need to find where the data is being logged. We\nalready know which variable contains the handle to the file, so lets find the first instance of\nit being used. Sure enough, there is a mov [rsp+928h+File], rax just after a call\nto CreateFileW. When looking at the arguments CreateFile takes, we can see that the\nvery first argument is the file name:\n```\nHANDLE CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,\ndwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);\n\n```\nIn this case, the first argument is a variable containing msimm.dat – one of the original\nstrings we decrypted. As there is no file path connected to it, it seems that this file is written\nin the current directory, so wherever the keylogger is run.\n\nWe know almost everything about how the file is logged and how the data is stored, so let’s\nsee if we can get a sample of the encrypted data in order to analyze it. Open up a VM and\nrun the DLL. In order to run it, I am using x64Dbg, as I couldn’t seem to\nget rundll32.exe to run it – maybe due to the lack of exports. Eventually, the file I wanted\nwas created on the Desktop, msimm.dat. Upon opening it, there is a lot of what seems to\nbe text in a different language, although this is just the encrypted text being displayed by\nNotepad. Open the file in something like CFF Explorer in order to view the hex data of the\n\n\n-----\n\nfile, so that we can XOR it back to plain\ntext. Copy this into a text file on your\nhost machine, and get your favourite\ntext formatting tool up.\n\nThe reason for this is because the script I have written is quite ‘hacky’. I tried several\ndifferent things in order for python to read hex bytes as hex bytes into an array – all failed.\nIf you guys have any ideas on how to improve it, let me know! Anyway, the text needs to be\nformatted in this way:\n```\n0x..., 0x..., 0x...\n\n```\nAnd as CFF explorer copies the hex in one long string, we need to split it every second\n[character and convert spaces to, 0x. I personally used this to do so. Now my script doesn’t](http://www.unit-conversion.info/texttools/replace-text/)\nwork 100% of the time – I’m mainly using it as an example here to show you how to\nreplicate the algorithm in Python. It only seems to work on one section of the text, but I’m\nsure those of you with a higher level of Pythonic knowledge and malware analysis\n[knowledge will be able to re purpose it so it works flawlessly. Anyway, here it is. When we](https://pastebin.com/Fwpz7PZf)\nrun the script, it will decrypt the section of hex data using the keys and output the plaintext.\n\n\n-----\n\nThere is also a legend that shows you which part means what. As I mentioned, there are so\nmany better ways to do this so that it works for different logs, however I didn’t have much\ntime to work on it and make it pristine.\n\nThat pretty much wraps up this analysis, as there isn’t much else to analyze. There is no\nmethod of extracting the log files in the keylogger, so I believe Turla only use it when they\nhave remote access to the machine, and extract the logs through a remote access tool or a\nbackdoor. So I hope you enjoyed the two part analysis, and I should hopefully have\nthe Hancitor part two write up soon. Thanks!\n\n**IOCs:**\n\nKeylogger: 59b57bdabee2ce1fb566de51dd92ec94\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-07-08 - Analyzing KSL0T Turlas Keylogger Part 2.pdf"
    ],
    "report_names": [
        "2019-07-08 - Analyzing KSL0T Turlas Keylogger Part 2.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "a97cf06d-c2e2-4771-99a2-c9dee0d6a0ac",
            "created_at": "2022-10-25T16:07:24.349252Z",
            "updated_at": "2025-03-27T02:02:10.184406Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "ATK 13",
                "Belugasturgeon",
                "Blue Python",
                "CTG-8875",
                "Group 88",
                "ITG12",
                "Iron Hunter",
                "Krypton",
                "Makersmark",
                "Operation Epic Turla",
                "Operation Moonlight Maze",
                "Operation Penguin Turla",
                "Operation Satellite Turla",
                "Operation Skipper Turla",
                "Operation Turla Mosquito",
                "Operation WITCHCOVEN",
                "Pacifier APT",
                "Pensive Ursa",
                "Popeye",
                "SIG15",
                "SIG2",
                "SIG23",
                "Secret Blizzard",
                "TAG-0530",
                "Turla",
                "UNC4210",
                "Venomous Bear",
                "Waterbug"
            ],
            "source_name": "ETDA:Turla",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "ATI-Agent",
                "AdobeARM",
                "Agent.BTZ",
                "Agent.DNE",
                "BigBoss",
                "COMpfun",
                "Chinch",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobra Carbon System",
                "ComRAT",
                "DoublePulsar",
                "EmPyre",
                "EmpireProject",
                "Epic Turla",
                "EternalBlue",
                "EternalRomance",
                "GoldenSky",
                "Group Policy Results Tool",
                "HTML5 Encoding",
                "HyperStack",
                "IcedCoffee",
                "IronNetInjector",
                "KSL0T",
                "Kapushka",
                "Kazuar",
                "KopiLuwak",
                "Kotel",
                "LOLBAS",
                "LOLBins",
                "LightNeuron",
                "Living off the Land",
                "Maintools.js",
                "Metasploit",
                "Meterpreter",
                "MiamiBeach",
                "Mimikatz",
                "MiniDionis",
                "Minit",
                "NBTscan",
                "NETTRANS",
                "NETVulture",
                "Neptun",
                "NetFlash",
                "NewPass",
                "Outlook Backdoor",
                "Penquin Turla",
                "Pfinet",
                "PowerShell Empire",
                "PowerShellRunner",
                "PowerShellRunner-based RPC backdoor",
                "PowerStallion",
                "PsExec",
                "PyFlash",
                "QUIETCANARY",
                "Reductor RAT",
                "RocketMan",
                "SMBTouch",
                "SScan",
                "Satellite Turla",
                "SilentMoon",
                "Sun rootkit",
                "TTNG",
                "TadjMakhal",
                "Tavdig",
                "TinyTurla",
                "TinyTurla Next Generation",
                "TinyTurla-NG",
                "Topinambour",
                "Tunnus",
                "Turla",
                "Turla SilentMoon",
                "TurlaChopper",
                "Uroburos",
                "Urouros",
                "WCE",
                "WITCHCOVEN",
                "WhiteAtlas",
                "WhiteBear",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Wipbot",
                "WorldCupSec",
                "XTRANS",
                "certutil",
                "certutil.exe",
                "gpresult",
                "nbtscan",
                "nbtstat",
                "pwdump"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8aaa5515-92dd-448d-bb20-3a253f4f8854",
            "created_at": "2024-06-19T02:03:08.147099Z",
            "updated_at": "2025-03-27T02:05:17.408118Z",
            "deleted_at": null,
            "main_name": "IRON HUNTER",
            "aliases": [
                "Belugasturgeon ",
                "Blue Python ",
                "CTG-8875 ",
                "ITG12 ",
                "KRYPTON ",
                "MAKERSMARK ",
                "Pensive Ursa ",
                "Secret Blizzard ",
                "Turla",
                "UAC-0003 ",
                "UAC-0024 ",
                "UNC4210 ",
                "Venomous Bear ",
                "Waterbug ",
                "ATK13 "
            ],
            "source_name": "Secureworks:IRON HUNTER",
            "tools": [
                " ComRAT",
                " Kazuar",
                " KopiLuwak",
                " LightNeuron",
                " Mosquito",
                " Nautilus",
                " Neuron",
                " Penquin",
                " PoisonFrog",
                " PyFlash",
                " Skipper",
                " Snake",
                " Tavdig",
                " TinyTurla",
                " Tunnus",
                "Carbon-DLL"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a97fee0d-af4b-4661-ae17-858925438fc4",
            "created_at": "2023-01-06T13:46:38.396415Z",
            "updated_at": "2025-03-27T02:00:02.823045Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Uroburos",
                "Hippo Team",
                "Pacifier APT",
                "MAKERSMARK",
                "ATK13",
                "UAC-0003",
                "IRON HUNTER",
                "Waterbug",
                "TAG_0530",
                "KRYPTON",
                "Popeye",
                "SIG23",
                "UAC-0144",
                "G0010",
                "Blue Python",
                "VENOMOUS Bear",
                "Group 88",
                "Pfinet",
                "ITG12",
                "UNC4210",
                "Secret Blizzard",
                "UAC-0024"
            ],
            "source_name": "MISPGALAXY:Turla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d11c89bb-1640-45fa-8322-6f4e4053d7f3",
            "created_at": "2022-10-25T15:50:23.509601Z",
            "updated_at": "2025-03-27T02:00:55.487991Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Turla",
                "IRON HUNTER",
                "Group 88",
                "Waterbug",
                "WhiteBear",
                "Krypton",
                "Venomous Bear",
                "Secret Blizzard",
                "BELUGASTURGEON"
            ],
            "source_name": "MITRE:Turla",
            "tools": [
                "PsExec",
                "nbtstat",
                "ComRAT",
                "netstat",
                "certutil",
                "KOPILUWAK",
                "IronNetInjector",
                "LunarWeb",
                "Arp",
                "Uroburos",
                "PowerStallion",
                "Kazuar",
                "Systeminfo",
                "LightNeuron",
                "Mimikatz",
                "Tasklist",
                "LunarMail",
                "HyperStack",
                "NBTscan",
                "TinyTurla",
                "Penquin",
                "LunarLoader"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536209,
    "ts_updated_at": 1743041781,
    "ts_creation_date": 1653488131,
    "ts_modification_date": 1653488131,
    "files": {
        "pdf": "https://archive.orkl.eu/e5c731104962831eefc27e18efb8402005a64c6a.pdf",
        "text": "https://archive.orkl.eu/e5c731104962831eefc27e18efb8402005a64c6a.txt",
        "img": "https://archive.orkl.eu/e5c731104962831eefc27e18efb8402005a64c6a.jpg"
    }
}