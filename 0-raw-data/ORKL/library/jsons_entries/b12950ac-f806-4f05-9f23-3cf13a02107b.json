{
    "id": "b12950ac-f806-4f05-9f23-3cf13a02107b",
    "created_at": "2023-01-12T15:06:54.606599Z",
    "updated_at": "2025-03-27T02:08:33.354756Z",
    "deleted_at": null,
    "sha1_hash": "de5e530b2ac383341014a844a0750fd4c7d03e5e",
    "title": "2021-06-23 - PYSA Loves ChaChi- a New GoLang RAT",
    "authors": "",
    "file_creation_date": "2022-05-28T23:12:28Z",
    "file_modification_date": "2022-05-28T23:12:28Z",
    "file_size": 7271784,
    "plain_text": "# PYSA Loves ChaChi: a New GoLang RAT\n\n**[blogs.blackberry.com/en/2021/06/pysa-loves-chachi-a-new-golang-rat](https://blogs.blackberry.com/en/2021/06/pysa-loves-chachi-a-new-golang-rat)**\n\nThe BlackBerry Research & Intelligence Team\n\n### Executive Summary\n\nThe [BlackBerry Threat Research and Intelligence SPEAR® Team have been tracking a previously](https://blogs.blackberry.com/en/author/the-blackberry-research-and-intelligence-team)\nunnamed Golang remote access Trojan (RAT) targeting Windows® systems. We’ve dubbed this RAT\n[ChaChi. This Trojan has been used by operators of the PYSA (aka Mespinoza) ransomware as part of their](https://malpedia.caad.fkie.fraunhofer.de/details/win.mespinoza)\ntoolset to attack victims globally, but most recently targeting education organizations.\n\nChaChi is another entry in the expanding list of malicious software written in Go, also known as Golang,\nwhich is a relatively young programming language. As this is such a new phenomenon, many core tools to\nthe analysis process are still catching up. This can make Go a more challenging language to analyze.\n\nChaChi has been observed in the wild since at least the first half of 2020 without receiving much attention\n[from the cybersecurity industry. The first known variant of ChaChi was used in attacks on the networks of](https://www.zdnet.com/article/france-warns-of-new-ransomware-gang-targeting-local-governments/)\n[local government authorities in France, and was listed as an indicator of compromise (IoC) in a publication](https://www.cert.ssi.gouv.fr/uploads/CERTFR-2020-CTI-003.pdf)\nby CERT France at the time of the attacks.\n\nThat first variant of ChaChi was very clearly a new tool in the PYSA operator’s arsenal as it lacked the\nobfuscation, port-forwarding and DNS tunnelling capabilities that were employed in the vast majority of\nobserved variants, since those attacks indicated some time was invested to rapidly develop ChaChi into\nthe tool it is today.\n\n\n-----\n\nSince then, BlackBerry analysts have observed the later, more refined versions of ChaChi being deployed\nby the PYSA Ransomware operators in a campaign that has shifted its focus to targeting educational\n[institutions across the U.S., which has seen a recent increase in activity as reported by the FBI.](https://www.ic3.gov/Media/News/2021/210316.pdf)\n\nBlackBerry has conducted many investigations and responded to incidents involving PYSA ransomware in\nwhich ChaChi was also identified on hosts in the victim environment.\n\nKey highlights of the PYSA campaign include:\n\n**Defense Evasion: PowerShell scripts to uninstall/stop/disable antivirus and other essential services.**\n**Credential Access: Dumping credentials from LSASS without Mimikatz (comsvcs.dll).**\n**Discovery: Internal network enumeration using Advanced Port Scanner.**\n**Persistence: ChaChi installed as a Service.**\n**Lateral Movement: RDP and PsExec.**\n**Exfiltration: Likely over ChaChi tunnel (not observed).**\n**Command and Control (C2): ChaChi RAT.**\n\n### Introduction\n\nThe name ChaChi comes from two key components of the RAT, Chashell and Chisel. These are tools used\nby the malware operators to perform their intended actions, rather than creating bespoke tools to\naccomplish this functionality.\n\nThe first versions of PYSA have been floating around since late 2018. This threat’s name comes from the\nfile extension (.PYSA) used by early variants to rename encrypted files, and from its ransom note that\nwarned victims to “Protect Your System Amigo.”\n\nThis threat is also sometimes referred to as Mespinoza, so named because of the email address used in\nthe dropped ransom notes. The actors behind the PYSA/Mespinoza ransomware campaigns have not\nbeen publicly attributed at the time of writing.\n\nThe PYSA campaigns are some of the latest in a relatively new breed of malware. Rather than depending\non automated propagation to find new victim machines by searching for exploits and vulnerabilities, PYSA\ncampaigns follow the style of “big game hunting” or human-orchestrated and controlled attacks on a given\ntarget.\n\n[This is a notable change in operation from earlier notable ransomware campaigns such as NotPetya or](https://blogs.blackberry.com/en/2017/07/threat-spotlight-petya-like-ransomware-is-nasty-wiper)\n[WannaCry. These actors are utilizing advanced knowledge of enterprise networking and security](https://blogs.blackberry.com/en/2017/05/threat-spotlight-wannacry-ransomware)\nmisconfigurations to achieve lateral movement and gain access to the victim’s environments. These newer\ntypes of attacks frequently exfiltrate data, steal credentials, and use other commodity malware in addition\nto bespoke malware such as ChaChi during campaigns.\n\n### PYSA Attacks Change Targets\n\n[The earliest variant of ChaChi was used in attacks on the networks of local government authorities in](https://www.zdnet.com/article/france-warns-of-new-ransomware-gang-targeting-local-governments/)\nFrance in March of 2020. Since then, PYSA, and therefore ChaChi, have been observed in attacks across\na variety of industries. This includes healthcare organizations, private companies, and most notably, a\nrecent surge in attacks against educational institutions as reported by the FBI earlier this year. In these\nrecent attacks, PYSA ransomware has been found across 12 U.S. states and in the UK, in data breaches\ntargeting higher education and K-12 schools.\n\n\n-----\n\nThese targeted business verticals have been a focal point for attackers and are continuing to be\ncompromised at an alarming rate. This may be due in part to healthcare and educational organizations\nbeing more susceptible to cyberattacks as they are less likely to have established security infrastructures\nor may lack the resources to prioritize security.\n\nHealthcare and education organizations also host large volumes of sensitive data, making them more\nvaluable targets. It is not uncommon for schools and hospitals to have legacy systems, poor email filtering,\nno data backups, or unpatched systems in their environments. This leaves their networks more vulnerable\nto exploits and ransomware attacks.\n\nIt is particularly concerning that attackers are focusing so heavily on education organizations, as they are\nespecially vulnerable. Higher education environments tend to function like miniature cities, with a heavy\ncultural emphasis on information-sharing. Not only do they host significant quantities of business data;\nschools also host traffic from students living on campus.\n\nThese students often have little security awareness training, and they might fall victim to suspicious emails,\nfail to recognize questionable websites, or download malicious programs onto their personal devices while\nconnected. These factors contribute to these industries being easy but valuable targets to threat actors and\nmay explain the sudden increase in PYSA actors attacking educational institutions.\n\n### Evolution\n\nIt is possible to map out an approximate timeline for the evolution of ChaChi by taking a number of factors\ninto account such as:\n\nFirst documented sightings of ChaChi variants in the wild.\nFirst seen dates of C2 Domains extracted from samples of ChaChi.\nFirst occurrences of specific functionality in ChaChi variants.\n\nCorrelation of each of these data points allow us to give an approximation for the code development\ntimeline for ChaChi:\n\n_Figure 1 - Approximate ChaChi Evolution Timeline._\n\nWe estimate that ChaChi was first developed no earlier than mid-2019. The actual development time was\nmore likely to be the beginning of 2020.\n\n\n-----\n\nAfter initial sightings in attacks during the first quarter of 2020, ChaChi s code was altered to include\nobfuscation and persistence in late March or early April. Very soon after that, we started seeing ChaChi\nvariants with the added DNS tunnelling and Port-Forwarding/Proxy functionality. There have been few\nnoteworthy changes after that point.\n\n### Obfuscation\n\nGolang malware has been around for a number of years, but obfuscation of Go malware is still relatively\n[uncommon. The Ekans ransomware appeared to be leveraging a new Go obfuscation technique in](https://www.dragos.com/blog/industry-news/ekans-ransomware-and-ics-operations/)\nDecember 2019, although the technique was not explicitly named at the time.\n\n[At the end of 2020, researchers reported the discovery of “BlackRota”, an ELF backdoor written in Go.](https://threatpost.com/blackrota-golang-backdoor-obfuscation/161544/)\nThey declared it “the most obfuscated Go-written malware in ELF format that we have found to date”.\n\nThe obfuscation used in Ekans, BlackRota and subsequently ChaChi, was “gobfuscate”, a Golang\n[obfuscation tool publicly available on GitHub. BlackBerry analysts observed samples of ChaChi actively](https://github.com/unixpickle/gobfuscate)\nusing gobfuscate shortly after the release of Ekans, but several months prior to the discovery of BlackRota.\n\nGobfuscate attempts to make a lot of information that would normally be easily available to the researcher\nvery difficult to recover. It obfuscates the runtime symbol table and type information, such as package\nnames, function names etc., by replacing them with randomly generated names, and obfuscating strings by\nreplacing them with functions:\n\n\n-----\n\nFigure 2 - Gobfuscated Function Names.\n\n_Figure 3 - Gobfuscated String, which is now a function._\n\nThis obfuscation was designed with the purpose of avoiding information leakage relating to the Go source\ncode, such as strings, package paths and field names. It has since been adopted by malware authors as a\nmeans of hindering analysis and reverse engineering efforts.\n\n\n-----\n\nSince its discovery as a tool for defence evasion, there have been a number of quite successful attempts\n[and blog postings dedicated to automating string de-obfuscation using plugins for both Binary Ninja and](https://www.kryptoslogic.com/blog/2020/12/automated-string-de-gobfuscation/)\n[Cutter. However, at the time of writing, there is no such plugin or script in existence for IDA.](https://www.goggleheadedhacker.com/blog/post/22)\n\nBlackBerry analysts have developed an internal tool – a IDAPython script – to handle string “degobfuscation” and subsequently reduce the time required to analyse gobfuscated binaries. Once the degobfuscation script is run across the ChaChi binary when loaded into IDA, it will locate all string decoding\nfunctions, extract the encoded bytes, and then perform the necessary XOR operation to recover the\noriginal strings. These strings are then used to rename all the decoding functions within, where an encoded\nstring was found, and additionally add comments to the disassembly code view where necessary:\n\n\n-----\n\n_Figure 4 - De-Gobfuscated String Function._\n\nWith the string gobfuscation defeated, there was still the problem of the randomly named packages, etc.\nOn the surface, the obfuscation of the names appeared to be an effective deterrent to analysis. However,\nwhen it was investigated more deeply, this was not overly difficult to overcome.\n\n\n-----\n\nPackage names are renamed in a consistent and uniform manner such that components of the same\npackage, function etc. share the same random name. When you combine this knowledge with the fact that\nthe function method names remain largely unaffected by the obfuscation, then once the usage of a\nparticular package was discovered, all entries that used the same random name could also be renamed via\na simple IDAPython helper script:\n\nFigure 5 - Gobfuscated Function Names.\n\n_Figure 6 – De-gobfuscated Function Names._\n\nWith the obfuscation defeated, efforts could be refocused on analysing ChaChi’s functionality and intent.\n\n### Persistence\n\nShortly after its initial execution ChaChi decodes a service name and service description:\n\n\n-----\n\n_Figure 7 - Decode Service Name and Description._\n\nUsing the decoded service name, ChaChi enumerates all installed services to check if a service with the\nsame name already exists. In this case, it is named “JavaJDBC”. If a service with the specified name is\nfound, then ChaChi will randomly select another service name from a hardcoded, albeit gobfuscated, list of\nservice name strings:\n\n\n-----\n\n_Figure 8 - Check if Service Name Exists._\n\n\n-----\n\n_Figure 9 - Decoding Alternate Service Names._\n\nAfter determining an appropriate name to use for service installation, ChaChi then checks to see if it has\nsufficient administrator privileges to carry out the service creation operation:\n\n\n-----\n\n_Figure 10 - Checking if running with Administrative Privileges._\n\nIf ChaChi is not running with administrative privileges, it bypasses its persistence code and begins to\ninitialize command-and-control (C2) communications. If the backdoor is running with administrative\nprivileges, it will install itself as a new service that is configured to auto-start, before manually starting the\nservice:\n\n_Figure 11 - Install as Service and Start the Service._\n\n\n-----\n\n### C2 Communications\n\nChaChi utilizes two protocols for C2 communications: DNS and HTTP. The primary, preferred method of\nC2 communication is DNS tunnelling using TXT queries.\n\nTXT or “text” records were originally intended to allow domain admins to associate arbitrary text with a\ndomain, such as domain ownership information or network and server information. Threat actors have\ntaken advantage of this for their own nefarious needs by encoding data in these TXT queries, which is a\nform of DNS tunnelling.\n\nDNS tunnelling allows malware authors to communicate in a covert channel that can bypass most firewalls.\nDNS traffic is widely used, and often blindly trusted with little to no monitoring. DNS requests can also get\nproxied via internal DNS resolvers, making it more difficult to track infected endpoints:\n\nFigure 12 - DNS traffic generated by ChaChi.\n\nShould the DNS communications fail for whatever reason, ChaChi also contains a failover mechanism\nwhere it uses HTTP in the form of encoded POST requests to communicate with its C2 servers. HTTP\nPOST requests are generally used to send data to a server to create or update a resource on that server.\nChaChi uses these requests for C2 communications instead. Before it can attempt to establish C2\ncommunications, it must first decode its embedded C2 server domains and IP addresses.\n\n### Decoding C2 IPs and Domains\n\nChaChi is preconfigured with a list of C2 domains for DNS tunnelling, as well as IP addresses for HTTP C2\nfailover. The domains are encoded just like any other string in a gobfuscated binary, using a dedicated\nfunction that carries out the XOR decode process:\n\n\n-----\n\n_Figure 13 - C2 Domains are Decoded from Gobfuscated functions._\n\nThe domain that will be used is chosen at random through the use of “Intn” from the “rand” package, which\nis seeded by the value returned from an earlier call to “time.Now”:\n\n\n-----\n\n_Figure 14 - Randomizing C2 Domain Selection._\n\nThe decoding of the C2 IP addresses is a little more complicated, although not overly so. As with the C2\ndomains, the inevitable selection of a C2 IP address is also randomized through calls to “time.Now”,\n“rand.Seed” and “rand.Shuffle”. The C2 IP decoding function takes several arguments: a pointer to the\nencoded C2 IP array, an integer value indicating the number of encoded IP addresses, and a hex number\nused in the decoding of each octet of each IP address. The decoding of the C2 IP addresses works as\nfollows:\n\nRead a word (2 bytes) at the initial offset into the C2 IP array determined by the earlier shuffle.\nSubtract the hex number (0xA in all observed cases) from the retrieved value.\nConvert the result to its base 10 equivalent (thereby creating a single octet of an IP).\nRepeat 4 times per encoded IP.\nJoin the decoded octets with a \".\" (thus fully decoding a stored C2 IP address).\n\nThese steps are repeated until all IP addresses have been decoded\n\nThe equivalent Python code for the decoding operation can been seen below, or an example CyberChef\n[recipe operating on one encoded IP address can be found here.](https://gchq.github.io/CyberChef/#recipe=Swap_endianness('Hex',2,true)From_Hex('Auto')Remove_null_bytes()SUB(%7B'option':'Hex','string':'A'%7D)To_Decimal('Space',false)Find_/_Replace(%7B'option':'Regex','string':'%20'%7D,'.',true,false,true,false)&input=QUEwMDFFMDA5RDAwQzIwMA)\n\n_Figure 15 - Python Code for C2 Decode._\n\n\n-----\n\nWith the C2 addresses decoded, ChaChi can now initiate a connection to its C2 infrastructure.\n\n### Modified Chashell\n\nRather than implement an entirely bespoke means of DNS tunnelling, the developers opted to leverage an\n[off-the-shelf solution (or at least components of that solution). They used a package called Chashell that](https://github.com/sysdream/chashell)\nprovides a reverse shell over DNS.\n\n[Chashell operates by taking data from a shell or terminal that it serializes into Protocol Buffers before](https://developers.google.com/protocol-buffers/)\nencrypting it using symmetric encryption in the form of XSalsa20 + Poly1305. This encrypted data is then\nhex encoded and packed into a TXT query. The response to the TXT query is also subject to the same\nprotocol buffer serialization, encryption, and hex encoding:\n\n_Figure 16 - Chashell DNS tunnelling Query and Response._\n\nThe default Chashell client takes a target domain and symmetric encryption key at build time, both of which\nare hardcoded. These are then used to establish the encrypted DNS tunnel to the Chashell server. Once a\nconnection is established, it redirects the standard input/output/error from “cmd.exe” or “/bin/sh” –\ndepending on the operating system target – into the DNS tunnel, thereby creating a reverse shell:\n\n_Figure 17 - Standard Chashell Client Code._\n\n\n-----\n\nThe ChaChi operators borrowed the DNS tunnelling transport mechanism from Chashell, but it is no longer\noperating as a simple reverse shell. They instead opted to make several modifications, including the\nremoval of the default action of spawning a reverse shell, and the addition of an extra layer of encoding on\nsome of the data passing through the DNS stream.\n\nIn effect, Chashell is just a cog in the machine that is ChaChi, so it can achieve covert C2 communications.\nAs mentioned, not all data traversing the DNS tunnel is subjected to this additional encoding, which is\nreserved for a specific proto-buffer field, of which there are five in use by Chashell:\n\n_Figure 18 - Chashell Protocol Buffer Message._\n\n**ClientGUID: This field is an ID that uniquely identifies messages from a specific client so they can be**\ncorrectly processed by the server. ClientGUID fields are present in all messages.\n**ChunkStart: This message is used to identify messages that belong to the same “chunk”.**\n**ChunkData: This is the message which transports the core data that will traverse the tunnel. In the**\ncase of a standard Chashell, this would contain the output of the standard streams. These messages\ncontain data that needs to be reconstructed based on the information provided by a “ChunkStart”\nmessage.\n**PollQuery: These messages are like heartbeat messages from the client to the server to query if**\nthere are commands/data waiting to be transmitted.\n**Infopacket:These messages are used to transport the hostname of the client to the server as a**\nmeans of more easily identifying active Chashell sessions. Only the “ChunkData” messages, in\nparticular the “packet” field of that message, are subjected to the additional custom encoding that is\nnot present in the standard Chashell client source code:\n\n\n-----\n\n_Figure 19 - ChunkData message structure._\n\nThe encoding in “ChunkData” messages happens immediately prior to serializing the data into a protocol\nbuffer, and it is performed in two steps. Step one involves Base64-encoding the data, which is then passed\nto another function that performs XOR encoding using a hardcoded string:\n\n_Figure 20 - Base64 and XOR encoding prior to Serialization._\n\nNow that we understand how data is encoded, serialized, and encrypted, and we can recover both the\nXOR key and symmetric encryption key through de-Gobfuscation, it is possible to decrypt ChaChi traffic.\nWe will discuss the decryption process in more depth later. In all samples found and analyzed, the XOR\nkey used was “d*ck” (replace * with an i) and the encryption key was\n“37c3cb07b37d43721b3a8171959d2dff11ff904b048a334012239be9c7b87f63”. This leaves little doubt that\nit is a singular threat actor or group behind all attacks where a ChaChi binary was found.\n\n### Alternative/Failover C2\n\nAs already mentioned, ChaChi will initially attempt to establish C2 communications over DNS via Chashells\nDNS Streams. Should those initial attempts fail, it will failover to HTTP:\n\n\n-----\n\n_Figure 21 - C2 Communications Failover._\n\nThis failover method is not ideal for the ChaChi operators. It does not offer the encryption afforded to the\nDNS tunnelling, and it is nowhere near as covert.\n\nThe HTTP C2 communications are performed using POST requests to one of the randomly selected C2\nIPs decoded earlier. The content of the HTTP POST is encoded using Base64 and XOR encoding to offer\nsome level of data protection, in the same way as the data was encoded prior to being serialized into the\n“ChunkData” messages in the case of DNS tunnelling.\n\nShould the C2 check-in fail, it will rotate through the other decoded C2 IPs in an attempt to create a\nconnection. If a connection is established, ChaChi will encode and send POST requests to the C2 and\nprocess its responses:\n\n\n-----\n\n_Figure 22 - HTTP POST Request and Response Processing._\n\n### Decrypting C2 Traffic\n\nAs the use of HTTP for C2 communications is less complicated and involves less steps when compared to\nDNS tunnelling, this section will focus on decryption of DNS traffic.\n\nDecryption of both HTTP and DNS C2 traffic is possible because, once we obtain both the XOR and\nencryption keys, we can reverse the process that has taken plaintext data and converted it to an encrypted\nform. Each phase in the encoding and encryption process is reversible:\n\n_Figure 23 - Encoding and Encryption Process to generate TXT Query._\n\nTo do this, we perform the following steps:\n\nRetrieve DNS TXT queries from packet captures or DNS logs.\nStrip the domain name and “.” separators.\nDecode the string from hex back to bytes.\nRun the decoded content along with the recovered encryption key through a XSalsa20+Poly1305\ndecryption process.\nDe-serialize the decrypted data in order to access the packet field of the “ChunkData” messages –\nother message types are fully decrypted at this point.\nApply XOR decoding using the recovered XOR key to the packet field of each “ChunkData” message.\nBase64-decode the result of the XOR operation.\n\n\n-----\n\nThe result of the above process yields decrypted and de-serialized protocol buffers as well as the original\ndata that was encoded and packed into “ChunkData” packets. Given our knowledge of the Chashell\nprotocol buffer message structure, we just need to search through the proto-buffer messages for\n“ChunkStart” messages. These will inform us about both the number of chunks that make up the original\ndata, and also the exact “ChunkData” messages containing that data:\n\n_Figure 24 - ChunkStart Message Structure._\n\nIf we do this successfully (and apply some formatting), we are able to decrypt the C2 traffic that is\nexchanged between the ChaChi server and client. If the ChaChi operators were leveraging a standard\nChashell build, we would see something like the content below in the decrypted traffic, where it is evident\nthat a reverse shell has been established:\n\n_Figure 25 - Traffic decrypted and Rebuilt from Standard Chashell._\n\n### C2 Check-In and Commands\n\nThe initial check-in data that is sent to the C2 server takes the following form:\n\n_Figure 26 - C2 Check-in Structure._\n\n\n-----\n\nThe ID is a hardcoded string value that varies between samples, but generally starts with a 1, 2 or 9,\nfollowed by 3 digits (e.g., “1018”). The last three digits are decoded from a gobfuscated string, and the first\ndigit is prepended to the check-in string shortly before check-in.\n\nThe MD5 hash is the result of hashing a randomly generated integer value that changes every time ChaChi\nis executed.\n\nThe computer name and username are obtained through the execution of two PowerShell commands that\nretrieve the values stored in the relevant environment variables:\n\n_Figure 27 - Obtaining Computer and Username using PowerShell._\n\nThere is a second check-in which occurs that contains just an ID, this time with 2 prepended instead of 1,\nand the same MD5 from the first check-in. No computer or username is used in the second check-in. Both\ncheck-in strings are encoded and encrypted using the method discussed earlier, but it is the responses to\neach of these individual check-ins that decides what happens next.\n\nBelow we can see the two C2 check-ins, and the responses from the server:\n\n\n-----\n\n_Figure 28 - Decrypted C2 Check-ins and Responses._\n\nIn the screenshot above, we can see the first check-in string. The response from the server to this first\ncheck-in is a string that contains the generated MD5 hash that was passed in the check-in, but with “-zig”\nappended to it.\n\nThe first character of this response (the “9”, in this case) is XOR’d with the first character of the XOR key\nthat is also used in the C2 encoding process (“d” in the sample that generated the above traffic). The result\nof this XOR operation is further XOR’d with the first, and in this case only, character returned as a response\nto the second C2 check-in (the letter “m”). The result of these two XOR operations is the number “0”.\n\nThis resultant integer, which is not always zero, is the command ID component of a larger string that is\npassed to a function that will decide the next action that ChaChi has been instructed to take. The expected\nargument for the command selection function takes the form shown in the image below. The number of\narguments expected varies depending on the command ID supplied to ChaChi, but no more than two\narguments are expected to follow the command ID. Each element is delimited by triple forward slashes,\n“///”:\n\n_Figure 29 - Command selection and Argument Structure._\n\nThe possible command ID options and their corresponding action on the host is documented in the table\nbelow. Invalid command IDs will not be processed:\n\n**Command ID** **Action**\n\n\n-----\n\n**1** Decode Base64 encoded arguments and execute them as a command on the host\n\n**2** Start reverse SOCKS5 proxy server by connecting to provided client address:port\n\n**3** Start reverse SOCKS5 proxy server by connecting to provided client address:port\n\n**4** Restart C2 session\n\n**7** Start Chisel client\n\n**9** Uninstall backdoor – delete service and binary\n\n_Table 1 - ChaChi Command ID to Operation Mapping._\n\n### Command Execution\n\nShould the ChaChi operators want to execute a command or run a program on the infected host, the\nexpected command structure would look like the example below. The command to be executed (including\nany arguments and switches) is encoded into a single Base64 string. ChaChi will handle the decoding and\nparsing of the string into a command line array, splitting the decoded string on every space encountered:\n\n_Figure 30 - ChaChi Command Execution Structure._\n\nIf an attacker wanted to execute something as simple as “whoami”, the command received by ChaChi\nwould look like the string below, where “whoami” is in Base64 encoded form:\n\n_Figure 31 - Format of \"whoami\" command._\n\nChaChi will parse this string, identify it as a command, decode it from Base64, and reconstruct the\ncommand line string:\n\n_Figure 32 - Base64 Decoding of command argument - \"whoami\"._\n\n\n-----\n\nIf the program name itself contains no path separators (as is the case in this example), the underlying Go\nfunction “os.exec.Command” will resolve the complete path name where possible. Otherwise, it uses the\nname directly as the path before executing the command:\n\n_Figure 33 - Executing Command._\n\n### Reverse SOCKS5 Proxy\n\nSOCKS proxies are a much-used tool by Red Teams and threat actors, as they offer a level of anonymity\nby making traffic appear as if it is originating from one machine when it is in fact coming from a different\nmachine. SOCKS proxies and in particular reverse SOCKS proxies, can also provide attackers with a\nmeans of persistent access into an otherwise inaccessible private network from a machine on the Internet.\n\nThe developers of ChaChi again opted to avoid reinventing the wheel when they decided to add SOCKS\nproxy functionality into ChaChi. They have borrowed yet more code, this time from what appears to be\n[rsocks.](https://github.com/brimstone/rsocks)\n\n“Rsocks” is a reverse SOCKS5 client and server, but only the server-side code has been integrated into\nChaChi. A default rsocks build does not offer any form of encryption of the traffic traversing the proxy, so\nthe ChaChi authors decided to add that functionality to their version of the code. They did this by swapping\nout the standard call to “net.Dial” with the more secure alternative “crypto[.]tls[.]DialWithDialer”, which\nencrypts the proxied traffic using TLS:\n\n\n-----\n\nFigure 34 - Original rsocks source code with net.Dial .\n\n_Figure 35 - Modified \"rsocks\" with added TLS encryption._\n\nWhen the ChaChi operators wish to start the proxy server on the infected host, the expected command\nstructure would look like the example in the picture below. In the case of the reverse SOCKS5 proxy, a\ncommand ID of 2 or 3 is accepted, because both have the exact same effect:\n\n_Figure 36 - Reverse SOCKS5 Proxy Command Structure._\n\nThe client address can take the form of an IP or domain. The example in the image below is trying to\nconnect to a client listening on the same machine (i.e., 127.0.0.1) and port 8080. This is the equivalent of\nrunning “rsocks -connect 127.0.0.1:8080”. In the case of the ChaChi operators, the “127.0.0.1” could also\nbe replaced by one of their public C2 IPs or domains:\n\n_Figure 37 - Reverse SOCKS5 proxy command example._\n\nBase64 encoding is not a requirement for the reverse socks proxy. ChaChi simply parses out the client\naddress and port, joins them with a colon, and passes that new string to the reverse SOCKS5 proxy setup\ncode that sets up the proxy session:\n\n_Figure 38 - Passing parsed “client:port” string to reverse socks Go routine._\n\n\n-----\n\nWith a SOCKS5 proxy session established, the ChaChi operators can now run tools such as nmap through\nthe proxy in order to scan the compromised internal network. As this is a reverse proxy, it is the server\ncomponent that initiates the connection to the client. This is obviously the better option for the operators of\nChaChi, because they will be operating from behind enemy lines, so to speak.\n\nIt is notable that the string “Starting server” from rsocks is not present in ChaChi. Instead, it is replaced with\n[“Starting client”, which appears in other Golang-base SOCKS proxy code such as the rclient component of](https://github.com/llkat/rsockstun/blob/master/rclient.go)\n[rsockstun. It is possible that this is a remnant of experimentation during the development process, as the](https://github.com/llkat/rsockstun)\n[first iteration of ChaChi was confirmed by BlackBerry analysts as using go-socks5, which is yet another](https://github.com/armon/go-socks5)\nGolang based SOCKS5 server. This indicates that ChaChi developers seem take what they require and\nleave what they don’t:\n\nFigure 39 - Default \"Starting server\" string.\n\n_Figure 40 - Modified \"Starting client\" string._\n\n### New C2 Session\n\nCommand ID 4 triggers a new C2 session. No other arguments are expected or even parsed if they should\nbe provided. This option would be useful in the event of a session timeout or if the session has become\nunresponsive and the attackers wanted to establish a fresh session. The other choice that is made is\n\n\n-----\n\nwhether to connect over DNS or HTTP, but this is automatically determined by which connection protocol\nwas successful in earlier attempts, rather than through any external action:\n\n_Figure 41 - Command ID 4 triggers a new C2 Connection over DNS or HTTP._\n\n### Chisel Client\n\nChisel is an application that simplifies port-forwarding and is useful in scenarios where an attacker might\nnot have access to an SSH client or server, as SSH is normally the tool of choice for port-forwarding when\nit’s available. However, the majority of Windows operating systems either do not have it installed, or it is\ndisabled by default.\n\nPort-forwarding also has some other benefits that would prove useful to the authors of ChaChi, which is\npotentially why they decided to include the Chisel client in their backdoor.\n\n[As described by its README on GitHub, “Chisel is a fast TCP/UDP tunnel, transported over HTTP,](https://github.com/jpillora/chisel)\n_secured via SSH … Chisel is mainly useful for passing through firewalls, though it can also be used to_\n_provide a secure endpoint into your network.”._\n\nThe Chisel client is activated using command ID 7. It expects to receive the IP or a domain name of the\nChisel server and a port. As we will see later, this is exposed on the Chisel Server (which is the attacker’s\nbox) that will be forwarded to the local SOCKS port, which is 1080:\n\n_Figure 42 - Chisel command example structure._\n\nChaChi will parse the address of the Chisel server and prepend it with http://, then append it with “:443”:\n\n_Figure 43 - Constructing the Chisel Server Address._\n\nThe provided port is concatenated with two other decoded strings to form a string that takes the form\n“R:0.0.0.0:<port>:socks”:\n\n\n-----\n\n_Figure 44 - Construction Chisel Port Forwarding String._\n\nThe constructed components are passed to a function that generates a new Chisel client, which – if it were\nrun with a standalone Chisel binary – would look something like this:\n\n_Figure 45 - Equivalent Chisel Command._\n\nIn effect, this will establish a reverse port forwarding connection to the Chisel server located at\nevildomain[.]xyz and listening on port 443. It will forward any connections made to the server port 1337 to\nthe local socks port, 1080, on the compromised host.\n\nBecause address “0.0.0.0” is specified as the local address on the server side, this would allow access to\nport 1337 from any interface on the server rather than just localhost. This should therefore allow the\nattackers to connect from anywhere on the Internet via evildomain[.]xyz:1337 directly into the compromised\nnetwork and have their traffic emerge on port 1080.\n\nShould they wish to, they could even have the rsocks server connect out via the Chisel tunnel. An\ninteresting point here is that the ChaChi operators have hard coded some of the strings used in this Chisel\ncommand string, namely the use of “HTTP” and port “443”. This would cause HTTP traffic to traverse the\nnetwork on a non-standard port (i.e., 443) which might be a red flag to an observant network analyst.\n\n### Uninstalling the Backdoor\n\nAs with command ID 4, command ID 9 does not expect any further arguments to be supplied. When the\nChaChi operators execute command 9, it undertakes the process of uninstalling itself from the infected\nhost machine. This is done in two stages. The first step involves deletion of the previous installed service\nusing the Windows utility “sc”:\n\n_Figure 46 - Use \"sc\" to delete service then get temp path._\n\n\n-----\n\nAs can be seen above, immediately following the service deletion, ChaChi retrieves the path to the\n%TEMP% directory using PowerShell. This is done because ChaChi will create and write a batch file,\n“del.bat”, to the temp directory that will carry out the task of deleting the ChaChi binary from its location on\ndisk:\n\n_Figure 47 - Contents of \"del.bat\" used to delete ChaChi binary._\n\nThis command is of particular use to the ChaChi operators because, once they have completed their\nobjectives within the compromised environment, they want to cover their tracks.\n\n### Network Infrastructure\n\nAnalysis of extracted networking indicators of compromise (IOCs) can yield some information that can be\nused as TTPs, and which hint at past (and potentially even current) targets. By mapping out a timeline of\nfirst-seen dates for domains extracted from ChaChi binaries, we can observe a period of time from late\n2019 up to the first quarter of 2021 where the PYSA operators were most active.\n\nA total of 19 new domains were created in that period, which acted as the C2 for ChaChi. From our data,\nChaChi domains can and have been created several months prior to an actual attack taking place. The\nsame ChaChi binaries, and therefore domains, were even used in multiple attacks:\n\n_Figure 48 - Timeline of Domains by first-seen dates._\n\nWhen we dig only a little deeper into these domains, we see what could be used as a TTP for the PYSA\noperators; their overwhelming preference for using the domain name registrar Namecheap:\n\n**Domain** **Registrar**\n\nstarhouse[.]xyz Namecheap Inc.\n\n\n-----\n\ndowax[.]xyz Namecheap Inc.\n\nntservicepack[.]com OVH Hosting\n\nreportservicefuture[.]website Namecheap Inc.\n\nspm[.]best Namecheap Inc.\n\nblitz[.]best Namecheap Inc.\n\naccounting-consult[.]xyz Namecheap Inc.\n\nstatistics-update[.]xyz Namecheap Inc.\n\nsbvjhs[.]club Namecheap Inc.\n\nsbvjhs[.]xyz Namecheap Inc.\n\nwiki-text[.]xyz Namecheap Inc.\n\nvisual-translator[.]xyz Namecheap Inc.\n\nfirefox-search[.]xyz Namecheap Inc.\n\nserchtext[.]xyz Namecheap Inc.\n\nenglishdict[.]xyz Namecheap Inc.\n\nenglishdialoge[.]xyz Namecheap Inc.\n\nenglish-breakfast[.]xyz Namecheap Inc.\n\npump-online[.]xyz Namecheap Inc.\n\ncvar99[.]xyz Namecheap Inc.\n\nproductoccup[.]tech Namecheap Inc.\n\ntransnet[.]wiki Namecheap Inc.\n\n_Table 2 - Mapping of Domains to Registrars._\n\n\n-----\n\nTaking the IP Addresses from ChaChi binaries and mapping them to their respective ASNs and Regions,\nwe can see IP addresses based in either Romania or Germany account for over 50% of the total.\nApproximately 60% of the IP addresses are sourced from just two ASNs:\n\n**IP ADDRESS** **ASN** **Region**\n\n23.83.133[.]136 AS19148 - LEASEWEB-USA U.S.\n\n172.96.189[.]167 AS20068 - HAWKHOST CA\n\n172.96.189[.]22 AS20068 - HAWKHOST CA\n\n172.96.189[.]246 AS20068 - HAWKHOST CA\n\n198.252.100[.]37 AS20068 - HAWKHOST CA\n\n185.185.27[.]3 AS201206 - LINEVAST DE\n\n160.20.147[.]184 AS30823 - COMBAHTON DE\n\n45.147.228[.]49 AS30823 - COMBAHTON DE\n\n45.147.229[.]29 AS30823 - COMBAHTON DE\n\n45.147.230[.]162 AS30823 - COMBAHTON DE\n\n45.147.230[.]212 AS30823 - COMBAHTON DE\n\n185.186.245[.]85 AS40824 - WZCOM-US U.S.\n\n185.183.96[.]147 AS60117 - HS NL\n\n194.5.249[.]137 AS64398 - NXTHOST RO\n\n194.5.249[.]138 AS64398 - NXTHOST RO\n\n194.5.249[.]139 AS64398 - NXTHOST RO\n\n194.5.249[.]18 AS64398 - NXTHOST RO\n\n194.5.249[.]180 AS64398 - NXTHOST RO\n\n\n-----\n\n194.5.250[.]151 AS64398 - NXTHOST RO\n\n194.5.250[.]162 AS64398 - NXTHOST RO\n\n194.5.250[.]216 AS64398 - NXTHOST RO\n\n193.239.84[.]205 AS9009 GB\n\n193.239.85[.]55 AS9009 RO\n\n37.120.140[.]184 AS9009 RO\n\n37.120.140[.]247 AS9009 RO\n\n37.120.145[.]208 AS9009 DK\n\n86.106.20[.]144 AS9009 NL\n\n89.38.225[.]208 AS9009 SG\n\n89.41.26[.]173 AS9009 U.S.\n\n194.187.249[.]102 AS9009 FR\n\n194.187.249[.]138 AS9009 FR\n\n37.221.113[.]66 AS9009 GB\n\n_Table 3 - IP to ASN and Region Mapping._\n\nBlackBerry researchers continuously track and monitor C2 servers by using a variety of fingerprinting and\ndiscovery techniques, storing all discovered C2 infrastructure in our internal Threat Intelligence systems.\n\nOne of the above IP addresses happened to appear in one of our intelligence platforms in early December\nof 2020 and was active for a period of just over 24 hours. The IP (45.147.230[.]212) is hosted by AS30823\nCombahton in Germany. It triggered one of our sensors for PowerShell Empire, artifacts of which have\n[been observed on systems following a PYSA ransomware incident:](https://www.cert.ssi.gouv.fr/uploads/CERTFR-2020-CTI-003.pdf)\n\n\n-----\n\n_Figure 49 - Alert for PowerShell Empire on Public Facing Server._\n\nChecking the domain resolutions on the extracted IP addresses can also provide some interesting results\nand intelligence. The IP address 194.187.249[.]102 was extracted from a sample of ChaChi along with a\ndomain used as a C2 server. This domain was sbvjhs[.]xyz. Unsurprisingly, the name servers, “ns1” and\n“ns2” for that domain also resolve to the same IP address. But what is interesting is that the other domain\nthat also resolves to that same IP is login.bancocchile[.]com.\n\n_Figure 50 - ChaChi IP resolving to fake Banco Chile Domain._\n\nThe legitimate domain for Banco Chile is hosted on a “.cl” Top Level Domain (TLD) and does not have the\nextra “c” between the words “Banco” and “Chile”. This is a domain that was potentially intended for one of\ntwo purposes:\n\nA phishing domain that is targeting either employees or customers of Banco Chile\nA domain used to stage and deliver a copy of ChaChi to unsuspecting clickers of a malicious link\n\nEither one or even both options are possible, considering these domains were active simultaneously and\nfor several months; their last-seen dates were as recent as June 1, 2021. Coincidentally, both nameserver\ndomains and the fake Banco Chile domain were all active before, during, and after the reported Breach at\nanother Chilean bank (Banco Estado), which was reported in September 2020 and attributed to REvil\n[ransomware.](https://www.zdnet.com/article/chilean-bank-shuts-down-all-branches-following-ransomware-attack/)\n\n### Conclusion\n\n\n-----\n\nChaChi is a custom RAT developed using the relatively new programming language Go (aka Golang). By\nusing Go to develop ChaChi, PYSA ransomware operators can frustrate detection and prevention efforts\nby analysts and tools unfamiliar with the language. The earliest version of ChaChi lacked several features\nof more mature malware, but its rapid evolution and recent deployment against national governments,\nhealthcare organizations, and educational institutions indicates this malware is being actively developed\nand improved.\n\nChaChi is a powerful tool in the hands of malicious actors who are targeting industries notoriously\nsusceptible to cyberattacks. It has demonstrated itself as a capable threat, and its use by PYSA\nransomware operatives is a cause for concern, especially at a time when ransomware is experiencing\n[alarming success through a string of high-profile attacks including campaigns conducted by REvil,](https://blogs.blackberry.com/en/2021/06/blackberry-prevents-revil-ransomware) [Avaddon](https://blogs.blackberry.com/en/2021/06/threat-thursday-avaddon-ransomware-uses-ddos-attacks-as-triple-threat)\n[and DarkSide. Organizations ignoring this threat do so at their own risk, in a year of one-after-another](https://blogs.blackberry.com/en/2021/05/threat-thursday-delving-into-the-darkside)\ncybersecurity disasters.\n\nAppendix\n\nYara Rule\nThe following Yara rule was authored by the BlackBerry Threat Research Team to catch the threat\ndescribed in this document:\n\nrule Mal_Backdoor_ChaChi_RAT\n\n{\nmeta:\n\ndescription = \"ChaChi RAT used in PYSA Ransomware Campaigns\"\n\nauthor = \"BlackBerry Threat Research & Intelligence\"\n\nstrings:\n\n// \"Go build ID:\"\n\n$go = { 47 6F 20 62 75 69 6C 64 20 49 44 3A }\n\n// dnsStream\n\n$dnsStream = { 64 6E 73 53 74 72 65 61 6D }\n\n// SOCKS5\n\n$socks5 = { 53 4F 43 4B 53 35 }\n\n// chisel\n\n$chisel = { 63 68 69 73 65 6C }\n\ncondition:\n\n// MZ signature at offset 0\n\nuint16(0) == 0x5A4D and\n\n// PE signature at offset stored in MZ header at 0x3C\n\nuint32(uint32(0x3C)) == 0x00004550 and\n// ChaChi Strings\n\nall of them\n\n}\n\n### Indicators of Compromise (IoCs)\n\nAt BlackBerry, we take a [prevention-first and AI-driven approach to cybersecurity. Putting prevention first](https://blogs.blackberry.com/en/2021/01/from-aspiration-to-realization-the-evolution-of-the-prevention-first-approach-to-security)\nneutralizes malware before the exploitation stage of the kill-chain.\n\nBy stopping malware at this stage, BlackBerry solutions help organizations increase their resilience. It also\nhelps reduce infrastructure complexity and streamline security management to ensure business, people,\nand endpoints are secure.\n\n\n-----\n\n**Indicator** **Type** **Description**\n\n12b927235ab1a5eb87222ef34e88d4aababe23804ae12dc0807ca6b256c7281c SHA256 ChaChi\n\n8a9205709c6a1e5923c66b63addc1f833461df2c7e26d9176993f14de2a39d5b SHA256 ChaChi\n\n37c3cb07b37d43721b3a8171959d2dff11ff904b048a334012239be9c7b87f63 SHA256 ChaChi\n\n0bcbc1faec0c44d157d5c8170be4764f290d34078516da5dcd8b5039ef54f5ca SHA256 ChaChi\n\n6eb0455b0ab3073c88fcba0cad92f73cc53459f94008e57100dc741c23cf41a3 SHA256 ChaChi\n\n89b9ba56ebe73362ef83e7197f85f6480c1e85384ad0bc2a76505ba97a681010 SHA256 ChaChi\n\n701791cd5ed3e3b137dd121a0458977099bb194a4580f364802914483c72b3ce SHA256 ChaChi\n\nc9bed25ab291953872c90126ce5283ce1ad5269ff8c1bca74a42468db7417045 SHA256 ChaChi\n\ne47a632bfd08e72d15517170b06c2de140f5f237b2f370e12fbb3ad4ff75f649 SHA256 ChaChi\n\n0fd13ece461511fbc129f6584d45fea920200116f41d6097e4dffeb965b19ef4 SHA256 ChaChi\n\n3a6ddc4022f6abe7bdb95a3ba491aaf7f9713bcb6db1fbaa299f7c68ab04d4f4 SHA256 ChaChi\n\n5d8459c2170c296288e2c0dd9a77f5d973b22213af8fa0d276a8794ffe8dc159 SHA256 ChaChi\n\n6d1fde9a5963a672f5e4b35cc7b8eaa8520d830eb30c67fadf8ab82aeb28b81a SHA256 ChaChi\n\n8b5cdbd315da292bbbeb9ff4e933c98f0e3de37b5b813e87a6b9796e10fbe9e8 SHA256 ChaChi\n\n2697bbe0e96c801ff615a97c2258ac27eec015077df5222d52f3fbbcdca901f5 SHA256 ChaChi\n\n85c8ccf45cdb84e99cce74c376ce73fdf08fdd6d0a7809702e317c18a016b388 SHA256 ChaChi\n\n7b5027bd231d8c62f70141fa4f50098d056009b46fa2fac16183d1321be04768 SHA256 ChaChi\n\n9986b6881fc1df8f119a6ed693a7858c606aed291b0b2f2b3d9ed866337bdbde SHA256 ChaChi\n\na30e605fa404e3fcbfc50cb94482618add30f8d4dbd9b38ed595764760eb2e80 SHA256 ChaChi\n\naa2faf0f41cc1710caf736f9c966bf82528a97631e94c7a5d23eadcbe0a2b586 SHA256 ChaChi\n\n\n-----\n\naf97b35d9e30db252034129b7b3e4e6584d1268d00cde9654024ce460526f61e SHA256 ChaChi\n\n045510eb6c86fc2d966aded8722f4c0e73690b5078771944ec1a842e50af4410 SHA256 ChaChi\n\nb0629dcb1b95b7d7d65e1dad7549057c11b06600c319db494548c88ec690551e SHA256 ChaChi\n\nccfa2c14159a535ff1e5a42c5dcfb2a759a1f4b6a410028fd8b4640b4f7983c1 SHA256 ChaChi\n\nd591f43fc34163c9adbcc98f51bb2771223cc78081e98839ca419e6efd711820 SHA256 ChaChi\n\nef31b968c71b0e21d9b0674e3200f5a6eb1ebf6700756d4515da7800c2ee6a0f SHA256 ChaChi\n\nf5cb94aa3e1a4a8b6d107d12081e0770e95f08a96f0fc4d5214e8226d71e7eb7 SHA256 ChaChi\n\nf8a5065eb53b1e3ac81748176f43dce1f9e06ea8db1ecfa38c146e8ea89fcc0b SHA256 ChaChi\n\n44af9d898f417506b5a1f9387f3ce27b9dfa572aae799295ca95eb0c54403cff SHA256 Bat file used\nto delete\nbackdoor\nbinary\n\n\nPowerShell $env:ComputerName Commandline\n\nPowerShell $env:Username Commandline\n\nPowerShell $env:tmp Commandline\n\nJavaJDBC Service\nname\n\nAzure Agent Controller Service\nname\n\n\nPowerShell\nused to\nobtain\nComputer\nName\n\nPowerShell\nused to\nobtain\nUsername\n\nPowerShell\nused to\nobtain\n%TEMP%\npath\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\n\n-----\n\nAzure Safe controller Service\nname\n\nAzureAgentController Service\nname\n\nCorpNativeHostDebugger Service\nname\n\nCorp Native Host Debugger Service\nname\n\nDefender Security Agents Service\nname\n\nDefenderSecurityAgent Service\nname\n\nGet Service Controller Service\nname\n\nGetServiceController Service\nname\n\nService agent security control Service\nname\n\nWindows service controller Service\nname\n\nMicrosoftSecurityManager Service\nname\n\nMicrosoft Security Manager Service\nname\n\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\n\n-----\n\nWindowsSoftwareManagerDebugger Service\nname\n\nMicrosoftTeamConnectDebugger Service\nname\n\nMicrosoftTriangleConnectDebugger Service\nname\n\nMicrosoft Triangle Connect Debugger Service\nname\n\nWindowsProtectionSystem Service\nname\n\nWindows Protection System Service\nname\n\nWindowsHealthSubSystem Service\nname\n\nMsStudioAgentUpdateService Service\nname\n\nVisualIdeIndexer Service\nname\n\nVisual studio indexer Service\nname\n\nVisual Ide Indexer Service\nname\n\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\nInstallation\nService\nName\n\n\ndel.bat Filename Bat file used\nto delete\nbackdoor\nbinary\n\n\n-----\n\nEnglishdialoge[.]xyz Domain ChaChi C2\n\nstarhouse[.]xyz Domain ChaChi C2\n\naccounting-consult[.]xyz Domain ChaChi C2\n\nblitzz[.]best Domain ChaChi C2\n\nccenter[.]tech Domain ChaChi C2\n\ncvar99[.]xyz Domain ChaChi C2\n\ndowax[.]xyz Domain ChaChi C2\n\nenglishdict[.]xyz Domain ChaChi C2\n\nenglish-breakfast[.]xyz Domain ChaChi C2\n\nfirefox-search[.]xyz Domain ChaChi C2\n\nntservicepack[.]com Domain ChaChi C2\n\nproductoccup[.]tech Domain ChaChi C2\n\npump-online[.]xyz Domain ChaChi C2\n\nreportservicefuture[.]website Domain ChaChi C2\n\nsbvjhs[.]club Domain ChaChi C2\n\nsbvjhs[.]xyz Domain ChaChi C2\n\nserchtext[.]xyz Domain ChaChi C2\n\nspm[.]best Domain ChaChi C2\n\nstatistics-update[.]xyz Domain ChaChi C2\n\ntransnet[.]wiki Domain ChaChi C2\n\nvisual-translator[.]xyz Domain ChaChi C2\n\n\n-----\n\nwiki-text[.]xyz Domain ChaChi C2\n\n160.20.147[.]184 IP ChaChi C2\nIP\n\n172.96.189[.]167 IP ChaChi C2\nIP\n\n193.239.84[.]205 IP ChaChi C2\nIP\n\n89.41.26[.]173 IP ChaChi C2\nIP\n\n172.96.189[.]22 IP ChaChi C2\nIP\n\n172.96.189[.]246 IP ChaChi C2\nIP\n\n185.183.96[.]147 IP ChaChi C2\nIP\n\n185.185.27[.]3 IP ChaChi C2\nIP\n\n185.186.245[.]85 IP ChaChi C2\nIP\n\n193.239.85[.]55 IP ChaChi C2\nIP\n\n194.187.249[.]102 IP ChaChi C2\nIP\n\n194.187.249[.]138 IP ChaChi C2\nIP\n\n194.5.249[.]137 IP ChaChi C2\nIP\n\n194.5.249[.]138 IP ChaChi C2\nIP\n\n194.5.249[.]139 IP ChaChi C2\nIP\n\n\n-----\n\n194.5.249[.]18 IP ChaChi C2\nIP\n\n194.5.249.[]180 IP ChaChi C2\nIP\n\n194.5.250[.]151 IP ChaChi C2\nIP\n\n194.5.250[.]162 IP ChaChi C2\nIP\n\n194.5.250[.]216 IP ChaChi C2\nIP\n\n198.252.100[.]37 IP ChaChi C2\nIP\n\n23.83.133[.]136 IP ChaChi C2\nIP\n\n37.120.140[.]184 IP ChaChi C2\nIP\n\n37.120.140[.]247 IP ChaChi C2\nIP\n\n37.120.145[.]208 IP ChaChi C2\nIP\n\n37.221.113[.]66 IP ChaChi C2\nIP\n\n45.147.228[.]49 IP ChaChi C2\nIP\n\n45.147.229[.]29 IP ChaChi C2\nIP\n\n45.147.230[.]162 IP ChaChi C2\nIP\n\n45.147.230[.]212 IP ChaChi C2\nIP\n\n\n-----\n\n86.106.20[.]144 IP ChaChi C2\nIP\n\n89.38.225[.]208 IP ChaChi C2\nIP\n\n### MITRE ATT&CK\n\n**Tactic** **ID** **Name** **Description**\n\n\n**Execution** [T1059/001](https://attack.mitre.org/techniques/T1059/001/) Command and\nScripting Interpreter:\nPowerShell\n\n\n[T1059/003](https://attack.mitre.org/techniques/T1059/003/) Command and Scripting\nInterpreter: Windows\nCommand Shell\n\n[T1569/002](https://attack.mitre.org/techniques/T1569/002/) System Services: Service\nExecution\n\n\nReverse shell and\nservice deletion\n\nUsed to execute\nChaChi once installed\n\n\nChaChi - enumerate system\nand execute commands - C2\nCommand\n\nChaChi Installation as a\nService\n\nChaChi - Gobfuscated\nFunctions and Strings\n\n\n**Persistence** [T1543/003](https://attack.mitre.org/techniques/T1543/003/) Create or Modify\nSystem Process:\nWindows Service\n\n\n**Defence**\n**Evasion**\n\n\n[T1027](https://attack.mitre.org/techniques/T1027/) Obfuscated Files or\nInformation\n\n\n**Discovery** [T1057](https://attack.mitre.org/techniques/T1057/) Process Discovery ChaChi - Process Enumeration\n\n\n[T1082](https://attack.mitre.org/techniques/T1082/) System Information\nDiscovery\n\n\nChaChi - Computer\nName and Username\n\n\n**C2** [T1572](https://attack.mitre.org/techniques/T1572/) Protocol Tunnelling ChaChi - DNS tunnelling for C2\n\n\n[T1071/001](https://attack.mitre.org/techniques/T1071/001/) Application Layer Protocol:\nWeb Protocols\n\n\nChaChi – HTTP for C2\n\n\n[T1090/002](https://attack.mitre.org/techniques/T1090/002/) Proxy: External Proxy ChaChi – SOCKS5\nproxy\n\n\n-----\n\n[T1001](https://attack.mitre.org/techniques/T1001/) Data Obfuscation ChaChi – Custom C2\nencoding\n\n[T1008](https://attack.mitre.org/techniques/T1008/) Fallback Channels ChaChi – DNS primary,\nHTTP fallback\n\n\n[T1573/001](https://attack.mitre.org/techniques/T1573/001/) Encrypted Channel:\nSymmetric Cryptography\n\n\nChaChi –\nXSalsa20+Poly1305 for\nC2 encryption\n\n\n**Exfiltration** [T1041](https://attack.mitre.org/techniques/T1041/) Exfiltration Over C2\nChannel\n\n\nChaChi\n\nChaChi Backdoor\n\n\n**Resource**\n**Development**\n\n\n[T1587/001](https://attack.mitre.org/techniques/T1587/001/) Develop Capabilities:\nMalware\n\n\n[T1583/001](https://attack.mitre.org/techniques/T1583/001/) Acquire Infrastructure:\nDomains\n\n**BlackBerry Assistance**\n\n\nChaChi Domain\nregistration\n\n\nIf you’re battling ChaChi GoLang RAT or a similar threat, you’ve come to the right place, regardless of your\nexisting BlackBerry relationship.\n\n[The BlackBerry Incident Response team is made up of world-class consultants dedicated to handling](https://www.blackberry.com/us/en/services/incident-response)\nresponse and containment services for a wide range of incidents, including ransomware and Advanced\nPersistent Threat (APT) cases.\n\nWe have a global consulting team standing by to assist you providing around-the-clock support, where\nrequired, as well as local assistance. Please contact us here:\n[https://www.blackberry.com/us/en/forms/cylance/handraiser/emergency-incident-response-containment.](https://www.blackberry.com/us/en/forms/cylance/handraiser/emergency-incident-response-containment)\n\n## About The BlackBerry Research & Intelligence Team\n\nThe BlackBerry Research & Intelligence team examines emerging and persistent threats, providing\nintelligence analysis for the benefit of defenders and the organizations they serve.\n\n\n-----\n\nBack\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-06-23 - PYSA Loves ChaChi- a New GoLang RAT.pdf"
    ],
    "report_names": [
        "2021-06-23 - PYSA Loves ChaChi- a New GoLang RAT.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536014,
    "ts_updated_at": 1743041313,
    "ts_creation_date": 1653779548,
    "ts_modification_date": 1653779548,
    "files": {
        "pdf": "https://archive.orkl.eu/de5e530b2ac383341014a844a0750fd4c7d03e5e.pdf",
        "text": "https://archive.orkl.eu/de5e530b2ac383341014a844a0750fd4c7d03e5e.txt",
        "img": "https://archive.orkl.eu/de5e530b2ac383341014a844a0750fd4c7d03e5e.jpg"
    }
}