{
    "id": "ddf90893-6ca1-42a1-a743-04eda76bdcfc",
    "created_at": "2023-01-12T15:07:19.532157Z",
    "updated_at": "2025-03-27T02:08:41.469628Z",
    "deleted_at": null,
    "sha1_hash": "db6bade5f9de9e6077dd342eeb9a8ba54411b1c0",
    "title": "2021-01-13 - [RE019] From A to X analyzing some real cases which used recent Emotet samples",
    "authors": "",
    "file_creation_date": "2022-05-28T03:53:31Z",
    "file_modification_date": "2022-05-28T03:53:31Z",
    "file_size": 3407871,
    "plain_text": "# [RE019] From A to X analyzing some real cases which used recent Emotet samples\n\n**[blog.vincss.net/2021/01/re019-from-a-to-x-analyzing-some-real-cases-which-used-recent-Emotet-samples.html](https://blog.vincss.net/2021/01/re019-from-a-to-x-analyzing-some-real-cases-which-used-recent-Emotet-samples.html)**\n\n### 1. Introduction\n\n**Emotet (also known as Heodo, Geodo) is one of the most dangerous Trojan today. Through mass email spam**\ncampaigns, it targets mostly companies and organizations to steal sensitive information from victims. Recent\nrecords show that Emotet is often used as a downloader for other malware, and is an especially popular\ndelivery mechanism for banking Trojans, such as Qakbot and TrickBot, and also lead to ransomware attacks\nusing Ryuk.\n\n[ANY.RUN’s annualreport pointed out that the most active malware in 2020 is Emotet.](https://any.run/cybersecurity-blog/annual-report-2020/)\n\n_Fig 1. Statistics of top threats by uploads for 2020_\n\nIn this article, we analyze in detail full attack flow in some real cases of recent Emotet samples which were\ndiscovered and handled by us while providing cyber security services to our customer:\n\n¨ Sample 1:\n\n[· Document template: b836b13821f36bd9266f47838d3e853e](https://www.virustotal.com/gui/file/66cf65178099c0dc02f51ffb7f4f3f2fe6e6b9f216d855172eeed318023b3308)\n\n[· Loader binary: 442506cc577786006da7073c0240ff59](https://www.virustotal.com/gui/file/a2eefb7fd4de96d56e98eb9612701ce66ef8d2bfaff35ded09f42b44c4a085c4)\n\n¨ Sample 2:\n\n[· Document template: 7dbd8ecfada1d39a81a58c9468b91039](https://www.virustotal.com/gui/file/dc40e48d2eb0e57cd16b1792bdccc185440f632783c7bcc87c955e1d4e88fc95)\n\n[· Loader binary: e87553aebac0bf74d165a87321c629be](https://www.virustotal.com/gui/file/9f3a07e6a4b0588cc4fcf4185639bde5806d212ea3b3ab8916fed2b1cc9414a7)\n\n¨ Sample 3:\n\n[· Document template: d5ca36c0deca5d71c71ce330c72c76aa](https://www.virustotal.com/gui/file/694a91bfb3682ed18a198d7872e50684580dd7610d1534675c665d0367095660)\n\n\n-----\n\n[Loader binary: 825b74dfdb58b39a1aa9847ee6470979](https://www.virustotal.com/gui/file/301c6be6158e5a28eeacab381f8e4266e4a15dc5bd149cb6724a3ea593bf0658)\n\n### 2. Type of infection\n\nThe main distribution method of Emotet malware is malicious email campaigns, using infected attachments, as\nwell as embedded URLs. These emails may appear to come from trusted sources (cause the victim's email\n_account was taken over). This technique helps trick users into downloading the Trojan onto their machine._\nSome illustration image of emails spread Emotet:\n\n_Fig 2. Examples of malicious emails with attachment_\n\n### 3. Document template and VBA code\n\nEmotet templates are constantly changing, the final target of attackers for leveraging templates to trick the\nvictims into enabling macros to start the infection.\n\n## 3.1. Sample 1\n\nDocument template:\n\n\n-----\n\n_Fig 3. Sample 1’s document template_\n\nThis sample still acts in the usual way:\n\nExecute VBA code when opening document through Sub Document_open().\nVBA code spawns powershell to execute encoded Base64 script.\n\n_Fig 4. VBA code spawns powershell to execute script_\n\nThe powershell script after decoding and deobfuscating usually look like the image below. It will download\nthe payload which is an exe file to execute:\n\n\n-----\n\n_Fig 5. Powershell script downloads payload from the C2 list for execution_\n\n## 3.2. Sample 2\n\nDocument template:\n\n_Fig 6. Sample 2’s document template_\n\nThis template also uses VBA, but there are some differences with Sample 1 as follows:\n\nVBA code is executed after closing document through Sub Document_Close().\nInstead of using powershell, this sample spawns certutil.exe for decoding enncoded Base64 payload\nand then call rundll32 for executing the decoded payload. The payload and related information are\nhidden in the document in white font.\n\n_Fig 7. VBA code uses certutil for decoding payload and calls rundll32 to load payload_\n\nDecode encoded base64 content will get VideoDownload.dll, this file has an exported function is In. This\nfunction is executed with the help of rundll32.exe.\n\n_Fig 8. Decoded payload is a DLL_\n\n\n-----\n\n_Fig 9. The expored function of DLL_\n\nThere is an embedded PE file in resource section of the above dll. The resource data is encoded.\n\n_Fig 10. DLL has a PE file that has been encoded_\n\nThe dll’s code when executed will load the content of a porn site, then retrieve the link of the .mp4 file\n(which is a hot keyword-related leaked sex clip of Vietnamese figure). It read bytes from mp4, through the\nloop, by using the read bytes as xor_key for decoding the above resource to get the complete PE file.\nThen it saves the decoded file to %temp%/tmp_e473b4.exe and execute this payload.\n\n\n-----\n\n_Fig 11. Pseudocode performs decoding resource data and spawns new process_\n\n## 3.3. Sample 3\n\nDocument Template:\n\n_Fig 12. Sample 3’s document template_\n\nSame as Sample 1:\n\nExecute VBA code when opening document through Sub Document_open().\nVBA code also spawns powershell to execute encoded Base64 script.\n\n\n-----\n\n_Fig13. VBA code spawns powershell to execute script_\n\nThe powershell script after decoding and deobfuscating will also performs the task of downloading the\npayload to execute:\n\n_Fig 14. Powershell script downloads payload from the C2 list for execution_\n\nDiffer from Sample 1 (use powershell to download loader is an exe file) and Sample 2 (decode DLL and\n_use this DLL to decrypt the loader as an exe file), in this Sample 3, the downloaded payload is a DLL file,_\nexports Control_RunDLL function. Script uses rundll32 to execute this payload. So that, the\ndownloaded payload is considered as a DLL loader.\n\n### 4. Loader payload\n\n## 4.1. Execution flow of loaders\n\nThe payloads of Sample 1 and 2 (PDB path information: \\eee\\ggggggg\\rseb.pdb) were built with Visual Basic:\n\n\n-----\n\n_Fig 15. Loaders of Sample 1 and 2 were built with Visual Basic_\n\n**Sample 3 was built with Visual C++ (PDB path information: E:\\WindowsSDK7-Samples-**\n**master\\WindowsSDK7-Samples-**\n**master\\winui\\shell\\appshellintegration\\RecipePropertyHandler\\Win32\\Release\\RecipePropertyHandler.pdb)**\n\n_Fig 16. Loader of Sample 3 was built with Visual C++_\n\nWhen first infected, the Emotet payload runs through two stages. During the first stage, it checks the victim\nsystem, if it's running with high privilege, it drops binary to CSIDL_SYSTEMX86, otherwise to\n**CSIDL_LOCAL_APPDATA. Finally, it launches the second instance. Payload running at the second stage will**\ncommunicate with C&C servers that embedded in its binary.\n\n_Fig 17. Sample 1 execution flow_\n\n\n-----\n\n_Fig 18. Sample 2 execution flow_\n\n_Fig 19. Sample 3 execution flow_\n\n## 4.2. Technical analysis of the loader\n\n 4.2.1. Sample 1 and 2\n\nThese loaders when executed will allocate and unpack the main payload to the allocated memory and execute\nthis payload:\n\n_Fig 20. Sample 1’s loader unpacks the main payload_\n\n\n-----\n\n_Fig 21. Sample 2’s loader unpacks the main payload_\n\nThese main payloads are quite small in size and were built with Visual C++:\n\n_Fig 22. The main payload of Sample 1 and 2_\n\n## 4.2.2. Sample 3\n\nThis sample, when executed, will get the address of two undocumented functions LdrFindResource_U and\n**LdrAccessResource from ntdll.dll. These functions are used to access resource data embedded in the**\nloader:\n\n_Fig 23. Sample 3’s loader accesses resource data_\n\n\n-----\n\nNext, it computes the MD5 hash of the pre initialized data and generates an RC4 key based on the computed\nhash. Then, use this RC4 key to decrypt the above resource data and execute the main payload:\n\n_Fig 24. Pseudocode performs decoding and executing the main payload_\n\nThe main payload is another DLL and also has an exported function is Control_RunDLL:\n\n_Fig 25. The main payload of Sample 3_\n\n### 5. Some techniques used in the main payload\n\n## 5.1. Control Flow Flattening\n\nA program’s control flow is a path created out of the instructions that can be executed by the program.\nDisassemblers, like IDA, Ghidra, visualize control flow as a graph by creating a series of connected blocks\n(called “basic blocks”). In order to make reverse engineering more difficult, thwart the analysis and avoid\ndetection, the main payload of Emotet usuallu apply an obfuscation technique is Control-flow flattening.\n\nBasically, this is a technique used to break the flow of a program's execution by flattening it. When the control\nflow is flattened, the program is divided into blocks, all of which are at the same level. Therefore, it will be\ndifficult to determine the execution order of the program at the first glance. After divided into blocks, there is a\ncontrol variable to determine which basic block should be executed. Its initial value is assigned before the loop.\nAt each block will update the value of the control variable to redirect the program flow to another branch\n\n\n-----\n\nBelow is the illustration for the main function of each above payload:\n\n_Fig 26. The main function of the main payload of Sample 1_\n\n_Fig 27. The main function of the main payload of Sample 2_\n\n\n-----\n\n_Fig 28. The main function of the main payload of Sample 3_\n\nIn order to deobfuscate this technique takes a lot of time and effort to do, so my personal experience as\nfollows:\n\nTry using [HexRaysDeob plugin that was developed by RolfRolles.](https://github.com/RolfRolles/HexRaysDeob)\nPerform static analysis using IDA, trying to guess the purpose of the functions, and name them.\nPerform debug and synchronize function names, variables that set in IDA with debugger with the help of\n[Labeless plugin. During debugging, note the order in which the functions are executed and make a](https://github.com/a1ext/labeless/)\ncomment back to IDA.\n\n## 5.2. Dynamic modules resolve\n\nAll payloads will rely on a pre-computed hash by the names of the DLLs to retrieve the base address of these\nDLLs when it needs to be used. In Sample 1 and 2, these hashes are passed directly to a function responsible\nfor obtaining the base address of the DLL (f_resolve_modules_from_hash):\n\n\n-----\n\n_Fig 29. Sampe 1 and 2 call f_resolve_modules_from_hash_\n\nParticularly in Sample 3, there is a little bit of change, hash values are pre-computed according to the name of\nthe DLL and the API function passed to the same function (f_get_api_funcs). Within this function, it uses\nthese hash values to retrieve the base address of the DLL:\n\n_Fig 30. Sample 3 call f_resolve_modules_from_hash_\n\nThe search algorithm in all three payloads is similar, only difference in the xored value:\n\n_Fig 31. Pseudocode performs looking up the hashes of the DLL name_\n\nRewrite the hash function, combined with IDAPython to get a list of DLLs that Emotet uses:\n\n_Fig 32. Results when using IDAPython_\n\n\n-----\n\nThe list of major DLLs that Emotet uses:\n\n**[+] userenv.dll**\n\n**[+] wininet.dll**\n\n**[+] urlmon.dll**\n\n**[+] shlwapi.dll**\n\n**[+] shell32.dll**\n\n**[+] advapi32.dll**\n\n**[+] crypt32.dll**\n\n**[+] wtsapi32.dll**\n\n**[+] kernel32.dll**\n\n**[+] ntdll.dll**\n\n_Fig 33. List of major DLLs that Emotet uses_\n\n## 5.3. Dynamic APIs resolve\n\nIn all three payloads, when need to use which API function Emotet will search and call that function. Based on\nthe base address of the given DLL, payloads resolve APIs by looking up the pre-computed hash.\n\n\n-----\n\nIn Sample 1 and 2,, these hashes are passed directly to a function responsible for obtaining API address\n(f_resolve_apis_from_hash):\n\n_Fig 34. Sampe 1 and 2 call f_resolve_apis_from_hash_\n\nIn Sample 3, as mentioned above, hash values are passed to the same function (f_get_api_funcs). Within this\nfunction calls to function (f_resolve_apis_from_hash) to retrieve the address of the API:\n\n_Fig 35. Sample 3 call f_resolve_apis_from_hash_\n\nThe search algorithm in all three payloads is similar, only difference in the xored value:\n\n_Fig 36. Pseudocode performs looking up the hashes of the API name_\n\nRewrite the hash function that payload uses, combined with IDAPython to retrieve all APIs and annotate to\nrelated code. The list of APIs used in these payloads are similar and similar to the other variants. The final\nresult is as follows:\n\n\n-----\n\n_Fig 37. The final result when using IDAPython to annotate related code_\n\n## 5.4. Decrypt strings\n\nAll strings are encrypted and only decrypt at runtime. The structure of the encrypted data is shown as below.\nThe decryption algorithm of the payloads is the same:\n\n_Fig 38. The payloads call the string decryption function_\n\nBased on the above information, can use IDApython to create a script to decrypt data as follows:\n\n_Fig 39. Python code is used for decrypting data_\n\nThe list of strings obtained in payloads is quite similar:\n\n\n-----\n\n_Fig 40. List of strings obtained after using the script_\n\n## 5.5. List of C2 (IP & Port)\n\nA list of C2 IP addresses and ports of Emotet payloads is stored in .data section as 8-byte blocks:\n\n_Fig 41. List of C2s is stored in each payload_\n\nThrough script can quickly retrieve the entire list of this C2:\n\n\n-----\n\n_Fig 42. List of IP:Port used by payloads_\n\n## 5.6. RSA Public Key\n\nThrough analysis, Emotet embeds an RSA public key in payloads. This RSA public key is also stored as a\nregular encrypted string and is decoded just like we did with strings. This key will then be used for the secure\ncommunication with the the C2 above.\n\nAll three payloads above after decrypt have the same RSA Public Key:\n\n_Fig 43. RSA Public Key after decrypted_\n\n## 5.7. Enumerating running processes\n\nTo get the list of the processes running on the victim machine, the payloads use APIs function\n**CreateToolhelp32Snapshot; Process32FirstW; Process32NextW. List the processes are guaranteed:**\n\nNo process names where parent process ID is 0.\nNo process is executed by Emotet.\nNo duplicated process names.\n\n\n-----\n\n_Fig 44. The payloads collect a list of the processes running on the victim machine_\n\n### 6. Conclusion\n\nEmotet was first discovered in 2014 as a banking Trojan, over time it continues to evolve and has always been\na leading threat to organizations around the world. Emotet has once again proven to be an advanced threat\ncapable of adapting and evolving quickly in order to wreak more havoc. This malware is mainly distributed\nthrough email spam campaigns, so to prevent it, organizations should regularly train information security\nawareness for end users.\n\n### 7. References / Further Reading\n\n_[Click here for Vietnamese version.](https://blog.vincss.net/2021/01/re019-phan-tich-tu-a-den-x-chien-dich-tan-cong-thuc-te-su-dung-Emotet-gan-day.html)_\n**Tran Trung Kien (aka m4n0w4r)**\n**Malware Analysis Expert**\n\n**R&D Center - VinCSS (a member of Vingroup)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-13 - [RE019] From A to X analyzing some real cases which used recent Emotet samples.pdf"
    ],
    "report_names": [
        "2021-01-13 - [RE019] From A to X analyzing some real cases which used recent Emotet samples.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536039,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653710011,
    "ts_modification_date": 1653710011,
    "files": {
        "pdf": "https://archive.orkl.eu/db6bade5f9de9e6077dd342eeb9a8ba54411b1c0.pdf",
        "text": "https://archive.orkl.eu/db6bade5f9de9e6077dd342eeb9a8ba54411b1c0.txt",
        "img": "https://archive.orkl.eu/db6bade5f9de9e6077dd342eeb9a8ba54411b1c0.jpg"
    }
}