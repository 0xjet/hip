{
    "id": "8ef73f02-5973-4501-9240-c97e1d99f1e4",
    "created_at": "2023-01-12T15:05:14.100384Z",
    "updated_at": "2025-03-27T02:09:20.697615Z",
    "deleted_at": null,
    "sha1_hash": "1a9ea56fb65a7da33946cce8675683c45ef5311a",
    "title": "2022-01-05 - Technical Analysis of CVE-2021-1732",
    "authors": "",
    "file_creation_date": "2022-05-27T22:15:37Z",
    "file_modification_date": "2022-05-27T22:15:37Z",
    "file_size": 4757497,
    "plain_text": "# Technical Analysis of CVE-2021-1732\n\n**[mcafee.com/blogs/enterprise/mcafee-enterprise-atr/technical-analysis-of-cve-2021-1732/](https://www.mcafee.com/blogs/enterprise/mcafee-enterprise-atr/technical-analysis-of-cve-2021-1732/)**\n\nBy [Eoin Carroll on Jan 05, 2022](https://www.mcafee.com/blogs/author/eoin-carroll/)\n\n## Introduction\n\n\nJanuary 5, 2022\n\n\n[In February 2021, the company Dbappsecurity discovered a sample in the wild that exploited](https://ti.dbappsecurity.com.cn/blog/index.php/2021/02/10/windows-kernel-zero-day-exploit-is-used-by-bitter-apt-in-targeted-attack/)\na zero-day vulnerability on Windows 10 x64.\n\nThe vulnerability, [CVE-2021-1732, is a win32k window object type confusion leading to an](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-1732)\nOOB (out-of-bounds) write which can be used to create arbitrary memory read and write\ncapabilities within the Windows kernel (local Elevation of Privilege (EoP)). Memory\nexploitation generally requires a read, write, and execute primitive to bypass modern exploit\nmitigations such as DEP ASLR and CFG on hardened operating systems such as Windows\n\n\n-----\n\n10. A [data-only attack requires only a read and write primitive as it does not seek to execute](https://threatpost.com/memory-corruption-mitigations-doing-their-job/124728/)\nmalicious code in memory, but rather manipulates data structures used by the operating\nsystem to its advantage (i.e., to achieve elevated privileges).\n\nKernel exploits are usually the most sophisticated attack as they interact directly with the\nWindows kernel. When such attacks are successful, they are critical because they provide\nhigh privileges to the attacker, which can be used to increase the impact of the overall exploit\nchain. In this case the exploit is a Local Privilege Escalation (LPE) that targets 64-bit\nWindows 10 version 1909. The original sample discovered was compiled in May 2020 and\nreported to Microsoft in December 2020. While searching for additional findings we went\nthrough a [public exploit published in March of 2021 by a](https://github.com/KaLendsi/CVE-2021-1732-Exploit) [researcher. Having this code](https://zhuanlan.zhihu.com/p/356149984)\npublicly available may raise the potential for additional threat attackers. While we have not\nfound clear evidence demonstrating malicious use of the proof-of-concept (POC), we did\ndiscover some variants being tested and uploaded to VirusTotal.\n\nIn this blog post, McAfee Advanced Threat Research (ATR) performed a deep dive into the\nanalysis of the vulnerability, to identify the primitives for detection and protection. The exploit\nis novel in its use of a new win32k arbitrary kernel memory read primitive using the\nGetMenuBarInfo API, which to the best of our knowledge had not been previously known\npublicly.\n\n## CVE-2021-1732 Deep Dive\n\nExploitation of CVE-2021-1732 can be divided into six stages with the end goal of escalating\na process’ privileges to System. The following diagram shows the stages.\n\nFigure 1 – Six stages of CVE-2021-1732\nBefore we dive into the details, we must give some background to win32k exploitation\nprimitives which are used in the exploitation of CVE-2021-1732.\n\n## Win32K Background\n\nWin32k is a Graphical (GUI) component of the Microsoft Windows Subsystem, most of which\nexists in the kernel for performance reasons. It is used for graphical print of the Windows OS\ndesktop. However, due to the win32k architecture, the kernel component of win32k still\nneeds to be able to make calls to user mode through user-mode callback functions to\nfacilitate window creation and management.\n\n\n-----\n\n[Kernel user-mode callbacks have been well researched as far back as 2008 and](http://www.uninformed.org/?v=10&a=2&t=sumry) [2010, with](https://j00ru.vexillium.org/2010/09/kernel-exploitation-r0-to-r3-transitions-via-keusermodecallback/)\n[a very comprehensive analysis in 2011 by Mandt. A win32k kernel function such as](http://mista.nu/research/mandt-win32k-paper.pdf)\nxxxCreateWindowEx will make a callback function such as\nxxxClientAllocWindowClassExtraBytes through the user process PEB KernelCallbackTable.\n\nWhen the user-mode callback has completed, NtCallbackReturn executes and passes the\nexpected return parameter back to the kernel. Due to the stateless nature of these callbacks,\nmany vulnerabilities have been discovered related to the locking mechanisms on the objects\nleading to use-after-free (UAF) exploitation.\n\nWin32k has been one of the most exploited components in the Windows kernel accounting\nfor [63% of vulnerabilities from 2010 to 2018, due to its large attack surface of syscalls](http://www.irongeek.com/i.php?page=videos/derbycon8/track-4-01-state-of-win32k-security-revisiting-insecure-design-vishal-chauhan)\nrelative to ntdll syscalls. Win32k vulnerabilities are generally turned into data-only attacks\nusing a read/write kernel primitive by using a desktop object known as a tagWND data\nstructure.\n\nThere are two aspects to data-only attacks:\n\n1. Discovering a vulnerability.\n2. Leveraging existing or new read/write primitives using specific OS APIs on object fields\n\nsuch as tagWND.cbWndExtra.\n\nThe tagWND data structure has two fields which make it a prime target for reading/writing\nwithin kernel memory; tagWND.cbWndExtra and tagWND.ExtraBytes. When a window is\ncreated using CreateWindowEx, it is possible to request additional bytes of memory directly\nafter the tagWND object in memory through the cbWndExtra field in the WNDCLASSEXA\nstructure when registering the window class.\n\nThe number of extra bytes is controlled by the cbWndExtra field, and the allocated additional\nmemory address is located at the ExtraBytes field. The read/write primitive is created as\nfollows:\n\n1. Discover a vulnerability such as a UAF, which will allow you to write to a tagWND\n\nobject in memory called WND0.\n2. Allocate another tagWND object called WND1 near the previously corrupted WND0 in\n\nmemory.\n3. Overwrite WND0.cbWndExtra to a large value such as 0xFFFFFFF.\n4. Call an API such as SetWindowLongPtr on WND0 which will write OOB to fields within\n\nWND1.\n\nWin32k kernel user-mode callbacks have been exploited many times by leveraging tagWND\nread/write capabilities within the Windows kernel for escalation of privileges such as CVE2014-4113, [CVE-2015-0057,](https://research.nccgroup.com/2015/07/08/exploiting-the-win32kxxxenablewndsbarrows-use-after-free-cve-2015-0057-bug-on-both-32-bit-and-64-bit/) [MS15-061,](https://www.nccgroup.com/ae/our-research/exploiting-ms15-061-use-after-free-windows-kernel-vulnerability/) [CVE-2016-7255 and](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/digging-windows-kernel-privilege-escalation-vulnerability-cve-2016-7255/) [CVE-2019-0808.](https://blog.exodusintel.com/2019/05/17/windows-within-windows/)\n\n\n-----\n\n## Win32k Exploit Primitives\n\nSeveral primitives have been observed in the CVE-2021-1732 exploit used by the attackers;\nadditionally, it is worth mentioning that some of them are new and not previously seen in the\nwild.\n\nPrior to Windows RS4 it was trivial to leak tagWND kernel addresses using multiple\n[techniques, such as calling HMValidateHandle to copy tagWND objects from the kernel to](https://blog.exodusintel.com/2019/05/17/windows-within-windows/)\nuser desktop heap. The latest version of Windows 10 has been hardened against such trivial\ntechniques.\n\nHowever, using the spmenu kernel address leak technique and relative tagWND desktop\nheap offsets, once a vulnerability is discovered to overwrite a tagWND.cbWndExtra field, it is\npossible to achieve kernel read/write capabilities without leaking the actual tagWND kernel\n[addresses. The spmenu technique in this exploit was used here and](https://bromiumlabs.wordpress.com/2016/11/08/thoughts-on-the-recent-ntsetwindowlongptr-vulnerability/) [here, but we are not](https://www.blackhat.com/docs/eu-16/materials/eu-16-Liang-Attacking-Windows-By-Windows.pdf)\naware of the GetMenuBarInfo API ever being used before in a win32k exploit.\n\nThe following diagram shows the primitives used in CVE-2021-1732.\n\nFigure 2 – CVE-2021-1732 Primitives\n\n## Existing Windows OS Mitigations\n\n\n-----\n\nGreat work has been done to harden the security of win32k against EoP attacks with new\n[and improved mitigations by the Microsoft OSR team, Mandt,](http://mista.nu/research/mandt-win32k-paper.pdf) [Google Project Zero,](https://googleprojectzero.blogspot.com/2016/11/breaking-chain.html) [Schenk](https://improsec.com/tech-blog/hardening-windows-10-with-zero-day-exploit-mitigations-under-the-microscope)\n[and Dabah. These mitigations include:](https://www.ragestorm.net/Win32k%20Smash%20the%20Ref.pdf)\n\n[1. Type isolation (all same type objects tagWND being used).](https://conference.hitb.org/hitbsecconf2018ams/materials/D1%20COMMSEC%20-%20Saif%20Elsherei%20and%20Ian%20Kronquist%20-%20The%20Life%20&%20Death%20of%20Kernel%20Object%20Abuse.pdf)\n[2. Win32k filtering (limited to Edge browser and not process wide but since this research](https://improsec.com/tech-blog/win32k-system-call-filtering-deep-dive)\n\nthere have been many improvements on win32k API filtering capabilities such as the\naddition of _stub_UserSetWindowLong and _stub_UserSetWindowLongPtr\n_stub_UserGetMenuBarInfo in win32k.sys).\n3. Fragmenting kernel desktop heap and removal of kernel addresses in the user desktop\n\nheap (can use relative offsets within user and desktop heaps described later in the\nblog).\n4. Removal of data type symbols from win32k drivers (obfuscation rather than mitigation).\n\nIn the context of a malicious process exploiting CVE-2021-1732, the above mitigations\nprovide no protection. However, it does not impact Google Chrome as it disallows win32k\ncalls (Windows 8 and higher), or Microsoft Edge as it applies win32k filtering on the relevant\nAPIs.\n\n## Triggering the Vulnerability and Patch Analysis\n\nWhen a window is created using CreateWindowEx API, a tagWND object is created by the\nWindows operating system. This window, as explained above, can be created with a\nparameter to allocate extra memory using cbWndExtra.\n\nDuring the windows creation process (CreateWindowEx API) a callback named\nxxxClientAllocWindowClassExtraBytes is triggered to allocate space in the user mode\ndesktop heap for the tagWND.ExtraBytes (offset 0x128) per the tagWND.cbWndExtra (offset\n0xc8) value size (see figure 3 and 4 below for WND1).\n\nFigure 3 – WND1 Kernel tagWND – User mode copy located at offset 0x28\n\n\n-----\n\nFigure 4 – WND1 User Mode tagWND\nThe location of this memory is stored as a user mode memory pointer to the desktop heap\nand placed at tagWND.ExtraBytes. It is then possible to convert the normal window to a\nconsole window using NtUserConsoleControl which will convert that user mode pointer at\ntagWND.ExtraBytes to an offset value which points into the kernel desktop heap (see figure\n5 below for WND0). It is this change in value at tagWND.ExtraBytes (window type confusion)\nthat can be exploited for an OOB write during the xxxClientAllocWindowClassExtraBytes\ncallback window.\n\nFigure 5 – WND0 User Mode tagWND\n\nFigure 6 – Triggering the type confusion vulnerability within win32kfull!xxxCreateWindowEx\nPer figure 6 above the following steps are required to trigger the vulnerability:\n\n1. Get a pointer to the HMValidateHandle inline function within user32.dll.\n2. Hook xxxClientAllocWindowClassExtraBytes within the PEB KernelCallBack table.\n\n\n-----\n\n3. Create multiple windows (we will just use the first two WND0 and WND1 created),\n\nusing the CreateWindowEx API, so that two windows are created in close memory\nproximity.\n4. Call HMValidateHandle on WND0 and WND1 which will copy their objects from the\n\nkernel desktop heap to user desktop heap. At tagWND+0x8 an offset is stored into the\ndesktop heap; this offset is the same for the user and kernel desktop heaps. The\nexploit uses these offset values to calculate the relative distance between WND0 and\nWND1 in the kernel desktop heap which is needed later for reading and writing OOB.\nPer table 1 below, by using these offsets there is no requirement to leak the actual\nWND0 and WND1 kernel addresses since read and writes can be done relative to the\noffsets (user and kernel desktop heaps have the same offsets).\n\nTable 1 – User and Kernel Desktop heaps have the same offsets\n5. WND0 is then converted to a console window by calling NtUserConsoleControl which\nconverts WND0.ExtraBytes from a user desktop heap pointer to an offset within the kernel\ndesktop heap. This is needed later so that WND0 can write OOB to WND1.\n\n6. Create malicious window WND_Malicious using the CreateWindowEx API\n\nDuring the window creation the callback xxxClientAllocWindowClassExtraBytes\nAPI is executed to request user mode to allocate memory for\nWND_Malicious.cbWndExtra and pass the user desktop heap pointer back to the\nkernel function win32kfull!xxxCreateWindowEx.\nxxxClientAllocWindowClassExtraBytes has now been hooked and we do the\nfollowing before returning to win32kfull!xxxCreateWindowEx:\n\nCall NtUserConsoleControl to convert WND_Malicious to a console window\nso converting its WND_Malicious.cbWndExtra from a user desktop heap\npointer to an offset within the kernel desktop heap.\nFinally call NtCallbackReturn which completes the callback and returns a\nsingle value to xxxClientAllocWindowClassExtraBytes. Instead of passing\nthe user desktop heap pointer as expected by\nxxxClientAllocWindowClassExtraBytes back to the kernel we pass the value\nat WND0+0x08 which is the kernel desktop heap offset to WND0 per figure\n7 below. Now anytime we call SetWindowLongW on WND_Malicious we will\nbe writing to WND0.\n\n\n-----\n\nFigure 7 – WND_Malicious\n\n## Patch Analysis\n\nThe vulnerability lies in the fact that win32kfull!xxxCreateWindowEx does not check whether\nthe window type has changed between the time it initiates the\nxxxClientAllocWindowClassExtraBytes and gets the response from NtCallbackReturn.\n\nWhen we call NtUserConsoleControl with WND_Malicious in the hook above,\nxxxConsoleControl checks if tagWND+0xE8 flag has been set to 0x800 to indicate a console\nwindow per figure below. As WND_Malicious was created as a normal window,\nxxxConsoleControl allocates memory at an offset within the kernel desktop heap and then\nfrees the user desktop heap pointer existing at WND_Malicious.ExtraBytes (0ffset 0x128). It\nthen places the offset to this new allocation in the kernel heap at WND_Malicious.ExtraBytes\n(0ffset 0x128) and sets the tagWND+0xE8 flag to 0x800 to indicate it’s a console window.\n\n\n-----\n\nAfter returning from the callback when we issued NtCallbackReturn above,\nxxxCreateWindowEx does not check that the window type has changed and places the\nWND0+0x08 at WND_Malicious.ExtraBytes per figure 9 below. The\nRedirectFieldpExtraBytes checks the WND_Malicious.ExtraBytes initialized value but it is too\nlate as WND0+0x08 has already been written to WND_Malicious.ExtraBytes (offset 0x128).\n\nFigure 9 – win32kfull!xxxCreateWindowEx (vulnerable version)\nThe patched win32kfull.sys has updated xxxCreateWindowEx to now check the ExtraBytes\ninitialized value before writing the returned value from user mode to tagWND. ExtraBytes\n(offset 0x128) per figure 10 below.\n\nFigure 10 – win32kfull!xxxCreateWindowEx (patched version)\nFigure 11 below shows that tagWND. ExtraBytes is initialized to zero within\nxxxCreateWindowEx during normal window creation.\n\nFigure 11 – tagWND. ExtraBytes initialization for normal\nwindow\nFigure 12 below shows that tagWND. ExtraBytes is initialized to the new offset value in the\nkernel desktop heap within xxxConsoleControl during console window creation.\nRedirectFieldpExtraBytes simply checks this initialized value to determine if the window type\nhas changed. In addition, Microsoft have also added telemetry for detecting changes to the\nwindow type flag in the patched version.\n\n\n-----\n\nFigure 12 – tagWND.\n\nExtraBytes initialization for console window\n\n## tagWND OOB Write\n\nThe vulnerability within the xxxCreateWindowEx API allowed the WND_Malicious.ExtraBytes\nfield be to set to a value of WND0 offset within the kernel desktop heap. Now any time\nSetWindowLongW is called on WND_Malicious it will write to WND0. By supplying an offset\nof 0xc8, the function will overwrite the WND0.cbWndExtra field to a large value of\n0XFFFFFFF per figures 13 and 14 below.\n\nThis means it can write beyond its tagWND structure and ExtraBytes in kernel memory to\nfields within WND1. In addition, WND0.ExtraBytes is also overwritten with the offset to itself\nso calls to SetWindowLongPtrA on WND0 will write to an offset in kernel desktop heap\nrelative to the start of WND0.\n\nFigure 13 – OOB Write from WND_Malicious to WND0\n\n\n-----\n\nFigure 14 – WND0 cbWndExtra overwritten with 0xFFFFFFF by WND_Malicious OOB write\n\n## Kernel Address Leak\n\nNow that the WND0.cbWndExtra field has been set to a very large value (0xFFFFFFF),\nanytime SetWindowLongPtrA is called on WND0 it will write into the adjacent WND1 in\nkernel memory per figure 15 below. By writing to specific fields in WND1 we can create a\nkernel address memory leak as follows:\n\n[1. Write a value of 0x400000000000000 to WND1 style field to temporarily change it to a](https://docs.microsoft.com/en-us/windows/win32/winmsg/window-styles)\n\nchild window per figures 15 and 16 below.\n[2. Calling SetWindowLongPtrA API on WND0 with a value of -12 (GWLP_ID) now allows](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptra)\n\nthe spmenu field (type tagMENU) of WND1 to be overwritten with a fake spmenu data\nstructure since we have changed it to be a child window per figure 15 and 17 below.\n3. Per [SetWindowLongPtrA API documentation, the return value will give us the original](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptra)\n\nvalue at the offset overwritten, i.e., the spmenu data structure pointer which is a kernel\nmemory address. So, we now have leaked a pointer to a spmenu (type tagMENU) data\nstructure in kernel memory and replaced the pointer in WND1.spmenu with a fake\nspmenu data structure within user desktop heap per figure 17 below.\n\n\n-----\n\nFigure 15 – OOB Write from WND0 to WND1 to Leak Kernel Address\n\nFigure 16 – WND1 Style field before and after writing 0x4000000000000000\n\nFigure 17 – spmenu kernel memory address pointer leaked and subsequently replaced by a\nuser mode address pointing to a fake spmenu data structure\n\n## Kernel Arbitrary Read\n\nUsing the spmenu data structure kernel pointer leaked previously we can use the layout of\nthis data structure and the [GetMenuBarInfo API logic to turn it into an arbitrary kernel](https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-menubarinfo)\nmemory read per figures 18,19 and 20 below.\n\n\n-----\n\nFigure 18 – Kernel Arbitrary Read using fake spmenu and GetMenuBarInfo\n\nFigure 19 – Fake spmenu data structure in user desktop heap with original spmenu leaked\nkernel pointer at crafted location to enable arbitrary read using GetMenuBarInfo API\n\nFigure 20 – WinDbg command to show location within spmneu data structure that is\ndeferenced by xxGetMenuBarInfo\nAs you can see from the xxxGetMenuBarInfo function in figures 21 and 22 below, by placing\nour leaked kernel address at the right location in our fake spmenu data structure we can\ncreate an arbitrary kernel memory read when calling GetMenuBarInfo.\n\n\n-----\n\nFigure 21 – win32kfull!xxxGetMenuBarInfo\n\nFigure 22 – GetMenuBarInfo data structure populated return values per normal spmenu and\nfake spmenu (leaks kernel address)\n\n## Kernel Arbitrary Write\n\nAn arbitrary kernel write primitive can be easily achieved now by writing our destination\naddress to WND1.ExtraBytes field by calling SetWindowLongPtrA on WND0 which will write\nOOB to WND1 relative to the offset we specify per figure 23 below\n\nIn this case the offset is 0x128 which is ExtraBytes. Then simply calling SetWindowLongPtrA\non WND1 will write a specified value at the address placed in the WND1.ExtraBytes field.\nThe arbitrary write is achieved because WND1 is a normal window (has not been converted\nto a console window like WND0 and WND_Malicious) and so will write to whatever address\nwe place in WND1.ExtraBytes.\n\n\n-----\n\nFigure 23– Kernel Arbitrary Write for What-Write-Where (WWW)\n\n## Data Only Attack\n\nThe arbitrary kernel read and write primitives can be combined to perform a data-only attack\nto overwrite a malicious process EPROCESS token with that of PID 4 which is System for an\nescalation of privilege (EoP).\n\nThe original spmenu kernel address leaked previously has a pointer to WND1 at offset 0x50\nper figures 24 and 25 below. Through multiple arbitrary reads using the GetMenuBarInfo on\nour fake spmenu data structure with this WND1 kernel address we can eventually read the\nPID 4 System EPROCESS token.\n\n\n-----\n\nFigure 24 – Combining fake spmenu with GetMenuBarInfo arbitrary read to get PID 4 token\n\n\n-----\n\nFigure 25– Original spmenu with\n\nWND1 kernel address pointer at offset 0x50\nBy placing the destination address (malicious process EPROCESS token) at\nWND1.ExtraBytes then the subsequent call to SetWindowLongPtrA will write the value (PID\n4 – System EPROCESS token) to that address per figures 26 and 27 below.\n\n\n-----\n\nFigure 26 – EPROCESS Token swap\n\nFigure 27 – Overwriting WND1.ExtraBytes with address of EPROCESS token\nThe exploit then restores overwritten data structure values once the EoP is complete to\nprevent a BSOD (Blue Screen of Death).\n\n## Conclusion\n\nIn this report, we undertook a deep analysis of CVE-2021-1732 which is a Local Privilege\nEscalation on Windows 10. Windows kernel data-only attacks are difficult to defend against,\nas once a vulnerability is discovered they use legitimate and trusted code through specific\nAPIs to manipulate data structures in kernel memory.\n\nThe win32k component has been hardened through great work by Microsoft against\nread/write primitives, but there are still opportunities for exploitation due to its large attack\nsurface (syscalls and callbacks) and lack of win32k filtering on a process-wide basis. It would\nalso be great to see a system wide win32k filtering policy capability within Windows 10.\n\nPatching is always the best solution for vulnerabilities, but a strong defense strategy such as\nthreat hunting is also required where patching may not be possible, and to detect variants of\nvulnerabilities/exploits being used by campaigns.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-05 - Technical Analysis of CVE-2021-1732.pdf"
    ],
    "report_names": [
        "2022-01-05 - Technical Analysis of CVE-2021-1732.pdf"
    ],
    "threat_actors": [
        {
            "id": "bf6cb670-bb69-473f-a220-97ac713fd081",
            "created_at": "2022-10-25T16:07:23.395205Z",
            "updated_at": "2025-03-27T02:02:09.777308Z",
            "deleted_at": null,
            "main_name": "Bitter",
            "aliases": [
                "T-APT-17",
                "TA397"
            ],
            "source_name": "ETDA:Bitter",
            "tools": [
                "Artra Downloader",
                "ArtraDownloader",
                "Bitter RAT",
                "BitterRAT",
                "Dracarys"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "655f7d0b-7ea6-4950-b272-969ab7c27a4b",
            "created_at": "2022-10-27T08:27:13.133291Z",
            "updated_at": "2025-03-27T02:00:55.490812Z",
            "deleted_at": null,
            "main_name": "BITTER",
            "aliases": [
                "T-APT-17"
            ],
            "source_name": "MITRE:BITTER",
            "tools": [
                "ZxxZ"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535914,
    "ts_updated_at": 1743041360,
    "ts_creation_date": 1653689737,
    "ts_modification_date": 1653689737,
    "files": {
        "pdf": "https://archive.orkl.eu/1a9ea56fb65a7da33946cce8675683c45ef5311a.pdf",
        "text": "https://archive.orkl.eu/1a9ea56fb65a7da33946cce8675683c45ef5311a.txt",
        "img": "https://archive.orkl.eu/1a9ea56fb65a7da33946cce8675683c45ef5311a.jpg"
    }
}