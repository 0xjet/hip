{
    "id": "ebd3cd87-6ebd-4703-99b7-d74afd661513",
    "created_at": "2023-01-12T15:10:18.566398Z",
    "updated_at": "2025-03-27T02:06:07.321801Z",
    "deleted_at": null,
    "sha1_hash": "f505c177ecd9114fb6bd81d358d9b6650859bf44",
    "title": "2022-04-17 - Qakbot Series- API Hashing",
    "authors": "",
    "file_creation_date": "2022-06-01T12:23:33Z",
    "file_modification_date": "2022-06-01T12:23:33Z",
    "file_size": 390982,
    "plain_text": "# Qakbot Series: API Hashing\n\n**malwarology.com/2022/04/qakbot-series-api-hashing/**\n\n2022-04-17\n\n\nApril 17, 2022\n\n\n[Malware Analysis,](https://www.malwarology.com/categories/malware-analysis) [Qakbot](https://www.malwarology.com/categories/qakbot)\nIn late March 2022, I was requested to analyze a software artifact. It was an instance of\nQakbot, a modular information stealer known since 2007. Differently to other analyses I do\nas part of my daily job, in this particular case I can disclose wide parts of it with you readers.\nI’m addressing them in a post series. Here, I’ll discuss about the Qakbot API hashing\n[techinque based on this specific sample.](https://www.virustotal.com/gui/file/8565e3e213572cbd7c3df45ae3fadd094831aef7b63d3b389e57097c1b8602d6/detection)\n\n**Figure 1**\n\nExample of protected API call in Qakbot\n\nAPI hashing is an anti-analysis technique aimed at hiding a potential source of information\nabout the malware capabilities. Analysts are used to rely on the API calls to form an\nhypothesis of what a given piece of code tries to do because much of the malware behavior\ncan be inferred by looking at how it interacts with the operating system. As an example,\n**Figure 1 shows a call to CreateThread (kernel32.dll) located at 0xb2348b. You cannot see**\nany reference to CreateRemote thread into the code, besides the comment I placed to\nslightly improve the code readability. To understand what is happening here, I need to\ndescribe the API hashing technique implemented in the sample object of analysis. Luckly,\nthis section is all around this topic.\n\n\n-----\n\n**Figure 2**\n\nQakbot API de-hashing main function\n\nQakbot attempts to invoke functions exported by 11 dynamic-link libraries: kernel32.dll,\nntdll.dll, advapi32.dll, netapi32.dll, shell32.dll, shlwapi.dll, user32.dll, wininet.dll, urlmon.dll,\ncrypt32.dll, and wtsapi32.dll. I know that because I found tracks of those libraries into the\nstrings. Don’t panic if you won’t find those strings into the sample because they are\nobfuscated. If you’are interested in knowing how Qakbot obfuscates the strings, I address\n[the topic in this post. From those strings, I was able to discover the function responsible for](https://www.malwarology.com/2022/04/qakbot-series-string-obfuscation/)\nthe API de-hashing. For API de-hashing I mean the process allowing to retrieve API\naddresses starting from rather anonymous numbers called hashes. That function is located\nat 0xb3050a and it is showed in Figure 2.\n\nThat function expects three arguments. The very first argument is an hash table, namely a\nvector of 32 bits hashes. A very important point to make clear here is that there is a\ndedicated and hardcoded hash table for every DLL mentioned above. The second argument\nis the size of the hash table. The last argument is the offset used by the function\n_deobfuscate_string_1 to de-obfuscate the name of the DLL. The goal of the de-hashing_\nfunction consists in allocating a new table containing the memory address of all the required\nAPIs for the given DLL. Once such an address table is allocated, invocations for an API may\noccur by just pointing at the corresponding entry in the table. Figure 1 shows an example of\nthis type of invocation where the offset 0x1c2 is aligned with the memory address of\n\n\n-----\n\nCreateThread into the kernel32.dll table (actually, the offset for CreateThread is 0x70, as it is\npossible to observe into the assembly listing at 0xb2348b. For some reason, Ghidra\ndecompiler reconstructed a different offset).\n\nAs a side note, 0x6e2 is the offset for kernel32.dll therefore the first condition in the listing of\n**Figure 2 checks if the caller has requested an API exported by kernel32.dll. Indeed, if that is**\nthe case then it is sufficient to invoke GetModuleHandleA to obtain an handle to the DLL\nbecause kernel32.dll is mapped in the memory space of every process at loading time.\nOtherwise, if the requested module isn’t kernel32.dll, LoadLibraryA is invoked to obtain the\nsame result. Notice that in the latter case the API invocation occurs via the kernel32 address\ntable where LoadLibraryA lies at offset 0.\n\n**Figure 3**\n\nHash checking to identify the requested export name\n\nThe actual de-hashing occurs in a sub-function of resolve_api_address located at 0xb303ca.\nThis function is responsible for resolving the address of a specific API of a given module\nstarting from an hash. The code snippet showed in Figure 3 highlights the hash check. That\nloop enumerates all the export names of a module and ends in two cases:\n\nWhen the hash provided to resolve_api_address is equal to the hash of an export\nname xor-ed with an hardcoded constant (0x218fe95b). In this case there is a hit and\nthe export name is later provided to GetProcAddress to obtain the corresponding API\naddress.\nThe provided hash doesn’t correspond to any export name of the module. In this case\nthe function returns NULL.\n\nI close this post by sharing the mapping between hashes and all the API functions requested\n[by this Qakbot sample. You will find the mapping here. Each row in this file contains the](https://www.malwarology.com/text/4-qakbot-api-hashing/dehashed_apis.txt)\nlibrary exporting the API function, the offset into the address table, the hash, and finally the\nAPI function name. The offset may turn useful for analysis purposes because it is often\nhardcoded as showed in Figure 1.\n\n\n-----\n\nAs always, if you want to share comments or feedbacks (rigorously in broken Italian or\nbroken English) do not esitate to drop me a message at admin[@]malwarology.com.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-17 - Qakbot Series- API Hashing.pdf"
    ],
    "report_names": [
        "2022-04-17 - Qakbot Series- API Hashing.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536218,
    "ts_updated_at": 1743041167,
    "ts_creation_date": 1654086213,
    "ts_modification_date": 1654086213,
    "files": {
        "pdf": "https://archive.orkl.eu/f505c177ecd9114fb6bd81d358d9b6650859bf44.pdf",
        "text": "https://archive.orkl.eu/f505c177ecd9114fb6bd81d358d9b6650859bf44.txt",
        "img": "https://archive.orkl.eu/f505c177ecd9114fb6bd81d358d9b6650859bf44.jpg"
    }
}