{
    "id": "deced68a-d55d-4b7a-b39b-2b8345f2601d",
    "created_at": "2023-01-12T15:06:34.987858Z",
    "updated_at": "2025-03-27T02:08:04.822676Z",
    "deleted_at": null,
    "sha1_hash": "b0e1752edbca118b15213b59b67709ba3201991e",
    "title": "2020-05-07 - Detecting COR_PROFILER manipulation for persistence",
    "authors": "",
    "file_creation_date": "2022-05-27T21:56:46Z",
    "file_modification_date": "2022-05-27T21:56:46Z",
    "file_size": 347366,
    "plain_text": "# See what it's like to have a partner in the fight.\n\n**redcanary.com/blog/cor_profiler-for-persistence/**\n\n**_[Editor’s note: We originally published this article on May 7 as part of our Blue Mockingbird](https://redcanary.com/blog/blue-mockingbird-detection/)_**\n_research. MITRE has since added the COR_PROFILER technique detailed in this blog to_\n_the ATT&CK® Framework. As such, we wanted to present this work to our readers again—_\n_and add references to its new ATT&CK page:_ _[COR_PROFILER (T1574.012).](https://attack.mitre.org/techniques/T1574/012/)_\n\n\n-----\n\nWe believe that security teams should prioritize their detection efforts according to the\nthreats that are most likely to affect them. In fact, that’s one reason we produce our annual\n[Threat Detection Report, which analyzes the top MITRE ATT&CK techniques observed](https://redcanary.com/threat-detection-report/)\nacross our customer base and by industry.\n\nWhen it comes to [persistence, Scheduled Task (T1053) ranked second overall and even](https://attack.mitre.org/tactics/TA0003/)\ntopped the list for a couple of industry verticals in 2019. Today, we’d like to talk about a\nnovel form of persistence that the Red Canary Cyber Incident Response Team (CIRT) has\nobserved an adversary leveraging in multiple incident response (IR) engagements. My\ncolleague Tony Lambert has broken down the adversary behaviors and TTPs in this blog\npost.\n\n[Component Object Model (COM) hijacking (T1122) did not come anywhere close to the top](https://attack.mitre.org/techniques/T1122/)\nof our 2020 report (it barely cracked the top 100). This doesn’t mean it isn’t leveraged by\nadversaries—rather, it’s usually the same “tried and true” methods of persistence\n(scheduled tasks, autorun registry keys, services, etc.) that we see used over and over\nagain that dominate our Threat Detection Report. This is why we urge new security teams\nto focus on detecting the most likely forms of persistence.\n\nAn adversary we’ve dubbed “Blue Mockingbird” leveraged multiple forms of persistence\nwhen deploying their primary payload consisting of XMRIG packaged as a dynamic link\nlibrary (DLL), including:\n\n[Scheduled Tasks (T1053)](https://attack.mitre.org/techniques/T1053/)\n[Modify Existing Service (T1031)](https://attack.mitre.org/techniques/T1031/)\n[New Service (T1050)](https://attack.mitre.org/techniques/T1050/)\n[COM Hijack using COR_PROFILER (T1574.012)](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/setting-up-a-profiling-environment)\n\nWe have detection logic for catching each of the techniques listed above, but the\n```\nCOR_PROFILER technique is pretty unusual. So let’s take a closer look.\n\n## COR_PROFILER for managed code development\n\n```\nThe .NET framework supports the loading of an unmanaged (something outside the .NET\n[framework like C++, which interacts directly with hardware) profiler DLL as a code profiler to](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview?redirectedfrom=MSDN)\nmonitor a managed application. This feature is intended to allow the unmanaged profiler\nDLL to load into any .NET process and interact directly with callback interfaces through a\n[profiling API to receive information about the state of the profiled application. Essentially,](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview?redirectedfrom=MSDN#the-profiling-api)\nthis means .NET developers can measure their managed code performance with an\nunmanaged DLL, which aids in troubleshooting and debugging their managed application.\n\n[For our purposes, we will be looking at startup-load profilers, which are attached to the](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ee471451(v=vs.100)?redirectedfrom=MSDN#startup-load-profilers)\nunmanaged profiler when a managed application starts. A startup-load profiler can be\n[registered by adding a few environment variables. Per Microsoft:](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ee471451(v=vs.100)?redirectedfrom=MSDN)\n\n\n-----\n\n```\nCOR_ENABLE_PROFILING 1\n\n```\nA value of 1 will enable the `COR_PROFILER, while 0 will disable it.`\n```\nCOR_PROFILER={CLSID of profiler}\n\n```\nPrior to .NET Framework 4, this CLSID must be specified and map to a COM object\nspecifying the location of the profiling DLL on disk. This can be any CLSID of the\nattackers choosing.\n```\nCOR_PROFILER_PATH=full path of the profiler DLL\n\n```\nThis environment variable was added with .NET Framework 4 and will skip searching\nthe Registry for the corresponding COM object specified in the `COR_PROFILER`\nenvironment variable for the path to the profiling DLL on disk. If `COR_PROFILER_PATH`\nis set, any arbitrary CLSID can be used for the `COR_PROFILER environment variable.`\n\n[In Windows, environment variables can have three scopes. The location of the](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/setting-up-a-profiling-environment#environment-variable-scope)\n```\nCOR_PROFILER environment variable definition dictates which types of processes will be\n\n```\nprofiled. Knowledge of these scopes can help inform a detection strategy when environment\nvariables are abused.\n\n**Machine (or system) scope**\n\nMachine environment variables are inherited by all downstream users and processes.\nModifying machine environment variables requires administrative permissions. These\nenvironment variables are stored in the\n\n```\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\n\n```\n```\n   Manager\\Environment registry hive.\n\n```\nBlue Mockingbird leveraged this type of environment variable, resulting in a more\nreliable persistence mechanism as all .NET processes loaded the malicious profiling\nDLL regardless of whether or not a user was logged on.)\n\n**User scope**\n\nUser scope environment variables are only available to individual users and include all\nmachine environment variables. These are stored in the current user registry hive at\n```\n   HKEY_CURRENT_USER\\Environment and in each respective user hive. For example,\n\n```\nhere is where the system account environment variables are stored: `HKEY_USERS\\S-`\n\n```\n1-5-18\\Environment\n\n```\n\n**Process scope**\n\n\n-----\n\nProcess environment variables are constructed from the machine and user scope\nenvironment variables. Child processes inherit any process scope environment\nvariables from their parent process. Process scope environment variables are only\navailable to the current process and any of its children. These variables are generally\nset using something like the SET command in Command Prompt, the $Env\n[PowerShell variable, or by the Environment.SetEnvironmentVariable .NET method.](https://docs.microsoft.com/en-us/dotnet/api/system.environment.setenvironmentvariable?view=netcore-3.1)\nThis is generally where a conservative .NET developer would place their\n```\n   COR_PROFILER environment variables.\n\n## COR_PROFILER and COM\n\n```\nEarly versions of .NET Framework required the `COR_PROFILER to be attached to a COM`\n[object in the registry. Beginning with .NET Framework 4, a registry-free](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ee471451(v=vs.100)?redirectedfrom=MSDN) `COR_PROFILER`\ncan be configured by specifying the `COR_PROFILER_PATH to the unmanaged profiling DLL`\non disk and any arbitrary CLSID. The CLSID does not need to actually exist in the registry\nas the CLR will load the specified DLL in `COR_PROFILER_PATH without initializing COM.`\n\n## COR_PROFILER and red teams\n\n[In May 2017, Casey Smith wrote a blog post outlining the potential for this feature to be](https://web.archive.org/web/20170720041203/http://subt0x10.blogspot.com/2017/05/subvert-clr-process-listing-with-net.html)\nabused by an adversary to hijack legitimate .NET processes and load a malicious\n[unmanaged DLL. Since then a few researchers and red team bloggers have expanded on](https://seclists.org/fulldisclosure/2017/Jul/11)\n[this technique as a method of](https://arxiv.org/pdf/1709.07508.pdf) [persistence, bypassing](https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-maintain-persistence/) [User Account Control (UAC) (T1088)](https://offsec.almond.consulting/UAC-bypass-dotnet.html)\nand Applocker restrictions when DLL enforcement is not turned on. There is also InvisiShell, which leverages a DLL profiler to hook .NET assemblies responsible for PowerShell’s\n[logging and the Antimalware Scanning Interface (AMSI).](https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal)\n\n\n-----\n\n_Registry-free process scope COR_PROFILER_\n\n## COR_PROFILER in the wild\n\nThere are multiple methods of modifying the environment variables required to configure\nthe `COR_PROFILER . For example, Reg.exe, Setx, and the Registry Editor ( regedit.exe )`\nare good candidates. Blue Mockingbird employed the Windows Management\nInstrumentation (WMI) command-line utility, `Wmic.exe, to add the` `COR_PROFILER as`\nmachine (system) environment variables. You can see a complete list of the commands\n[Blue Mockingbird leveraged in my colleague Tony’s blog post.](https://redcanary.com/blog/blue-mockingbird-cryptominer/)\n\nWe have observed adversaries registering the CLSID COM interface specified in the\n```\nCOR_PROFILER environment variable in the Windows Registry to ensure backwards\n\n```\ncompatibility on machines with versions of .NET Framework lower than version 4. This\nmakes sense, as an adversary will want to ensure their persistence mechanisms are\nresilient and work regardless of the environment. If the machine they land on is running\n.NET Framework 4, the malicious DLL specified in the `COR_PROFILER_PATH will be loaded`\nand the COM interface will not be used.\n\nIf the machine is running versions of .NET Framework lower than 4 and the\n```\nCOR_PROFILER_PATH environment variable is supplied, the technique will still work as the\n\n```\nmalicious DLL in the registered COM interface will be loaded.\n\nIn our experience with the `COR_PROFILER technique, what results is a stealthy persistence`\nmechanism that executes each time any process loads the .NET CLR. Native Windows\nprocesses like PowerShell and the Microsoft Management Console ( mmc.exe ) load the\n\n\n-----\n\n.NET CLR, and any installed application written in .NET will load the CLR. This results in\nthe malicious profiling DLL loading into the memory space of each of those processes and\ndeploying more traditional forms of persistence like services and scheduled tasks that\nseemingly appear out of thin air.\n\nIt’s worth noting the malicious profiling DLLs we’ve observed in IR engagements were not\ndetected by antivirus scanners on VirusTotal. It’s also worth noting that Microsoft’s Autoruns\ndoes not check for the `COR_PROFILER leveraged for persistence.`\n\n## Detection Analytics\n\nTo aid defenders in detecting malicious COM Hijacking and UAC bypass leveraging the\n```\nCOR_PROFILER, we’ve released three Atomic Red Team tests. The first test uses user\n\n```\nscope environment variables and registers a COM object in the Registry. This test\nleverages PowerShell to modify `COR_PROFILER user scope environment variables in the`\nWindows Registry and deploys an unmanaged payload DLL written in C++.\n\nHere is an example of what the user scope environment variable modifications look like in\n[endpoint detection and response (EDR) telemetry:](https://redcanary.com/solutions/endpoint-detection-and-response/)\n\nThe second Atomic Red Team test leverages machine (system) scope `COR_PROFILER`\nenvironment variables similarly to how we have observed adversaries abuse this technique,\nwith a slight twist. This test does not add a COM object associated with the CLSID GUID we\nset in the `COR_PROFILER environment variable. This technique requires .NET Framework`\n4 or higher, which ships with all modern versions of Windows. This technique also requires\nthe machine to reboot for the system environment variables to take effect.\n\nHere is an example of what the system scope environment variable modifications look like:\n\nThe third test leverages Registry-free user scope COR_PROFILER environment variables.\nAgain, .NET Framework 4 is required. This technique will not bypass UAC.\n\n\n-----\n\nHere is an example of the unmanaged profiling DLL loading into PowerShell shortly after\nthe CLR is loaded:\n\nDetection strategies should focus on suspicious modifications to the environment variables\nassociated with the COR_PROFILER in the System and User registry hives. This will\nensure you can detect COR_PROFILER modifications regardless of the method employed\nto set environment variables.\n\n**User scope:**\n```\nHKEY_USERS\\<user_sid>\\environment\\cor_enable_profiling\nHKEY_USERS\\<user_sid>\\environment\\cor_profiler\nHKEY_USERS\\<user_sid>\\environment\\cor_profiler_path\n\n```\nMachine (system) scope environment variables can be detected by looking for the same\nregistry modification in\n\n```\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\n\n```\n```\nManager\\Environment\\ :\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\nManager\\Environment\\cor_enable_profiling\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\nManager\\Environment\\cor_profiler\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\nManager\\Environment\\cor_profiler_path\n\n```\nNote: process scope environment variables are stored in memory. Higher integrity child\nprocesses do not inherit these environment variables if their parent process is of a lower\nintegrity, therefore, UAC is not bypassed.\n\nInvestigation should focus on the malicious profiler DLL written to disk and loading shortly\nafter the CLR ( clr.dll ) is loaded in the victim processes. The telemetry presented below\nshows our Atomic Red Team T1122 tests loading the unmanaged DLL payload into\n```\nmmc.exe and executing the legitimate notepad.exe as a child process. If system or user\n\n```\nscope `COR_PROFILER are leveraged and run with an administrative account, this`\ntechnique will also bypass UAC.\n\n\n-----\n\nAgain, any arbitrary CLSID COM interface (GUID) can be specified. With .NET Framework\n4, the COM interface does not need to exist as long as the `COR_PROFILER_PATH`\nenvironment variable points to the location of the profiling DLL on disk.\n\nIn our research, leveraging `wmic.exe to modify the` `COR_PROFILER environment`\nvariables has been directly associated with adversary activity. Some legitimate developer\n[debugging tools, like Ncover or](https://www.ncover.com/) [AppDynamics, may read or delete the](https://www.appdynamics.com/info/net-code-profiler) `COR_PROFILER`\nregistry keys, but it’s less likely you’ll see these tools repeatedly writing data into these\nregistry keys.\n\n## Mitigations\n\nThe `COR_PROFILER is a legitimate method developed by Microsoft for profiling managed`\napplications. There doesn’t appear to be a method for disabling the feature to prevent\nadversaries from using for persistence. As with other techniques that abuse system\nfeatures, it’s best to have a solid detection strategy.\n\nIt is possible to mitigate the UAC bypass by ensuring proper segmentation of administrative\naccounts. We recommend ensuring administrative accounts are not used for day-to-day\n[operations by implementing Least-Privilege Administrative Models.](https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/implementing-least-privilege-administrative-models)\n\n## Closing thoughts\n\nWhen leveraged maliciously, the `COR_PROFILER can be a highly effective form of`\npersistence that has the added benefit of bypassing UAC. This technique can also bypass\nAppLocker as DLL enforcement is not typically enabled by default. Defenders can audit the\nRegistry keys associated with the `COR_PROFILER and create high signal-to-noise methods`\nfor detection.\n\nIf you’ve seen the `COR_PROFILER leveraged for persistence, bypassing UAC, or in other`\n[ways, please reach out—we would love to hear from you. You can also join the Atomic Red](http://10.10.0.46/mailto:blog@redcanary.com)\nTeam Slack and share your thoughts, improvements, and questions about the\n```\n COR_PROFILER tests.\n\n```\nRelated Articles\n\n\n-----\n\nDetection and response\n\n### ChromeLoader: a pushy malvertiser\n\nDetection and response\n\n### Intelligence Insights: May 2022\n\nDetection and response\n\n### The Goot cause: Detecting Gootloader and its follow-on activity\n\nDetection and response\n\n### Marshmallows & Kerberoasting\n\n**Subscribe to our blog**\n\nOur website uses cookies to provide you with a better browsing experience. More\n[information can be found in our Privacy Policy.](https://redcanary.com/privacy-policy)\n\nX\n\n**Privacy Overview**\n\nThis website uses cookies to improve your experience while you navigate through the\nwebsite. Out of these cookies, the cookies that are categorized as necessary are stored on\nyour browser as they are essential for the working of basic functionalities of the website. We\nalso use third-party cookies that help us analyze and understand how you use this website.\nThese cookies will be stored in your browser only with your consent. You also have the\noption to opt-out of these cookies. But opting out of some of these cookies may have an\neffect on your browsing experience.\n\nNecessary cookies are absolutely essential for the website to function properly. This category\nonly includes cookies that ensures basic functionalities and security features of the website.\nThese cookies do not store any personal information.\n\nAny cookies that may not be particularly necessary for the website to function and is used\nspecifically to collect user personal data via analytics, ads, other embedded contents are\ntermed as non-necessary cookies. It is mandatory to procure user consent prior to running\nthese cookies on your website.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-07 - Detecting COR_PROFILER manipulation for persistence.pdf"
    ],
    "report_names": [
        "2020-05-07 - Detecting COR_PROFILER manipulation for persistence.pdf"
    ],
    "threat_actors": [
        {
            "id": "e568e9d7-ae94-4ce5-9039-4fd17c731c1d",
            "created_at": "2022-10-25T15:50:23.491763Z",
            "updated_at": "2025-03-27T02:00:55.483586Z",
            "deleted_at": null,
            "main_name": "Blue Mockingbird",
            "aliases": [
                "Blue Mockingbird"
            ],
            "source_name": "MITRE:Blue Mockingbird",
            "tools": [
                "FRP",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535994,
    "ts_updated_at": 1743041284,
    "ts_creation_date": 1653688606,
    "ts_modification_date": 1653688606,
    "files": {
        "pdf": "https://archive.orkl.eu/b0e1752edbca118b15213b59b67709ba3201991e.pdf",
        "text": "https://archive.orkl.eu/b0e1752edbca118b15213b59b67709ba3201991e.txt",
        "img": "https://archive.orkl.eu/b0e1752edbca118b15213b59b67709ba3201991e.jpg"
    }
}