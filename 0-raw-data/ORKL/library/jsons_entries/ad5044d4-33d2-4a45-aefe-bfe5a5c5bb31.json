{
    "id": "ad5044d4-33d2-4a45-aefe-bfe5a5c5bb31",
    "created_at": "2023-01-12T15:10:51.458673Z",
    "updated_at": "2025-03-27T02:05:29.324305Z",
    "deleted_at": null,
    "sha1_hash": "ce1739db1381fa767e573573e3e575d0e0d0b27d",
    "title": "2021-05-04 - Pingback- Backdoor At The End Of The ICMP Tunnel",
    "authors": "",
    "file_creation_date": "2022-05-28T15:26:35Z",
    "file_modification_date": "2022-05-28T15:26:35Z",
    "file_size": 1166324,
    "plain_text": "# Pingback: Backdoor At The End Of The ICMP Tunnel\n\n**[trustwave.com/en-us/resources/blogs/spiderlabs-blog/backdoor-at-the-end-of-the-icmp-tunnel/](https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/backdoor-at-the-end-of-the-icmp-tunnel/)**\n\nLoading...\n\nBlogs & Stories\n\n## SpiderLabs Blog\n\nAttracting more than a half-million annual readers, this is the security community's go-to\ndestination for technical breakdowns of the latest threats, critical vulnerability disclosures\nand cutting-edge research.\n\n## Introduction\n\nIn this post, we analyze a piece of malware that we encountered during a recent breach\ninvestigation. What caught our attention was how the malware achieved persistence, how it\nused ICMP tunneling for its backdoor communications, and how it operated with different\nmodes to increase its chances of a successful attack. Malware using ICMP is not new but is\nrelatively uncommon. Because of this, and the presence of certain strings, we decided to\nname this malware ‘Pingback’. Below we demonstrate how Pingback’s protocols work and\nalso provide sample code on how we interacted with the malware\n\n\n-----\n\nWe begin by looking at how Pingback achieves persistence through DLL hijacking.\n\n## Persistence through DLL Hijacking\n\nDLL (Dynamic Link Library) hijacking is a technique that involves using a legitimate\napplication to preload a malicious DLL file. Attackers commonly abuse the Windows DLL\nSearch Order and take advantage of this to load a malicious DLL file instead of the\nlegitimate one.\n\nThe file we investigated was a DLL file called oci.dll. We knew that the file was suspicious\nduring our initial triaging, but we could not figure how it was loaded into the system because\nthe DLL was not loaded through traditional rundll32.exe.\n\n**_Figure 1: oci.dll file information_**\n\nWe found out later that it got loaded through a legitimate service called msdtc (a.k.a\nMicrosoft Distributed Transaction Coordinator). This service, as the name suggests,\ncoordinates transactions that span multiple machines, such as databases, message\nqueues, and file systems.\n\nIt turns out the msdtc service indirectly loads oci.dll through MSDTCTM.DLL that loads an\nODBC library to support Oracle databases called MTXOCI.DLL. This library searches for\nand tries to load three Oracle ODBC DLLs which include oci.dll, SqlLib80.dll, and xa80.dll.\n\n\n-----\n\n**_Figure 2: Malicious oci.dll is indirectly loaded by msdtc service_**\n\n\n-----\n\n**_Figure 3: MTxOCI.DLL loads three plugin DLLs that support the Oracle ODBC interface_**\n\nBy default, the three Oracle DLLs do not exist in the Windows system directory. So, in\ntheory, an attacker with system privileges can drop a malicious DLL and save it using one of\nthe DLL filenames that MTxOCI loads. We have experimented with dropping all three DLL\nfilenames but only oci.dll was successfully loaded by the service.\n\n\n-----\n\n**_Figure 4: oci.dll runs in the background loaded by msdtc.exe_**\n\n**msdtc by default does not run during start-up. To remain persistent, the msdtc service**\nneeds to be configured to start automatically, so the attacker would need system privileges\nto reconfigure the msdtc startup type. It can be done manually using SC command, via\nmalicious scripts, or through a malware installer.\n\nOur theory is that a separate executable installed this malware. In fact, after a bit of hunting,\nwe [found a sample in VirusTotal with similar IOCs that installs oci.dll into the Windows](https://www.virustotal.com/gui/file/4ff77ea841544569e9da8aa3990724d1473731e684a162014ad1ad54e8c8cef2/detection)\nSystem directory and then sets msdtc service to start automatically.\n\n**_Figure 5: A loader configuring msdtc service to start automatically_**\n\n\n-----\n\nWe also observed during our analysis that in a VMware environment, the VM Tools service\nalso loads MTXOCI and eventually loads the malicious OCI.DLL.\n\n**_Figure 6: In Process Explorer, we found that OCI.DLL is also loaded by VMTools service in_**\n_a VMware Environment_\n\nSo that is the DLL loading part. But before turning our attention to Pingback itself and its\noperation, let us first lay out what is ICMP and how ICMP tunneling works.\n\n## ICMP Foundation\n\nThe Internet Control Message Protocol (ICMP) is a network layer protocol mainly used by\nnetwork devices for diagnostic and control purposes. It is used in utilities such as ping to\ndetermine reachability and roundtrip time, traceroute, and path MTU discovery to avoid\npacket fragmentation and enhance performance. It can also be misused by malicious actors\nto scan and map a target’s network environment. This is one of the reasons why there are\nsome debates over whether ICMP should be disabled or not. In most cases, users do not\npay attention to ICMP packets either as they do not manifest open ports on the machine.\n\n\n-----\n\nThe malware, Pingback, at the center of our investigation, oci.dll, uses the ICMP protocol\nfor its main communication. This has the effect of being hidden from the user as ports\ncannot be listed by netstat. Below we detail how Pingback uses the ICMP protocol to pass\ndata back and forth between the infected host and the attacker’s host. A technique called\nICMP tunneling.\n\nTo explain ICMP tunneling, let us first understand an ICMP packet:\n\n**_Figure 7: A diagram of an ICMP packet. ICMP_**\n\n_data size varies, we assume that the IP maximum transmission unit is 1500 bytes. The_\n_packet size limit for an ICMP Data is maximum allowed size of an IPv4 network packet,_\n_minus the 20 byte IP header and 8 byte ICMP header._\n\nAn ICMP packet is built on top of the IP layer and has an 8 byte ICMP header. The packet\nsize limit for ICMP data is a maximum allowed size of an IPv4 network packet, minus the 20\nbyte IP header and 8 byte ICMP header. Or approximately 64K. The ICMP data is\ndetermined by the message type. The message types are defined here:\n[https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)\n\nAn ICMP tunnel mainly uses these two types:\n\n**Code** **Type** **Description**\n\n0 Echo Reply ping reply\n\n8 Echo ping\n\nIn the diagram below, A echo packet header defines the ICMP type, code, checksum,\nidentifier and sequence number. And lastly, the ICMP data section is where an attacker can\npiggyback an arbitrary data to be sent to a remote host. The remote host replies in the\nsame manner, by piggyback an answer into another ICMP packet and sending it back.\n\n\n-----\n\n**_Figure 8: ICMP packet. The size of the ICMP data sent by the attacker is always 788 bytes_**\n\n\n-----\n\n**_Figure 9: Packet capture of the attacker's ICMP packet_**\n\n## ICMP Tunneling\n\nNow that we have laid out the foundation and how an attacker can piggyback data on the\nICMP packets, we are ready to explain exactly how exactly this malware works.\n\nPingback specifically uses the echo (ping) request or type 8 ICMP message. It starts a\nsniffer for every IP address on the host, spawning a thread to sniff packets on each\nindividual IP address. To distinguish between its own packets and other packets, the sniffer\nignores anything else that’s not an ICMP echo packet and does not contain the ICMP\nsequence number 1234, 1235 or 1236. It also ignores packets not destined for the specified\nIP address.\n\nIt then interprets the data in the following format:\n\n\n-----\n\n**_Figure 10: Malware's ICMP data is represented by this C structure. See appendix below for_**\n_detailed information of the cmd and cmd_line fields._\n\nThe sequence is used as a message type for each ICMP data. It currently supports 3\nmessage types:\n\n1234 – the packet contains a command or data\n1235 and 1236 – used for pure ICMP packet communication only. 1235 being the data\nhas been received at the other end, and 1236 as new data has been received by the\nmalware.\n\nPingback supports several commands including:\n\n**shell – execute a shell**\n**download – 3 different modes of download are provided:**\n\nMode 1: Infected host connects back to the attacker’s host (works well if\nincoming TCP connections are blocked by firewall)\nMode 2: Infected host opens a socket on a specified port and waits for the\nattacker to connect.\nMode 3: Purely ICMP-based, but this is very slow and the current\nimplementation is not very reliable in terms of flow control.\n**upload – also supports 3 different modes, similar to the Download command.**\n**exec – execute a command on the infected host.**\n\nThis is interesting, you can see Pingback uses a combination of ICMP for initiating any of\nthe commands and TCP for better performance and reliability. A pure ICMP mode is also\nprovided but is not very reliable.\n\n## Protocol example\n\nTo download a file in mode 1, the attacker performs:\n\nCreate a socket and listen on a port\nSend the following ICMP packet:\n\nICMP echo request with sequence 1234\nPayload contains: “download”, name of file to download and, IP address and\nport of the newly created socket, this is where the malware will stream the file to\nWait for connections and receive data. There is an additional protocol here which\nincludes is reasonably simple (send and receive) and wait for “END\\x00” string.\n\n\n-----\n\nWe have provided a source to demonstrate all three modes and most of the commands\nsupported by Pingback.\n\nSource available here:\n\n[https://github.com/SpiderLabs/pingback](https://github.com/SpiderLabs/pingback)\n\nWe have also prepared a video to demonstrate how our client interacts with the malware\nrunning in an isolated infected system.\n\nWatch Video At:\n\nhttps://youtu.be/OlzgEVk3dig\n\n## Final Words\n\nICMP tunneling is not new, but this particular sample piqued our interest as a real-world\nexample of malware using this technique to evade detection. ICMP is useful for diagnostics\nand performance of IP connections in the real world. It is very useful to have them enabled\nbut must be balanced by real-world threats. While we are not suggesting that ICMP should\nbe disabled, we do suggest putting in place monitoring to help detect such covert\ncommunications over ICMP.\n\nFor network administrators and technical audience, a rule can be implemented to check if a\npacket is an ICMP echo (type 8), the data size is 788 bytes or greater and check for ICMP\nsequence number: 1234, 1235 or 1236. Backdoor command strings such as “download”,\n“upload”, “exec”, “exep”, “rexec”, “shell” that found in an ICMP data packet can also be\nflagged. [Trustwave Managed IDS devices can also detect this malicious traffic.](https://www.trustwave.com/en-us/services/technology/intrusion-detection-and-prevention/)\n\n\n-----\n\nFinally, this malware did not get into the network through ICMP but rather utilizes ICMP for\nits covert bot communications. The initial entry vector is still being investigated.\n\n## Appendix\n\n**cmd – bot commands and may be any of the following:**\n\n_exep (execute process) – execute a binary/command on the remote host_\n_download (download mode 1) - attacker’s initial connection is done via ICMP and_\nappears as a ping packet. The ICMP echo packet contains data that specifies the\nattacker’s host and port to where the malware connects back. The ICMP data also\ncontains a file path that the attacker requests. Using the host and port information, the\nmalware creates a new socket, then transmits the requested file back to the attacker.\n_upload (upload mode 1) – attacker’s initial connection is done via ICMP. The malware_\nreceives the initial connection then connects back to attacker’s host and port specified\nin the ICMP Echo packet. It then receives the file from the attacker to be saved in the\ninfected system’s local disk\n_download2 – (download mode 2), initial ICMP packet is sent by the attacker. The_\nICMP echo packet contains the requested filename and path in the infected system. It\nalso contains a port number where the malware will bind and listen to. The malware\nthen waits for the attacker to connect, afterward, it begins transmitting the requested\nfile.\n_upload2 – (upload mode 2), initial ICMP packet is sent by the attacker. The ICMP_\necho packet contains the filename of the file to be received. It also contains a port\nnumber where the malware will bind and listen to. The malware then creates the file in\nthe remote host and waits for the attacker to connect. Once connection is established,\nthe attacker begins transmitting the file content to the remote host\n_download3 – (download mode 3), a file is sent to the attacker purely through ICMP_\ndata. Although this mode is more covert as it appears as ping packets only, this is\nslower than using TCP directly as only 1 packet can be transmitted at a time. The\nmalware has to wait for acknowledgment from the attacker’s end.\n_upload3 – (upload mode 3), same as download mode 3 – although the attacker_\nuploads the file purely through ICMP. Also slower and unreliable but more covert than\nother modes.\n_shell – request malware to connect back to the attacker with a shell. Initial request is_\ndone via ICMP packet containing information including attacker’s host IP and port to\nwhere the malware makes a TCP connection.\n\n**cmd_line - In exep command, this variable holds the command to be executed on the**\nremote host. While in download and upload command, this variable contains the remote file\nname.\n\n## IOC:\n\n\n-----\n\n**File:**\n\nFilename: Oci.dll\nSHA256: E50943D9F361830502DCFDB00971CBEE76877AA73665245427D817047523667F\nPDB path: c:\\Users\\XL\\Documents\\Visual Studio\n2008\\Projects\\PingBackService0509\\x64\\Release\\PingBackService0509.pdb\n\n**Network:**\n\nSource: <Attacker IP address>\nDestination: <Target host>\nICMP Type: 8\nSequence Number: 1234|1235|1236\nData size: 788 bytes\n\nPCAP: [https://github.com/SpiderLabs/IOCs-IDPS/tree/master/Pingback](https://github.com/SpiderLabs/IOCs-IDPS/tree/master/Pingback)\n\n**Yara:**\n\nrule PingBack\n{\nmeta:\ndescription = \"This rule detects PingBack malware\"\nauthor = \"Trustwave SpiderLabs\"\ndate = \"May 4th, 2021\"\n\nstrings:\n$string1 = \"Sniffer ok!\" ascii\n$string2 = \"lock2\" ascii\n$string3 = \"recvfrom failed\" ascii\n$string4 = \"rexec\" ascii\n$string5 = \"exep\" ascii\n$string6= \"download\" ascii\n$string7 = \"download2\" ascii\n$string8 = \"download3\" ascii\n$string9 = \"upload\" ascii\n$string10 = \"upload2\" ascii\n$string11 = \"upload3\" ascii\n$string12 = \"cmd.exe\" ascii\n$string13 = \"PingBackService\" ascii\n\ncondition:\nall of them\n\n\n-----\n\n}\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-04 - Pingback- Backdoor At The End Of The ICMP Tunnel.pdf"
    ],
    "report_names": [
        "2021-05-04 - Pingback- Backdoor At The End Of The ICMP Tunnel.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536251,
    "ts_updated_at": 1743041129,
    "ts_creation_date": 1653751595,
    "ts_modification_date": 1653751595,
    "files": {
        "pdf": "https://archive.orkl.eu/ce1739db1381fa767e573573e3e575d0e0d0b27d.pdf",
        "text": "https://archive.orkl.eu/ce1739db1381fa767e573573e3e575d0e0d0b27d.txt",
        "img": "https://archive.orkl.eu/ce1739db1381fa767e573573e3e575d0e0d0b27d.jpg"
    }
}