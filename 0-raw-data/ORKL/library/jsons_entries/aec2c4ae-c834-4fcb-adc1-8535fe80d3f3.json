{
    "id": "aec2c4ae-c834-4fcb-adc1-8535fe80d3f3",
    "created_at": "2023-01-12T15:02:35.32341Z",
    "updated_at": "2025-03-27T02:05:45.341894Z",
    "deleted_at": null,
    "sha1_hash": "b4fa764ac80b8bd1b3324192797101ab9d8bb345",
    "title": "2021-04-30 - Detecting network beacons via KQL using simple spread stats functions",
    "authors": "",
    "file_creation_date": "2022-05-28T23:31:59Z",
    "file_modification_date": "2022-05-28T23:31:59Z",
    "file_size": 253126,
    "plain_text": "# Detecting network beacons via KQL using simple spread stats functions\n\n**[ateixei.medium.com/detecting-network-beacons-via-kql-using-simple-spread-stats-functions-c2f031b0736b](https://ateixei.medium.com/detecting-network-beacons-via-kql-using-simple-spread-stats-functions-c2f031b0736b)**\n\nAlex Teixeira April 30, 2021\n\n[Alex Teixeira](https://ateixei.medium.com/?source=post_page-----c2f031b0736b--------------------------------)\n\nApr 30, 2021\n\n\n8 min read\n\nWhat’s a network beacon? Why is that important? Well, let’s start with a quick definition\nbefore jumping into detection design and KQL code.\n\nAs Google suggests, beacon is a visible object serving as a signal or warning. That’s what\nwe, as detection engineers, are looking for when deploying a new detection or analytic rule.\n\nIn our context, beacon is referred to as traffic leaving the network at somewhat regular\nintervals with the purpose of communicating with a command-and-control server (C2).\n\nThis method can be used in a variety of ways: to ‘heartbeat’, to request new commands, or\nto download updates by interacting with the C2 server. It also works over any protocol,\nmostly leveraging outbound allowed network connections via the web proxy or firewall\n(HTTP/S, DNS, etc).\n\n## What data or log telemetry to use?\n\n\n-----\n\nWhile there are many methods to tackle the challenge of detecting beaconing traffic, among\nthe target data sources to use, web proxy, firewall and DNS log sources are figuring as top\ncandidates.\n\nMoreover, any data source providing time series telemetry including the origin and target of\nthe network connection is also a potential candidate. Examples:\n\nHost FW such as Windows Firewall (/ eventlogs)\nEDR (some provide all external network connections)\n\nIn this example, we are going to pick Palo Alto events that are logged to the\n**CommonSecurityLog table in Log Analytics/Azure Sentinel. The events look like the**\nfollowing (base query):\n\nAs it applies to many other NG FWs or UTMs, the [user account is also logged and that](https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClYuCAK)\nmakes a big difference here.\n\nRegardless of the (dynamic) IP address assigned to an affected host, tracking the origin via\nthe user account eases the process of doing Hostname lookups while also making it faster to\ntrack the affected user.\n\n## Crafting a fully parameterized query\n\nKQL (Kusto Query Language) allows us to define constants and variables to be used\nthroughout the code, just like a procedural programming language does.\n\n\n-----\n\nThat s done via the statement:\n\nClick to view\nHere’s where we define all the parameters, from the query’s time period, to beacon’s\nattributes, including which IP address ranges to ignore.\n\nSome of those key parameters are explained further below and you can find all descriptions\nin the query as comments.\n\n## The Beacons table\n\nThis dynamic table holds a list of beacon candidates. The CommonSecurityLog table is used\nto store events from multiple products and vendors, therefore we need to narrow the query\ndown to our scope.\n\nIn this case, we look for related events coming from vendor which also provides a valid\nvalue:\n```\nlet Beacons = materialize(CommonSecurityLog| where TimeGenerated between\n(start..end)| where DeviceVendor has \"palo alto\" and Activity =~ \"traffic\" and\nisnotempty(SourceUserName)| where not(ipv4_is_private(DestinationIP))| evaluate\nipv4_lookup(ExcludedNets, DestinationIP, ExcludedNet, return_unmatched = true)| where\nisempty(ExcludedNet)| project TimeGenerated, SourceUserName, DestinationIP,\nDestinationPort, DeviceAction, ReceivedBytes, Protocol, SentBytes\n\n```\nAfter excluding unwanted traffic, we simply project the relevant fields, speeding up the\nprocess. Another best practice we are leveraging here is the use of special function, which\nenables results caching.\n\n## Calculating stats per beacon instance\n\nFirst of all, there are probably many other ways to do that. Happy to discuss other ideas and\nhow we could improve it.\n\nI’ve tried using the operator which enables sub-query over split-by results but unfortunately\ngiven the high number of potential distinct tuples (cardinality), the max partitions limit (64) is\neasily reached.\n\n\n-----\n\nIn Splunk (SPL), many commands do support that approach, including eventstats and\n_[streamstats, which is what I leverage here.](https://github.com/inodee/threathunting-spl/blob/master/hunt-queries/Detecting_Beaconing.md)_\n\n[In Kusto (KQL), there’s a super awesome list of resources provided by Ashwin Patil (Senior](https://twitter.com/ashwinpatil)\n[Program Manager @Microsoft MSTIC) that covers an example of Network Beaconing](https://twitter.com/Microsoft)\ndetection but using a different, much simpler approach:\n\n## ashwin-patil/blue-teaming-with-kql\n\n### Repository with Sample KQL Query examples for Threat Hunting This folder has various KQL examples related to Threat…\n\ngithub.com\n\nThe way to calculate those stats is basically by sorting the events by time and ‘tuple’ and\n[then using Windows Functions to reference fields from previous records matching the current](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/windowsfunctions)\ntuple at hand.\n\n**What’s in a tuple?**\n\nIn this context, it’s basically what identifies a distinct instance of a beacon candidate. That’s\ndefined in this example by the following line:\n```\n| extend tuple = strcat(SourceUserName, '->', Protocol, ' ', DestinationIP, ':',\nDestinationPort, ' (', DeviceAction, ')')\n\n```\nThat means tuple holds both the origin (username) and target (destination IP + Port) related\nto a potential beacon. To make it even stricter, we also add the traffic outcome (allow/deny)\nto the tuple identifier.\n\n## The delta and variance\n\nThe key detection design here, besides scoping on the important fields and other\nenrichments (covered later) is on how to calculate the difference in time or delta between two\nconsecutive requests matching the same tuple, and later measuring how dispersed those\n**values are.**\n\nThat’s done by referencing the TimeGenerated from previous/current record and later\ncalculating the standard deviation of those values split by tuple.\n\nAnd here’s how we’ve done it with function:\n```\n| extend TimeGenerated_prev=prev(TimeGenerated)| extend diff=iff(tuple ==\nprev(tuple), datetime_diff('second', TimeGenerated, TimeGenerated_prev), 9999)|\nsummarize EventCount=count(), stdevif(diff, diff != 9999), stdev(ReceivedBytes),\narg_max(TimeGenerated, *) by tuple, Bin=bin(TimeGenerated, bin_size)\n\n```\n\n-----\n\nInstead of standard deviation, we could have used variance but with the former, it s easier to\n_describe what happened, more below._\n\nAs you can see, the first parameter is consumed here: . That is defined earlier in the query\nvia let statement and represents the size of each window for collecting deltas from\nconsecutive similar records.\n```\nlet bin_size = 1h;\n\n```\nThe idea is of course to enable easier code customization.\n\nThe last bit on beacon candidates is to filter on relevant flows only, and that’s done by using\nthe operator in combination with other parameters which behave as thresholds.\n```\n| where EventCount >= min_events_per_bin and stdevif_diff <= max_delta_deviation and\nstdev_ReceivedBytes <= max_receive_bytes_deviation);\n\n```\nThe most important here is the following:\n```\nlet max_delta_deviation = 15; // delta = diff, in secs, between consecutive similar\nrequests, this = max stdev(delta)\n\n```\nRoughly speaking, setting that value to 15 and assuming the times are in seconds, we are\nselecting network flows in which delta values observed are within 15s from their mean.\n\nThat enables us to tackle some jitter componentsand other simple evasion techniques\navailable from some C2 tools and attack frameworks.\n\nThe final part o the candidates table is shown below:\n\nClick to enlarge\n\n## Increasing Fidelity\n\nHere’s a list of additional enrichments and behavioral checks done in order to increase\ndetection efficacy, all made possible via ops:\n\n“Are there multiple accounts matching the same destination IP address?” If there are\ntoo many, that’s a Set this via ;\n“Is the destination IP matching a Threat Intel feed?” In this example, we leverage the\ntable. In case you want to alert only when there are matches, set to 1;\n“Is the beaconing traffic consistent?” Despite suggesting to detect beacons within 1h,\nover how many hours is the traffic observed? Check the parameter for details on that\nimportant setting;\n\n\n-----\n\nIn a common C2 scenario, data inflow (received bytes) tends to be fairly stable and\nconsistent, check how is used.\n\n## The output\n\nBelow is an expanded record, including a Description of the alert:\n\n## The query (rule template)\n\nThe full KQL code or rule template is available below and can easily be adapted to any other\ndata source — providing it contains the necessary fields.\n\nYou can also use this template to create a baseline, which enables detection of new\nbeacons as they happen by comparing their signature (tuple) to previously tracked ones.\n\nPlease feel free to reach out to exchange ideas on how to use and improve this method and\nhappy hunting!\n\n\n-----\n\n```\n// Excluded networks, RFC 1918 are excluded via ipv4_is_private()let ExcludedNets \ndatatable(ExcludedNet: string)  [  '200.1.0.0/16',  // Pub range 1  \n'200.2.0.0/16'  // Pub range 2  ];// Query schedule parameterslet time_offset =\n2h;      // how far back the needle should end?let time_window = 8h;     \n// how much time to look back from there?let end = ago(time_offset);   // latest\n(TimeGenerated)let start = end - time_window; // earliest (TimeGenerated)// Beacon\ndetection parameters let threat_match_only = 0;       // set to 1 to alert\nonly when there's also a match from ThreatIntelligenceIndicatorlet bin_size = 1h;  \n// what's the size of each window for collecting deltas of consecutive similar\nflowslet min_bins = 8;            // how many distinct hours (within\ntime_window) needed to consider it a consistent beacon flowlet min_events_per_bin =\n60;      // how many events (minimum) needed within each bin (bin_size) to\nconsider it a beaconlet max_delta_deviation = 15;      // delta = diff, in secs,\nbetween consecutive similar requests, this = max stdev(delta)let max_victims = 2;  \n// how many max distinct SourceUserName values should be seen linked to an external\nIP addresslet max_receive_bytes_deviation = 1024; // max deviation on\nstdev(ReceivedBytes), assuming the bytes received should not change muchlet Beacons =\nmaterialize(CommonSecurityLog  | where TimeGenerated between (start..end)  |\nwhere DeviceVendor has \"palo alto\" and Activity =~ \"traffic\" and\nisnotempty(SourceUserName)  | where not(ipv4_is_private(DestinationIP))  |\nevaluate ipv4_lookup(ExcludedNets, DestinationIP, ExcludedNet, return_unmatched =\ntrue)  | where isempty(ExcludedNet)  | project TimeGenerated, SourceUserName,\nDestinationIP, DestinationPort, DeviceAction, ReceivedBytes, Protocol, SentBytes  |\nextend tuple = strcat(SourceUserName, '->', Protocol, ' ', DestinationIP, ':',\nDestinationPort, ' (', DeviceAction, ')')  | extend\nTimeGenerated=bin(TimeGenerated, 1s) // this and next keep only one event per tuple in case the request is made in the same second  | distinct TimeGenerated,\nSourceUserName, DestinationIP, DestinationPort, DeviceAction, ReceivedBytes,\nProtocol, SentBytes, tuple  | sort by tuple asc, TimeGenerated asc  | extend\nTimeGenerated_prev=prev(TimeGenerated)  | extend diff=iff(tuple == prev(tuple),\ndatetime_diff('second', TimeGenerated, TimeGenerated_prev), 9999)  | summarize\nEventCount=count(), stdevif(diff, diff != 9999), stdev(ReceivedBytes),\nStartTime=min(TimeGenerated), EndTime=arg_max(TimeGenerated, *) by tuple,\nBin=bin(TimeGenerated, bin_size)  | where EventCount >= min_events_per_bin and\nstdevif_diff <= max_delta_deviation and stdev_ReceivedBytes <=\nmax_receive_bytes_deviation);let InfrequentDestinationIPs = Beacons   | summarize\nVictimCount=dcount(SourceUserName) by DestinationIP  | where VictimCount <=\nmax_victims;let ConsistentBeacons = Beacons  | summarize BinCount=dcount(Bin) by\ntuple  | where BinCount >= min_bins;Beacons| lookup kind=inner\n(InfrequentDestinationIPs) on DestinationIP| lookup kind=inner (ConsistentBeacons) on\ntuple| join kind=leftouter (ThreatIntelligenceIndicator  | where TimeGenerated >\nago(90d) and ConfidenceScore >= 75  | where isnull(KillChainReconnaissance) and\nConfidenceScore >= 30 and not(Description matches regex \"(?i)(brute.*force)\")  |\nextend DestinationIP = coalesce(NetworkDestinationIP, NetworkIP, NetworkSourceIP)  \n| where DestinationIP matches regex '[0-9]'  | summarize\nConfidenceScore=max(ConfidenceScore), LastSeen=max(TimeGenerated) by DestinationIP,\nThreatDescription=Description, ThreatType  | sort by LastSeen desc, ConfidenceScore\ndesc)  on DestinationIP| where ConfidenceScore > 0 or 0 == threat_match_only|\nsummarize arg_min(StartTime, EndTime, stdevif_diff, VictimCount, EventCount,\nstdev_ReceivedBytes, BinCount, Protocol, DestinationIP, DestinationPort,\nDeviceAction, ThreatType, ConfidenceScore, ThreatDescription),\nTotalEventCount=sum(EventCount), TotalBytesSent=sum(SentBytes),\nTotalBytesReceived=sum(ReceivedBytes) by tuple| sort by stdevif_diff asc,\nstdev_ReceivedBytes asc, EventCount desc| extend Description=strcat('Between ',\nStartTime, ' and ', EndTime, ', potential beaconing traffic matching [', tuple, ']\n\n```\n\n-----\n\n```\nhas generated, EventCount, events in, bin_size, with,\nround(stdevif_diff,1), 's deviation among beacons and ', TotalEventCount, ' total\nevents observed in the entire window checked.')\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-30 - Detecting network beacons via KQL using simple spread stats functions.pdf"
    ],
    "report_names": [
        "2021-04-30 - Detecting network beacons via KQL using simple spread stats functions.pdf"
    ],
    "threat_actors": [
        {
            "id": "faa4a29b-254a-45bd-b412-9a1cbddbd5e3",
            "created_at": "2022-10-25T16:07:23.80111Z",
            "updated_at": "2025-03-27T02:02:09.985067Z",
            "deleted_at": null,
            "main_name": "LookBack",
            "aliases": [
                "FlowingFrog",
                "LookBack",
                "LookingFrog",
                "TA410",
                "Witchetty"
            ],
            "source_name": "ETDA:LookBack",
            "tools": [
                "FlowCloud",
                "GUP Proxy Tool",
                "SodomMain",
                "SodomMain RAT",
                "SodomNormal"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535755,
    "ts_updated_at": 1743041145,
    "ts_creation_date": 1653780719,
    "ts_modification_date": 1653780719,
    "files": {
        "pdf": "https://archive.orkl.eu/b4fa764ac80b8bd1b3324192797101ab9d8bb345.pdf",
        "text": "https://archive.orkl.eu/b4fa764ac80b8bd1b3324192797101ab9d8bb345.txt",
        "img": "https://archive.orkl.eu/b4fa764ac80b8bd1b3324192797101ab9d8bb345.jpg"
    }
}