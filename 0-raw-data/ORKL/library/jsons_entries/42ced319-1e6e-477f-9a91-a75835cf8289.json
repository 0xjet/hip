{
    "id": "42ced319-1e6e-477f-9a91-a75835cf8289",
    "created_at": "2023-01-12T15:05:18.033912Z",
    "updated_at": "2025-03-27T02:05:22.521769Z",
    "deleted_at": null,
    "sha1_hash": "f646f1ddcc5a654b95735628fefa5c68f1aad06b",
    "title": "2017-05-03 - Deep Analysis of New Emotet Variant - Part 1",
    "authors": "",
    "file_creation_date": "2022-05-29T10:40:31Z",
    "file_modification_date": "2022-05-29T10:40:31Z",
    "file_size": 610925,
    "plain_text": "# Deep Analysis of New Emotet Variant – Part 1\n\n**[blog.fortinet.com/2017/05/03/deep-analysis-of-new-emotet-variant-part-1](http://blog.fortinet.com/2017/05/03/deep-analysis-of-new-emotet-variant-part-1)**\n\nThreat Research\n\nBy [Xiaopeng Zhang | May 03, 2017](http://blog.fortinet.com/blog/search?author=Xiaopeng+Zhang)\n\n## Background\n\n\nMay 3, 2017\n\n\nLast week, FortiGuard Labs captured a JS file that functions as a malware downloader to\nspread a new variant of the Emotet Trojan. Its original file name is\n_Invoice__779__Apr___25___2017___lang___gb___GB779.js. A JS file, as you may be_\naware, is a JavaScript file that can be executed by a Window Script Host (wscript.exe) simply\nby double-clicking on it. In this blog we will analyze how this new malware works by walking\nthrough it step by step in chronological order.\n\n## A JS file used to spread malware\n\nThe original JS code is obfuscated, and therefore hard to understand. Based on my analysis,\nits task is to generate a new JS code into an array and execute it. The new code is easier to\nunderstand, as you can see in the code snippet in Figure 1. As I mentioned, it’s a\ndownloader tool that tries to download malware from five URLs onto the affected device.\nOnce one download is finished, the malware is saved to the system temporary folder as\n“random name.exe” and executed.\n\n\n-----\n\nFigure 1. Snippet of the generated JS code\n\n## Running the downloaded exe file\n\nWhile the downloaded exe file is executed, it moves itself to “%LocalAppData%\\random\nname\\random name.exe” . A random name for the file is generated using local file names.\nYou can treat it as any random name, however, in my environment, the name is\n“LatnParams.exe”.\n\nTo protect itself, once LatnParams.exe is executed it extracts code from itself, inserts it into a\nnewly-created LatnParams.exe by calling the CreateProcessW function with a\nCREATE_SUSPENDED flag, and then restores the second process to run. Once that is\ncomplete, the first process exits. Later, the LatnParams.exe’s lnk file is created inside the\nStartup folder in the system Start Menu so it can automatically run whenever the system\nstarts. See Figure 2.\n\n\n-----\n\nFigure 2. Malware in Startup folder\n\n## The main function of the second process\n\nNext, we’ll look to see how the code works inside the second process that is created. There\nis a hidden window created for the second process. Its WindowProc function is to handle all\nwindows messages for the window. This malware uses a WM_TIMER message to initiate it.\nCalling the SetTimer function can generate such a message.\n\nOnce this window is created, a WM_CREATE message is sent to the WindowProc function,\nwhere it calls the SetTimer function to keep the system posting WM_TIMER messages every\n200ms and then callback the window’s WindowProc function.\n\n\n-----\n\nFigure 3. Call SetTimer Function\n\nNext, we will examine this WindowProc function. Figure 4 is the structure of this function in\npseudo code.\n\n\n-----\n\nFigure 4. WindowProc Function\n\n## Case 6 Code Branch\n\nIn the case 6 code branch, the malware collects system information from the affected device,\nincluding computer name, country name, the names of all running programs, and content\nabout whether or not MS Office Outlook is installed. It then puts all the collected data\ntogether into a memory buffer and encrypts it. Figure 5 shows the data ready for encryption.\n\n\n-----\n\nFigure 5. Collected data from the victim’s system\n\nAs you can see, the first part is the computer name. Following “16 00 01 00” is the CPU\ninformation. The next part is the running process names, followed by the string “Microsoft\nOutlook,” which means that MS Office Outlook is installed on this machine. You may also\nnotice that the debugger name “OllyDBG.exe” is also in the process name list. Through my\nanalysis I found that the C&C server checks the process names. If it learns that a debuggingrelated tool (such as OllyDbg, WinDbg, IDA Pro, etc.) is being running on the victim’s\nmachine, a different response is returned. In this case, it replies with a new version of itself,\ncausing itself to upgrade again and again until those tools exit.\n\nAfter encryption, it copies the encrypted data, the encryption key, and the hash value\ntogether into a new buffer. It then sets the next case number to 7 and exits the case 6\nbranch.\n\n## Case 7 Code Branch\n\nIn the case 7 code branch the main function is to connect to the C&C server and send\ncollected data to the server. It also receives data from the C&C server. We’ll take a look at\nhow it works here.\n\n\n-----\n\nThe C&C server s IP and port are hard-coded. In this version there are eleven, as shown\nbelow:\n```\n   004175D0        ; DATA XREF: WindowProc+257r\n   004175D0        ;sub_403AE0+Co\n   004175D0 dd 0D453A62Dh ;212.83.166.45\n   004175D4 dd 1F90h   ;8080\n   004175D8 dd 0ADE68843h ;173.230.136.67\n   004175DC dd 1BBh    ;443\n   004175E0 dd 0ADE0DA19h ;173.224.218.25\n   004175E4 dd 1BBh    ;443\n   004175E8 dd 68E38922h ;104.227.137.34\n   004175EC dd 1BA8h   ;7080\n   004175F0 dd 894AFE40h ;137.74.254.64\n   004175F4 dd 1F90h   ;8080\n   004175F8 dd 0BCA5DCD6h ;188.165.220.214\n   004175FC dd 1F90h   ;8080\n   00417600 dd 558FDDB4h ;85.143.221.180 \n   00417604 dd 1BA8h   ;7080\n   00417608 dd 77521BF6h ;119.82.27.246\n   0041760C dd 1F90h   ;8080\n   00417610 dd 0C258F607h ;194.88.246.7\n   00417614 dd 1F90h   ;8080\n   00417618 dd 0CED6DC4Fh ;206.214.220.79\n   0041761C dd 1F90h   ;8080\n   00417620 dd 68EC02FDh ;104.236.2.253\n   00417624 dd 1BBh    ;443\n\n```\nIt gets the data generated in the case 6 branch and encodes it using base64. It then sends\nthe base64-encoded data as a Cookie value to the C&C server. Figure 6 shows the data in\nWireshark.\n\n\n-----\n\nFigure 6. Send collected system information to C&C server\n\nIn Figure 6, the status of the response from C&C server is “404 Not Found.” This message is\nused is to confuse analysts. The body, however, is the encrypted data. After receiving all\ndata from the server, it sets the next case number to 8 and exits this branch.\n\n## Case 8 Code Branch\n\nThe only thing done in the case 8 branch is decrypt the data received in case 7. It then exits\nthis branch and sets the next case number to 9.\n\n## Case 9 Code Branch\n\nThe case 9 branch is used to process the data decrypted in case 8. Figure 7 is a part of the\npseudo code of case 9.\n\n\n-----\n\nFigure 7. Pseudo code of case 9\n\nThere are some sub-cases in the case 9 branch. The case number “v8” comes from\ndecrypted data. Following are two examples of the decrypted data.\n\nIn Figure 8, “08 01” is about a sub-case. “08” is a kind of flag or C&C command, and “01”\nrefers to sub-case number 1. As you may know, the following data is an .exe file. In the subcase 1 branch, this file is executed to upgrade the Emotet malware. Usually, it receives an\nupgrade command because the C&C server has detected that there is debugging-related\ntool in the running program names. It’s a way to both protect itself against debugging and\nconfuse analysts. In sub-case 1 branch, it saves the .exe file into a system temporary folder\nand runs it by calling the ShellExecuteW function. Meanwhile, the parent process exits to\nfinish the upgrade.\n\n\n-----\n\nFigure 8. Sub-case 1 example\n\n\n-----\n\nFigure 9. Sub-case 4 example\n\nI manually modified the “OllyDBG.exe” to another program name before encryption (refer\nback to Figure 5). Then I was able to get the response shown in Figure 9. The flag changes\nto “08 04”, where “04” means sub-case number 4. In my analysis, it contains 3 modules (.dll\nfiles) in the decrypted data. The flags for all of them are “08 04”. Which means the modules\nare all processed in the sub-case 4 branch. As you can see in Figure 7, the sub-case 4 calls\nthe CreateThread function to create threads and run the modules in the ThreadFunction, with\none thread for one module.\n\n\n-----\n\nSo far, we have only finished the analysis of one of the three Emotet modules. We are still\nworking on analyzing the others, and will share that analysis in another blog.\n\nSo next, let’s take a look at what this module is able to do.\n\n## The module loaded in a thread\n\nBased on my analysis, this module steals credential information from a victim’s machine. It\nthen encrypts that stolen data and sends it to the C&C server.\n\nWhen this module is loaded in the ThreadFunction, it inserts the code extracted from itself\ninto a newly-created LathParams.exe process to run. The newly-created process has a\ncommand line parameter like “%temp%\\A98b.tmp”. This is a temporary file used to save the\nstolen credential information.\n\nIt is able to steal credentials for Google accounts, FTP accounts saved in IE, Google Talk,\nOffice Outlook, IncrediMail, Group Mail, MSN Messenger, Mozilla Thunderbird, and many\nothers. The following screenshot shows some of them.\n\nFigure 10. Targeted email-related credentials\n\n\n-----\n\nFor testing purposes, I added a test account into MS Office Outlook to see how it works. The\naccount profile is shown here in Figure 11:\n\nFigure 11. Test account added into Outlook\n\nThe stolen credential data is saved in the temporary file specified in the command line\nparameter, where it will be encrypted and sent to the C&C server in the ThreadFunction. In\nthe following several figures you can see the stolen credential information in the temporary\nfile, the data in memory before encryption, and the data sent to the C&C server.\n\n\n-----\n\nFigure 12. Stolen credential\n\nFigure 13. Before encryption\n\n\n-----\n\nFigure 14. Data sent to the C&C server\n\n## Solution\n\nThe original JS file has been detected as JS/Nemucod.F436!tr and the downloaded Emotet\nexe has been detected as W32/GenKryptik.ADJR!tr by the FortiGuard Antivirus service.\n\n## IoC\n\n### URL:\n\n\"hxxp://willemberg.co.za/TwnZ36149pKUsr/\"\n\n\"hxxp://meanconsulting.com/K44975X/\"\n\n\"hxxp://microtecno.com/i17281nfryG/\"\n\n\"hxxp://thefake.com/Y96158yeXR/\"\n\n\"hxxp://cdoprojectgraduation.com/eaSz15612O/\"\n\n### Sample SHA256:\n\nInvoice__779__Apr___25___2017___lang___gb___GB779.js\n\nB392E93A5753601DB564E6F2DC6A945AAC3861BC31E2C1E5E7F3CD4E5BB150A4\n\n### Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-05-03 - Deep Analysis of New Emotet Variant - Part 1.pdf"
    ],
    "report_names": [
        "2017-05-03 - Deep Analysis of New Emotet Variant - Part 1.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535918,
    "ts_updated_at": 1743041122,
    "ts_creation_date": 1653820831,
    "ts_modification_date": 1653820831,
    "files": {
        "pdf": "https://archive.orkl.eu/f646f1ddcc5a654b95735628fefa5c68f1aad06b.pdf",
        "text": "https://archive.orkl.eu/f646f1ddcc5a654b95735628fefa5c68f1aad06b.txt",
        "img": "https://archive.orkl.eu/f646f1ddcc5a654b95735628fefa5c68f1aad06b.jpg"
    }
}