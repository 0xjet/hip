{
    "id": "de715cf3-7ccd-4277-8e23-74872f09cad3",
    "created_at": "2022-10-25T16:48:11.199581Z",
    "updated_at": "2025-03-27T02:16:28.851916Z",
    "deleted_at": null,
    "sha1_hash": "0acc6bd7228fe5a1b059de2ba51e76cbe9717fc4",
    "title": "",
    "authors": "",
    "file_creation_date": "2019-04-23T01:53:49Z",
    "file_modification_date": "2019-04-23T01:53:49Z",
    "file_size": 993040,
    "plain_text": "# “Funky malware format” found in Ocean Lotus sample\n\n**[blog.malwarebytes.com/threat-analysis/2019/04/funky-malware-format-found-in-ocean-lotus-sample](https://blog.malwarebytes.com/threat-analysis/2019/04/funky-malware-format-found-in-ocean-lotus-sample/)**\n\nPosted: April 19, 2019 by hasherezade April 19, 2019\n\nRecently, [at the SAS conference I talked about “Funky malware formats”—atypical executable formats used](https://speakerdeck.com/hshrzd/funky-malware-formats)\nby malware that are only loaded by proprietary loaders. Malware authors use them in order to make static\ndetection more difficult, because custom formats are not recognized as executable by AV scanners.\n\nUsing atypical formats may also slow down the analysis process because the file can’t be parsed out of the\nbox by typical tools. Instead, we need to [write custom loaders in order to analyze them freely.](https://www.msreverseengineering.com/blog/2018/9/2/weekend-project-a-custom-ida-loader-module-for-the-hidden-bee-malware-family)\n\nLast year, we described one such format in [a post about Hidden Bee. This time, we want to introduce you](https://blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements/)\nto another case that we discussed at the SAS Conference. It is a sample of Ocean Lotus, also known as\nAPT 32, a threat group associated with Vietnam.\n\n## Sample\n\n[49a2505d54c83a65bb4d716a27438ed8f065c709 – the main executable](https://beta.virusbay.io/sample/browse/46745e29f15eedfabba7e080f6295200?q=5c069cf73d275127369cb440)\n\n_Special thanks to_ _[Minh-Triet Pham Tran for providing the material.](https://twitter.com/MinhTrietPT)_\n\n## Overview\n\nThe sample comes with two elements—BLOB and CAB—that are both executables in the same unknown\nformat. The custom format is achieved by conversion from PE format (we can guess it by observing some\nartifacts typical for PE files, i.e. the manifest) However, the header is fully custom, and the way of loading it\nhas no resemblance with PE. Some of the information from a typical PE (for example, the layout of the\nsections) is not preserved: sections are shuffled.\n\n\n-----\n\n## Origin\n\nThis sample is from June 10, 2017, from the following email:\n\nContent of the phishing email, along with its attachment\n\nThe title “Sổ tay vấn đề pháp lý cho các nhà hoạt động nhân quyền” translates to: “Handbook of legal\nissues for human rights activists.” It’s a subject line for a spear phishing campaign targeting Vietnamese\nactivists.\n\nThe malicious sample was delivered as an attachment to the email: a zipped executable. The icon tried to\nimitate a PDF (FoxitPDF reader).\n\nAn executable with FoxitFDF icon\n\n## Behavioral analysis\n\nAfter being run, the sample copies itself into %TEMP%, unpacks, and launches the decoy PDF.\n\nThe main executable and the decoy copied to the Temp folder\n\nWhile the user is busy reading the launched document, the dropper unpacks the real payload. It is dropped\ninto C:\\ProgramData\\Microsoft Help:\n\n\n-----\n\nAll the elements of the malware unpacked\n\nThe dropper executable is deleted afterwards.\n\nThe malware manages to bypass UAC at default level. We can see the application sporder.exe running with\nelevated privileges.\n\nPersistence is provided by a simple Run key, leading to the dropped script:\n\nAdded run key (view from Sysinternals Autoruns)\n\nThe interesting factor is that the sample has an “expiry date” after which the installer no longer runs.\n\n## Internals\n\nThe main executable sporder.exe is packed with UPX. It imports the DLL SPORDER.dll:\n\n\n-----\n\nImport table of SPORDER.exe (view from PE-bear)\n\nSPORDER.dll imports another of the dropped DLLs, hp6000.dll:\n\nImport table of SPORDER.exe (view from PE-bear)\n\nThe key malware functionality is, however, not provided by any of the dropped PE files. They are just used\nas loaders.\n\nAs it turns out, the core is hidden in two unknown files: BLOB and CAB.\n\n## Custom formats\n\nThe files with extensions BLOB and CAB are obfuscated with XOR. After decoding them, we notice some\nreadable strings of code. However, none of them are valid PE files, and we cannot find any of the typical\nheaders.\n\n### BLOB\n\nThe BLOB file is obfuscated by XOR. We can see the repeating pattern and use it as an XOR key:\n\nSPORDER.blob (original version), the repeating pattern is selected\n\n\n-----\n\nAs a result, we get the following clear version: [2e68afae82c1c299e886ab0b6b185658](https://www.virustotal.com/#/file/f3f62d0813c1226316e12d0d403bad475b6f0128918a845695686d4b9359c546/detection)\n\nBLOB’s header:\n\nThe BLOB file looks like a processed PE file, however, its sections appear to be in swapped order. The first\nsection seems to be .data, instead of .text.\n\nWe can see visible artifacts from the [BZIP library and C++ standard library.](https://github.com/google/bzip2-rpc/blob/master/bzlib.c)\n\n### CAB\n\nThe CAB file is obfuscated with XOR in a similar way, but with a different key:\n\nWhen we apply the key, we get an analogical clear version: [b3f9a8adf0929b2a37db7b396d231110](https://www.virustotal.com/#/file/a87d6c0ef82bd430e7b54de5b41668bf2f1fa688e45206c871f259508653d006/details)\n\nThis sample also has a custom header, which does not resemble the PE header. However, we found\nsections inside that are typical for PE files, for example, a manifest.\n\n### Loader\n\nAs it turned out, both files are loaded by hp6000.dll: [67b8d21e79018f1ab1b31e1aba16d201](https://www.virustotal.com/#/file/806d6f36e39de3c1775e0856227aab65f5772d6111101189651b67dd9e6d81f4/detection)\n\nThe loading function is executed in an obfuscated way: when the DllMain is executed, it patches the main\nexecutable that loaded the DLL.\n\n\n-----\n\nFirst, the file name of the current module is retrieved. Then, the file is read and the address of the entry\npoint is fetched. Then, the analogical module that is loaded in the memory is set as an executable:\n\nUsing VirtualProtect to make the main module writable\n\nFinally, the bytes are patched so that the entry point will redirect back to the appropriate function in the\nloading DLL:\n\nPatching the entry point of the main module, byte by byte\n\nThis is how the entry point of the main module looks after the patch is applied:\n\nThe Entry Point of the main module (sporder.exe) after patching\n\nWe see that the Virtual Address (RVA 0x1210 + DLL loading base) of the function within the DLL is moved\nto EAX, and then the EAX is used as a jump target.\n\nThe function that starts at RVA 0x1210 is a loader for BLOB and CAB:\n\n\n-----\n\nBeginning of the loading function\n\nThis redirection works, thanks to the fact that when the executable is loaded into the memory, before the\nEntry Point of the main module is hit, all the DLLs that are in its Import Table are loaded, and the DllMain of\neach is called. Just after the DLLs are loaded, the execution of the main executable starts. And in our case,\nthe patched entry point redirects back to the DLL.\n\nInside the function loading BLOB and CAB:\n\nThe function loading BLOB and CAB\n\n\n-----\n\nAs you can see, the CAB file is loaded first:\n\nExecuting the function loading CAB file\n(unconditional)\n\nFurther, we see this function retrieving some\nenvironmental variable. This variable is used to\nstore the state of the application, and is shared\nbetween consecutive executions. Depending on\nthis state, one of multiple execution paths can\nbe taken.\n\nThe name of the variable is created by concatenating:\n\n1. hardcoded string: L”Local\\\\{076B1DB0-2C01-45A5-BD0A-0CF5D6410DCB}”\n2. the name of the executable\n3. a local username\n\nSetting the variable name\n\nThe content variable may be one of the following: ‘@’, ‘*’,’:’. If it is empty, the first value ‘@’ is set. Those\nvariables are translated to particular states that control the flow.\n\n‘@’ -> state 1\n‘*’ -> state 2\n‘:’ -> state 3\n\nThe main process is restarted on each state change. Finally, the state 3 creates mutex and loads the file\nwith the BLOB extension.\n\n\n-----\n\nFinal state: setting the mutex and loading the BLOB\n\nThe mutex name is the same as the variable name, but with a suffix “_M” added:\n\nSetting the mutex\n\nWhile the application runs, we can see the BLOB being loaded in executable form inside the main module’s\nmemory:\n\nMemory of the sporder.exe, view from Process Hacker\n\nBy comparing the format that is loaded in the memory with the format that is stored on the disk, we can see\nthat the beginning and the end of the BLOB is skipped in the loading process. So, we can guess that those\nparts are some headers that contains the information necessary for loading, but not for execution. The\nheader at the beginning of the file will be referenced as Header1, and the one at the end (footer) will be\nreferenced as Header2.\n\n\n-----\n\nThe Header2 file in the memory vs. its equivalent on the disk:\n\nComparing the memory dump with the raw file\n\nWe also found that some of the addresses were relocated (the new Image Base was added).\n\n## Reversing the reversed PE\n\nThe files with both extensions CAB and BLOB are loaded by the same function:\n\nView from IFL (Interactive Functions List)\n\nThe core of the loader is in the following function:\n\nThis is the function that we need to analyze in\norder to make sense out of the custom format.\n\nLet’s take a look at the loading process itself.\n\nFirst, DWORD of the Header1 is skipped. Then,\nwe have two DWORDs that are used as an XOR\nkey. Once they are fetched, the rest of the header\nis decoded.\n\n\n-----\n\nAfter applying the key, we get the content of the file in its clear form. The next value from the headers is\nused in the formula calculating the size for loading the executable part of the module. In the currently\nanalyzed case (the CAB file), it is 0x17000:\n\nHeader 1 at the beginning of the CAB file, decoded\n\nSo, 0x17000 + 0x2000 is the size of the memory that will be allocated for the payload.\n\nExample (from CAB file):\n\n\n-----\n\nThen, 0x17000 bytes of the payload is copied, but the beginning containing the Header1 is skipped (the\nfirst 16 bytes).\n\nAfter the module content is copied, Header2 is used to continue loading.\n\nLooking at Header2, we can see some similarities with Header1. Again, the initial DWORD is skipped, and\nthen we have a value that is used in a formula calculating the size of the memory to be allocated. The new\nmemory region that is being allocated this time is used for the imports that are going to be loaded (the full\nprocess will be explained further).\n\nConceptually, we can divide Header 2 into two parts.\n\nFirst comes a prolog that contains two DWORD values. Example from the currently-analyzed CAB file:\n\nHeader2 (at the end of the CAB file) – prolog is hilighted\n\nval[0] = 0x21A0 -> skipped\nval[1] = 0x013D -> val[1]*8+0x400 -> size of the next area to allocate\n\nThen there is a list of records of a custom type. Each record represents a different piece of information that\nis necessary for loading the module. They are identified by the type ID that is represented by a DWORD at\nthe beginning of the record.\n\nHeader2 (at the end of the CAB file) – records are hilighted\n\n\n-----\n\n### Relocations\n\nType 1 stands for relocation. It has one DWORD as an argument. It is an address that needs to be\nrelocated.\n\ntypedef struct {\nDWORD reloc_field;\n} reloc_t;\n\nParsing of the type 1\n\nWe can see how the field is used to relocate the address. Example: filling the address at 0x8590:\n\nThe address pointed by the relocation record is relocated to the base at which the module was loaded\n\n\n-----\n\n## Entry point\n\nType 2 stands for entry point or an exported function. The pointed address is stored on the list in order to\nbe called later, after the loading finished. This record has three DWORD parameters.\n\ntypedef struct {\n\nDWORD count;\n\nDWORD entry_rva;\n\nDWORD name_rva;\n\n} entry_point_t;\n\nExample of the record of type 2:\n\nParsing of the type 2\n\nAddress to be stored: params[1] = 0x00001030\n\n\n-----\n\nRecord of the type 2 in the original file\n\nBy observing the execution flow, we can confirm that indeed the stored entry point of the module is being\ncalled later:\n\nThe address in the loader where the CAB module is called after being loaded\n\nExported functions are stored in the same way, along with their names.\n\n## Imports\n\nType 3 stands for imports. It has four DWORD parameters.\n\ntypedef struct {\n\nDWORD type;\n\nDWORD dll_rva;\n\nDWORD func_rva;\n\nDWORD iat_rva;\n\n} import_t;\n\n\n-----\n\nParsing of the type 3\n\nExample of a chunk responsible for encoding imports:\n\nRecord of the type 3 in the original file\n\nType: params[0] = 0x00000002 – means the function will be imported by name, meaning of all the possible\ntypes of this record.\n\nAddress of the DLL: params[1] = 0x0107DA\n\n\n-----\n\nAddress of the import: params[2] = 0x010774\n\nIn contrast to PE format, the address of the imported function is not loaded into the main module. Instead, it\nis written into the separate executable area (in the given example it is written at VA: 0x00240001):\n\nAnd then, the address where the import was filled is filled back in the main module. The address in the\nmain module that needs to be filled is specified by the last parameter of this record. In the given example,\nchunk[3] = 0x0000E014 is being filled by 0x00240001:\n\n### Atypical IAT\n\nThe functions from the embedded list are for a loader, however, as mentioned earlier, the addresses are not\nfilled in a normal IAT, typical for PE format. Rather, all are filled as a list of jumps stored in a newly-allocated\nmemory page.\n\n\n-----\n\nThe import loading function not only fills the address, but also emits the necessary code for the jump:\n\nAddress of the imported function is retrieved and written into the emitted jump\n\nMeaning of the type field\n\nThe import record has a field type, that can have one of the following values: 1,2,3,4.\n\nThe 1 and 2 are the most important: They are used for loading the imports. 1 stands for loading by ordinals,\n2 for loading by name. The remaining 3 and 4 are used for cleanup of the fields that are no longer needed.\n3 erases import name, 4 erases DLL name.\n\n\n-----\n\nWhen the record of the type 3 or 4 occurs, the pointer in the IAT area is still incremented, so as a result we\ncan see some gaps between the functions records:\n\n\n-----\n\n## Functionality of the custom files\n\nThe CAB file is another installer that provides persistence to the whole package by creating a service:\n\n\n-----\n\n“C:\\Windows\\system32\\wscript.exe” /B /nologo “C:\\Users\\tester\\Desktop\\mod\\sporder.vbs”\n\nI also generate the VBS script that is dropped:\n\nThe CAB file is loaded first, just to install the malware, and then deleted.\n\nAll the espionage-related features are performed by the BLOB that is loaded later and kept persistent in the\nmemory of the loader.\n\nIn addition to being in a custom format, BLOB is also heavily obfuscated.\n\nWe can observe its attempts to connect to one of the CnCs:\n\n\n-----\n\npng.eirahrlichmann.com : 443\nengine.lanaurmi.com :3389\nmovies.onaldest.com : 44818\nimages.andychroeder.com : 80\npng.eirahrlichmann.com : 44818\nengine.lanaurmi.com : 44818\nmovies.onaldest.com : 9091\nimages.andychroeder.com : 9091\npng.eirahrlichmann.com : 3389\n\nSome of those domains are known from\nprevious reports on Ocean Lotus, i.e. [the\nCyclance white paper].\n\n## Ocean Lotus: a creative APT\n\nOcean Lotus often surprises researchers with its creative obfuscation techniques. Recently, a different\nsample of Ocean Lotus was found using steganography to hide their executables (you can read more about\nit in [the report of ThreatVector). The format that we described is just one of many unusual forms that their](https://threatvector.cylance.com/en_us/home/report-oceanlotus-apt-group-leveraging-steganography.html)\nimplants can take.\n\n## Appendix\n\nParser for the described format:\n[https://github.com/hasherezade/funky_malware_formats/tree/master/lotus_parser](https://github.com/hasherezade/funky_malware_formats/tree/master/lotus_parser)\n\nPresentation from the SAS conference:\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2019/2019.04.19.Funky_malware_format/Funky%20malware%20format%20found%20in%20Ocean%20Lotus%20sample.pdf"
    ],
    "report_names": [
        "Funky malware format found in Ocean Lotus sample"
    ],
    "threat_actors": [
        {
            "id": "870f6f62-84f5-48ca-a18e-cf2902cd6924",
            "created_at": "2022-10-25T15:50:23.303818Z",
            "updated_at": "2025-03-27T02:00:55.435309Z",
            "deleted_at": null,
            "main_name": "APT32",
            "aliases": [
                "APT32",
                "SeaLotus",
                "OceanLotus",
                "APT-C-00",
                "Canvas Cyclone"
            ],
            "source_name": "MITRE:APT32",
            "tools": [
                "Mimikatz",
                "ipconfig",
                "Kerrdown",
                "Cobalt Strike",
                "SOUNDBITE",
                "OSX_OCEANLOTUS.D",
                "KOMPROGO",
                "netsh",
                "RotaJakiro",
                "PHOREAL",
                "Arp",
                "Denis",
                "Goopy"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "af509bbb-8d18-4903-a9bd-9e94099c6b30",
            "created_at": "2023-01-06T13:46:38.585525Z",
            "updated_at": "2025-03-27T02:00:02.866727Z",
            "deleted_at": null,
            "main_name": "APT32",
            "aliases": [
                "TIN WOODLAWN",
                "OceanLotus Group",
                "OceanLotus",
                "Sea Lotus",
                "G0050",
                "Cobalt Kitty",
                "SeaLotus",
                "ATK17",
                "Ocean Lotus",
                "Ocean Buffalo",
                "POND LOACH",
                "Canvas Cyclone",
                "APT-C-00",
                "APT-32",
                "APT 32"
            ],
            "source_name": "MISPGALAXY:APT32",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f1518ac1-4710-4dd1-a422-e3801e4806cb",
            "created_at": "2024-05-01T02:03:08.147856Z",
            "updated_at": "2025-03-27T02:05:17.421275Z",
            "deleted_at": null,
            "main_name": "TIN WOODLAWN",
            "aliases": [
                "Cobalt Kitty",
                "OceanLotus",
                "WOODLAWN ",
                "APT32 "
            ],
            "source_name": "Secureworks:TIN WOODLAWN",
            "tools": [
                " Denis",
                " Goopy",
                " JEShell",
                " KerrDown",
                " Mimikatz",
                " Ratsnif",
                " Remy",
                " Rizzo",
                " RolandRAT",
                "Cobalt Strike"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "2439ad53-39cc-4fff-8fdf-4028d65803c0",
            "created_at": "2022-10-25T16:07:23.353204Z",
            "updated_at": "2025-03-27T02:02:09.749502Z",
            "deleted_at": null,
            "main_name": "APT 32",
            "aliases": [
                "APT 32",
                "APT-C-00",
                "APT-LY-100",
                "ATK 17",
                "Lotus Bane",
                "Ocean Buffalo",
                "OceanLotus",
                "Operation Cobalt Kitty",
                "Operation PhantomLance",
                "Pond Loach",
                "SeaLotus",
                "SectorF01",
                "Tin Woodlawn"
            ],
            "source_name": "ETDA:APT 32",
            "tools": [
                "Agentemis",
                "Android.Backdoor.736.origin",
                "AtNow",
                "Backdoor.MacOS.OCEANLOTUS.F",
                "BadCake",
                "CACTUSTORCH",
                "CamCapture Plugin",
                "CinaRAT",
                "Cobalt Strike",
                "CobaltStrike",
                "Cuegoe",
                "DKMC",
                "Denis",
                "Goopy",
                "HiddenLotus",
                "KOMPROGO",
                "KerrDown",
                "METALJACK",
                "MSFvenom",
                "Mimikatz",
                "Nishang",
                "OSX_OCEANLOTUS.D",
                "OceanLotus",
                "PHOREAL",
                "PWNDROID1",
                "PhantomLance",
                "PowerSploit",
                "Quasar RAT",
                "QuasarRAT",
                "RatSnif",
                "Remy",
                "Remy RAT",
                "Rizzo",
                "Roland",
                "Roland RAT",
                "SOUNDBITE",
                "Salgorea",
                "Splinter RAT",
                "Terracotta VPN",
                "Yggdrasil",
                "cobeacon",
                "denesRAT",
                "fingerprintjs2"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716491,
    "ts_updated_at": 1743041788,
    "ts_creation_date": 1555984429,
    "ts_modification_date": 1555984429,
    "files": {
        "pdf": "https://archive.orkl.eu/0acc6bd7228fe5a1b059de2ba51e76cbe9717fc4.pdf",
        "text": "https://archive.orkl.eu/0acc6bd7228fe5a1b059de2ba51e76cbe9717fc4.txt",
        "img": "https://archive.orkl.eu/0acc6bd7228fe5a1b059de2ba51e76cbe9717fc4.jpg"
    }
}