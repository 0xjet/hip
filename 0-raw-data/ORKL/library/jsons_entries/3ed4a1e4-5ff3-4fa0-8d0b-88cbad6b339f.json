{
    "id": "3ed4a1e4-5ff3-4fa0-8d0b-88cbad6b339f",
    "created_at": "2023-01-12T15:09:07.453997Z",
    "updated_at": "2025-03-27T02:05:51.482366Z",
    "deleted_at": null,
    "sha1_hash": "92b3cf362b22306fda5f5e1f43cbf02587cc5a74",
    "title": "2021-10-26 - Detecting CONTI CobaltStrike Lateral Movement Techniques - Part 1",
    "authors": "",
    "file_creation_date": "2022-05-28T17:10:25Z",
    "file_modification_date": "2022-05-28T17:10:25Z",
    "file_size": 1577661,
    "plain_text": "# Detecting CONTI CobaltStrike Lateral Movement Techniques - Part 1\n\n**unh4ck.com/detection-engineering-and-threat-hunting/lateral-movement/detecting-conti-cobaltstrike-lateral-movement-**\ntechniques-part-1\n\nDetecting CONTI CobaltStrike Lateral Movement Techniques - Part 1\n\nDetection opportunities on lateral movement techniques used by CONTI ransomware group\nusing CobaltStrike.\n\nIntroduction:\n\nIn an attempt to contribute to the defensive capabilities of security teams regarding the\nincrease of CobaltStrike usage by threat actors (TA) and in a joined effort with\n[@MichalKoczwara, a series of articles will be released on CobaltStrike's TTP detections](https://twitter.com/MichalKoczwara)\nrelated to the CONTI leak.\nFor the first part of this blog post, I will cover detection opportunities for lateral movement\n(LM) techniques used by the TA CONTI via CobaltStrike. Keep in mind that I tried to boil it\ndown to analytics that can be used for other lateral movements variation and not just specific\nto CONTI Group or CobaltStrike (CS).\n\nDefinition:\n\nMITRE ATT&CK defines lateral movement as :\n\n_Lateral Movement consists of techniques that adversaries use to enter and control_\n_remote systems on a network. Following through on their primary objective often_\n_requires exploring the network to find their target and subsequently gaining access to_\n_it. Reaching their objective often involves pivoting through multiple systems and_\n_accounts to gain. Adversaries might install their own remote access tools to_\n_accomplish Lateral Movement or use legitimate credentials with native network and_\n_operating system tools, which may be stealthier._\n\nLooking in the CobaltStrike documentation we can find some built-in modules for Lateral\nMovement defined in the table bellow which were included in the leaked documentation:\n\nJump Module\n\nArch\n\nDescription\n\n\n-----\n\n**psexec**\n\nx86\n\nUse a service to run a Service EXE artifact\n\n**psexec64**\n\nx64\n\nUse a service to run a Service EXE artifact\n\n**psexec_psh**\n\nx86\n\nUse a service to run a PowerShell one-liner\n\n**winrm**\n\nx86\n\nRun a PowerShell script via WinRM\n\n**winrm64**\n\nx64\n\nRun a PowerShell script via WinRM\n\nOther capabilities are used by the group like `Remote-Exec command, PTH module, RDP`\nand `SHELL` command to remotely execute commands using `WMIC.EXE utility. I will go`\nthrough these TTPs in the second part.\n\nRemote-Exec Module\n\nDescription\n\n**psexec**\n\nRemote execute via Service Control Manager\n\n**winrm**\n\nRemote execute via WinRM (PowerShell)\n\n**wmi**\n\nRemote execute via WMI (PowerShell)\n\n\n-----\n\nSimulation Setup\n\nCobaltStrike\n\nZeek\n\nElastic Stack (Winlogbeat + Filebeat)\n\n[Sysmon Configuration Blacksmith OTRF](https://github.com/OTRF/Blacksmith/tree/master/resources/configs/sysmon)\nVICTIM Windows 10 user machine (Initial Access)\n\nDC_ATLAS Domain Controller Windows Server 2016 (Lateral Movement Target)\n\nT1021.006 Remote Services: Windows Remote Management\n\nA primer to WinRM\n\n**WinRM is the Microsoft implementation of WS-Management protocol which is an open**\nsource standard for constructing XML messages following the standards of Simple Object\nAccess Protocol (SOAP) messages.\n\nThis great [blog explain in simple steps a typical WinRM based conversation for invoking](https://www.hurryupandwait.io/blog/a-look-under-the-hood-at-powershell-remoting-through-a-ruby-cross-plaform-lens)\ncommands:\n\n1. 1.\n\n[Send a Create Shell message and get the shell id from the response](https://msdn.microsoft.com/en-us/library/cc251739.aspx)\n2. 2.\n\n[Create a command in the shell sending the command and any arguments and grab the](https://msdn.microsoft.com/en-us/library/cc251740.aspx)\ncommand id from the response\n3. 3.\n\n[Send a request for output on the command id which may return streams (stdout and/or](https://msdn.microsoft.com/en-us/library/cc251741.aspx)\nstderr) containing base64 encoded text.\n4. 4.\n\nKeep requesting output until the command state is done and examine the exit code.\n\n5. 5.\n\n[Send a command termination signal](https://msdn.microsoft.com/en-us/library/cc251743.aspx)\n6. 6.\n\n[Send a delete shell message](https://msdn.microsoft.com/en-us/library/cc251746.aspx)\n\nI will go more in depth about WinRM from a defensive perspective during lateral movement\nin a separate blog but for more details I recommend checking the official documentation [MSWSMV]. However, a couple of things we should keep in mind when it come to the limitations\nof WinRM and why PowerShell Remoting Protocol (PSRP) is much better choice to go with.\n\n\n-----\n\nThe default value of a SOAP message size 512KB and a maximum of 8192KB. This\nattribute can be modified with the following command : `winrm set winrm/config/winrs`\n```\n'@{<Quota>=\"<Value>\"}' .\n\n```\nWinRM also doesn't have a built-in functionality for file transfer. We will learn in the next\nsection that PowerShell Remoting Protocol (PSRP) is much better alternative.\n\nWindows Built-in WinRM tools\n\nIn order to understand CobaltStrike WinRM beacon capabilities, first, I tried to see normal\nbehavior of some of the tools that can be used in a legitimate way. There are 3 main ways to\nexecute command remotely using WinRM:\n\n**WinRS:**\n\nWindows Remote Shell built-in tool is a pure implementation of remote command execution\nvia WinRM. Upon executing a command using winrs.exe utility via the command `winrs -`\n```\nr:dc_atlas \"ipconfig\" the following telemetry was recorded on the destination:\n   svchost.exe spawns winrshost.exe with the parent command line\n   C:\\\\Windows\\\\system32\\\\svchost.exe -k DcomLaunch\n\n```\nThe `winrshost.exe then invokes cmd.exe` instance and execute the command\nwithin its context.\n\n\n-----\n\nAfter finishing the execution of the command these processes are terminated because\n```\nwinrs.exe doesn't support persistent sessions so every time you execute a command\n\n```\nremotely this behavior repeats itself.\n\n\n-----\n\nwinrs process tree\n\n**Invoke-Command & Enter-PSSession :**\n\n[These PowerShell cmdlets use the PowerShell Remoting Protocol [MS-PSRP] which is a](https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-PSRP/%5BMS-PSRP%5D.pdf)\nseparate protocol that runs over WinRM. PSRP supports many message types to execute\ncommands and retrieve their outputs and its main difference from WSMV specs is its\nmessage fragmentation handling process which makes it more reliable vis-à-vis WinRM\nmessage size limitations.\nWhile testing these cmdlets, the following telemetry was recorded on the destination:\n```\n   svchost.exe spawns wsmprovhost.exe with the parent command line\n   C:\\Windows\\system32\\svchost.exe -k DcomLaunch\n\n```\nExecuting nslookup command via Enter-PSSession\n\n\n-----\n\nExecuting ipconfig via Invoke-Command\n```\n   Invoke-Command & Enter-PSSession both run commands within the context of\n   wsmprovhost.exe\n\n```\nThe difference between these two cmdlets is that `Invoke-Command will terminate`\n```\nwsmprovhost.exe process after receiving the output while the Enter-PSSession will\n\n```\nestablish a persistent session.\n\nInvoke-Command & Enter-PSSession process tree\n\nNow that we have established what telemetry can be left behind by using Windows built-in\ntools we can distinguish suspicious process behavior. lets see in the following section how\nCS default configurations for lateral movement behave.\n\nCobaltStrike jump winrm\n\n\n-----\n\nFirst, lets discover the telemetry that will be generated from source and destination for every\nattempt to use WinRM remotely:\n\n**_On the source:_**\n\nEID\n\nAction\n\nProvider\n\nComment\n\n6\n\nWSMan Session Creation\n\nMicrosoft-Windows-WinRM\n\nCreating WSMan Session. This event will give you the PID that initiated the connection\n\n31\n\nWSMan Session Creation\n\nMicrosoft-Windows-WinRM\n\nWSMan Session Created Successfully\n\n3\n\nNetwork Connection\n\nMicrosoft-Windows-Sysmon\n\nNetwork Direction: egress\n\nInfected Source Process Name\n\nDestination port : 5985 or 5986\n\n**_On the destination:_**\n\nEID\n\nAction\n\nProvider\n\n\n-----\n\nComment\n\n1\n\nWSMan Session Creation\n\nMicrosoft-Windows-Sysmon\n\nProcess Name : `wsmprovhost.exe`\n\nProcess CMD : `C:\\Windows\\system32\\wsmprovhost.exe -Embedding`\n\nProcess Parent Name : `svchost.exe`\n\nProcess Parent CMD : `C:\\Windows\\system32\\svchost.exe -k DcomLaunch`\n\n3\n\nWSMan Session Creation\n\nMicrosoft-Windows-Sysmon\n\nNetwork Direction: ingress\n\nProcess Name: System\n\nDestination port : 5985 or 5986\n\nUser : NT `AUTHORITY\\SYSTEM`\n\n17\n\nPipe Created\n\nMicrosoft-Windows-Sysmon\n\nNetwork Direction: egress\n\nInfected Source Process Name\n\nDestination port : 5985 or 5986\n\nPipe Name : `\\PSHost.[%NUMBERS%].`\n```\n      [%PID%].DefaultAppDomain.wsmprovhost\n\n```\nProcess Name : `wsmprovhost.exe`\n\n4656\n\n\n-----\n\nProcess Access\n\nMicrosoft-Windows-Security-Auditing\n\nObject Server : WS-Management Listener\n\nProcess Name : `C:\\Windows\\System32\\svchost.exe`\n\n400\n\nPowerShell Session Start\n\nPowerShell\n\nHost Name = `ServerRemoteHost` (Remote PowerSehll Session)\n\nEngine Version (Good for Downgrading PS attacks)\n\nHost Application : `C:\\Windows\\system32\\wsmprovhost.exe -Embedding`\n\n91\n\nWSMan Session Creation\n\nMicrosoft-Windows-WinRM\n\n31\n\nWSMan Session Creation\n\nMicrosoft-Windows-WinRM\n\nWSMan Session Created Successfully\n\n142\n\nWSMan Operation Failure\n\nMicrosoft-Windows-WinRM\n\nHelpful when WinRM is not enabled on the targeted host\n\nOther events are generated on the destination side but these in the previous table are the\nmost relevant to remote WinRM activity. You can use them according to your collection and\ncorrelation strategy. Obviously, `EID 1,` `EID 91` and EID 4656 have much higher event\n\n\n-----\n\ndecisiveness than the rest. I will be releasing a Mindmap that groups all this telemetry in one\nplace at the end of this blog post series.\n\nNow jumping to `jump winrm command and some first differences in process tree behavior`\nwere observed at execution time:\n```\n   jump winrm command generated the same telemetry as in previous observations\n\n```\nexcept that the beacon runs under the context of a PowerShell instance invoked by\n```\n   wsmprovhost.exe . This is not something we can normally observe by using winrs,\n   Invoke-Command or Enter-PSSession except if the command invoked\n   powershell.exe itself then PowerShell cmdlets would produce this behavior.\n\n```\nBy default the powershell.exe instance run via the command line :\n```\n   \"c:\\windows\\syswow64\\windowspowershell\\v1.0\\powershell.exe\" -Version\n   5.1 -s -NoLogo -NoProfile\n\n```\nCobalStrike provides a `shell` command to interact with the beacon and execute\ncommand. The `shell` command spawns a `cmd.exe instance from the invoked`\n```\n   powershell.exe process for every executed command\n\n```\n\n-----\n\nExecuting systeminfo command via jump winrm beacon.\n\nA general diagram of process tree observed during the execution of this CS module is\nillustrated bellow:\n\njump winrm process tree diagram\n\nCobaltStrike jump winrm64\n\nHere are the main differences from `jump winrm command :`\n\nLike `Enter-PSSession,` `jump winrm64 executes commands within the context of a`\n```\n   wsmprovhost.exe instance. The session is persistent no termination of the\n   wsmprovhost.exe process was observed.\n\n```\n\n-----\n\nExecuting ipconfig and hostname command via a jump winrm64 shell\n\nJump winrm64 process tree diagram\n\nEvidence of Execution\n\nIn the previous sections we have established some key observations regarding remote\ncommand execution via WinRM. However, during the demo, I used a stageless beacon. The\nscript first decodes the Base64 encoded payload then it uses the `.Net API to call`\nWindows API function in memory using assemblies. The script then allocates some memory\nand copies the payload in the allocated memory space. The payload was a 64-bits DLL and\ntechnique used was DLL Reflective Loading.\n\nThe payload strings contained by default:\n\n\"beacon.dll\"\n\n\"beacon.x86.dll\"\n\n\"beacon.x64.dll\"\n\nThis [yara rule can be effective in detecting default usage of CS stageless beacons.](https://github.com/airbnb/binaryalert/blob/master/rules/public/hacktool/windows/hacktool_windows_cobaltstrike_beacon.yara)\n\n\n-----\n\nThe following PowerShell events were observed on the target:\n```\n   EID 4104 Script Block Logging:\n\n```\nThis event can be considered noisy, so be careful during you detection\nengineering process and consider its verbosity.\n\nScript blocks exceeding the maximum length of an event log message are\nfragmented into multiple entries.\n\nUnlike `EID 4103, this event doesn't record the output of the script`\n```\n   EID 4103 Module Logging:\n\n```\nGenerates a large volume of events\n\nRecords the output of the executed commands\n\nKeep in mind that these event are not enabled by default.\n\nSigma Rules\n\n[PowerShell Events : Remote PowerShell Session by](https://github.com/SigmaHQ/sigma/blob/master/rules/windows/powershell/powershell_remote_powershell_session.yml) [@Cyb3rWard0g](https://twitter.com/Cyb3rWard0g)\n[Sysmon Process : Remote PowerShell Session by](https://github.com/OTRF/ThreatHunter-Playbook/blob/master/signatures/sigma/sysmon_remote_powershell_session_process.yml) [@Cyb3rWard0g](https://twitter.com/Cyb3rWard0g)\n[Windows Events : Remote PowerShell Session by](https://github.com/OTRF/ThreatHunter-Playbook/blob/master/signatures/sigma/win_remote_powershell_session.yml) [@Cyb3rWard0g](https://twitter.com/Cyb3rWard0g)\n[Sysmon Network : Remore PowerShell Session by](https://github.com/OTRF/ThreatHunter-Playbook/blob/master/signatures/sigma/sysmon_remote_powershell_session_network.yml) [@Cyb3rWard0g](https://twitter.com/Cyb3rWard0g)\n\nDetection Validation\n\n\n-----\n\nIn order to validate your detection rules against WinRM being used for remote command\nexecution, Atomic Red Team provides a great guide bellow:\n\natomic-red-team/T1021.006.md at master · redcanaryco/atomic-red-team\n\nGitHub\n\nDFIR\n\nIn DFIR engagements these events can be good source of information to get the right attack\nattributions:\n\n**EID 142 WSMan operation CreateShell failed (Helpful when WinRM is not enabled on**\nthe target host)\n\n**EID 169 User Authenticated Successfully (The user who was connected remotely)**\n\n**EID 81 Processing Client Request for Operation CreateShell (Start of remoting activity)**\n\n**EID 134 Sending Response for Operation DeleteShell (End of remoting activity)**\n\n**EID 403 Engine state is changed from Available to Stopped (This event records the**\ncompletion of a PowerShell activity)\n\nWinRM event logs lack simple attribution and traceability meaning you need multiple\ncorrelation layers in order to identify the user, source IP and the ID of the infected process.\n\nThe command `Get-WSManInstance -ComputerName localhost -ResourceURI Shell -`\n```\nEnumerate lists all currently active remote WinRM sessions and provides useful information\n\n```\n:\n\n**Owner : Username that opened the remote session**\n\n**ClientIP: Source IP from where the attacker attempted to move laterally.**\n\n**ProcessID: In this case it is wsmprovhost.exe where the executed commands will be**\ninvoked from.\n\n**ChildPocesses: Number of child processes it opened.**\n\n**MemoryUsed: Can be good indicator since** `winrm64 CS module used more than`\ntwice the memory used by `Enter-PSSession for the same command.`\n\n1\n\n\n-----\n\nPS C:\\\\Users\\\\Administrator> Get-WSManInstance -ComputerName localhost -ResourceURI\nShell -Enumerate\n\n2\n\n3\n\nrsp : <http://schemas.microsoft.com/wbem/wsman/1/windows/shell>\n\n4\n\nlang : en-US\n\n5\n\nShellId : 04E49AF8-1CA8-4ACC-9135-6A3269115F3E\n\n6\n\nName : WinRM1\n\n7\n\nResourceUri : <http://schemas.microsoft.com/powershell/Microsoft.PowerShell>\n\n8\n\nOwner : ATLAS\\\\Administrator\n\n9\n\nClientIP : 10.10.10.30\n\n10\n\nProcessId : 2844\n\n11\n\nIdleTimeOut : PT7200.000S\n\n12\n\nInputStreams : stdin pr\n\n13\n\n\n-----\n\nOutputStreams : stdout\n\n14\n\nMaxIdleTimeOut : PT2147483.647S\n\n15\n\nLocale : en-US\n\n16\n\nDataLocale : en-US\n\n17\n\nCompressionMode : XpressCompression\n\n18\n\nProfileLoaded : Yes\n\n19\n\nEncoding : UTF8\n\n20\n\nBufferMode : Block\n\n21\n\nState : Connected\n\n22\n\nShellRunTime : P0DT0H4M32S\n\n23\n\nShellInactivity : P0DT0H1M28S\n\n24\n\nMemoryUsed : 134MB\n\n25\n\nChildProcesses : 2\n\n\n-----\n\nCopied!\n\nA good idea would be to generate an event with the output of this command every time the\nprocess wsmprovhost.exe is created using scheduled tasks.\n\nT1570 : Lateral Transfer Tool\n\nCobaltStrike jump psexec & psexec64\n\nI love going through ZEEK logs first and look for network related telemtery specially for\nlateral movement techniques. When using CS psexec or psexec64 modules for lateral\nmovement I observed remote service creation.\n\nThese modules use named pipes (RPC/NP) method to interact with the service control\nmanager (SCM) RPC server. The server interface is identified by UUID `367ABB81-9844-`\n```\n35F1-AD32-98F038001003 and uses RPC endpoint \\\\PIPE\\\\svcctl .\n\n```\nThe following ZEEK event logs were recorded :\n\nZEEK DCE-RPC event was generated with DCE-RPC endpoint `SVCCTL and`\noperation `CreateServiceWoW64A`\n\nZeek DCE-RPC Telemtry for Service Creation\n\n\n-----\n\nOn the target `EID 5145 A network share object was checked to see whether client`\ncan be granted desired access will be generated with `Relative Target Name`\ndefined as `SVCCTL` and Share Name `\\*\\IPC$`\n\nA service is then created with a random name and Image Path calling the process via\nthe command `\\\\127.0.0.1\\ADMIN$\\[SERVICE_RANDOM_NAME].exe . This will`\ngenerate `EID 7045 New Service Was Installed and` `EID 4697 A Service Was`\n```\nInstalled in the System\n\n```\nThen `\\\\127.0.0.1\\ADMIN$\\[SERVICE_RANDOM_NAME].exe is executed and it`\ninvokes a `rundll32.exe instance with no arguments which is very suspicious.`\n\n\n-----\n\nInteracting with the beacon via `SHELL` command invokes a `CMD` instance\n\nExeecuting Net command via jump psexec installed beacon\n\nThe following table is a summary of the observed telemetry relevant to this lateral movement\ntechnique.\n\nEID\n\nAction\n\n\n-----\n\nProvider\n\nComment\n\n5145\n\nNetwork Share Access\n\nMicrosoft-Windows-Security-Auditing\n\nRelative Target Name : `svcctl`\n\nShare Name : `\\*\\IPC$`\n\n7045\n\nService Creation\n\nSystem\n\nService File Name: `\\\\127.0.0.1\\ADMIN$\\[SERVICE_RANDOM_NAME].exe`\n\n4697\n\nService Creation\n\nMicrosoft-Windows-Security-Auditing\n\nService File Name: `\\\\127.0.0.1\\ADMIN$\\[SERVICE_RANDOM_NAME].exe`\n\n1\n\nProcess Creation\n\nMicrosoft-Windows-Sysmon\n\nCommand Line : `\\\\127.0.0.1\\ADMIN$\\[SERVICE_RANDOM_NAME].exe`\n\nParent Command Line : `C:\\Windows\\System32\\services.exe`\n\n1\n\nProcess Creation\n\nMicrosoft-Windows-Sysmon\n\nCommand Line : `C:\\Windows\\System32\\rundll32.exe`\n\nArguments count : 0\n\n\n-----\n\nParent Image : `\\\\127.0.0.1\\ADMIN$\\[SERVICE_RANDOM_NAME].exe`\n\n13\n\nRegistry Value Set\n\nMicrosoft-Windows-Sysmon\n\nImage Path : `\\\\127.0.0.1\\ADMIN$\\[SERVICE_RANDOM_NAME].ex e`\n\nCobaltStrike jump psexec_psh\n\nCobaltStrike can laverage a PowerShell version of PsExec using the built-in module\npsexec_psh with everything being executed in memory via a one-liner.\n\nAs previously noticed an interaction with SCM RPC server in order to create a service\nremotely was observed. Bellow are the ZEEK DCE-RPC event logs with the same\noperation as `psexec & psexec64` `CreateServiceWOW64A`\n\nFollowed by creation of a new service which generated EID 7045/4697 with\n\n`%COMSPEC% and` `powershell` in the `Service File Name field.`\n\n\n-----\n\nPowerShell s EID 400 can be used as a detection opportunity where\n\n`HostApplication` contains `powershell -nop -w hidden -encodedcommand .`\n\nPipe creation with regex pattern `status_[0-9a-f]{2} was also observed. I provided`\nbellow a gist with several regex pattern to detect hard coded named pipes in\nCobaltStrike modules. Bellow is a EID 5145 that can be used for this purpose but I\nencourage you to sysmon instead for it high event traceability quality.\n\n\n-----\n\nCobalt Strike Named Pipe Regex.csv\n\nInteracting with the beacon via the CS `shell` command would invoke a `cmd.exe`\ninstance.\n\nExecuting commands via psexec_psh module\n\n\n-----\n\nThis pattern alone is very suspicious and can be a good detection opportunity for default\nusage of `psexec_psh command.`\n\nThe following are the event logs I observed during the demos:\n\nEID\n\nAction\n\nProvider\n\nComment\n\n5145\n\nNetwork Share Access\n\nMicrosoft-Windows-Security-Auditing\n\nRelative Target Name : `status_[0-9a-f]{2}`\n\nShare Name : `\\*\\IPC$`\n\n7045\n\nService Creation\n\nSystem\n\nService File Name contains : `%COMSPEC% or` `powershell`\n\n4697\n\nService Creation\n\nMicrosoft-Windows-Security-Auditing\n\nService File Name contains : `%COMSPEC% or` `powershell`\n\n\n-----\n\n17\n\nPipe Created\n\nMicrosoft-Windows-Sysmon\n\nCommand Line : `\\\\127.0.0.1\\ADMIN$\\[SERVICE_RANDOM_NAME].exe`\n\nParent Command Line : `C:\\Windows\\System32\\services.exe`\n\n18\n\nPipe Connected\n\nMicrosoft-Windows-Sysmon\n\nImage Path : `\\\\127.0.0.1\\ADMIN$\\[SERVICE_RANDOM_NAME].ex e`\n\n1\n\nProcess Creation\n\nMicrosoft-Windows-Sysmon\n\nCommand Line Arguments : `powershell, -nop, hidden, -encodedcommand`\n\nProcess Name : `powershell.exe`\n\nParent Process Name : `cmd.exe`\n\nSigma Rules\n\nDetection Validation\n\nAtomic Red Team provides a good start to validate your detection against some of these\nattack techniques:\n\natomic-red-team/T1569.002.md at master · redcanaryco/atomic-red-team\n\nGitHub\n\nDFIR\n\n\n-----\n\nYou can use the following CyberChef recipe to decode and extract shellcode\ninformation executed by psexec_psh command.\n\nCyberChef/Cobalt Strike recipe for JABz.txt at main · SophosRapidResponse/CyberChef\n\nGitHub\n\nYou can list created pipes using Get-ChilIt `em` PowerShell cmdlets\n\n1\n\nGet-ChildItem \\\\\\\\.\\\\pipe\\\\\n\nCopied!\n\nSystinternal has a dedicated tool that also can be leveraged for the same purpose.\n\nPipelist - Windows Sysinternals\n\ndocsmsft\n\nClosing thoughts\n\nThis blog post series of Detecting CONTI CobaltStrike Lateral Movement Techniques is\nfocused on default usage of CS built-in capabilities meaning that sophisticated attacker will\nbe able to change these settings and evade detections based on them thanks to CobalStrike\nmodularity. My hope is to increase awareness at least about the telemetry that needs to be\naudited and qualified, how to correlate it and how to respond to relevant attacks in order to\nincrease the time, effort and skills an APT has to invest in order to compromise your assets.\n\n[You can read my previous post on Detection Engineering Dimensions Analytics part where I](https://www.unh4ck.com/detection-engineering-dimensions/analytics)\ndiscuss analytic resilience.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-26 - Detecting CONTI CobaltStrike Lateral Movement Techniques - Part 1.pdf"
    ],
    "report_names": [
        "2021-10-26 - Detecting CONTI CobaltStrike Lateral Movement Techniques - Part 1.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536147,
    "ts_updated_at": 1743041151,
    "ts_creation_date": 1653757825,
    "ts_modification_date": 1653757825,
    "files": {
        "pdf": "https://archive.orkl.eu/92b3cf362b22306fda5f5e1f43cbf02587cc5a74.pdf",
        "text": "https://archive.orkl.eu/92b3cf362b22306fda5f5e1f43cbf02587cc5a74.txt",
        "img": "https://archive.orkl.eu/92b3cf362b22306fda5f5e1f43cbf02587cc5a74.jpg"
    }
}