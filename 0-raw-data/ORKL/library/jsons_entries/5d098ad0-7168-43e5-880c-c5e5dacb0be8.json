{
    "id": "5d098ad0-7168-43e5-880c-c5e5dacb0be8",
    "created_at": "2023-01-12T14:59:41.284829Z",
    "updated_at": "2025-03-27T02:15:38.117316Z",
    "deleted_at": null,
    "sha1_hash": "bda45e93123752071ea0d5eb41f0c4aba8e92630",
    "title": "2020-12-14 - Using Qiling Framework to Unpack TA505 packed samples",
    "authors": "",
    "file_creation_date": "2022-05-28T15:41:38Z",
    "file_modification_date": "2022-05-28T15:41:38Z",
    "file_size": 504153,
    "plain_text": "# Using Qiling Framework to Unpack TA505 packed samples\n\n**[blueliv.com/cyber-security-and-cyber-threat-intelligence-blog-blueliv/using-qiling-framework-to-unpack-ta505-packed-samples/](https://www.blueliv.com/cyber-security-and-cyber-threat-intelligence-blog-blueliv/using-qiling-framework-to-unpack-ta505-packed-samples/)**\n\nUsing Qiling Framework to Unpack TA505 packed samples\n\n14.Dec.2020\n\nAlberto Marín and Carlos Rubio, supported by the Blueliv Labs team, an Outpost24 company\n\n[Threat Intelligence](https://www.blueliv.com/blog?tags=335)\n\nIn this blogpost, we are going to show how to unpack TA505 packed samples using the Qiling Framework emulator version 1.2, which will\nallow us to do so, without needing to study and replicate all the implementation details of the unpacking algorithm.\n\n\n-----\n\nUnpack TA505\n\n\n**Introduction**\n\nThreat Actors make use of packers when distributing their malware as they remain an effective way to evade detection and to make them more\ndifficult to analyze. Manual analysis can defeat these protections and help to develop tools that allow the unpacking of the malware. To develop\nthese tools, it is necessary to know how the process of unpacking for those malware samples is done in order to replicate their functionality.\nThis can be a costly task, and the modification of the unpacking algorithm by the Threat Actor would entail to study the malware and modify the\ntools again.\n\n\n-----\n\nt ue, a Outpost co pa y, e t ac eat cto s e 505, o a so a e use o pac e s t e a a e d st but o ca pa g s\n[Regarding TA505, there are currently tools like TAFOF-Unpacker able to successfully unpack their samples replicating the unpacking algorithm](https://github.com/Tera0017/TAFOF-Unpacker)\nprocess.\n\n[In this blogpost, we are going to show how to unpack TA505 packed samples using the Qiling Framework emulator version 1.2, which will](https://www.qiling.io/)\nallow us to do so, without needing to study and replicate all the implementation details of the unpacking algorithm.\n\n## TA505 Packer\n\nOur goal is to dump the unpacked payload from TA505 packed samples using emulation. As we said before, this approach allows us to\ncircumvent the study of every implementation detail of the unpacking algorithm. However, we still need to manually analyze the packer to find a\nway of getting the unpacked content and dump it.\n\nIn the case of TA505 packer, we could differentiate 3 stages.\n\n### First stage\n\nThis stage consists of executing useless instructions and loops in order to obfuscate and/or slow down the analysis. It also makes use of some\nanti-emulation techniques to avoid being studied by this kind of software.\n\n**Use of useless loops to slow down emulation tasks:**\n\n_Figure 1. Anti-Emulation used in sample e4eb1a831a8cc7402c8e0a898effd3fb966a9ee1a22bce9ddc3e44e574fe8c5e_\n\n**Dummy functions in different samples:**\n\n_Figure 2. Dummy function used in sample e4eb1a831a8cc7402c8e0a898effd3fb966a9ee1a22bce9ddc3e44e574fe8c5e_\n\n\n-----\n\n_gu e 3_ _u_ _y u ct o_ _used_ _sa_ _p e bb505_ _0ec e6980 65 b93 9a0b5acec ed936053c3e 0938b5 a0 a9da_ _ee_\n\n_Figure 4. Dummy function used in sample 4b0eafcb1ec03ff3faccd2c0f465f5ac5824145d00e08035f57067a40cd179d2_\n\n**GetLastError() Anti-Emulation technique**\n\nWe can see that between different samples, the dummy and useless functions vary. However, the anti-emulation technique remains the same\n[in all of them, being present in the GetLastError() function. From the Official Windows API documentation:](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)\n\n“Retrieves the calling thread's last-error code value. The last-error code is maintained on a per-thread basis. Multiple threads do not\n_overwrite each other's last-error code.”_\n\nThis technique is used with different expected return values across different malware samples (using different API calls before the\nGetLastError() occurs), for example:\n\n**SetClipboardData:**\n\n_Figure 5. Anti-Emulation used in sample ad320839e01df160c5feb0e89131521719a65ab11c952f33e03d802ecee3f51f_\n\n**GetWindowContextHelpId:**\n\n_Figure 6. Anti-Emulation used in sample e4eb1a831a8cc7402c8e0a898effd3fb966a9ee1a22bce9ddc3e44e574fe8c5e_\n\n\n-----\n\n_Figure 7. Anti-Emulation used in sample 4b0eafcb1ec03ff3faccd2c0f465f5ac5824145d00e08035f57067a40cd179d2_\n\n_Figure 8. Anti-Emulation used in sample bb5054f0ec4e6980f65fb9329a0b5acec1ed936053c3ef0938b5fa02a9daf7ee_\n\nFor instance, last figure shows the malware calls GetLastError() and the only instruction executed before this one that could have set an error\n[value is the execution of the API call GetWindowsContextHelpId(). From the Official Windows API Documentation:](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowcontexthelpid)\n\n“Retrieves the Help context identifier, if any, associated with the specified window.”\n\nGiven that the window handle used in this function is invalid, the sample expects this last call to set error value to 0x578\n[(ERROR_INVALID_WINDOW_HANDLE), (which is what would happen in a non-emulated environment), and then continues execution. We](https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--1300-1699-)\nwill have to code this behavior so that the emulation can detonate the actual sample, because the emulator is not able to predict the value\ncorresponding to GetLastError() by itself, since it does not have the real running context of an operating system.\n\n### Second stage\n\nUnpacks an encrypted shellcode in a newly allocated memory in the heap and transfers execution to it. This shellcode contains the actual Stub\nof the packer. This stage may also contain junk and useless code to difficult the malware analysis.\n\n_Figure 9. Unpacking Packer Stub bb5054f0ec4e6980f65fb9329a0b5acec1ed936053c3ef0938b5fa02a9daf7ee_\n\n\n-----\n\n### d stage\n\nThis is the TA505 Packer Stub (piece of code containing the decryption routine), that will act as a loader for the final payload, which is written\nin heap memory and executed. It starts by storing some strings in the stack that will use to find the Windows APIs needed to unpack itself:\n**VirtualAlloc, VirtualProtect, LoadLibraryA, VirtualFree and VirtualQuery.**\n\n_Figure 10. TA505 packers store strings in the stack to resolve Windows API functions._\n\nIt relies on a self-modifying unpacking technique, trying to acquire a block of writeable, executable memory, unpacking (decrypting and writing)\ncode to the newly allocated memory and finally, transferring execution to the unpacked code in the newly allocated memory.\n\n_Fi_ _11 P_ _k_ _St b bb5054f0_ _4 6980f65fb9329 0b5_ _1 d936053 3 f0938b5f 02 9d f7_\n\n\n-----\n\nAs it is shown in the last screenshot. The Stub calls VirtualFree() after having written the decrypted payload in the newly allocated memory.\nOur strategy should consider saving the allocated blocks of memory and dump them once VirtualFree() is executed (at this point we have\nseen that the malware is just about to start running the unpacked payload and it's in the state which is going to be executed; it is safe to\n**dump now). Before VirtualFree() happens, we can see the unpacked layer in the last allocated block of memory that we’ve named allocated2.**\n\n_Figure 12. Unpacked payload bb5054f0ec4e6980f65fb9329a0b5acec1ed936053c3ef0938b5fa02a9daf7ee_\n\nWe should be able, with emulation, to guide the execution until this point and then dump right away the contents of the last allocated code to\nget the next unpacked layer. This is what we are going to try with Qiling Framework v1.2. Executing the sample using Qiling Framework\nwould allow it to be unpacked automatically, and we would only have to put hooks into specific Windows API functions to get the unpacked\nbinary.\n\n## Qiling Framework\n\n**[Qiling Framework is an advanced open source binary emulation Framework, with binary instrumentation and API emulation being its main](https://www.qiling.io/)**\nfocus and priority. It is designed as a cross-platform binary instrumentation and binary emulation framework and has support for multiarchitecture. Code interception and arbitrary code injection before or during a binary execution are one of its powerful features, as well as\nbeing able to patch a binary during execution.\n\nThe advantage of using the Qiling Framework for this purpose is that changes made to the unpacking algorithm will not prevent the samples\nfrom being unpacked. This is because we are obviously not implementing the decryption algorithm itself, but emulating it instead. However, we\nalso find some obstacles when using emulators, as packers can also make use of anti-emulation techniques. In this case we would need to\nunderstand how the packer detects the emulator in order to bypass the countermeasures.\n\nFor what we have seen during the analysis of the packer. We would need to:\n\n1. Bypass anti-emulation techniques to execute the Packer Stub\n2. Store dynamically allocated blocks of memory information (address and size)\n3. Dump the unpacked PE once it is ready. (For example, before VirtualFree() gets executed)\n\n### Bypass anti-emulation techniques\n\n**Bypass GetLastError() anti-emulation technique**\n\n\n-----\n\n505 pac e a es use o Get ast **o () ca to a o d u pac** g t s u g a e u ated e o e t o bypass t s easu e, e\nneed to find out which API call is meant to set the expected error code in the packer, this will usually happen just before the actual call to\n**GetLastError(). Once found, we should add a hook to this API call and force the return of the expected error code. This way, when**\n**GetLastError() gets emulated, it will receive the value we want, and continue the execution.**\n\nMost of the analyzed samples, make use of the call GetWindowContextHelpId() in an “obfuscated” way. They load the string\n“SetWindowContextHelpId” and replace the first letter with a “G” before making the call.\n\n_Figure 13. bb5054f0ec4e6980f65fb9329a0b5acec1ed936053c3ef0938b5fa02a9daf7ee calling GetWindowContextHelpId as part of its anti-_\n_emulation technique_\n\nOther samples may use different approaches, but all based on the GetLastError() technique. For example, the sample\ne4eb1a831a8cc7402c8e0a898effd3fb966a9ee1a22bce9ddc3e44e574fe8c5e makes use of the API call **[SetClassLongA(). From the Official](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setclasslonga)**\nWindows API Documentation:\n\n[“Replaces the specified 32-bit (long) value at the specified offset into the extra class memory or the WNDCLASSEX structure for the](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-wndclassexa)\n_class to which the specified window belongs.”_\n\nWhen being used like in these samples, the expected behavior (as it is using an invalid Window Handle) is to get an error 0x578\n[(ERROR_INVALID_WINDOW_HANDLE).](https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--1300-1699-)\n\n\n-----\n\n_Figure 14. e4eb1a831a8cc7402c8e0a898effd3fb966a9ee1a22bce9ddc3e44e574fe8c5e anti-emulation techniques before unpacking the_\n_Packer Stub_\n\nOnce identified those API calls, we can reimplement them with Qiling to make sure they set the proper error codes so that the next call to\n**GetLastError() jumps to the correct branch of the code. Qiling Framework allows us to reimplement these API calls easily:**\n\n**GetWindowContextHelpId() hook implementation:**\n\nDWORD GetWindowContextHelpId( HWND Arg1 );\n\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\") def hook_GetWindowContextHelpId(ql, address, params):\nERROR_INVALID_WINDOW_HANDLE = 0x578 ql.os.last_error = ERROR_INVALID_WINDOW_HANDLE return 0\n\nSetClassLongA() hook implementation:\n\nDWORD SetClassLongA( HWND hWnd, int nIndex, LONG dwNewLong );\n\n@winsdkapi(cc=STDCALL, dllname=\"user32_dll\") def hook_SetClassLongA(ql, address, params): ERROR_INVALID_WINDOW_HANDLE =\n0x578 ql.os.last_error = ERROR_INVALID_WINDOW_HANDLE return 0\n\nWe have to set API hooks before calling \"ql.run()\".\n\nql.set_api(\"GetWindowContextHelpId\", hook_GetWindowContextHelpId) ql.set_api(\"SetClassLongA\", hook_SetClassLongA)\n\n**Qiling Framework emulator is constantly evolving. However, there might be some API calls still not present in the code. In those cases, we**\nwill have to reimplement them, although we could also just give to the caller what he expects in order to bypass the different anti-emulation\ntechniques (not emulating the actual Windows call, but leaving what the sample needs, like the error code in this case, instead).\n\nThis is the case of some API calls that need to be “emulated” so that the malware can continue with its execution. For instance, the following\nFigure shows a packed sample where the interesting “GetLastError()” anti-emulation technique is inside an if statement. We need to make\n[sure that the sample takes the correct conditional path. To do so, we need to reimplement “ImageList_Add()” as by the time of writing this](https://docs.microsoft.com/en-us/windows/win32/api/commctrl/nf-commctrl-imagelist_add)\n\n\n-----\n\nogpost, t s s ot e u ated by de au t by Q g\n\n_Figure 15. bb5054f0ec4e6980f65fb9329a0b5acec1ed936053c3ef0938b5fa02a9daf7ee anti-emulation techniques before unpacking Packer_\n_Stub_\n\n**ImageList_Add() hook implementation:**\n\nint ImageList_Add( HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask );\n\n@winsdkapi(cc=STDCALL, dllname=\"comctl32_dll\") def hook_ImageList_Add(ql, address, params): ret = 0xFFFFFFFF return ret\n\nThe same happens in sample bb5054f0ec4e6980f65fb9329a0b5acec1ed936053c3ef0938b5fa02a9daf7ee with __wgetmainargs:\n\n**__wgetmainargs() hook implementation:**\n\nint __wgetmainargs ( int *_Argc, wchar_t ***_Argv, wchar_t ***_Env, int _DoWildCard, _startupinfo * _StartInfo )\n\n@winsdkapi(cc=STDCALL, dllname=\"msvcrt_dll\") def hook___wgetmainargs(ql, address, params): return 0\n\nThe sample 74c5ae5e64d0a850eb0ebe3cbca4c6b92918a8365f2f78306643be9cffc32def also makes use of some API calls that need to be\nreimplemented to get the malware to execute the unpacking Stub.\n\n**CoReleaseMarshalData() hook implementation:**\n\nHRESULT CoReleaseMarshalData( LPSTREAM pStm );\n\n@winsdkapi(cc=STDCALL, dllname=\"ole32_dll\") def hook_CoReleaseMarshalData(ql, addrss, params): E_INVALIDARG = 0x80070057 return\nE_INVALIDARG\n\n**NOTE: During the development of this tool, we found out that the hooks for CoReleaseMarshalData and ImageListAdd where not working.**\nApparently, these functions are properly declared in Qiling Framework version 1.2, but when we try to run our tool we got a \"Windows API\n**[implementation error\". This is because Qiling is missing some references in its const.py file. More precisely, it is missing the references for:](https://github.com/qilingframework/qiling/blob/1.2/qiling/os/const.py)**\n\n\"HBITMAP\": \"HANDLE\", \"HIMAGELIST\": \"HANDLE\", \"LPSTREAM\" : \"POINTER\"\n\nA [pull request to the Qiling project has already been accepted and commited to the development branch which solves this issue.](https://github.com/qilingframework/qiling/pull/594)\n\n**ShellExecuteA() hook implementation:**\n\nHINSTANCE ShellExecuteA( HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory INT\nnShowCmd );\n\n\n-----\n\n@ sd ap (cc S C, d a e s e 3 _d ) de oo _S e ecute (q, add ess, pa a s) etu 0\n\nCreateEventA() hook implementation:\n\nHANDLE CreateEventA( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName );\n\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\") def hook_CreateEventA(ql, address, params): return 0\n\n**VirtualQuery hook implementation:**\n\n**VirtualQuery also seems to give problems when running those samples. The easiest way to make these samples continue with their**\nexecution is reimplementing this API call too so that it gives the sample what it wants. In the case of TA505 Packer, the unpacking Stub just\nchecks if the return value of this call is a positive value. We can consider then:\n\nSIZE_T VirtualQuery( LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength );\n\n@ winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\") def hook_VirtualQuery(ql, address, params): return params['dwLength']\n\n**Bypass useless loops to slow down emulation tasks**\n\nSome TA505 Packed samples make use of another anti-emulation technique. They execute long useless loops that makes emulation take\nforever (as these loops execute fast in non-emulated environments). Long loops with calls to Windows Api calls can also be used as an antisandbox technique. This can be seen in the following figure:\n\n_Figure 16. Anti-Emulation technique used in e4eb1a831a8cc7402c8e0a898effd3fb966a9ee1a22bce9ddc3e44e574fe8c5e_\n\nTo bypass this with Qiling in an “automated” way, we could obviously manually patch the binary or use Qiling search pattern to add this\nfunctionality in our unpacking script.\n\ndef patch_binary(ql): patches = [] ''' Original 81 7D B4 40 42 0F 00 cmp [ebp+var_4C], 1000000 Patch: 81 7D B4 00 00 00 00 cmp\n\n[ebp+var_4C], 0 ''' patch_ = { 'original': b'\\x81\\x7D\\xB4\\x40\\x42\\x0F\\x00', 'patch': b'\\x81\\x7D\\xB4\\x00\\x00\\x00\\x00' } patches.append(patch_)\nfor patch in patches: antiemu_loop_addr = ql.mem.search(patch['original']) if antiemu_loop_addr: ql.nprint(D_INFO, 'Found Anti-Emulation loop\nat addr: {}'.format(hex(antiemu_loop_addr[0]))) try: ql.patch(antiemu_loop_addr[0], patch['patch']) ql.nprint(D_INFO, 'Successfully patched!')\nreturn except Exception as err: ql.nprint(D_INFO, 'Unable to patch binary: {}'.format(err))\n\n### Store dynamically allocated blocks of memory information (address and size)\n\nAs we said previously, the unpacked malware will be written into a new allocated block of memory. It will use VirtuAlloc() and VirtualAllocEx()\nto allocate space for the unpacking Stub and the payload. We will need to keep track of these allocations in order to be able to dump them\nwhen VirtualFree() gets called. We could reimplement VirtualAlloc() and VirtualAllocEx() for the unpacking in this way:\n\nLPVOID VirtualAllocEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect );\n\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\") def hook_VirtualAllocEx(ql, address, params): dw_size = params[\"dwSize\"] addr =\nql.os.heap.alloc(dw_size) fl_protect = params[\"flProtect\"] if fl_protect in [0x1, 0x2, 0x4, 0x8,0x10, 0x20, 0x40, 0x80]: ql.nprint(D_INFO,\n\"VirtualAllocEx start: {} - size: {}\".format(hex(addr), hex(dw_size))) mem_regions.append({\"start\": addr, \"size\": dw_size}) return addr\n\nLPVOID VirtualAlloc( LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect );\n\n@winsdkapi(cc=STDCALL, dllname=\"kernel32_dll\") def hook_VirtualAlloc(ql, address, params): dw_size = params[\"dwSize\"] addr =\nql.os.heap.alloc(dw_size) fl_protect = params[\"flProtect\"] if fl_protect in [0x1, 0x2, 0x4, 0x8,0x10, 0x20, 0x40, 0x80]: ql.nprint(D_INFO,\n\"VirtualAlloc start: {} - size: {}\".format(hex(addr), hex(dw_size))) mem_regions.append({\"start\": addr, \"size\": dw_size}) return addr\n\n\n-----\n\n### u p t e u pac ed o ce t s eady\n\nNow the last thing left to do is to dump the contents of the last allocated block once we reach the execution of VirtualFree():\n\ndef dump_memory_region(ql, address, size): ql.nprint(D_INFO, \"Read memory region at address: {} - size: {}\".format(hex(address), hex(size)))\ntry: excuted_mem = ql.mem.read(address, size) except Exception as err: log.warning('Unable to read memory region at address: {}. Error:\n{}'.format(hex(address), err)) return ql.nprint(D_INFO, \"Dump memory region at address: {} - size: {}\".format(hex(address), hex(size))) with\nopen(\"unpacked_\"+hex(address)+\".bin\", \"wb\") as f: f.write(excuted_mem) # write extracted code to a binary file\n\nBOOL VirtualFree( LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType );\n\n@winapi(cc=STDCALL, params={ \"lpAddress\": POINTER, \"dwSize\": SIZE_T, \"dwFreeType\": DWORD }) def hook_VirtualFree(ql, address,\nparams): global mem_regions lpAddress = params[\"lpAddress\"] ql.nprint(D_INFO, \"VirtualFree called for address: {}\".format(hex(lpAddress)))\nql.nprint(D_INFO, \"Memory regions stored: {}\".format(mem_regions)) try: if mem_regions: unpacked_layer = mem_regions[-1] # Unpacked\nlayer is in the last allocated block start = unpacked_layer[\"start\"] size = unpacked_layer[\"size\"] dump_memory_region(ql, start, size) except\nException as err: ql.nprint(D_INFO, 'Unable to dump memory region: {}'.format(err)) ql.os.heap.free(lpAddress) ql.emu_stop() return 1\n\n## Proof of Concept\n\n[You can find our proof of concept in our repository.](https://github.com/Blueliv/unpack-ta505packer-qiling)\n\n## IOC\n\n**SHA256 Packed samples:**\n\n**SHA256 Unpacked samples:**\n\n**Malware: AZORULT**\n\n**e4eb1a831a8cc7402c8e0a898effd3fb966a9ee1a22bce9ddc3e44e574fe8c5e**\n\n**103084a964d0b150e1268c8a1a9d8c2545f7f0721e78a1b98b74304320aeb547**\n\n**Malware: GELUP**\n\n**bb5054f0ec4e6980f65fb9329a0b5acec1ed936053c3ef0938b5fa02a9daf7ee**\n\n**6d15cd4cadac81ee44013d1ad32c18a27ccd38671dee051fb58b5786bc0fa7d3**\n\n**Malware: SILENCE**\n\n**4b0eafcb1ec03ff3faccd2c0f465f5ac5824145d00e08035f57067a40cd179d2**\n\n**b9a0bde76d0bc7cc497c9cd17670d86813c97a9f8bed09ea99d4bf531adafb27**\n\n**Malware: AMY RAT**\n\n**ad320839e01df160c5feb0e89131521719a65ab11c952f33e03d802ecee3f51f**\n\n**8a30f4c59d111658b7f9efbd5f5b794228394cd53d22a1fb389fd3a03fc4d1f7**\n\n**Malware: TINYMET**\n\n**74c5ae5e64d0a850eb0ebe3cbca4c6b92918a8365f2f78306643be9cffc32def**\n\n**6831fc67ca09d9027fef8b3031a11e9595fc1df1cb547c6f587947d13dad151a**\n\n## Conclusion\n\n\n-----\n\ns as bee see t oug out t e a t c e, co po at g Q **g** **a** **e o** as o e o you e e se e g ee g too s ac tates t e tas s o\nmalware analysis. In this case, it allows us to easily and quickly unpack samples packed with TA505Packer without needing to have extensive\nknowledge about its implementation details. Moreover it is cross-platform.\n\nFrom Blueliv we encourage other researchers to make use of Qiling Framework and we hope this project continues growing.\n\n[For more details about how we reverse engineer and analyze malware, visit our targeted malware module page.](https://www.blueliv.com/products/cyber-threat-intelligence/malware-protection)\n\n## References\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-14 - Using Qiling Framework to Unpack TA505 packed samples.pdf"
    ],
    "report_names": [
        "2020-12-14 - Using Qiling Framework to Unpack TA505 packed samples.pdf"
    ],
    "threat_actors": [
        {
            "id": "42a6a29d-6b98-4fd6-a742-a45a0306c7b0",
            "created_at": "2022-10-25T15:50:23.710403Z",
            "updated_at": "2025-03-27T02:00:55.531313Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "Whisper Spider"
            ],
            "source_name": "MITRE:Silence",
            "tools": [
                "Winexe",
                "SDelete"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "88e53203-891a-46f8-9ced-81d874a271c4",
            "created_at": "2022-10-25T16:07:24.191982Z",
            "updated_at": "2025-03-27T02:02:10.13692Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "ATK 86",
                "Contract Crew",
                "TAG-CR8",
                "TEMP.TruthTeller",
                "Whisper Spider"
            ],
            "source_name": "ETDA:Silence",
            "tools": [
                "EDA",
                "EmpireDNSAgent",
                "Farse",
                "Ivoke",
                "Kikothac",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Meterpreter",
                "ProxyBot",
                "ReconModule",
                "Silence.Downloader",
                "TiniMet",
                "TinyMet",
                "TrueBot",
                "xfs-disp.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "99cb4e5b-8071-4f9e-aa1d-45bfbb6197e3",
            "created_at": "2023-01-06T13:46:38.860754Z",
            "updated_at": "2025-03-27T02:00:02.937438Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "SectorJ04 Group",
                "Dudear",
                "G0092",
                "ATK103",
                "Hive0065",
                "Spandex Tempest",
                "GRACEFUL SPIDER",
                "GOLD TAHOE",
                "CHIMBORAZO",
                "SectorJ04"
            ],
            "source_name": "MISPGALAXY:TA505",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5e6b31a6-80e3-4e7d-8b0a-d94897ce9b59",
            "created_at": "2024-06-19T02:03:08.128175Z",
            "updated_at": "2025-03-27T02:05:17.400394Z",
            "deleted_at": null,
            "main_name": "GOLD TAHOE",
            "aliases": [
                "SectorJ04 ",
                "Spandex Tempest ",
                "TA505 ",
                "FIN11 "
            ],
            "source_name": "Secureworks:GOLD TAHOE",
            "tools": [
                " Cobalt Strike",
                " FlawedAmmy",
                " Get2",
                " GraceWire",
                " Malichus",
                " SDBbot",
                " ServHelper",
                " TrueBot",
                "Clop"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "75d4d6a9-b5d1-4087-a7a0-e4a9587c45f4",
            "created_at": "2022-10-25T15:50:23.5188Z",
            "updated_at": "2025-03-27T02:00:55.489882Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "TA505",
                "Hive0065",
                "Spandex Tempest",
                "CHIMBORAZO"
            ],
            "source_name": "MITRE:TA505",
            "tools": [
                "AdFind",
                "Azorult",
                "FlawedAmmyy",
                "Mimikatz",
                "Dridex",
                "TrickBot",
                "Get2",
                "FlawedGrace",
                "Cobalt Strike",
                "ServHelper",
                "Amadey",
                "SDBbot",
                "PowerSploit"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "e447d393-c259-46e2-9932-19be2ba67149",
            "created_at": "2022-10-25T16:07:24.28282Z",
            "updated_at": "2025-03-27T02:02:10.159466Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "ATK 103",
                "Chimborazo",
                "Gold Evergreen",
                "Gold Tahoe",
                "Graceful Spider",
                "Hive0065",
                "Operation Tovar",
                "Operation Trident Breach",
                "SectorJ04",
                "Spandex Tempest",
                "TA505",
                "TEMP.Warlock"
            ],
            "source_name": "ETDA:TA505",
            "tools": [
                "Amadey",
                "AmmyyRAT",
                "AndroMut",
                "Azer",
                "Bart",
                "Bugat v5",
                "CryptFile2",
                "CryptoLocker",
                "CryptoMix",
                "CryptoShield",
                "Dridex",
                "Dudear",
                "EmailStealer",
                "FRIENDSPEAK",
                "Fake Globe",
                "Fareit",
                "FlawedAmmyy",
                "FlawedGrace",
                "FlowerPippi",
                "GOZ",
                "GameOver Zeus",
                "GazGolder",
                "Gelup",
                "Get2",
                "GetandGo",
                "GlobeImposter",
                "Gorhax",
                "GraceWire",
                "Gussdoor",
                "Jaff",
                "Kasidet",
                "Kegotip",
                "Kneber",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Locky",
                "MINEBRIDGE",
                "MINEBRIDGE RAT",
                "MirrorBlast",
                "Neutrino Bot",
                "Neutrino Exploit Kit",
                "P2P Zeus",
                "Peer-to-Peer Zeus",
                "Philadelphia",
                "Philadephia Ransom",
                "Pony Loader",
                "Rakhni",
                "ReflectiveGnome",
                "Remote Manipulator System",
                "RockLoader",
                "RuRAT",
                "SDBbot",
                "ServHelper",
                "Shifu",
                "Siplog",
                "TeslaGun",
                "TiniMet",
                "TinyMet",
                "Trojan.Zbot",
                "Wsnpoem",
                "Zbot",
                "Zeta",
                "ZeuS",
                "Zeus"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535581,
    "ts_updated_at": 1743041738,
    "ts_creation_date": 1653752498,
    "ts_modification_date": 1653752498,
    "files": {
        "pdf": "https://archive.orkl.eu/bda45e93123752071ea0d5eb41f0c4aba8e92630.pdf",
        "text": "https://archive.orkl.eu/bda45e93123752071ea0d5eb41f0c4aba8e92630.txt",
        "img": "https://archive.orkl.eu/bda45e93123752071ea0d5eb41f0c4aba8e92630.jpg"
    }
}