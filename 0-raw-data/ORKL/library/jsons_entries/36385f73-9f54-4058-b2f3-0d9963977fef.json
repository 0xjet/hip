{
    "id": "36385f73-9f54-4058-b2f3-0d9963977fef",
    "created_at": "2023-01-12T15:06:50.785113Z",
    "updated_at": "2025-03-27T02:16:26.495861Z",
    "deleted_at": null,
    "sha1_hash": "0338152d80e1701890cccc2e41bfd0c2f3c652bf",
    "title": "2022-01-17 - Android-BianLian payload",
    "authors": "",
    "file_creation_date": "2022-08-18T04:00:55Z",
    "file_modification_date": "2022-08-18T04:00:55Z",
    "file_size": 2725144,
    "plain_text": "# Android/BianLian payload\n\n**[cryptax.medium.com/android-bianlian-payload-61febabed00a](https://cryptax.medium.com/android-bianlian-payload-61febabed00a)**\n\n@cryptax January 17, 2022\n\n[@cryptax](https://cryptax.medium.com/?source=post_page-----61febabed00a--------------------------------)\n\nJan 17\n\n\n9 min read\n\nIn the previous article, we discussed the packing mechanism of a Bian Lian sample, and how\nto unpack. This article reverse engineers the payload of the malware. It explains:\n\nThe malicious components the bot implements. Those components can be seen as,\nand they are launched at the beginning. Each of them do their job, handle accessibility\nevents which concern and notifies or responds to the C&C. The implementation is\nclearly organized to easily welcome future modules.\nThe . The bot understands and responds to several commands. The commands are\nimplemented in the relevant component. The communication protocol is fairly simple:\nover HTTP (not HTTPS), with a plaintext JSON object as data (no encryption).\nThe of each major component.\n\n## Three DEXes\n\nTo be precise, note the Bian Lian we discuss uses three different DEX:\n\n1. The main APK‚Äôs DEX ‚Äî which is responsible for decrypting and loading via multidex\n\nthe second DEX. For reminder, the APK‚Äôs sha256 is\n```\n   5b9049c392eaf83b12b98419f14ece1b00042592b003a17e4e6f0fb466281368\n\n```\n2. The second DEX ‚Äî which implements the malicious payload of the bot. This is what\n\nwe discuss in this article. Its sha256 is\n```\n   d0d704ace35b0190174c11efa3fef292e026391677ff9dc10d2783b4cfe7f961\n\n```\n3. A third DEX. It is downloaded by the second DEX from the remote C&C, but is not\n\ninteresting for the analysis of the malware because it only contains non-malicious utility\nfunctions. Its package name is `com.fbdev.payload .`\n\n## Reverse engineer is loooong\n\n\n-----\n\nThis reverse engineering took me several days. Actually, between unpacking, reverse\nengineering and writing the blog, it approximately took me 2 weeks! I am not particularly\nproud about it, but I often get the question ‚Äúwhow, how long did it take you?‚Äù and although I‚Äôd\nlove to appear extremely skilled, the reality is that reverse engineering is a long process. It\ncan be compared to puzzles or a plate of spaghetti: at first, you don‚Äôt know where to start,\nyou follow a path and often get lost in the middle and soon don‚Äôt exactly know what you were\nsearching for üòÑ\n\nConsequently, I am sharing my JEB project (which contains all the functions I renamed, my\ncomments etc): [you can download it here.](https://my.owndrive.com/s/zz48eoiePNoKKYW)\n\nAlso, the article ends with a few remaining questions on the reverse engineering of the\nsample. You are welcome to interact if you have an idea.\n\nNow, let‚Äôs start!\n\n## Overview of malicious components\n\nThis malware is a bot, which reports and receives commands from a remote server (C&C). It\nimplements several malicious components:\n\nBulk SMS. The attacker specifies the body of a SMS to send, and it is sent to all\ncontacts of the victim‚Äôs smartphone.\nInject. The attacker provides an image to download from the web and inject (overlay)\non a given list of apps.\nInstall Apps. The attacker specifies a list of applications to install on the phone.\nLocker. This disables the ringer, and displays a text taken randomly from a pool of\npossible messages.\nNotification Disabler. Disables notifications of given applications.\nPIN code. Steals the lock PIN code for some phone brands. The sample we analyze\nsupports Samsung and Huawei.\nSMS. This is to send specific SMS messages. The attacker specifies the body and\nphone number to send to.\nScreencast. Takes screenshots of given applications.\nSound switch. Turn ringer on or off.\nTeam viewer. The is a well known non-malicious app to access your smartphone from\nany other computer. Here, the attacker uses it to access the victim‚Äôs smartphone\nremotely.\nUSSD. The attacker specifies the premium phone number to call. For the victim, this\nmay result in extra cost, depending on his/her subscription.\n\n## Communication with the C&C\n\n\n-----\n\nThe URL to the remote C&C is found encrypted in the shared preferences file\n```\npref_name_setting.xml . The algorithm uses slightly modified XOR algorithm with a hard\n```\ncoded key derived from the string `sorry!need8money[for`food .`\n\nDecrypting the preferences entry ‚Äúadmin_panel_url_‚Äù\n\nThe XOR key is composed of characters !8[`. For example\n‚ÄúIL/p:/trI]:cNT7iDJhQ53iNV]9sHL&gt;‚Äù decrypts to e\nThe remote attacker and the bot exchange a JSON string, where JSON keys specify actions\n(or responses) to conduct.\n\n\n-----\n\nList of commands understood by the BianLian bot. The commands are keys within a JSON\nobject, and values specify command arguments. The JSON object is sent or received from\n\n\n-----\n\nthe C&C.\n\nList of Bian Lian bot responses to commands.\n\n## Malicious injections\n\nThe bot implements an injection module which overlays attacker chosen images on top of\ntarget applications.\n\nFirst, the bot reports its activity to the C&C. The attacker answers back to the bot with a list\nof applications it is interested to inject into (see ‚ÄústockInjects‚Äù key):\n\n\n-----\n\nIn this case, the C&C was interested in many mobile turkish bank apps.\nThe bot searches which of these apps are installed on the victim‚Äôs phone and reports the\ninformation back to the C&C (see ‚Äúapp_list‚Äù key).\n\nFor example, in this case, the bot notifies the C&C 3 interesting mobile apps are installed.\nWhen an app among this list is launched, the bot requests the C&C an HTML page to\noverlay.\n\n\n-----\n\nIn this network capture, the bot requests an HTML page to display above the bank‚Äôs\napplication.\nFrom victim‚Äôs point of view, everything happens fast and it is not easy to detect something\nfishy is happening: the victim opens his/her mobile banking app. S/he will perhaps notice a\nquick screen flickering: this occurs when the bot has downloaded the attacker‚Äôs HTML and\noverlays it on top of the real app. See below an example of overlay.\n\n\n-----\n\nBeware the malicious overlay! This screenshot was taken on an infected Android emulator. If\nwe are cautious, we can spot the trick here because the overlay is not perfect: the real app is\nrunning behind (we see the real logo at the top) and the malicious page is overlaid in front.\nThis is actually not an image but an entire HTML page, with hard-coded embedded logo\nimages, layout and JavaScript. The card number, expiration date & CVV are sent back to the\nC&C.\n\n## Team Viewer component\n\n\n-----\n\nThe bot support teamViewerOptions command which triggers the Team Viewer app to\nremotely access and control the victim‚Äôs smartphone. The C&C sends a username and\npassword, and the bot (1) launches the Team Viewer app (if necessary), (2) accepts the\nEULA displayed by KLMS Agent on Samsung devices (security framework), (3) enters\nusername and password in Team Viewer and (4) finally connects to the remote end.\n\nThis functionality heavily relies on using (abusing) the Accessibility Service.\n\nDecompiled code of the malware‚Äôs team viewer component. The Accessibility Service is\nused to see which node/view is currently displayed, locate the relevant button and\nautomatically click on it. Team Viewer is automatically configured by automatically entering\nusername/password inside the right text views of the application.\n\n\n-----\n\nTo abuse Accessibility Services, the malware requests initial permissions. Yes, in theory, an\nend-user should not click ‚ÄúOK‚Äù to such a request, but let‚Äôs be honest, there are many popups on a smartphone & it‚Äôs not always clear to the end-user what they are authorizing. That‚Äôs\nhow we end up with an infected smartphone‚Ä¶\n\n## Disabling notifications\n\nThe C&C sends a command ‚ÄúdisabledPackages‚Äù with a list of package names to disable\nnotifications for. The bot processes those packages one by one, launches the notification\nsettings panel and uses the Accessibility Service API to ensure the notification switch for the\napp is turned off.\n\n\n-----\n\nThis is the part of the bot‚Äôs code that disables notification for an app. The bot opens the\nnotification settings for a given app. At this point, the method above gets called. It checks\nwhether the notification switch is already checked or not. If checked, it unchecks it. If not\nchecked, it leaves it unchecked and continues to the next app.\n\n## Screencast component\n\nThe C&C may also send a ‚ÄúshowScreen‚Äù which is implemented by the Screencast\ncomponent of the bot.\n\nFirst of all, if the device is locked, the bot broadcasts a swipe action to unlock.\n```\nIntent intent = new Intent(InjAccessibilityService.broadcast_swipe_unlock); //\n\"broadcast_swipe_to_unlock_action\"intent.putExtra(\"task\",\n669);Context.this.sendBroadcast(intent);\n\n```\nThen, it starts an activity that initiates screen capture.\n```\nif(!this.active && this.mediaprojectmgr != null) { \nactivity.startActivityForResult(this.mediaprojectmgr.createScreenCaptureIntent(),\n0x1E240); }\n\n```\nThis should normally prompt the end user if s/he accepts screen capture: the bot handles\nthis and automatically accepts it on user‚Äôs behalf.\n\n\n-----\n\nWhen a screen capture is requested, the system normally displays a system UI pop-up\nasking for confirmation. The code above checks this is the confirmation pop-up, that it\nrequests screen capture for the Video Player (the sample poses as a Video Player app) and\nautomatically confirms & remembers the choice.\nWhen a screenshot is ready, it is sent to the C&C in base64 format.\n\nEncode bitmap in Base64 and send it to C&C. If upload fails, stop screen cast service.\nUnless an error occurs, a new screenshot will be taken in a second. This can get pretty\nintensive and slow down the phone, which probably explains why the bot displays a fake\nnotification saying the phone is currently updating Google Play!\n```\nthis.startForeground(0x74A, new\nNotification.Builder(this.getApplicationContext()).setContentTitle(\"Google\").setConten\n Google Play Service\").setSmallIcon(0x7F050001).setProgress(0, 100, true).build());\n\n## Locker component\n\n```\nWhen the bot receives the ‚Äúlocked‚Äù command with a flag set to True, it sets the ringer to\nsilent mode and displays an activity meant to have the victim believe a recovery is under\nprogress. The displayed messages are initially the following:\n```\nAndroid system corrupted files recovery <3e>Kernel version 2.1.0.3DO NOT TURN THE\nSYSTEM OFF\n\n```\n\n-----\n\nThe mechanism to lock the device is simple: the message is displayed full screen, without\nnavigation buttons, and the bot prevents any window focus change. This results in the user\nbeing locked on the given screen.\n```\nprivate void fullScreen() { \nthis.getWindow().getDecorView().setSystemUiVisibility(0xF06); //\nSYSTEM_UI_FLAG_FULLSCREEN=4 | SYSTEM_UI_FLAG_HIDE_NAVIGATION=2}public void\nonWindowFocusChanged(boolean arg5) {    super.onWindowFocusChanged(arg5); \nif(arg5) {  this.fullScreen(); }}\n\n```\nWhen the C&C sends a ‚Äúlocked‚Äù command with flag to False, the bot simply kills the locking\nactivity and the victim may resume its usage of the phone.\n\n## PIN code component\n\nWhen the bot receives a ‚Äúaction_request_pin‚Äù command, it tries to steal the victim‚Äôs PIN.\nDepending on the device, it asks the victim to set a new password and steals it by monitoring\nthe Accessibility API, or it steals the current PIN by overlaying a fake PIN code request\nwindow.\n\nIf the C&C provides a ‚ÄúapprovedPin‚Äù command, the bot will additionally try to modify the\ncurrent PIN with the new value selected by the C&C.\n\nTask of the PIN code component\n\n## Install component\n\n\n-----\n\nThe C&C may send a list of apps to install via command apks . The applications are\ndownloaded from a URL specified in the command. The installation is performed by abusing\nthe Accessibility API. The code is quite lengthy because there are many cases: check the\nevent occurs in the system installer, if the app installer occurs in an alert dialog then\nautomatically click to install. If the system is requesting permission to install from an external\nsource, authorize it etc.\n\nAutomatically authorizing install of APKs from external sources\nThe same component also deals with removal of applications. The command names are\nmisleading ‚Äúremove_all‚Äù uninstalls only Team Viewer, and ‚Äúremove_by_id‚Äù removes a\nspecified app. If the package name is ‚Äúbot‚Äù, then the bot removes itself. A self ‚Äúcleaning‚Äù\ncommand!\n\nProcessing C&C commands to delete applications\n\n## Sound component\n\nThe C&C may turn on or off the ringer via command ‚ÄúsoundEnabled‚Äù followed by a boolean.\nTurning the ringer on / off is performed simply by a call to `setRingerMode .`\n\n## USSD component\n\n\n-----\n\nThe bot may be instructed to call USSD (quick codes). For instance, we see it requests\n*101# which returns the current subscription rate.\n\nCode calling a given phone number (USSD)\n\n## SMS component\n\nThe bot has the capability to spy on incoming SMS and report the messages to the C&C.\nThis feature is quite common in malware, and performed by reading the incoming PDU ‚Äî as\nusual.\n\nThe bot can also be instructed to send SMS specified by the ‚Äúsms‚Äù command. The SMS is\nsent using the common `sendTextMessage API.`\n```\nthis.sendSms(command.get(\"id\").toString(), command.get(\"phone_number\").getString(),\ncommand.get(\"message\").getString()); // calls sendTextMessage\n\n## Unsure / Do you know why? Contact me!\n\n```\nWhen `prem_flag is set, the bot sends a SMS to notify a new victim has ‚Äúregistered‚Äù to the`\nbotnet. The SMS is sent to phone number ‚Äú0001‚Äù, which is strange because it should not\ncorrespond to anything. Unless there is a trick with SMS filtering.\n\nCode in com.pmmynubv.nommztx.bot.components.h.k\nThe sound component implements a lengthy `onAccessibilityEvent() method which`\nhandles events on settings, policy and sound. I have not understood why this is necessary\nwhen `setRingerMode does the job.`\n\n\n-----\n\nCode in com.pmmynubv.nommztx.bot.components.g.a\nFinally, in the SMS component ( com.pmmynubv.nommztx.bot.components.h.a ), it is not\nclear why the bot also implements sending SMS by abusing the SMS application and\nautomatically clicking through the nodes ‚Äî when `sendTextMessage does the job in far less`\nlines of code üòè\n\n‚Äî the Crypto Girl\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-17 - Android-BianLian payload.pdf"
    ],
    "report_names": [
        "2022-01-17 - Android-BianLian payload.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536010,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1660795255,
    "ts_modification_date": 1660795255,
    "files": {
        "pdf": "https://archive.orkl.eu/0338152d80e1701890cccc2e41bfd0c2f3c652bf.pdf",
        "text": "https://archive.orkl.eu/0338152d80e1701890cccc2e41bfd0c2f3c652bf.txt",
        "img": "https://archive.orkl.eu/0338152d80e1701890cccc2e41bfd0c2f3c652bf.jpg"
    }
}