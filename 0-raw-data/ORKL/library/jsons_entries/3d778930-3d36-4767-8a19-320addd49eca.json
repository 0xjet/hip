{
    "id": "3d778930-3d36-4767-8a19-320addd49eca",
    "created_at": "2023-01-12T15:10:24.826432Z",
    "updated_at": "2025-03-27T02:06:02.332873Z",
    "deleted_at": null,
    "sha1_hash": "ae190cc9558f37b811bec09dae7bf0aa34b89868",
    "title": "2019-09-28 - MMD-0064-2019 - Linux-AirDropBot",
    "authors": "",
    "file_creation_date": "2022-05-29T01:00:56Z",
    "file_modification_date": "2022-05-29T01:00:56Z",
    "file_size": 3317192,
    "plain_text": "# MMD-0064-2019 - Linux/AirDropBot\n\n**[blog.malwaremustdie.org/2019/09/mmd-0064-2019-linuxairdropbot.html](https://blog.malwaremustdie.org/2019/09/mmd-0064-2019-linuxairdropbot.html)**\n\n## Prologue\n\nThere are a lot of botnet aiming multiple architecture of Linux basis internet of thing, and this\nstory is just one of them, but I haven't seen the one was coded like this before.\n\nLike the most of other posts of our analysis reports in MalwareMustDie blog, this post has\nbeen started from a friend's request to take a look at a certain Linux executable malicious\nbinary that was having a low (or no) detection, and at that time the binary hasn't been\ncategorized into a correct threat ID.\n\nThis time I decided to write the report along with my style on how to reverse engineering this\nsample, which is compiled in the MIPS processor architecture.\n\nSo I was sent with this MIPS 32bit binary ..\n```\ncloudbot-mips: ELF 32-bit MSB executable, MIPS, MIPS-I \nversion 1 (SYSV), statically linked, stripped\n\n```\n..and according to its detection report in the Virus Total hash it is supposed to be a \"Mirailike\" or Mirai variant malware, (thank's to good people for uploading the sample to\nVirusTotal). But the fact after my analysis is saying differently, these are not Mirai,\n**_Remaiten, GafGyt (Qbot/Torlus base), Hajime, Luabots, nor China series DDoS_**\n**_binaries or Kaiten (or STD like). It is a newly coded Linux malware picking up several idea_**\nand codes from other known malware, including Mirai.\n\nThis sample is just one of a series of badness, my honeypots, OSINT and a given\ninformation was leading me into 26 types of samples that are meant to pwned series of\n**internet of thing (IoT) devices running on Linux OS, and this MIPS-32 ELF binary one I**\nreceived is just one of the flocks.\n\n\n-----\n\nIf you see the filenames you can guess some of those binaries are meant to aim specific\nIoT/router platforms and not only for several randomly cross-compiled architecture supported\nresult. This type of binaries seem to be started appearing in the early August, 2019, in the\ninternet.\n\nBelow is the additional list of the compiled binaries meant to run on several non-Intel CPU\nrunning Linux operating systems, they can affect network devices like routers, bridges,\nswitches, and other the small internet of things that we may already use on daily basis:\n```\nm68k-68xxx.cloudbot:  32-bit MSB Motorola m68k, 68020, version 1 (SYSV), statically\nlinked\nhnios2.cloudbot:    32-bit LSB Altera Nios II, version 1 (SYSV), dynamically\nlinked\nhriscv64.cloudbot:   64-bit LSB UCB RISC-V, version 1 (SYSV), dynamically linked\nmicroblazebe.cloudbot: 32-bit MSB Xilinx MicroBlaze 32-bit RISC, version 1 (SYSV),\nstatically linked\nmicroblazeel.cloudbot: 32-bit LSB version 1 (SYSV), statically linked,\nsh-sh4.cloudbot:    32-bit LSB Renesas SH, version 1 (SYSV), statically linked.\nxtensa.cloudbot:    32-bit LSB Tensilica Xtensa, version 1 (SYSV), dynamically\nlinked.\narcle-750d.cloudbot:  32-bit LSB ARC Cores Tangent-A5, version 1 (SYSV), statically\nlinked.\narc.cloudbot:     32-bit LSB ARC Cores Tangent-A5, version 1 (SYSV), dynamically\nlinked.\n\n```\n(The hashes are all recorded in the \"Hashes\" section of this post)\n\n## Binary Analysis\n\nSince I was asked to look into the MIPS sample so I started with it. The binary analysis is\nshowing a symbol striping result, but we can still get some executable section's information,\ncompiler setting/trace that's showing how it should be run, and some information regarding of\n\n\n-----\n\nthe size for the section/program headers, but it s all just too few isn t it? Still this analysis is\ngood for getting information we need for supporting dynamic analysis (if needed) afterward. I\npersonally love to solve malware stuff as statically as possible.\n\nI don't think I will get much information on the early stage (binary analysis) with this ELF\nbinary, except what had already known, such as cross-compiling result, not packed, and\nheaders and entry0 are in place, so I'm good for conducting the next analysis step.\n\nFor file attributes I extracted them using forensics tools included in Tsurugi Linux commands,\nwhich are also not showing special result too, except of what has been recorded from the\ninfected box. So I was taking several checks further I run some several ELF pattern\nsignatures I know, with running it against my collection of Yara rules and ClamAV signature\nto match it to previous threat database that I have, and this is only to make me understand\nwhy several false-positive results came up in other Anti Virus product's detection. The\nmalware yet is having several interesting strings but they are still too generic to be processed\nto identify the threat without reading its assembly further.\n\nSo my \"practical binary analysis\" result for this MIPS binary is going to be it, nothing much.\n\n## Some methods on MIPS-32 static analysis to dissect this sample with radare2:)\n\n\n-----\n\nSo this is the fun part, the binary analysis with radare2 ;). no cutter GUI, no fancy huds, just\nan old-schooler way with command line, visual mode and graph in a r2shell.\n\nI think there is really no such precise step by step \"cookbook\" on how to to use radare2\nduring analyzing something, and basically radare2 is enriched in design coded by several\ncoders for any kind of users to use it freely with many flavor and options or purpose in binary\nanalysis, once you get into it you'll just get use to use it since radare2 will eventually adapting\nto your methods, and before you know it you are using it forever.\n\nMy line of work from day one is UNIX operating systems, I use radare2 since the name is\n\"radare\" compiled from FreeBSD ports in between years of 2006 to 2007, and I mostly use\ncommand line basis on every radare shell on my VT100x/VT200x terminal emulation variants\nI use afterwards, this is kind of building my reversing forms with radare2 until now. The\ncommand line base.\n\nBut first, let's make sure you are setting\"mips\" and \"32\" in radare2 environment of assembly\narchitecture (arc) and bits for this binary, then try to recognize the \"main function\", which is in\n\"0x4016a0\" at the pattern/location that's different than Intel basis assembly like shown in the\npicture below:\n\nNext, I may just run following commands to be sure that it can be reversed well. It is a simple\ncommand for only showing how many Linux syscall is used, and this will work after the\nradare2 parse and analyze the binary to the analysis database.\n\n\n-----\n\nPS: If you know what you're doing, an simpler/easier way for the MIPS 32bit to seek where\nthe syscall codes placed is by grepping the assembly code with the hex value of\n\"0x0000000c\" like below, the same result should come up:\n\n\n-----\n\nIn my case on dealing with Linux or UNIX binaries, I have to know first what syscalls are\nused (that kernel uses for making basic operations), \"syscall\" is used to request a service\nfrom kernel. Any good or bad program are using those (if they need to run on that OS), so\nsyscalls have to be there. For me, the syscalls is important and its amount will tell you how\nbig the work load will be, ..then the rest is up to you and radare2 to extract them, the more of\nthose syscalls, the merrier our RE life will be, without knowing these syscalls there's no way\nwe can solve such stripped binary :)\n\nIn a Linux MIPS architecture, where assembly and register (reduced registers due to small\nspace) is different than PC's Intel ones (MISP is RISC, Intel is CISC, RISC is for a CPU that\nis designed based on simple orders to act fast, many networking devices are on RISC for\nthis reason). Linux OS in some MIPS platform can be configured to run either in big or in little\nendian mode too, you have to be careful about the endianness in reversing MIPS, like this\nMIPS binary is using big endian, also binaries for SGI machines, but some machines like\n_Loongson 3 are just like Intel or PPC works in little endian, several Linux OS is differing their_\npackage for supporting each endianness with \"mips\" (big) or \"mipsel\" (little) in their MIPS\nport. Information on the target machines for each sample can help to recognize the\nendianness used.\n\nIn MIPS the way \"syscall\" used is also have its own uniqueness. Basically, a designated\nservice code for a syscall must be passed in $v0 register, and arguments are passed in other\nregisters. A simple way in assembly code to recognize a syscall is as per below snipped\ncode:\n```\nli $v0, 0x1\nadd $a0, $t0, $zero\nsyscall\n\n```\nExplanation: The \"0x1\" is stored in the \"$v0\" register (it doesn't have to be assembly\ncommand \"li\" but any command in MIPS assembly in example \"addliu\", etc, can be used for\nthe same effect), which means the service code used to print integer. The next line is to\nperform a copy value from the register \"$t0\" to \"$a0\" (register where argument is usually\nsaved).\nFinally (the third line) the syscall code is there, with these components altogether one\n\"syscall\" can be executed.\nWe can apply the above concept in the previously grep syscall result. The objective is to\nrecognize the address of its syscall wrapper function for this stripped binary analysis\npurpose. For example, at the second result at \"0x004019d0\" there's a syscall number, and\nby radare2 you go to that location with seek (s) command and using visual mode we can\nfigure the function name in no time. I will show you how.\n\n\n-----\n\nLet s fix the screen for it as per below so we can be at the same page:\n\nI marked the line where it is assigning \"0xfa2\" value to \"$v0\", and \"0xfa2\" is the number\nregistered for \"fork\" syscall in Linux MIPS 32bit OS, that's also saying 0xfa2 is syscall\n**number of sys_fork (system call for fork comnmand), if you scroll up a bit you can see the**\nfunction name \"fcn.004019a0\", which is the \"wrapper function\" for this \"syscall fork\" or\n**\"sys_fork\". The syscall command will accept the passed syscall number stored in \"$v0\" to**\nbe translated in the syscall table to pass it through the OS specific registered syscall name\nalongside with the arguments needed to perform the further desired syscall operation.\n\nNoted that the syscall number can always be confirmed in designated Linux OS in the file\nwith the below formula, and more information on register assignment on MIPS architecture\n[that explains syscalls calling conventions can be read in ==>[link].](https://www.linux-mips.org/wiki/Syscall)\n```\n/usr/include/{YOUR_ARCH}/asm/unistd_{YOUR_BIT}.h\n\n```\n[The manual of syscall [link] is a good reference explaining syscall wrapper in libc. Quoted:](http://man7.org/linux/man-pages/man2/intro.2.html)\n\n\n-----\n\n```\n Usually, system calls are not invoked directly: \ninstead, most system calls have corresponding C library wrapper \nfunctions which perform the steps required (e.g., trapping to kernel \nmode) in order to invoke the system call. \nThus, making a system call looks the same as invoking a\nnormal library function.\nIn many cases, the C library wrapper function does nothing more than:\n* copying arguments and the unique system call number to the\n  registers where the kernel expects them;\n* trapping to kernel mode, at which point the kernel does the real\n  work of the system call;\n* setting errno if the system call returns an error number when the\n  kernel returns the CPU to user mode.\nHowever, in a few cases, a wrapper function may do rather more than\nthis, for example, performing some preprocessing of the arguments\nbefore trapping to kernel mode, or postprocessing of values returned\nby the system call. Where this is the case, the manual pages in\nSection 2 generally try to note the details of both the (usually GNU)\nC library API interface and the raw system call. Most commonly, the\nmain DESCRIPTION will focus on the C library interface, and\ndifferences for the system call are covered in the NOTES section.\"\n\n```\n\n-----\n\nUsing this method, in no time you ll get the full list of the syscall function s used by this\nmalware as per following table that I made for myself during this analysis:\n\nThe rest is up to you on how to make it easy to name the strings for each \"syscall\" for your\npurpose, I go by the above strings naming since it is fit to my RE platform, I suggest you\n[refer to Linux syscall base on naming them [link].](http://man7.org/linux/man-pages/man2/syscalls.2.html)\n\nThe next step is, you may need to change all function name in radare2 according to this\n\"syscall table\". Using the visual mode and analyze function name (afn) command is the\nfaster way to do it manually, or you can script that too, radare2 can be used with varied of\nmethods, anything will do as long as we can get the job's done. In my case I like to use these\nradare2 shell macro based on table I made for myself:\n```\n  :\ns 0x0402060; af; afn ____connect; pdf |head \ns 0x0401CF0; af; afn ____write; pdf |head \ns 0x04019B0; af; afn ____fork; pdf |head \n  :\n\n```\nThe result is as per seen in the below screenshot:\n\n\n-----\n\n-----\n\nUp to this way, we ll have all of the syscalls back in place :) Don t worry, you ll do this faster if\nyou get used to it.\n\n\n-----\n\nThe result looks cool enough for me to read the radare2 graph on examining how this MIPS\nbinary further goes..\n\nThe next step is a generic way on reversing a stripped binary, by defining the functions that\nis not part of Libc but likely coded by malware coder. For this task, you have to check the\nrest of the function and seek whether the XREF doesn't go to any of syscall wrapper\nfunctions, make sure that function itself is not the main() function, init_proc() nor init_term()\nfunctions, and that goes to the below leftover list, just naming it to anything you think it is fit\nwith to what it does.\n\n\n-----\n\nIn my case I named them this way:\n\nThen we can put the correct function name into the binary using the same macro I showed\nyou previously, then we are pretty much completed in making this binary so readable... hold\non, but read it from where? Where to start?\n\nTo pick a good place to start to start reversing, this command will help you to pick some juicy\nspots, all the extractable strings will be dumped and we can pick one interesting one to start,\nand go up to build the big picture.:)\n\nActually symbols are giving us much better options, but right now we don't have anything\nelse that is readable enough to start..\n\nYou can start to trace this binary from these text address reference and then go up to the call\nin the main function that supports it. For example, by using the visual mode you can seek the\nXREF of each text to see how it is called from which function and you can trail them further\nafter that. This isn't going to be difficult to read since you have all functions back in place.\n\n\n-----\n\nThe picture below is showing how the **air dropping is referred to the caller function.**\n\nThat's it. These methods I shared are useful methodology in analyzing Linux MIPS-32 binary\nespecially stripped ones like the one I have now. I think you're good enough to go to\ncomplete your own analysis by yourself too. Please just tried those methods if you don't have\nany other better ways and don't be afraid if other RE tools can't make you read the MIPS-32\nbinary well, just fire the radare2 with the tips written above, and everything should be okay :)\n\nWe go on with the malware analysis of this binary and its threat then..\n\n## What does this MIPS-32 binary do?\n\nPractically. the MIPS binary is bot that is having a mission to infect the host it was dropped\ninto (note: so it needs a dropping scheme to go to the infected host beforehand), making a\nmalicious process called \"cloudprocess\", send message of \"airdopping clouds\" through\nthe standard output (that can be piped later on). It is recording its \"PID\" and fork its process\nfor the further step. The message of \"airdropping clouds\" is the reason why I called this\nmalware as \"AirDropBot\" eventhough the coder prefer to use \"Cloudbot\", which there is also\na legitimate good software that uses that name too as their brand.\n\nUpon successful forking it will extract the what the coder so-called \"encrypted array\", it's ala\nMirai table crypted keywords in its concept, but it is different in implementation., I must guess\nthat it could be originally coded to avoid XOR operation which is the worst Mirai bug in the\nhistory :) but this \"encrypt_array\" is just ending up to an encoded obfuscation function :) Anyhow the value from this \"decrypted\" coded is used for further malware process.\n\nThen the malware tries to connect to the C2 which its IP address is hard-coded in the binary,\n_on a success connection attempt to C2 server, it will parse the commands sent by the C2 to_\n_perform three weaponized functions on the binary to perform TCP, and UDP DDoS attack_\n\n\n-----\n\n_with either using the specific hex-coded payload, or the latter on is using a custom pattern_\n_so-called \"hex-attack\" that sends DoS packet in a hex escape strings format to the targeted_\nhost.\n\nI will break it down to more details in its specific functions in the next sections.\n\n## The \"encryption\" (aka the obfuscation)\n\nThe challenge was the \"encryption\" part, it was I used radare2 with ESIL to see the\n\"encrypted\" variables, as per snipped below as PoC:\n\nThe decryption is by [shift-1] as per shown in the cascade loop shown in every encoded\nstrings.\n\nIf we want to translate this decryoter scheme, it may look something like this (below), I break\nit up in 3 functions but in assembly it is all in a function and cascaded to each strings to be\ndecoded:\n\n\n-----\n\n```\nint encrypt_array()\n{\n array_splitter(\"xxxx\");\n array_splitter(\"yyyy\");\n  :\n}\nint array_splitter(char *src)\n{\n strcpy(var_char_buffer, src);\n char_decrypter(var_char_buffer);\n  array_counter++\n return;\n}\nint char_decrypter(char *src2)\n{\n int i; strcpy(dstring, src2);\n for ( i = 0; strlen(dstring) > i; ++i )\n  // {redacted shift -1 logic to dstring} //\n strcpy(j, dstring);\n return j++\n}\n\n```\nThe result for the \"decryption\" can be shown as per below, using ESIL with the fake stack\ncan be used to emulate this with the same result, so you don't need to get into the debug\nmode:\n\nThe last four strings:\n```\n/proc/\n/maps\n/cmdline \n/status \n/exe\n\n```\n...are used for taking information (process name) from the infected Linux box, that will be\nused for the malware other functions like \"killing\" processes, etc. The other decrypted strings\nare used for infecting purpose (known credentials for telnet operation), and also for other\nbotnet operation related.\nUnderstanding the \"decrypter\" logic used is important because the same decrypter is used\nagain to decode the C2 sent commands to the active bots before parsed and executed.\n\n\n-----\n\n## The C2, its commands and bot offensive activity\n\nWhat happened after decryption (encrypt_array) of these strings is, the binary gets into the\nloop to call the \"connecting\" function per 5 seconds. If I try to write C code based on this\nstage it's going to be like below snipcode:\n\nWithin each loop, when it calls \"connecting\" function it will try to connect the C2 which is\ndefined a struct sockaddr \"addr\", pointing to port number (htons) 455 (0x1c7) and IP:\n\"179.43.149[.]189\".\n\nWhen connected to C2, it will listen and receive the data sent by C2, to perform decryption\nand then to send its decryption result (as per previous logic) to the \"command parsing\"\nfunction, that's having \"cmd_parse\" sub-function inside. The \"command parsing\" is\ndelimiting received command with the white space \" \" for the \"cmd_parse\" to grep three\npossible keywords of \"udp\", \"tcp\", and \"hex\", which in next paragraph those keywords will\nbe explained further.\n\n\n-----\n\nBelow is the loop when the command from C2 is received (listened) inside the connecting\nfunction in radare2:\n\nNow we come into the offensive capability of this bot binary. The \"udp\" keyword will trigger\nthe execution of \"udpattack\" function, \"tcp\" will execute \"tcpattack\" and so does the \"hex\"\nfor executing the \"hexattack\" function. Each of the trigger keywords are followed by\narguments that are passed to its related attack function, it emphasizes that a textual basis\nDoS attack command line starting with udp, tcp or hex, following by the targets or optional\n_attack parameters are pushed from the C2 to the AirDropBots. Based on experience, the C2_\nCLI interface of recent DDoS botnets is having such interface matched to this criteria.\n\n\n-----\n\nTCP and UDP is having the same payload packet in binary is as per below:\n\n...that is sent from tcpattack() and udpattack() in TCP and UDP different socket connection\nfrom the target sent by C2.\n\nThe hexattack is having a different payload that looks like this:\n\nOne last command is is \"killyourself\" (taken from decrypted table that was saved in a var)\nthat will stop the scanning function fork with the flow more or less like this:\n```\nresult = strstr(var_parsed_cmd, \"killyourself\");\n if ( result )\n  { kill(scanner_fork_PID, 9);\n   exit(0);\n  }\nreturn result;\n\n```\n..and the kill function above is executing \"kill -9\" by calling int kill(__pid_t pid, int sig).\n\n\n-----\n\nAs additional, in the older version, there is also another C2 command called: **http that will**\nexecute \"httpattack\" function that is using HTTP to perform L7 DoS attack using the\ncombination of User-Agents, but in this sample series I don't see such function.\n\n## Is there any difference between MIPS and other binaries?\n\nOh yes it has. The Intel and ARM version (or to binary that is having a scanner function) is\ninterestingly having more functions. If I go to details on each functions for Intel binary maybe\nI will not stop writing this post, so I will summary them below with a pseudo code snips if\nnecessary.\n\n**1. The \"array_kill_list\" function**\n\nThis function is used to kill process that matched to these strings:\n\nIt seems this is how the bot herder gets rid of the competitor if they're in the same infected\nLinux box.\n\nThis \"array_kill_list\" is accessed from killer() function that is being executed before going to\n\"connecting\" loop in the main for Intel version.\n\nThe killer function is having multiple capability to stop unwanted processes too, it will be too\nlong to describe it one by one but in simple C code and comments as per picture below will\nbe enough to get the idea:\n\n\n-----\n\n**2. The scanner, the spreader via exploit**\n\nThe bot herder is aiming Lynksys tmUnblock.cgi of a known router's brand, the\nvulnerability that has to be patched since published 5 years ago. For this purpose, in intel\nand ARM binaries right after killer() function it runs scanner() function, targeting\n**randomized formed IP addresses, using a hard-coded \"payload\" data, spoofed its origin**\nby faking the HTTP request headers (for \"tcp\" or \"http\" flood), which is aiming TCP port 8080\nwith the code translated from assembly to simplified C code looks like below:\n\n\n-----\n\nThis scanner is having four pattern of payloads which I quickly paste it below for your\nreference if you are either receiving or researching this attack:\n\nMaybe one of the thing that I may suggest for this bot's scanner functionality is what it seems\nlike a spoof capability. I examined into low level for code generation of about this part and\nfound what the send syscall performed when AirDrop bot make scanning with exploit is\ninteresting :) please take a look yourself of what has been recorded as per below snipcodes:\n\n\n-----\n\nOn those scanner function supported binary, the spreading scheme is executed with\ntargeting random generated IP addresses by calling sub-function \"get_random_ip\" right\nafter the the C2 has been attempted to call, and is using the same socket for multiple effort\nto infect Linksys CGI vulnerability. Below is the record in re-production this activity:\n\n**3. The \"singleInstance\" function**\n\nThis is a code to make sure that there is no duplication of \"cloudprocess\" process that runs\nafter a device getting infected. It's a simple code to kill -KILL the PID of detected double\ninstance. You can easily reverse and examine it by yourself.\n\n\n-----\n\nBelow is the example ARM-32 assembly code for this function with my comments in it just in\ncase:\n\nfor the right side of code, if I write that in C it's going to be something like this, more or less:\n\n## BONUS: AirDropBot and the custom ELF packer case\n\nAs per other ELF badness produced by botnet adversaries in the internet, the AirDropBot is\nhaving binary that is packed with custom packer too.\n\n\n-----\n\n[The below file [link] is one good real example of AirDropBot ELF in packed mode, the](https://www.virustotal.com/gui/file/187492dca212f30e70cc7226a28f3704abd7fe37f1d4c33a70884539c670c05f/detection)\nVirusTotal detection is like below:\n\nThis sample is spotted in the wild a while ago on trying to infect one of my honeytraps. The\n\"file\" result looks like this:\n```\nx86.cloudbot: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux),\nstatically linked, stripped\n\n```\nThe binary is packed and by reading the assembly flow in the packer codes we can tell it is a\nUPX-like packer. It looks like this:\n\nIf you follow my presentation in R2CON2018 in the last part (the main course) about\nunpacking with radare2 for an unknown packer, the same method can be applied for you to\nget the OEP by implementing several \"bp\" on the unpacker processes. There are slides and\n[video for that, use this link for some more information: [link]](https://www.reddit.com/r/LinuxMalware/comments/9eqn6m/about_my_presentation_of_unpacking_the/)\nThat is exactly the method I applied to unpack this ELF.\n\n\n-----\n\nThen next, after you bp to part where packed code copied to the base memory defined in the\nLOAD0 section, I will share \"my way to\" easily extract the unpacked ELF afterward:\n\nELF file headers is having enough information to be rebuilt, let's use it, assuming the header\ntable is the last part of the ELF the below formula is more or less describing the size of the\nunpacked object:\n```\n// formula:\ne_shoff + ( e_shentsize * e_shnum ) = +/- file_size\n// math way:\n0x00013af8 + ( 0x0028 * 0x0013 ) = file_size\n// radare2 way:\n? (0x0028 * 0x0013) + 0x00013af8|grep hex\n\n```\n[And.. there you go, this is my unpacked file: [link]](https://www.virustotal.com/gui/file/e42964a8d5aa0d82bf2eda129d422baa4201600c92a89af0f3fdbd67cfed40e0/detection)\n\n\n-----\n\nNext, let s see the detection ratio of this packed binary in Virus Total after successfully\nunpacked (..well, at least it is two points higher than the packed one) :\n\nAnd the binary after unpacked is very much readable now..and BOOM! the C2 of this packed\nELF is in 185.244.25[.]200, 185.244.25[.]201, and 185.244.25[.]202 are revealed! :)) Now\nwe know why the adversary wanted to pack their binary that bad.\n\nFor the addition, nowadays IoT botnet adversaries are not only packing the Intel binaries, but\nthe embedded platform's (some are RISC cpu too) Linux binary are often seen packed also\n[with the custom packers. Like in this similar threat report I made [link], with the ELF binary for](https://imgur.com/a/Ak9zICq)\nMIPS cpu (noted: big endian one), sample that was actually spotted inside of the house of a\nvictim (in his MIPS IoT daily used device, I won't disclose it further). I analyzed and unpacked\nit, to find that is not only \"UPX!\" bytes tampering that has been replaced.\n\n\n-----\n\nLet me quote it in here too about my suggested unpacking methods for embedded Linux\nbinaries I wrote in the linked post, as follows:\n```\n\"There are other radare2 ways also for unpacking and extracting \nunpacked sample manually too.\nThe \"dmda\" is also useful to dump but it's maybe a bit hard effort to \nrun it on embedded system, or, you can fix the load0 and load1 that can \nalso be done after you grab \"OEP\", or, you can also break it in the exact\nrewriting process to the base address, but either ways, should be able \nto unpack it. \nFirst ones will consume workspace in the memory for performing it.. I \ndon't think RISC systems has much luxury in space for that purpose, \nbut the latter one in some circumstance can be performed in ESIL mode.\"\n\n```\nThe thing is you should master all of those methods, and only by that most of binary packing\npossibility in Linux can be solved manually without depending on UPX or any automation\ntools.\n\n**\"So don't worry, just fire your radare2, and everything will be just Okay!\" :D (my**\nfavorite motto)\n\n## In a short summary as the conclusion\n\nThis binaries are a DoS bot clients, a part of a DDoS botnet. It spread as a worm with\ncurrently aiming Lynksys tmUnblock.cgi routers derived by non MIPS built binaries that\ninfects machines to act as payload spreader too. I must warn you that I did not check the\ndetails in every 26 binaries came up during this investigation, but I think the general aspect is\ncovered.\n\nThese are malware for Linux platform, it has backdoor, bot functions and are having infection\ncapability with aiming vulnerability in routers CGI or telnet. The malware is coded with many\noriginality intact, again, it is a newly coded, it is not using codes from Mirai-like, GafGyt\n(Qbot/Torlus base), or Kaiten (or STD like), but I can tell that the development is not mature\nyet. I was about to name it as \"Cloudbot\" but it looks like there is a legitimate software\nalready using it so I switched to the \"Airdropbot\" instead due to the hardcoded message\nprinted on a success infection. This is a new strain of various library of IoT botnet, I hope that\nother security entities and law enforcer aware of what has just been occurred here, before it\nis making bigger damage like Mirai botnet did before.\n\n## Detection methods\n\n Binary detection\n\n\n-----\n\nFor the binary signature method of detection. The unpacked version will hit just fine. But\nsince the AirDropBot was developed to support many embed platform from various CPU and\n\"endianness\" type, to detect it precisely you may need to code several signatures. However,\nif you see the typical functions of their binary carefully, so it is yes, one generic rule can be\ngenerated and applied. For that I PoC'ed it myself to develop a bit complex Yara rules to\ndetect them all and to recognize which binary that is having the scanner and not.\n\nThe snippet code and scan example is as per screenshot below.\n\n## Traffic detection\n\nFor the traffic detection, there are two methods that you can apply as detection: (1) The\n**_Initial Connection and activities of AirDropBot does right after the success infection, or (2)_**\n**_the DoS traffic, I am explaining both as follows._**\n\nThe Initial connection detection is related to the nature of this malware, which is connecting\nto C2 and performing scanning for vulnerabilities aiming random IP in 8080. I can suggest a\nnice Suricata or Snort rule can be coded for connection that's aiming TCP/455 (C2\nconnection port), but the C2 port can be changed by the adversaries too on their next\ncampaign, but that's not going to be easy for them to prepare all of those varied binaries and\nC2 port changes immediately (smile). The other way is to focus on the scanner payloads as\nper described in some of pictures above, the Surucata rules to detect them will last longer IF\nthe same vulnerability is still being aimed.\n\n\n-----\n\nThe other detection is by using the AirDropBot's hardcoded flood packets, which I was in\npurpose whoring them in the attached pictures above too. This way you may be able to\nrecognize the DoS traffic activity performed by this threat in the future DDoS incidents.\nSucicata and Snort rules are supported for this purpose.\n\nThe bad actors and his gang are still at large and reading this blog post too :), I am sorry I\ncan not share the generic scanning code I made in here, but the screenshots I provided are\nenough for fellow reversers to recognize and implement these detection methods to filter\nthese series of AirdropBot activities. The rest is OpSec.\n\n## Hashes and IOC information\n\nThe hashes are listed as per below and IOC has been posted to MISP and OTX for all blueteamer community to be noticed.\n\n\n-----\n\n```\n../bins/aarch64be.cloudbot  | 417151777eaaccfc62f778d33fd183ff\n../bins/arc.cloudbot     | d31f047c125deb4c2f879d88b083b9d5\n../bins/arcle-750d.cloudbot  | ff1eb225f31e5c29dde47c147f40627e\n../bins/arcle-hs38.cloudbot  | f3aed39202b51afdd1354adc8362d6bf\n../bins/arm.cloudbot     | 083a5f463cb84f7ae8868cb2eb6a22eb\n../bins/arm5.cloudbot     | 9ce4decd27c303a44ab2e187625934f3\n../bins/arm6.cloudbot     | b6c6c1b2e89de81db8633144f4cb4b7d\n../bins/arm7.cloudbot     | abd5008522f69cca92f8eefeb5f160e2\n../bins/fritzbox.cloudbot   | a84bbf660ace4f0159f3d13e058235e9\n../bins/haarch64.cloudbot   | 5fec65455bd8c842d672171d475460b6\n../bins/hnios2.cloudbot    | 4d3cab2d0c51081e509ad25fbd7ff596\n../bins/hopenrisc.cloudbot  | 252e2dfdf04290e7e9fc3c4d61bb3529\n../bins/hriscv64.cloudbot   | 5dcdace449052a596bce05328bd23a3b\n../bins/linksys.cloudbot   | 9c66fbe776a97a8613bfa983c7dca149\n../bins/m68k-68xxx.cloudbot  | 59af44a74873ac034bd24ca1c3275af5\n../bins/microblazebe.cloudbot | 9642b8aff1fda24baa6abe0aa8c8b173\n../bins/microblazeel.cloudbot | e56cec6001f2f6efc0ad7c2fb840aceb\n../bins/mips.cloudbot     | 54d93673f9539f1914008cfe8fd2bbdd\n../bins/mips2.cloudbot    | a84bbf660ace4f0159f3d13e058235e9\n../bins/mpsl.cloudbot     | 9c66fbe776a97a8613bfa983c7dca149\n../bins/ppc.cloudbot     | 6d202084d4f25a0aa2225589dab536e7\n../bins/sh-sh4.cloudbot    | cfbf1bd882ae7b87d4b04122d2ab42cb\n../bins/sh4.cloudbot     | b02af5bd329e19d7e4e2006c9c172713\n../bins/x86.cloudbot     | 85a8aad8d938c44c3f3f51089a60ec16\n../bins/x86_64.cloudbot    | 2c0afe7b13cdd642336ccc7b3e952d8d\n../bins/xtensa.cloudbot    | 94b8337a2d217286775bcc36d9c862d2\n\n## Salutation & Epilogue\n\n```\nI would like to thank to @0xrb for his persistence trying to convince me that this binary is\ninteresting. It is interesting indeed, and as promised, this is the analysis I did after work,\nwriting this in 8hours more non-stop. Thank's also for other readers who keep on supporting\nMMD, and as team, we appreciate your patience in waiting for our new post.\n\nThank you pancake and Radare2 teams who keep on making radare2 the best RE tools for\nUNIX (All of the radare2 reversing was done in FreeBSD OS, thank you for your great\n**support to FreeBSD!), and also I thank Tsurugi DFIR team for your great forensics tools.**\nFor these open source security frameworks I still keep on helping with tests and bug reports.\n\nOkay, I will rest and will wordsmith some miserable jargon parts of the post later, maybe I will\nadd detail that I didn't have much time to write it now, or, to correct some minor stuff. In the\nmean time, enjoy the writing, please share with mention or using #MalwareMustDie hashtag.\nThis post is a start for more posts to come.\n\nA tribute to the newborn radare2 community in Japan \"r2jp\", that we established in 2013\ntogether with \"pancake\" on AVTokyo workshop in Tokyo, Japan.\n\n\n-----\n\n_This technical analysis and its contents is an original work and firstly published in the current_\n_MalwareMustDie Blog post (this site), the analysis and writing is made by @unixfreaxjp._\n\n[The research contents is bound to our legal disclaimer guide line in sharing of](https://blog.malwaremustdie.org/p/the-rule-to-share-malicious-codes-we.html)\nMalwareMustDie NPO research material.\n\nMalware Must Die!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-09-28 - MMD-0064-2019 - Linux-AirDropBot.pdf"
    ],
    "report_names": [
        "2019-09-28 - MMD-0064-2019 - Linux-AirDropBot.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536224,
    "ts_updated_at": 1743041162,
    "ts_creation_date": 1653786056,
    "ts_modification_date": 1653786056,
    "files": {
        "pdf": "https://archive.orkl.eu/ae190cc9558f37b811bec09dae7bf0aa34b89868.pdf",
        "text": "https://archive.orkl.eu/ae190cc9558f37b811bec09dae7bf0aa34b89868.txt",
        "img": "https://archive.orkl.eu/ae190cc9558f37b811bec09dae7bf0aa34b89868.jpg"
    }
}