{
    "id": "4f26d847-9433-4632-9d60-ca18052aa81e",
    "created_at": "2023-01-12T15:04:23.959715Z",
    "updated_at": "2025-03-27T02:05:59.998044Z",
    "deleted_at": null,
    "sha1_hash": "ee176c3d5d76d0ef55320775209e20b706d047b8",
    "title": "2022-08-08 - YARA for config extraction",
    "authors": "",
    "file_creation_date": "2022-08-18T03:56:40Z",
    "file_modification_date": "2022-08-18T03:56:40Z",
    "file_size": 651584,
    "plain_text": "# YARA for config extraction\n\n**n1ght-w0lf.github.io/tutorials/yara-for-config-extraction/**\n\n### Abdallah Elshinbary\n\nMalware Analysis & Reverse Engineering Adventures\n\n8 minute read\n\n\nAugust 8, 2022\n\n\nYARA is a tool aimed at helping malware researchers to identify and classify malware\nsamples It’s considered to be the pattern matching swiss knife for malware researchers\n\n\n-----\n\nIf you are not familiar with writing YARA rules, the [official docs would be a great start.](https://yara.readthedocs.io/en/stable/index.html)\n\nIn this blog I will go through how YARA rules can be used for malware config extraction.\n\nYARA has come a long way since its original release and it now has some awesome\nmodules for writing better and more complex rules.\n\n## What is a YARA module\n\nA YARA module is like a plugin for extending YARA features, it allows you to define data\nstructures and functions which can be used in your rules.\n\nTo use a YARA module you simply import it using `import \"module_name\", you can refer to`\nthe docs to learn about the available functions of each module.\n\nExample:\n```\nimport \"pe\"\n\nrule test {\n\n  condition:\n\n    pe.number_of_sections == 1\n\n}\n\n\n```\nWith that said let’s now jump into malware land, I will demonstrate on two variants of\n[RedLine Stealer which is a very popular dotnet stealer.](https://malpedia.caad.fkie.fraunhofer.de/details/win.redline_stealer)\n\n## RedLine Stealer Variant1\n\nThe first variant stores the config in plaintext, we are only interested in two fields (C2 and\nBotnetID).\n\n[To read these fields we need to understand how ldstr instruction works. The instruction’s](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes.ldstr?view=net-6.0)\nopcode is `0x72 followed by 4 bytes which represent the string token.`\n\nA token is a DWORD value that represents a table and an index into that table. For\nexample, the EntryPointToken 0x0600002C, references table 0x06 (MethodDef) and its\nrow 0x2C. The table index is 1 byte and the row index is 3 bytes.\n\n\n-----\n\nIn the following instruction for example, the string token is `0x7000067B (little-endian) and`\nthe row index is `0x67B .`\n```\n727B060070  // ldstr \"87.251.71.4:80\"\n\n\n```\nThe `dotnet module already has the functionality to retrieve all user strings from a dotnet`\nsample.\n```\nimport \"dotnet\"\n\nimport \"console\"\n\nrule Test {\n\n  condition:\n\n    for all i in (0..dotnet.number_of_user_strings-1): (\n\n      console.log(dotnet.user_strings[i])\n\n    )\n\n}\n\n\n```\nNotice that I used `sed to remove null characters because dotnet user strings are`\nstored as an array of unicode strings.\n\nThis is cool but we need to get the user strings using the row index from the string token.\n\nTo achieve this we need to make a couple of changes to the `dotnet module source file at`\n```\nlibyara/modules/dotnet/dotnet.c .\n\n```\nThis will index the user strings array by row index (offset from the start of the strings table).\n\nTo compile and install yara you need to run these two scripts for the first time only:\n\n\n-----\n\n```\n$ ./bootstrap.sh\n\n$ ./configure\n\n```\nThen you build YARA with your changes:\n```\n$ make\n\n$ sudo make install\n\n\n```\nWe can now write a simple rule to read the config fields.\n```\nimport \"dotnet\"\n\nimport \"console\"\n\nrule Redline {\n\n  strings:\n\n    $get_conf_v1 = {\n\n      72 ?? ?? ?? 70   // IL_0000: ldstr   \"87.251.71.4:80\"\n\n      80 ?? ?? ?? 04   // IL_0005: stsfld  <IP>\n\n      72 ?? ?? ?? 70   // IL_000A: ldstr   \"lyla\"\n\n      80 ?? ?? ?? 04   // IL_000F: stsfld  <ID>\n\n      72 ?? ?? ?? 70   // IL_0014: ldstr   \"\"\n\n      28 ?? ?? ?? ??   // IL_0019: call   set_Message(string)\n\n      2A         // IL_001E: ret\n\n    }\n\n  condition:\n\n    $get_conf_v1\n\n    and console.log(\"[+] C2: \",\n\n      dotnet.user_strings[int32(@get_conf_v1+1) & 0xffffff]\n\n    )\n\n    and console.log(\"[+] Botnet: \",\n\n      dotnet.user_strings[int32(@get_conf_v1+11) & 0xffffff]\n\n    )\n\n}\n\n      @get_conf_v1 : address of the first match of $get_conf_v1\n      int32 : reads 4 bytes (string token) from an offset, I used 0xffffff bit mask\n\n```\nto only get the row index.\n\nCool, Let’s move to the second variant.\n\n## RedLine Stealer Variant2\n\nThis variant stores the config in an encrypted form.\n\n\n-----\n\nThe decryption algorithm looks as follows:\n\nCurrently YARA doesn’t have a module to do `base64 and` `xor operations in conditions,`\nso why not write our own module :)\n\n## Writing our own YARA module\n\nModules are written in C and built into YARA as part of the compiling process.\n\n[I will explain briefly how to write a YARA module, for more details refer to the official docs.](https://yara.readthedocs.io/en/stable/writingmodules.html)\n\nYARA modules reside in `libyara/modules, it’s recommended to use the module name as`\nthe file name for the source file. Here I created a new module directory named `malutils`\nand inside it is the source file named `malutils.c, now let’s go through the source code.`\n\nFirst we need to include the required headers to be able to use YARA’s module API.\n\nNext we define the required functions:\n\nXor decryption function which takes a buffer and a key and returns the decrypted string\nbuffer.\n\n\n-----\n\nBase64 decoding function which takes a base64 encoded string and returns the\ndecoded value.\n\n\n-----\n\nHelper function to convert dotnet user strings from wide to ascii.\n\nThen comes the declaration section where we declare the functions and data structures that\nwill be available for our YARA rules.\n\nAfter that we have 2 pairs of functions, the first pair is `module_initialize &`\n```\nmodule_finalize .\n\n```\nThese functions allow you to initialize and finalize any global data structure you may need to\nuse in your module, and both functions are invoked whether or not the module is being\nimported by some rule.\n\n\n-----\n\nThe second pair is `module_load &` `module_unload .`\n\nThe `module_load function is invoked once for each scanned file (only if the module is`\nimported in your rule). It’s is where your module can inspect the file being scanned, parse or\nanalyze it in the way preferred, and then populate the data structures defined in the\ndeclarations section.\n\nFor each call to `module_load there is a corresponding call to` `module_unload . This`\nfunction allows your module to free any resource allocated during `module_load .`\n\n## Final Touches\n\n\n-----\n\nBefore we test our module there’s a nasty bug we need to take care of.\n\nWhen writing a YARA module, instead of using the C return statement in your declared\nfunctions you must use `return_string(x),` `return_integer(x) or` `return_float(x)`\nto return from a function.\n\nThe problem occurs when we return from `base64d function, the decoded string might`\ncontain null bytes so `return_string won’t return the full buffer.`\n\nAs you can see below, `return_string uses` `strlen to determine the length of the`\nreturned string so it will stop at the first null byte.\n\nAs a workaround, I defined a new return macro called `return_sized_string which`\nenables us to set the length of the returned string rather than relying on `strlen .`\n\n\n-----\n\n## Building our module\n\nTo include our module in the compiling process of YARA we must follow two further steps:\n\nAdd our module name to the module_list at `libyara/modules/module_list`\n```\nMODULE(malutils)\n\n\n```\nAdd our module source file to the must compiled modules at `libyara/Makefile.am`\n```\nMODULES += modules/malutils/malutils.c\n\n\n```\nFinally we build YARA with our module:\n```\n$ make\n\n$ sudo make install\n\n\n```\nWith everything in place, let’s now test our module.\n\n## Testing our module\n\nBelow is the final YARA rule that handles both RedLine variants.\n\n\n-----\n\n```\nimport dotnet\n\nimport \"console\"\n\nimport \"malutils\"\n\nrule Redline {\n\n  meta:\n\n    date = \"2022-08-08\"\n\n    author = \"Abdallah 'n1ghtw0lf' Elshinbary\"\n\n    description = \"Extracts Redline config (educational)\"\n\n  strings:\n\n    $get_conf_v1 = {\n\n      72 ?? ?? ?? 70   // IL_0000: ldstr   \"87.251.71.4:80\"\n\n      80 ?? ?? ?? 04   // IL_0005: stsfld  <IP>\n\n      72 ?? ?? ?? 70   // IL_000A: ldstr   \"lyla\"\n\n      80 ?? ?? ?? 04   // IL_000F: stsfld  <ID>\n\n      72 ?? ?? ?? 70   // IL_0014: ldstr   \"\"\n\n      28 ?? ?? ?? ??   // IL_0019: call   set_Message(string)\n\n      2A         // IL_001E: ret\n\n    }\n\n    $get_conf_v2 = {\n\n      72 ?? ?? ?? 70   // IL_0000: ldstr  \n\"CyYOXysPAwUnB1NQCxtdWioxKUInBC5QCDNUUw==\"\n\n      80 ?? ?? ?? 04   // IL_0005: stsfld  <IP>\n\n      72 ?? ?? ?? 70   // IL_000A: ldstr   \"FzcNJDEOEDw7O1Y/FEM/IQ==\"\n\n      80 ?? ?? ?? 04   // IL_000F: stsfld  <ID>\n\n      72 ?? ?? ?? 70   // IL_0014: ldstr   \"\"\n\n      80 ?? ?? ?? 04   // IL_0019: stsfld  <Message>\n\n      72 ?? ?? ?? 70   // IL_001E: ldstr   \"Baying\"\n\n      80 ?? ?? ?? 04   // IL_0023: stsfld  <Key>\n\n    }\n\n  condition:\n\n    dotnet.is_dotnet and\n\n    (\n\n     (\n\n      $get_conf_v1\n\n      and console.log(\"[+] C2: \",\n\n       malutils.wtoa(dotnet.user_strings[int32(@get_conf_v1+1) & 0xffffff])\n\n      )\n\n      and console.log(\"[+] Botnet: \",\n\n       malutils.wtoa(dotnet.user_strings[int32(@get_conf_v1+11) & 0xffffff])\n\n      )\n\n     )\n\n     or\n\n     (\n\n      $get_conf_v2\n\n      and console.log(\"[+] C2: \",\n\n       malutils.base64d(\n\n        malutils.xord(\n\n         malutils.base64d(\n\n          malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+1) &\n\n```\n\n-----\n\n```\n0xffffff])  // enc c2\n\n         ), malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+31) &\n0xffffff]) // xor key\n\n        )\n\n       )\n\n      )\n\n      and console.log(\"[+] Botnet: \",\n\n       malutils.base64d(\n\n        malutils.xord(\n\n         malutils.base64d(\n\n          malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+11) &\n0xffffff])  // enc botnet\n\n         ), malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+31) &\n0xffffff]) // xor key\n\n        )\n\n       )\n\n      )\n\n      and console.log(\"[+] Key: \",\n\n       malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+31) & 0xffffff])\n\n      )\n\n     )\n\n    )\n\n}\n\n```\nRunning the rule on a list of samples produces the following output:\n\n\n-----\n\nBeautiful right!\n\n[You can pull the code and try it yourself at https://github.com/N1ght-W0lf/yara/tree/malutils.](https://github.com/N1ght-W0lf/yara/tree/malutils)\n\nIt was just for learning purposes so not the best code :)\n\n## Samples\n\nfed976b2d134008fd6daec8edc00099935df756beb721034f71db33e4d675a6e\ne4f7246b103d9bda3a7604bea12dc5ac1064764c0f3691617c9829c4e5d469b5\n2d3503d8540e319851a67e55f06ed9e5ba060e821eec6dbc83960a5947ad1310\na8c498f5129af0229081edf1e535ac9dab6ad568befcbcecbfc7cc4c61e0a8eb\nc19938f0b9648dc1f6b95d0e767164da832b9a92f8128ab47dcb81c5e1ceb31a\ne94d48e09cace8937941fbf81d1a466fa2b2b6acfd0d6142fc3443c70e067294\nf343005539a589ec5512559e0bdc824c1069196ae39d519e5b1f3257f4a6660b\n\n\n-----\n\n## References\n\n[https://yara.readthedocs.io/en/stable/index.html](https://yara.readthedocs.io/en/stable/index.html)\n\n[https://www.ntcore.com/files/dotnetformat.htm](https://www.ntcore.com/files/dotnetformat.htm)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-08 - YARA for config extraction.pdf"
    ],
    "report_names": [
        "2022-08-08 - YARA for config extraction.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535863,
    "ts_updated_at": 1743041159,
    "ts_creation_date": 1660795000,
    "ts_modification_date": 1660795000,
    "files": {
        "pdf": "https://archive.orkl.eu/ee176c3d5d76d0ef55320775209e20b706d047b8.pdf",
        "text": "https://archive.orkl.eu/ee176c3d5d76d0ef55320775209e20b706d047b8.txt",
        "img": "https://archive.orkl.eu/ee176c3d5d76d0ef55320775209e20b706d047b8.jpg"
    }
}