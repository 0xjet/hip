{
    "id": "d4320d95-0d48-4b7b-8cf0-265aaf42d06c",
    "created_at": "2023-01-12T15:08:00.345478Z",
    "updated_at": "2025-03-27T02:09:18.143922Z",
    "deleted_at": null,
    "sha1_hash": "878d4b70b00d9a50332dcd0c6965a313e506cfd2",
    "title": "2021-12-29 - Cobalt Strike DFIR- Listening to the Pipes",
    "authors": "",
    "file_creation_date": "2022-05-27T21:37:38Z",
    "file_modification_date": "2022-05-27T21:37:38Z",
    "file_size": 161134,
    "plain_text": "# Cobalt Strike DFIR: Listening to the Pipes\n\n**bmcder.com/blog/cobalt-strike-dfir-listening-to-the-pipes**\n\n[VelociraptorAPI HookingNamed PipesCobalt StrikeDFIR](http://10.10.0.46/blog/category/Velociraptor)\n29 Dec\nWritten By [Blake .](http://10.10.0.46/?author=619747b44b867078535168fc)\n\n\nDecember 29, 2021\n\n\nHappy Holidays! This weeks update is a bit of a shorter blog, mostly to keep me busy while\non Christmas holidays!\n\n[Recently I stumbled across svch0st’s “Guide to Named Pipes and Hunting for Cobalt Strike](https://twitter.com/svch0st)\nPipes”. If you haven’t read it, I highly recommend it.\n\nNamed Pipes have been something that I’ve thought about for a while, especially how do\nwe take advantage of them during active compromise. Named Pipes have worked their way\ninto a lot of common malicious behaviour, especially with:\n\nModulated Implants: Communicating between malicious children processes back to\nthe implant core, often utilized with Key Loggers.\n\nPrivilege Escalation: The Potato family being the most frequent recently, but even\nMetasploit’s “Get-System” uses Named Pipes.\n\nLateral Movement: Many system pipes allow for remote code execution.\n\nPersistence: Some implants (such as Cobalt Strike) can now listen on a Named Pipe,\nproviding a static backdoor: no beacons, no ports, just a named pipe!\n\nOften it can be advantageous to leave an actor on a network, while you fully scope out the\nextent of the compromise and their accesses. This can ensure that you fully remove the\nactor in one sweep, rather than playing whack a mole for the next few months.\n\nIf you are monitoring an actor though, you need to make sure you have full coverage over\ntheir actions. But the problem is, how do we monitor these pipes? I searched across a few\noptions, but none of them seemed quite right:\n\nETW: No great providers for monitoring all named pipes, all though you can capture\nSMB traffic which will show remote Named Pipe exploitation.\n\nKernel: Seemed overkill, especially when monitoring implants. The unknown could be\na high risk of blue screens.\n\n\n-----\n\nEventually I came to the idea of API hooking, what if we used actor techniques against\nthem and hooked common Named Pipe functions. If we hook these functions, that puts us\nin a unique spot to log, respond and react to actor activities. So, what are the common\nNamed Pipe functions?\n\n## How Named Pipes Work\n\nNamed Pipes work in a client / server model.\n\nThe server is responsible for setting up the Named Pipe, then waits for one or many clients\nto connect. The Server and Clients then treat the Named Pipe as a file, using CreateFile,\nReadFile and Write file to communicate through the pipe. Once done, they can both close\nthe pipe like a standard file.\n\n\n-----\n\nTo understand how modulated malware uses Named Pipes, you just need to replace\n“server” with the core implant, and “client” as the module, such as a key logger.\n\nBecause Named Pipes normally go by unnoticed, most malware (that I’ve observed) don’t\nbother encrypting data being sent over a Named Pipe. Because of that, we’re left in a prime\nopportunity to get a copy of the data being sent.\n\nNote: There are a few other functions that are sometimes used with Named Pipes, so\nyou’d probably want to check how your target uses Named Pipes before hooking\nthem. Some other functions include WaitNamedPipe, CallNamedPipe and\nTransactNamedPipe.\n\n## API Hooking Workflow\n\nI wrote an injectable DLL, that once attached to a process will iterate through each of the\nstandard Named Pipe functions and install a hook. The functions I was hooking in my PoC\nare:\n\nCreateFileA\n\nCreateFileW\n\nReadFile\n\nWriteFile\n\nCreateNamedPipe\n\nNote: I used EasyHook for this proof of concept, so I wasn’t reinventing the wheel with\nAPI hooking and reliability. If this were to be productionized, I would not recommend\nusing EasyHook, as you’re required to load the EasyHook{32/64}.dll which will make\nyour presence extremely obvious.\n\nFor the standard file interaction functions, such as Create, Read and Write, I implement a\nquick check to see if the function is targeting a Named Pipe. If not, return it right away, so\nwe’re not holding up the process.\n```\nif (wcsstr(lpFileName, L\"\\\\\\\\.\\\\pipe\\\\\") == NULL)\n    goto Cleanup;\n\n```\nOnce we know we’ve hooked a Named Pipe, we capture the relevant data before allowing\nthe process to continue as normal.\n\n\n-----\n\nBut how do we get our data back to us?\n\nInitially I had two solutions but they both had big flaws:\n\n1. Use Easy Hooks IPC communications: Sounds great in theory, but in production we\n\nwouldn’t want to send out an individual controller.\n\n2. Use ETW: Sound great in theory, but that would depend on the injected process have\n\nthe rights to create a provider and send events. This would also have a whole bunch\nof overhead, installing the ETW manifest.\n\nSo the solution that I landed on, funnily enough, was named pipes!\n\nI capture the data from the hooked parameters and place them within a struct (this includes\ncopying the buffer into a char array). I used a separate struct for each hooked function to\nensure that relevant data was captured. That initial byte of each structure references an\nenum. This can help us separate the different hook types, so we can differentiate them on\nthe server end.\n\nThe structure is then written to the named pipe as a char array. Once the data is received\nby the name pipe server, I can read the first byte to decode the byte array into the hook\nstructure.\n```\nenum HOOKS {\n  CreateA = 0x00,\n  CreateW = 0x01,\n  Read = 0x02,\n  Write = 0x03,\n  CreateP = 0x04\n};\n\n```\nNote: EasyHook allows us to exclude our thread from being captured by our hooked\nfunction. This allows us to use the Named Pipe functions without capturing ourselves\nin an infinite loop. I also added a check to ignore any functions targeting the Named\nPipe “\\\\.\\pipe\\PipeHook”.\n\n## Production Ready Code?\n\nProof of Concepts are great but to actually use this in the wild, we need to consider:\n\nHow we inject the DLL,\n\nHow we read the traffic\n\n\n-----\n\nHow we do this at scale.\n\nSimilar to previous posts, Velociraptor is an open source EDR that allows us to remotely\nmonitor and interact with our hosts. The problem is, there’s no real functionality to either\ninject a DLL or setup a Named Pipe. To fix this, I just wrote some plugins to enable this\ncapability!\n\nWhile Velociraptor is written in GoLang, it is very easy to call straight C functions. Because\nof this, I used the standard DLL injection technique: Loading a Library, then creating a\nremote thread executing it. There’s nothing to special about it, I just wanted to get a PoC\nworking.\n\n\n-----\n\nImage ref: [Open Security Research: Windows DLL Injection Basics](http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html)\n\nNote: If you were going to do this within a live environment, you should probably look\nto use a reflective injection technique to hide your DLL from basic actor triaging.\n\n\n-----\n\nA similar process was followed for the Named Pipe Server, I created the plugin\n“watch_pipe”. I kept it simple with only a single argument, pipe name. I figured this could be\na useful plugin for other projects, where I want to get data back to Velociraptor without\nwriting to disk.\n```\ntype _WatchPipePluginArgs struct {\n     PipeName string `vfilter:\"required,field=pipe_name,doc=The name of the named\npipe.\"`\n}\n\n```\n[For the Named Pipe aspect of the code, I used the npipe package for Go-Lang. Again,](https://github.com/natefinch/npipe)\nlaziness on my part. But this provided a super quick solution and saved me the time of\nmanually importing the Windows API functions. Soo…. ¯\\_(ツ)_/¯\n\nThe code itself is pretty simple, I have a routine that creates the Named Pipe then just loops\nthrough waiting for a connection. Once I receive a message, I transform the it into a byte\narray so I can decode them into their structures in post analysis. Velociraptor expects data\nto be sent within a dictionary, so I just through it in with the “data” row.\n\n\n-----\n\n```\n// Create the pipe. \nconn, err := npipe.Listen(fmt.Sprintf(`\\\\.\\pipe\\%s`, pipename))\nif err != nil {\n     scope.Log(\"create_pipe: %v\", err)\n     return\n}\nscope.Log(\"Created Named Pipe: %s\", fmt.Sprintf(`\\\\.\\pipe\\%s`, pipename))\nfor {\n     // Check for message. \n     msg, err := conn.Accept()\n     if err != nil {\n          scope.Log(\"conn_accept: %v\", err)\n          continue\n     }\n     // Read the message into a buffer. \n     buf := make([]byte, 256)\n     size, err := msg.Read(buf)\n     if err != nil || size <= 0 {\n          scope.Log(\"msg_read: %v\", err)\n          continue\n     }\n     // Convert the message into a dictionary. \n     event := ordereddict.NewDict().\n          Set(\"Data\", fmt.Sprintf(\"%x\", buf))\n     scope.Log(\"msg: %v\", event)\n     // Output to our channel. \n     select {\n     case <-ctx.Done():\n          return\n     case output_chan <- event:\n     }\n}\n\n```\nOnce the data is received, it comes through with just three fields: Time, Data and Client ID.\nYou can see the first byte in the image below refers to the enum that we referenced above.\nEach of those messages being a “WriteFile” hook.\n\n\n-----\n\n## Wrap up\n\nWhile this code is nowhere near production ready, it was nice to see that API hooking could\nbe a feasible way to track malicious Named Pipe usage and could warrant further\ninvestigation.\n\nA point worth mentioning is that I didn’t have a copy of Cobalt Strike readily available, so I\nquickly wrote up my own Named Pipe server and client. Ideally I would like to test this with\nCobalt Strike in the future. This could also be tested with other malware families.\n\nThis also provided a nice basis for a “watch_pipe” plugin for Velociraptor, a more lightweight\nand lower privileged method for getting tool events back to your Velociraptor server.\n\nI’ve got the Named Pipe plugin on my forked Velociraptor repo on GitHub if you want to try it\nout yourself. Check the “watch_pipe” branch!\n\nAs always, any questions, feel free to reach out to me on Twitter! Otherwise, Happy\nHolidays!\n\nBlake .\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-12-29 - Cobalt Strike DFIR- Listening to the Pipes.pdf"
    ],
    "report_names": [
        "2021-12-29 - Cobalt Strike DFIR- Listening to the Pipes.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536080,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653687458,
    "ts_modification_date": 1653687458,
    "files": {
        "pdf": "https://archive.orkl.eu/878d4b70b00d9a50332dcd0c6965a313e506cfd2.pdf",
        "text": "https://archive.orkl.eu/878d4b70b00d9a50332dcd0c6965a313e506cfd2.txt",
        "img": "https://archive.orkl.eu/878d4b70b00d9a50332dcd0c6965a313e506cfd2.jpg"
    }
}