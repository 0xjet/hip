{
    "id": "ff168643-1742-4b86-90bb-748acb9013ca",
    "created_at": "2023-01-12T15:03:11.79783Z",
    "updated_at": "2025-03-27T02:06:09.439098Z",
    "deleted_at": null,
    "sha1_hash": "5551cbc41923d3f3430ff8d2a1585b7f617e649c",
    "title": "2019-11-21 - Going Deep - A Guide to Reversing Smoke Loader Malware",
    "authors": "",
    "file_creation_date": "2022-05-27T22:38:23Z",
    "file_modification_date": "2022-05-27T22:38:23Z",
    "file_size": 5371999,
    "plain_text": "# Going Deep | A Guide to Reversing Smoke Loader Malware\n\n**[sentinelone.com/blog/going-deep-a-guide-to-reversing-smoke-loader-malware/](https://www.sentinelone.com/blog/going-deep-a-guide-to-reversing-smoke-loader-malware/)**\n\nNovember 21, 2019\n\nWorking in infosec and supporting clients and SOCs has always exposed me to a huge\nnumber of alerts and incidents. Some of these are more interesting than others. Recently we\n[stumbled across a particular sample of Smoke Loader malware. Smoke Loader has been in-](https://attack.mitre.org/software/S0226/)\nthe-wild since circa 2013 and is often used to distribute additional malicious components or\nartifacts. While the sample is not new, it did prove to be a good opportunity to revisit this\nthreat and walk through some of the internals.\n\n\n-----\n\nThis alert was raised against a suspicious file, classified as a trojan, that was killed and\nquarantined. What raised my curiosity was the number of detections over only a few hours,\nalways from the same workstation, and only from the same user.\n\nKnowing that the threat was killed without doing any harm, I decided to dig into it a bit more.\nJust looking at the [SentinelOne console, I was able to see :](https://www.sentinelone.com/)\n\nThe full path where the detection was made.\nThe associated risk level is High: this implies that it‚Äôs a positive detection.\nFile unique hash that can be tested for any public Indicators of Compromise (IoC).\n\n\n-----\n\nIn order to do a walk-through of malware reverse engineering steps, I downloaded the threat\nfile and started the analysis.\n\n## First Layer: A Packed VB Win32 Program\n\nWith the downloaded file in my pocket, I quickly fired up an isolated analysis machine\n[equipped with the Flare tools and started to investigate. At first glance, the sample appears](https://github.com/fireeye/flare-vm)\nto be a Visual Basic program leveraging Win32 APIs.\n\n\n-----\n\nLet‚Äôs see what else we can get from its headers. Looks like pretty standard information,\nconfirming a Visual Basic program due to its import table.\n\nWe can spot some rude and folkloristic words inside the binary strings, some of which make\nme think of a regional dialect of southern Italy.\n\n\n-----\n\nWith a bit of experience, we can safely assume that the file is packed with an external layer\nof Visual Basic that tries to stop, or at least slow down, static analysis. But what about its\nruntime behavior?\n\nObserving the sample during runtime, we can observe the process injection: this behaviour is\ncommon for VB packers and luckily for us, is often trivial to defeat.\n\n## Defeating Visual Basic Packer\n\nWe won‚Äôt spend too much time on this: there are plenty of resources on how to unpack such\n[packers and I highly recommend the OALabs Youtube video tutorials. It‚Äôs necessary and](https://www.youtube.com/channel/UC--DwaiMV-jtO-6EvmKOnqg)\nenough to put a breakpoint at `CreateProcessInternalW API inside the debugger to stop`\nthe execution at the right time.\n\nAt this point, somewhere in memory, there is a PE file ready to be run. We only need to find\nit. To do so, we can search the entire memory map for a clue: I decided to search for the\n‚ÄúDOS‚Äù substring that can usually be found as part of the ‚ÄúThis program cannot be run in DOS\n_mode‚Äù string within the PE._\n\n\n-----\n\nWe got plenty of results for the string, whose hex is `44 4F 53 .`\n\n\n-----\n\nHowever, we are particularly interested in just a few locations. Usually the executable is\nloaded at `0x00400000 address, so the result we had at` `0x0040006C looks like our`\nexecutable itself.\n\nThings become particularly interesting at `0x002F0094, which we can follow in the memory`\ndump.\n\n\n-----\n\nA memory region with a PE file inside, mapped as Executable, Read, Write. This is definitely\nour injected file.\n\nWe can simply dump out this memory region to file, clean the junk before the MZ header and\nanalyze its headers.\n\n\n-----\n\nIt seems like a legitimate executable, but something is going on: no imports at all. This is\ninteresting!\n\n## Second layer: Static Analysis\n\nWhen we load this new executable in IDA Pro, this was the only chunk of code that was\ndisassembled.\n\n\n-----\n\n-----\n\nHere we recognize that it s a XOR loop that will decode, from address 0x00401567, a blob\nof code with the size of `0xCD bytes with a XOR key equal to` `0xCB . At the end of the loop,`\nthe same starting address `0x00401567 is pushed onto the stack and with the RET`\ninstruction the program flow will be branched over there.\n\n## Decoding the Buffer\n\nWith a little bit of IDA scripting, we can XOR the encrypted buffer and move forward in the\nanalysis.\n\nAfter de-xoring the buffer we are met with a mixture of anti-disassembly and anti-debug\ntechniques. It is now possible to map the purpose of the code blocks.\n\n\n-----\n\n-----\n\nInside this code, we can observe plenty of tricks that try to fool the disassembly flow. A few\nexamples:\n\nAbusing CALL and RET instruction to mess up function boundaries. The CALL\ninstruction will push the return address onto the stack. The RET instruction will then\npop off this address into the EIP register, which effectively makes these two instructions\nuseless. However, these few opcodes make IDA think that the function ends there and\nthat the next instruction is the end of another function.\nAbusing branch instructions that do nothing: CALL `<address> and at` `<address> :`\n**POP** `<reg> . It‚Äôs the easiest way to get an address inside the EIP register and so to`\ncontrol the program‚Äôs flow.\nAbusing JMP instructions: simply putting a lot of JMP instructions that will jump back\nand forth only to make the life of the analyst miserable.\n\nObfuscated with these techniques, the malware checks if it‚Äôs being debugged. The code that\nimplements this check is nothing complicated: it queries certain flags of the PEB in order to\nspot the debugger, `IsDebuggerPresent .`\n```\nmov eax, fs:[30h] ; Process Environment Block\ncmp b [eax+2], 0 ; check BeingDebugged\njne being_debugged\n\n```\nAs said, this code is heavily obfuscated with junk jumps and a lot of instructions with the only\npurpose of increasing complexity of analysis. As an example, this little chunk of code is the\nfinal part of a dozen lines of code used to put value `0x30 inside the EAX register with the`\npurpose of locating the PEB.\n\n\n-----\n\n-----\n\nAt the end of this function, we spot another XOR stub decoding routine that will decode\nanother blob of code and, after that, redirect the execution flow. Decoding will start at\naddress `0x004014E8, with a buffer size of` `0x7F and the same XOR key` `0xCB .`\n\nAs before, we can proceed in the static analysis, manually decoding this buffer with the same\nscript.\n\nBut wait! Here we go again, another anti-debugging trick, `NtGlobalFlag check:`\n\n\n-----\n\n```\nmov eax, fs:[30h] ; Process Environment Block\nmov al, [eax+68h] ; NtGlobalFlag\nand al, 70h\ncmp al, 70h\nje being_debugged\n\n```\n[This chunk of code checks if the process is attached to a debugger and, if it goes well,](https://www.aldeid.com/wiki/PEB-Process-Environment-Block/NtGlobalFlag)\nanother XOR decoding stub starts from address `0x00401000, with buffer size` `0x4E8 and`\n**XOR key** `0xCB .`\n\n\n-----\n\nAfter decoding the new buffer, we need to face another anti-disassembly trick; namely, JMP\ninstructions with a constant value. This is the most common trick used by malware to fool\nstatic analysis. Basically, it creates jumps into a new location plus one or a few bytes. It\nresults in an erroneous interpretation of the opcode by the disassembler. It‚Äôs [trivial to defeat](https://www.techbliss.org/threads/anti-disassembly-techniques-used-by-malware-a-primer-by-rahul-nair.804/)\nbut time intensive.\n\n## IAT Resolution at Runtime\n\nAt address `0x00401000 there‚Äôs a simple call to another address` `0x00401049, where it`\nstarts to become interesting as the malware appears to dynamically resolve its imports. As\nwe noted before, the binary header analysis showed no imports at all. With this code, from\nthe PEB location found earlier, the malware finds the base address of `ntdll.dll .`\n\nBut how is this happening? In all recent Windows versions, the GS register points to a data\nstructure called the Thread Environment Block (TEB). At offset `0x30 of the TEB, there‚Äôs`\nanother data structure, namely the Process Environment Block (PEB) we saw earlier.\n\n[We can inspect these data structures with the help of Microsoft public symbols and WinDBG.](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools)\n\nWith the same tools we can inspect the PEB too:\n\n\n-----\n\nWith the third instruction, we are following the offset `0x0C, the` `_PEB_LDR_DATA`\nstructure. This structure is fairly important because it contains a pointer,\n```\nInInitializationOrderModuleList, to the head of a double-linked list that contains the\n\n```\nNTDLL loader data structures for the loaded modules.\n\n[Each item in the list is a pointer to an LDR_DATA_TABLE_ENTRY structure. If we inspect](https://docs.microsoft.com/it-it/windows/win32/api/winternl/ns-winternl-peb_ldr_data?redirectedfrom=MSDN)\nthis structure, we get the `DLLBase .`\n\n\n-----\n\nLooking at this inside the debugger helps to shed some light:\n\n\n-----\n\nWe got the base address of module `ntdll.dll into EDX register, because this is the first`\nmodule loaded into every process in a Windows environment. We have added comments\nand renamed select functions to clear up some of the observables.\n\nAfter the malware gets the `ntdll.dll base address, it loops twice calling a function`\nnamed `DecryptionFunction . This function receives as input a dword, which here is a`\n[hash. As we‚Äôre going to see, it will walk the Export Address Table of the module searching](https://www.sentinelone.com/blog/what-is-hash-how-does-it-work/)\nfor a particular function with the name matching to the passed hash. With this first loop, the\nmalware finds two functions: `strstr and` `LdrGetDllHandle .`\n\nAs an example, in this particular case, the `DecryptionFunction is walking, as we`\nexplained before for `ntdll.dll, the module` `kernel32.dll, retrieving the address of`\n```\nVirtualAlloc put inside the EAX register as return value.\n\n```\n\n-----\n\n## DecryptionFunction\n\nAfter fully disassembling the function(s) we have the following:\n\n\n-----\n\nThe hashes of the resolved and imported functions appear as follows:\n\n\n-----\n\nAfter using the debugger to step into the loops of the `DecryptionFunction, we were able`\nto find what functions the malware uses next.\n\nThis part of the executable almost works the same way through libraries and functions. I\nhighly suggest looking at the disassembly line by line to understand the inner working of the\nWindows Internal Subsystem and API calls.\n\nAnother interesting trick to be even more stealthy is the use of stack strings to build calls to\n```\nLoadLibraryA . The secret here is that, by definition, the CALL instruction pushes the next\n\n```\naddress onto the stack as the return address. But this address is an ASCII null terminated\nstring that will be an argument for the next `LoadLibraryA call. Here you can see how it`\nloads two libraries: `advapi32 and` `user32 .`\n\n\n-----\n\nImmediately after resolving the imports, the malware sleeps for 10 seconds and then\nretrieves a filename via `GetModuleFileNameA .`\n\n\n-----\n\nInterestingly, the image above also shows how the code checks if its own name contains the\nstring ‚Äúsample‚Äù and if so consequently terminates itself. You can see how the call to the\n```\nstrstr function is built and how the previous push is given to check for the ‚Äúsample‚Äù string.\n\n```\nIt‚Äôs a simple anti-analysis technique that might easily catch you out. Protip: do not call your\nsample ‚Äúsample‚Äù. üôÇ\n\nNext, the malware performs another check via `GetVolumeInformationA, which is`\n[thoroughly documented in MSDN. Let‚Äôs look inside this call to understand its purpose.](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationa)\n\n\n-----\n\nFrom the above disassembly, we can see that it retrieves the volume serial number and\nchecks if it‚Äôs equal to some two serials. It then opens a registry key with `RegOpenKeyExA,`\npushing one of the arguments with the same CALL technique. It then obtains the value of\nthe registry key, closes the handle, and converts the value to lowercase before proceeding.\n\n\n-----\n\nIt looks clear when you see it in the debugger.\n\n\n-----\n\nWith this string saved somewhere in memory, the code goes on to perform some other\nchecks trying to find any sign of running inside a virtual environment.\n\nAs part of the anti-virtual machine checks, it initializes a 4 cycle loop; during this loop it\nperforms a call to the `strstr function to search inside the retrieved registry value for any`\nsign of the strings: ‚Äúqemu‚Äù, ‚Äúvirtual‚Äù, ‚Äúvmware‚Äù, ‚Äúxen‚Äù. If you notice in the previous debugger\n\n\n-----\n\nscreenshot, I m running the sample inside a VMWare machine, so to continue I will need to\npatch the return value of `strstr function calls to return zero.`\n\nOther checks are waiting:\n\nAs you can see, the malware tries to understand if it‚Äôs being debugged or executed inside a\n[sandbox by trying to get a handle to modules sbiedll and](https://www.sandboxie.com/SBIE_DLL_API) [dbghelp. If it‚Äôs able to detect one of](https://docs.microsoft.com/en-us/windows/win32/debug/debug-help-library)\nthese two libraries, it terminates the process and exits.\n\n## Finally, The Payload!\n\nHaving passed all sorts of anti-analysis and anti-debugging checks, we finally reach the\npayload! Now, the malware begins to reveal its secrets in memory.\n\n\n-----\n\nWe can clearly see it‚Äôs a PE file, but it‚Äôs scrambled somehow. This code will be decoded and\nmanaged in memory with a complex routine.\n\n\n-----\n\nDigging into this code will require more time and effort than the analyst will normally want to\nexpend. Instead, we can detonate the malware in our isolated environment and observe its\nexecution. As we will see in the next post, this will reveal that a new instance of\n```\nsvchost.exe is loaded into memory, which suggests some sort of process injection. If you\n\n```\nenjoyed this deep dive and would like to know when the next Going Deep post is available,\njust subscribe to the SentinelOne blog newsletter!\n\n**IOCs**\n\nSample Hash `07e81dfc0a01356fd96f5b75efe3d1b1bc86ade4`\n\n**MITRE ATT&CK**\n\n[Smoke Loader {S0226}](https://attack.mitre.org/software/S0226/)\n\n[Virtualization/Sandbox Evasion {T1497}](https://attack.mitre.org/techniques/T1497/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-11-21 - Going Deep - A Guide to Reversing Smoke Loader Malware.pdf"
    ],
    "report_names": [
        "2019-11-21 - Going Deep - A Guide to Reversing Smoke Loader Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535791,
    "ts_updated_at": 1743041169,
    "ts_creation_date": 1653691103,
    "ts_modification_date": 1653691103,
    "files": {
        "pdf": "https://archive.orkl.eu/5551cbc41923d3f3430ff8d2a1585b7f617e649c.pdf",
        "text": "https://archive.orkl.eu/5551cbc41923d3f3430ff8d2a1585b7f617e649c.txt",
        "img": "https://archive.orkl.eu/5551cbc41923d3f3430ff8d2a1585b7f617e649c.jpg"
    }
}