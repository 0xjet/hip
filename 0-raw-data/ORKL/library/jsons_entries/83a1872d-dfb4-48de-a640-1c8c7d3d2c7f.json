{
    "id": "83a1872d-dfb4-48de-a640-1c8c7d3d2c7f",
    "created_at": "2023-01-12T15:08:36.529532Z",
    "updated_at": "2025-03-27T02:14:42.816158Z",
    "deleted_at": null,
    "sha1_hash": "4bcdf63a3de2075b4c4a8d3f273c05e6b8b0b691",
    "title": "2018-03-01 - FinFisher exposed- A researcher’s tale of defeating traps, tricks, and complex virtual machines",
    "authors": "",
    "file_creation_date": "2022-05-28T21:56:05Z",
    "file_modification_date": "2022-05-28T21:56:05Z",
    "file_size": 1395139,
    "plain_text": "# FinFisher exposed: A researcher’s tale of defeating traps, tricks, and complex virtual machines\n\n**cloudblogs.microsoft.com/microsoftsecure/2018/03/01/finfisher-exposed-a-researchers-tale-of-defeating-traps-tricks-and-complex-virtual-**\nmachines/\n\nMarch 1, 2018\n\n[Office 365 Advanced Threat Protection (Office 365 ATP) blocked many notable zero-day exploits in 2017. In our](https://products.office.com/en-us/exchange/online-email-threat-protection?ocid=cx-blog-mmpc)\n[analysis, one activity group stood out: NEODYMIUM. This threat actor is remarkable for two reasons:](https://blogs.technet.microsoft.com/mmpc/2016/12/14/twin-zero-day-attacks-promethium-and-neodymium-target-individuals-in-europe/)\n\nIts access to sophisticated zero-day exploits for Microsoft and Adobe software\nIts use of an advanced piece of government-grade surveillance spyware FinFisher, also known as FinSpy\n[and detected by Microsoft security products as Wingbird](https://www.microsoft.com/en-us/wdsi/threats/malware-encyclopedia-description?Name=Backdoor:Win32/Wingbird.A!dha)\n\nFinFisher is such a complex piece of malware that, like other researchers, we had to devise special methods to\ncrack it. We needed to do this to understand the techniques FinFisher uses to compromise and persist on a\nmachine, and to validate the effectiveness of Office 365 ATP detonation sandbox, Windows Defender Advanced\n[Threat Protection (Windows Defender ATP) generic detections, and other Microsoft security solutions.](https://www.microsoft.com/en-us/windowsforbusiness/windows-atp?ocid=cx-blog-mmpc)\n\nThis task proved to be nontrivial. FinFisher is not afraid of using all kinds of tricks, ranging from junk instructions\nand “spaghetti code” to multiple layers of virtual machines and several known and lesser-known anti-debug and\ndefensive measures. Security analysts are typically equipped with the tools to defeat a good number of similar\ntricks during malware investigations. However, FinFisher is in a different category of malware for the level of its\nanti-analysis protection. It’s a complicated puzzle that can be solved by skilled reverse engineers only with good\namount of time, code, automation, and creativity. The intricate anti-analysis methods reveal how much effort the\nFinFisher authors exerted to keep the malware hidden and difficult to analyze.\n\nThis exercise revealed tons of information about techniques used by FinFisher that we used to make Office 365\nATP more resistant to sandbox detection and Windows Defender ATP to catch similar techniques and generic\nbehaviors. Using intelligence from our in-depth investigation, Windows Defender ATP can raise alerts for\nmalicious behavior employed by FinFisher (such as memory injection in persistence) in different stages of the\nattack kill chain. [Machine learning in Windows Defender ATP further flags suspicious behaviors observed related](https://cloudblogs.microsoft.com/microsoftsecure/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/)\nto the manipulation of legitimate Windows binaries.\n\n\n-----\n\n_Figure 1. Generic Windows Defender ATP detections trigger alerts on FinFisher behavior_\n\nWhile our analysis has allowed us to immediately protect our customers, we’d like to share our insights and add\nto the growing number of published analyses by other talented researchers (listed below this blog post). We hope\nthat this blog post helps other researchers to understand and analyze FinFisher samples and that this industrywide information-sharing translate to the protection of as many customers as possible.\n\n## Spaghetti and junk codes make common analyst tools ineffective\n\nIn analyzing FinFisher, the first obfuscation problem that requires a solution is the removal of junk instructions\nand “spaghetti code”, which is a technique that aims to confuse disassembly programs. Spaghetti code makes\nthe program flow hard to read by adding continuous code jumps, hence the name. An example of FinFisher’s\nspaghetti code is shown below.\n\n\n-----\n\n_Figure 2. The spaghetti code in FinFisher dropper_\n\nThis problem is not novel, and in common situations there are known reversing plugins that may help for this\ntask. In the case of FinFisher, however, we could not find a good existing interactive disassembler (IDA) plugin\nthat can normalize the code flow. So we decided to write our own plugin code using IDA Python. Armed with this\ncode, we removed this first layer of anti-analysis protection.\n\nRemoving the junk instructions revealed a readable block of code. This code starts by allocating two chunks of\nmemory: a global 1 MB buffer and one 64 KB buffer per thread. The big first buffer is used as index for multiple\nconcurrent threads. A big chunk of data is extracted from the portable executable (PE) file itself and decrypted\ntwo times using a custom XOR algorithm. We determined that this chunk of data contains an array of opcode\ninstructions ready to be interpreted by a custom virtual machine program (from this point on referenced\ngenerically as “VM”) implemented by FinFisher authors.\n\n\n-----\n\n_Figure 3. The stages of the FinFisher multi layered protection mechanisms_\n\n## Stage 0: Dropper with custom virtual machine\n\nThe main dropper implements the VM dispatcher loop and can use 32 different opcodes handlers. Th 64KB\nbuffer is used as a VM descriptor data structure to store data and the just-in-time (JIT) generated code to run.\nThe VM dispatcher loop routine ends with a JMP to another routine. In total, there are 32 different routines, each\nof them implementing a different opcode and some basic functionality that the malware program may execute.\n\n_Figure 4. A snapshot of the code that processes each VM opcode and the associate interpreter_\n\nThe presence of a VM and virtualized instruction blocks can be described in simpler terms: Essentially, the\ncreators of FinFisher interposed a layer of dynamic code translation (the virtual machine) that makes analysis\nusing regular tools practically impossible. Static analysis tools like IDA may not be useful in analyzing custom\ncode that is interpreted and executed through a VM and a new set of instructions. On the other hand, dynamic\nanalysis tools (like debuggers or sandbox) face the anti-debug and anti-analysis tricks hidden in the virtualized\ncode itself that detects sandbox environments and alters the behavior of the malware.\n\nAt this stage, the analysis can only continue by manually investigating the individual code blocks and opcode\nhandlers, which are highly obfuscated (also using spaghetti code). Reusing our deobfuscation tool and some\nother tricks, we have been able to reverse and analyze these opcodes and map them to a finite list that can be\nused later to automate the analysis process with some scripting.\n\nThe opcode instructions generated by this custom VM are divided into different categories:\n\n1. Logical opcodes, which implement bit-logic operators (OR, AND, NOT, XOR) and mathematical operators\n2. Conditional branching opcodes, which implement a code branch based on conditions (equals to JC, JE, JZ,\n\nother similar branching opcodes)\n3. Load/Store opcodes, which write to or read from particular addresses of the virtual address space of the\n\nprocess\n4. Specialized opcodes for various purposes, like execute specialized machine instruction that are not\n\nvirtualized\n\nWe are publishing below the (hopefully) complete list of opcodes used by FinFisher VM that we found during our\nanalysis and integrated into our de-virtualization script:\n\n\n-----\n\n**INDEX** **MNEMONIC** **DESCRIPTION**\n\n0x0 EXEC Execute machine code\n\n0x1 JG Jump if greater/Jump if not less or equal\n\n0x2 WRITE Write a value into the dereferenced internal VM value (treated as a pointer)\n\n0x3 JNO Jump if not overflow\n\n0x4 JLE Jump if less or equal (signed)\n\n0x5 MOV Move the value of a register into the VM descriptor (same as opcode 0x1F)\n\n0x6 JO Jump if overflow\n\n0x7 PUSH Push the internal VM value to the stack\n\n0x8 ZERO Reset the internal VM value to 0 (zero)\n\n0x9 JP Jump if parity even\n\n0xA WRITE Write into an address\n\n0xB ADD Add the value of a register to the internal VM value\n\n0xC JNS Jump if not signed\n\n0xD JL Jump if less (signed)\n\n0xE EXEC Execute machine code and branch\n\n0xF JBE Jump if below or equal or Jump if not above\n\n0x10 SHL Shift left the internal value the number of times specified into the opcodes\n\n0x11 JA Jump if above/Jump if not below or equal\n\n0x12 MOV Move the internal VM value into a register\n\n0x13 JZ JMP if zero\n\n0x14 ADD Add an immediate value to the internal Vm descriptor\n\n0x15 JB Jump if below (unsigned)\n\n0x16 JS Jump if signed\n\n0x17 EXEC Execute machine code (same as opcode 0x0)\n\n0x18 JGE Jump if greater or equal/Jump if not less\n\n0x19 DEREF Write a register value into a dereferenced pointer\n\n0x1A JMP Special obfuscated “Jump if below” opcode\n\n0x1B - Resolve a pointer\n\n0x1C LOAD Load a value into the internal VM descriptor\n\n0x1D JNE Jump if not equal/Jump if not zero\n\n0x1E CALL Call an external function or a function located in the dropper\n\n\n-----\n\n0x1F MOV Move the value of a register into the VM descriptor\n\n0x20 JNB Jump if not below/Jump if above or equal/Jump if not carry\n\n0x21 JNP Jump if not parity/Jump if parity odd\n\nEach virtual instruction is stored in a special data structure that contains all the information needed to be properly\nread and executed by the VM. This data structure is 24 bytes and is composed of some fixed fields and a\nvariable portion that depends on the opcode. Before interpreting the opcode, the VM decrypts the opcode’s\ncontent (through a simple XOR algorithm), which it then relocates (if needed), using the relocation fields.\n\nHere is an approximate diagram of the opcode data structure:\n\n_Figure 5. A graphical representation of the data structure used to store each VM opcode_\n\nThe VM handler is completely able to generate different code blocks and deal with relocated code due to address\nspace layout randomization (ASLR). It is also able to move code execution into different locations if needed. For\ninstance, in the case of the “Execute” opcode (0x17), the 32-bit code to run is stored entirely into the variable\nsection with the value at offset 5 specifying the number of bytes to be copied and executed. Otherwise, in the\ncase of conditional opcodes, the variable part can contain the next JIT packet ID or the next relative virtual\naddress (RVA) where code execution should continue.\n\nOf course, not all the opcodes are can be easily read and understood due to additional steps that the authors\nhave taken to make analysis extremely complicated. For example, this is how opcode 0x1A is implemented: The\nopcode should represent a JB (Jump if below) function, but it’s implemented through set carry (STC) instruction\nfollowed by a JMP into the dispatcher code that will verify the carry flag condition set by STC.\n\n_Figure 6. One of the obfuscation tricks included by the malware authors in a VM opcode dispatcher_\n\nEven armed with the knowledge we have described so far, it still took us many hours to write a full-fledged\nopcode interpreter that’s able to reconstruct the real code executed by FinFisher.\n\n## Stage 1: Loader malware keeps sandbox and debuggers away\n\n\n-----\n\nThe first stage of FinFisher running through this complicated virtual machine is a loader malware designed to\nprobe the system and determine whether it’s running in a sandbox environment (typical for cloud-based\ndetonation solution like Office 365 ATP).\n\nThe loader first dynamically rebuilds a simple import address table (IAT), resolving all the API needed from\nKernel32 and NtDll libraries. It then continues executing in a spawned new thread that checks if there are\nadditional undesired modules inside its own virtual address space (for example, modules injected by certain\nsecurity solutions). It eventually kills all threads that belong to these undesired modules (using\n_ZwQueryInformationThread native API with ThreadQuerySetWin32StartAddress information class)._\n\nThe first anti-sandbox technique is the loader checking the code segment. If it’s not 0x1B (for 32-bit systems) or\n_0x23 (for 32-bit system under Wow64), the loader exits._\n\nNext, the dropper checks its own parent process for indications that it is running in a sandbox setup. It calculates\nthe MD5 hash of the lower-case process image name and terminates if one of the following conditions are met:\n\n1. The MD5 hash of the parent process image name is either D0C4DBFA1F3962AED583F6FCE666F8BC or\n\n3CE30F5FED4C67053379518EACFCF879\n2. The parent process’s full image path is equal to its own process path\n\nIf these initial checks are passed, the loader builds a complete IAT by reading four imported libraries from disk\n(ntdll.dll, kernel32.dll, advapi32.dll, and version.dll) and remapping them in memory. This technique makes use of\ndebuggers and software breakpoints useless. During this stage, the loader may also call a certain API using\nnative system calls, which is another way to bypass breakpoints on API and security solutions using hooks.\n\n_Figure 7. FinFisher loader calling native Windows API to perform anti-debugging tricks_\n\nAt this point, the fun in analysis is not over. A lot of additional anti-sandbox checks are performed in this exact\norder:\n\n1. Check that the malware is not executed under the root folder of a drive\n2. Check that the malware file is readable from an external source\n3. Check that the hash of base path is not 3D6D62AF1A7C8053DBC8E110A530C679\n4. Check that the full malware path contains only human readable characters (“a-z”, “A-Z”, and “0-9”)\n5. Check that no node in the full path contains the MD5 string of the malware file\n\n\n-----\n\n6. Fingerprint the system and check the following registry values:\n\n1. HKLM\\SOFTWARE\\Microsoft\\Cryptography\\MachineGuid should not be “6ba1d002-21ed-4dbe-afb5\n08cf8b81ca32”\n2. HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\DigitalProductId should not be “55274\n649-6478953-23109”, “A22-00001”, or “47220”\n3. HARDWARE\\Description\\System\\SystemBiosDate should not contain “01/02/03”\n7. Check that the mutex WininetStartupMutex0 does not already exist\n8. Check that no DLL whose base name has hash value of 0xC9CEF3E4 is mapped into the malware address\n\nspace\n\nThe hashes in these checks are most likely correspond to sandbox or security products that the FinFisher\nauthors want to avoid.\n\nNext, the loader checks that it’s not running in a virtualized environment (VMWare or Hyper-V) or under a\ndebugger. For the hardware virtualization check, the loader obtains the hardware device list and checks if the\nMD5 of the vendor ID is equal to a predefined list. In our tests, the malware sample was able to easily detect both\nVMWare and Hyper-V environments through the detection of the virtualized peripherals (for example, Vmware\nhas VEN_15AD as vendor ID, HyperV has VMBus as bus name). Office 365 ATP sandbox employs special\nmechanisms to avoid being detected by similar checks.\n\nThe loader’s anti-debugger code is based on the following three methods:\n\n1. The first call aims to destroy the debugger connection:\n\nNOTE: This call completely stops the execution of WinDbg and other debuggers\n\n1. The second call tries to detect the presence of a debugger:\n\n1. The final call tries to destroy the possibility of adding software breakpoint:\n\nFinally, if the loader is happy with all the checks done so far, based on the victim operating system (32 or 64-bit) it\nproceeds to decrypt a set of fake bitmap resources (stage 2) embedded in the executable and prepares the\nexecution of a new layer of VM decoding.\n\nEach bitmap resource is extracted, stripped of the first 0x428 bytes (BMP headers and garbage data), and\ncombined into one file. The block is decrypted using a customized algorithm that uses a key derived from the\noriginal malware dropper’s TimeDateStamp field multiplied by 5.\n\n\n-----\n\n_Figure 8. The fake bitmap image embedded as resource_\n\nThe 32-bit stage 2 malware uses a customized loading mechanism (i.e., the PE file has a scrambled IAT and\nrelocation table) and exports only one function. For the 64-bit stage 2 malware, the code execution is transferred\n[from the loader using a well-known technique called Heaven’s Gate. In the next sections, for simplicity, we will](https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html)\ncontinue the analysis only on the 64-bit payload.\n\n_Figure 9. Heaven’s gate is still in use in 2017_\n\n## Stage 2: A second multi-platform virtual machine\n\nThe 64-bit stage 2 malware implements another loader combined with another virtual machine. The architecture\nis quite similar to the one described previously, but the opcodes are slightly different. After reversing these\nopcodes, we were able to update our interpreter script to support both 32-bit and 64-bit virtual machines used by\nFinFisher.\n\n**INDEX** **MNEMONIC** **DESCRIPTION**\n\n0x0 JMP Special obfuscated conditional Jump (always taken or always ignored)\n\n0x1 JMP Jump to a function (same as opcode 0x10)\n\n0x2 CALL Call to the function pointed by the internal VM value\n\n0x3 CALL Optimized CALL function (like the 0x1E opcode of the 32-bit VM)\n\n0x4 EXEC Execute code and move to the next packet\n\n0x5 JMP Jump to an internal function\n\n0x6 NOP No operation, move to the next packet\n\n\n-----\n\n0x7 CALL Call an imported API (whose address is stored in the internal VM value)\n\n0x8 LOAD Load a value into the VM descriptor structure *\n\n0x9 STORE Store the internal VM value inside a register\n\n0xA WRITE Resolve a pointer and store the value of a register in its content\n\n0xB READ Move the value pointed by the VM internal value into a register\n\n0xC LOAD Load a value into the VM descriptor structure (not optimized)\n\n0xD CMP Compare the value pointed by the internal VM descriptor with a register\n\n0xE CMP Compare the value pointed by the internal VM descriptor with an immediate value\n\n0xF XCHG Exchange the value pointed by the internal VM descriptor with a register\n\n0x10 SHL Jump to a function (same as opcode 0x1)\n\nThis additional virtual machine performs the same duties as the one already described but in a 64-bit\nenvironment. It extracts and decrypts the stage 3 malware, which is stored in encrypted resources such as fake\ndialog boxes. The extraction method is the same, but the encryption algorithm (also XOR) is much simpler. The\nnew payload is decrypted, remapped, and executed in memory, and represents the installation and persistence\nstage of the malware.\n\n## Stage 3: Installer that takes DLL side-loading to a new level\n\nStage 3 represents the setup program for FinFisher. It is the first plain stage that does not employ a VM or\nobfuscation. The code supports two different installation methods: setup in a UAC-enforced environment (with\nlimited privileges), or an installation with full-administrative privileges enabled (in cases where the malware gains\nthe ability to run with elevated permissions). We were a bit disappointed that we did not see traces of a true\nprivilege escalation exploit after all this deobfuscation work, but it seems these FinFisher samples were designed\nto work just using UAC bypasses.\n\nThe setup code receives an installation command from the previous stage. In our test, this command was the\nvalue 3. The malware creates a global event named 0x0A7F1FFAB12BB2 and drops some files under a folder\nlocated in C:\\ProgramData or in the user application data folder. The name of the folder and the malware\nconfiguration are read from a customized configuration file stored in the resource section of the setup program.\n\nHere the list of the files potentially dropped during the installation stage:\n\n**FILE NAME** **STAGE** **DESCRIPTION**\n\nd3d9.dll Stage 4 Malware loader used for UAC environments with limited privileges; also\nprotected by VM obfuscation\n\n\naepic.dll, sspisrv.dll,\nuserenv.dll\n\n\nStage 4 Malware loader used in presence of administrative privileges; executed from\n(and injected into) a fake service; also protected by VM obfuscation\n\n\nmsvcr90.dll Stage 5 Malware payload injected into the explorer.exe or winlogon.exe process;\nalso protected by VM obfuscation\n\n<randomName>.cab Config Main configuration file; encrypted\n\nsetup.cab Unknown Last section of the setup executable; content still unknown\n\n<randomName>.7z Plugin Malware plugin used to spy the victim network communications\n\n\n-----\n\nwsecedit.rar Stage 6 Main malware executable\n\nAfter writing some of these files, the malware decides which kind of installation to perform based on the current\nprivilege provided by the hosting process (for example, if a Microsoft Office process was used as exploit vector):\n\n1. Installation process under UAC\n\nWhen running under a limited UAC account, the installer extracts d3d9.dll and creates a persistence key under\n_HKCU\\Software\\Microsoft\\Windows\\Run. The malware sets a registry value (whose name is read from the_\nconfiguration file) to “C:\\Windows\\system32\\rundll32.exe c:\\ProgramData\\AuditApp\\d3d9.dll, Control_Run”.\nBefore doing this, the malware makes a screenshot of the screen and displays it on top of all other windows for\nfew seconds. This indicates that the authors are trying to hide some messages showed by the system during the\nsetup process.\n\nWhen loaded with startup command 2, the installer can copy the original explorer.exe file inside its current\nrunning directory and rename d3d9.dll to uxtheme.dll. In this case the persistence is achieved by loading the\noriginal explorer.exe from its startup location and, using DLL side-loading, passing the execution control to the\nstage 4 malware (discussed in next section).\n\nFinally, the malware spawns a thread that has the goal to load, remap, and relocate the stage 5 malware. In this\ncontext, there is indeed no need to execute the stage 4 malware. The msvcr90.dll file is opened, read, and\ndecrypted, and the code execution control is transferred to the RunDll exported routine.\n\nIn the case of 32-bit systems, the malware may attempt a known UAC bypass by launching printui.exe system\nprocess and using token manipulation with NtFilterToken as described in this blog post.\n\n1. Installation process with administrative privilege\n\nThis installation method is more interesting because it reveals how the malware tries to achieve stealthier\npersistence on the machine. The method is a well-known trick used by penetration testers that was automated\nand generalized by FinFisher\n\nThe procedure starts by enumerating the KnownDlls object directory and then scanning for section objects of the\ncached system DLLs. Next, the malware enumerates all .exe programs in the %System% folder and looks for an\noriginal signed Windows binary that imports from at least one KnownDll and from a library that is not in the\n_KnownDll directory. When a suitable .exe file candidate is found, it is copied into the malware installation folder_\n(for example, C:\\ProgramData). At this point the malware extracts and decrypts a stub DLL from its own\nresources (ID 101). It then calls a routine that adds a code section to a target module. This section will contain a\nfake export table mimicking the same export table of the original system DLL chosen. At the time of writing, the\ndropper supports aepic.dll, sspisrv.dll, ftllib.dll, and userenv.dll to host the malicious FinFisher payload. Finally, a\nnew Windows service is created with the service path pointing to the candidate .exe located in this new directory\ntogether with the freshly created, benign-looking DLL.\n\nIn this way, when the service runs during boot, the original Windows executable is executed from a different\nlocation and it will automatically load and map the malicious DLL inside its address space, instead of using the\ngenuine system library. This routine is a form of generic and variable generator of DLL side-loading\ncombinations.\n\n\n-----\n\n_Figure 10. Windows Defender ATP timeline can pinpoint the service DLL side-loading trick (in this example, using_\n_fltlib.dll)._\n\nIn the past, we have seen other activity groups like LEAD employ a similar attacker technique named “proxylibrary” to achieve persistence, but not with this professionalism. The said technique brings the advantage of\navoiding auto-start extensibility points (ASEP) scanners and programs that checks for binaries installed as\nservice (for the latter, the service chosen by FinFisher will show up as a clean Windows signed binary).\n\nThe malware cleans the system event logs using OpenEventLog/ClearEventLog APIs, and then terminates the\nsetup procedure with a call to StartService to run the stage 4 malware.\n\n\n-----\n\n_Figure 11. The DLL side-loaded stage 4 malware mimicking a real export table to avoid detection_\n\n## Stage 4: The memory loader – Fun injection with GDI function hijacking\n\nDepending on how stage 4 was launched, two different things may happen:\n\nIn the low-integrity case (under UAC) the installer simply injects the stage 5 malware into the bogus\n_explorer.exe process started earlier and terminates_\nIn the high-integrity case (with administrative privileges or after UAC bypass), the code searches for the\nprocess hosting the Plug and Play service (usually svchost.exe) loaded in memory and injects itself into it\n\nFor the second scenario, the injection process works like this:\n\n1. The malware opens the target service process.\n2. It allocates and fills four chunks of memory inside the service process. One chunk contains the entire\n\nmalware DLL code (without PE headers). Another chunk is used to copy a basic Ntdll and Kernel32 import\naddress table. Two chunks are filled with an asynchronous procedure call (APC) routine code and a stub.\n3. It opens the service thread of the service process and uses the ZwQueueApcThread native API to inject an\n\nAPC.\n\nThe APC routine creates a thread in the context of the svchost.exe process that will map and execute the stage 5\nmalware into the winlogon.exe process.\n\nThe injection method used for winlogon.exe is also interesting and quite unusual. We believe that this method is\nengineered to avoid trivial detection of process injection using the well-detected CreateRemoteThread or\n_ZwQueueApcThread API._\n\nThe malware takes these steps:\n\n1. Check if the system master boot record (MBR) contains an infection marker (0xD289C989C089 8-bytes\n\nvalue at offset 0x2C), and, if so, terminate itself\n2. Check again if the process is attached to a debugger (using the techniques described previously)\n3. Read, decrypt, and map the stage 5 malware (written in the previous stage in msvcr90.dll)\n4 Open winlogon exe process\n\n\n-----\n\n5. Load user32.dll system library and read the KernelCallbackTable pointer from its own process environment\n\nblock (PEB) (Note: The KernelCallbackTable points to an array of graphic functions used by Win32 kernel\nsubsystem module win32k.sys as call-back into user-mode.)\n6. Calculate the difference between this pointer and the User32 base address.\n7. Copy the stage 5 DLL into winlogon.exe\n8. Allocate a chunk of memory in winlogon.exe process and copy the same APC routine seen previously\n9. Read and save the original pointer of the __fnDWORD internal User32 routine (located at offset +0x10 of\n\nthe KernelCallbackTable) and replace this pointer with the address of the APC stub routine\n\nAfter this function pointer hijacking, when winlogon.exe makes any graphical call (GDI), the malicious code can\nexecute without using CreateRemoteThread or similar triggers that are easily detectable. After execution it takes\ncare of restoring the original KernelCallbackTable.\n\n## Stage 5: The final loader takes control\n\nThe stage 5 malware is needed only to provide one more layer of obfuscation, through the VM, of the final\nmalware payload and to set up a special Structured Exception Hander routine, which is inserted as\n_Wow64PrepareForException in Ntdll. This special exception handler is needed to manage some memory buffers_\nprotection and special exceptions that are used to provide more stealthy execution.\n\nAfter the VM code has checked again the user environment, it proceeds to extract and execute the final unobfuscated payload sample directly into winlogon.exe (alternatively, into explorer.exe) process. After the payload\nis extracted, decrypted, and mapped in the process memory, the malware calls the new DLL entry point, and then\nthe RunDll exported function. The latter implements the entire spyware program.\n\n## Stage 6: The payload is a modular spyware framework for further analysis\n\nOur journey to deobfuscating FinFisher has allowed us to uncover the complex anti-analysis techniques used by\nthis malware, as well as to use this intel to protect our customers, which is our top priority. Analysis of the\nadditional spyware modules is future work.\n\nIt is evident that the ultimate goal of this program is to steal information. The malware architecture is modular,\nwhich means that it can execute plugins. The plugins are stored in its resource section and can be protected by\nthe same VM. The sample we analyzed in October, for example, contains a plugin that is able to spy on internet\nconnections, and can even divert some SSL connections and steal data from encrypted traffic.\n\n[Some FinFisher variants incorporate an MBR rootkit, the exact purpose of which is not clear. Quite possibly, this](http://artemonsecurity.blogspot.com/2017/01/finfisher-rootkit-analysis.html)\nroutine targets older platforms like Windows 7 and machines not taking advantage of hardware protections like\nUEFI and SecureBoot, available on Windows 10. Describing this additional piece of code in detail is outside the\nscope of this analysis and may require a new dedicated blog post.\n\n## Defense against FinFisher\n\nExposing as much of FinFisher’s riddles as possible during this painstaking analysis has allowed us to ensure\nour customers are protected against this advanced piece of malware.\n\n[Windows 10 S devices are naturally protected against FinFisher and other threats thanks to the strong code](https://www.microsoft.com/en-us/windows/windows-10-s?ocid=cx-blog-mmpc)\nintegrity policies that don’t allow unknown unsigned binaries to run (thus stopping FinFisher’s PE installer) or\n[loaded (blocking FinFisher’s DLL persistence). On Windows 10, similar code integrity policies can be configured](https://www.microsoft.com/en-us/windows/get-windows-10?ocid=cx-blog-mmpc)\nusing [Windows Defender Application Control.](https://cloudblogs.microsoft.com/microsoftsecure/2017/10/23/introducing-windows-defender-application-control/)\n\n\n-----\n\n[Office 365 Advanced Threat Protection secures mailboxes from email campaigns that use zero day exploits to](https://products.office.com/en-us/exchange/online-email-threat-protection?ocid=cx-blog-mmpc)\ndeliver threats like FinFisher. Office 365 ATP blocks unsafe attachments, malicious links, and linked-to files using\ntime-of-click protection. Using intel from this research, we have made Office 365 ATP more resistant to\nFinFisher’s anti-sandbox checks.\n\nGeneric detections, advanced behavioral analytics, and machine learning technologies in Windows Defender\nAdvanced Threat Protection detect FinFisher’s malicious behavior throughout the attack kill chain and alert\nSecOps personnel. Windows Defender ATP also integrates with the Windows protection stack so that protections\nfrom [Windows Defender AV and](https://www.microsoft.com/en-us/windows/windows-defender?ocid=cx-blog-mmpc) [Windows Defender Exploit Guard are reported in Windows Defender ATP portal,](https://blogs.technet.microsoft.com/mmpc/2017/10/23/windows-defender-exploit-guard-reduce-the-attack-surface-against-next-generation-malware/)\nenabling SecOps personnel to centrally manage security, and as well as promptly investigate and respond to\nhostile activity in the network.\n\nWe hope that this writeup of our journey through all the multiple layers of protection, obfuscation, and antianalysis techniques of FinFisher will be useful to other researchers studying this malware. We believe that an\nindustry-wide collaboration and information-sharing is important in defending customers against this complex\npiece of malware. For further reading, we recommend these other great references:\n\nTo test how Windows Defender ATP can help your organization detect, investigate, and respond to advanced\nattacks, **[sign up for a free trial.](https://www.microsoft.com/en-us/windowsforbusiness/windows-atp?ocid=cx-blog-mmpc)**\n\n**_Andrea Allievi, Office 365 ATP Research team_**\n_with Elia Florio, Windows Defender ATP Research team_\n\nSample analyzed:\n\nMD5: a7b990d5f57b244dd17e9a937a41e7f5\nSHA-1: c217d48c4ac1555491348721cc7cfd1143fe0b16\nSHA-256: b035ca2d174e5e4fd2d66fd3c8ce4ae5c1e75cf3290af872d1adb2658852afb8\n\n\n-----\n\n**Talk to us**\n\n[Questions, concerns, or insights on this story? Join discussions at the Microsoft community and](https://answers.microsoft.com/en-us/protect) Windows\nDefender Security Intelligence.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-03-01 - FinFisher exposed- A researcher’s tale of defeating traps, tricks, and complex virtual machines.pdf"
    ],
    "report_names": [
        "2018-03-01 - FinFisher exposed- A researcher’s tale of defeating traps, tricks, and complex virtual machines.pdf"
    ],
    "threat_actors": [
        {
            "id": "27485543-d2e7-4053-a660-157489732cbb",
            "created_at": "2022-10-25T16:07:23.895403Z",
            "updated_at": "2025-03-27T02:02:10.018168Z",
            "deleted_at": null,
            "main_name": "Neodymium",
            "aliases": [],
            "source_name": "ETDA:Neodymium",
            "tools": [
                "Wingbird"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "67fbc7d7-ba8e-4258-b53c-9a5d755e1960",
            "created_at": "2022-10-25T16:07:24.077859Z",
            "updated_at": "2025-03-27T02:02:10.101173Z",
            "deleted_at": null,
            "main_name": "Promethium",
            "aliases": [
                "APT-C-41",
                "Promethium",
                "StrongPity"
            ],
            "source_name": "ETDA:Promethium",
            "tools": [
                "StrongPity",
                "StrongPity2",
                "StrongPity3",
                "Truvasys"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "400a3efc-44a1-4d83-a724-cd16818328f9",
            "created_at": "2023-01-06T13:46:38.516115Z",
            "updated_at": "2025-03-27T02:00:02.853085Z",
            "deleted_at": null,
            "main_name": "NEODYMIUM",
            "aliases": [
                "G0055"
            ],
            "source_name": "MISPGALAXY:NEODYMIUM",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "cbede712-4cc3-47c6-bf78-92fd9f1beac6",
            "created_at": "2022-10-25T15:50:23.777222Z",
            "updated_at": "2025-03-27T02:00:55.544919Z",
            "deleted_at": null,
            "main_name": "PROMETHIUM",
            "aliases": [
                "PROMETHIUM",
                "StrongPity"
            ],
            "source_name": "MITRE:PROMETHIUM",
            "tools": [
                "Truvasys",
                "StrongPity"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "c11cbeb5-461f-4bd8-a86b-f57e471a664d",
            "created_at": "2022-10-25T15:50:23.257383Z",
            "updated_at": "2025-03-27T02:00:55.409898Z",
            "deleted_at": null,
            "main_name": "NEODYMIUM",
            "aliases": [
                "NEODYMIUM"
            ],
            "source_name": "MITRE:NEODYMIUM",
            "tools": [
                "Wingbird"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "4660477f-333f-4a18-b49b-0b4d7c66d482",
            "created_at": "2023-01-06T13:46:38.511962Z",
            "updated_at": "2025-03-27T02:00:02.852307Z",
            "deleted_at": null,
            "main_name": "PROMETHIUM",
            "aliases": [
                "StrongPity",
                "G0056"
            ],
            "source_name": "MISPGALAXY:PROMETHIUM",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536116,
    "ts_updated_at": 1743041682,
    "ts_creation_date": 1653774965,
    "ts_modification_date": 1653774965,
    "files": {
        "pdf": "https://archive.orkl.eu/4bcdf63a3de2075b4c4a8d3f273c05e6b8b0b691.pdf",
        "text": "https://archive.orkl.eu/4bcdf63a3de2075b4c4a8d3f273c05e6b8b0b691.txt",
        "img": "https://archive.orkl.eu/4bcdf63a3de2075b4c4a8d3f273c05e6b8b0b691.jpg"
    }
}