{
    "id": "f79a8ae8-e62e-45c3-81ef-aa97d805d274",
    "created_at": "2023-01-12T15:08:23.983334Z",
    "updated_at": "2025-03-27T02:09:29.667997Z",
    "deleted_at": null,
    "sha1_hash": "4ab3773af4830c3e87b2bac1917aed09432a5d81",
    "title": "2019-05-10 - Exploring Mimikatz - Part 1 - WDigest",
    "authors": "",
    "file_creation_date": "2022-05-27T22:36:21Z",
    "file_modification_date": "2022-05-27T22:36:21Z",
    "file_size": 1249912,
    "plain_text": "# Exploring Mimikatz - Part 1 - WDigest\n\n**blog.xpnsec.com/exploring-mimikatz-part-1/**\n\n[« Back to home](https://blog.xpnsec.com/)\nWe’ve packed it, we’ve wrapped it, we’ve injected it and powershell’d it, and now we’ve settled on feeding it a\nmemory dump, and still Mimikatz remains the tool of choice when extracting credentials from lsass on Windows\n[systems. Of course this is due to the fact that with each new security control introduced by Microsoft, GentilKiwi](https://twitter.com/gentilkiwi)\nalways has a trick or two up his sleeve. If you have ever looked at the effort that goes into Mimikatz, this is no easy\ntask, with all versions of Windows x86 and x64 supported (and more recently, additions to support Windows on ARM\narch). And of course with the success of Mimikatz over the years, BlueTeam are now very adept at detecting its use\nin its many forms. Essentially, execute Mimikatz on a host, and if the environment has any maturity at all you’re\nlikely to be flagged.\n\nThrough my many online and offline rants conversations, people likely know by now my thoughts on RedTeam\nunderstanding their tooling beyond just executing a script. And with security vendors reducing and monitoring the\nattack surface of common tricks often faster than we can discover fresh methods, knowing how a particular\ntechnique works down to the API calls can offer a lot of benefits when avoiding detection in well protected\nenvironments.\n\nThis being said, Mimikatz is a tool that is carried along with most post-exploitation toolkits in one form or another.\nAnd while some security vendors are monitoring for process interaction with lsass, many more have settled on\nattempting to identify Mimikatz itself.\n\nI’ve been toying with the idea of stripping down Mimikatz for certain engagements (mainly those where exfiltrating a\nmemory dump isn’t feasible or permitted), but it has been bugging me for a while that I’ve spent so long working with\na tool that I’ve rarely reviewed low-level.\n\nSo over a few posts I wanted to change this and explore some of its magic, starting with where it all began….\nWDigest. Specifically, looking at how cleartext credentials are actually cached in lsass, and how they are extracted\nout of memory with `\"sekurlsa::wdigest\" . This will mean disassembly and debugging, but hopefully by the end`\nyou will see that while its difficult to duplicate the amount of effort that has gone into Mimikatz, if your aim is to only\nuse a small portion of the available functionality, it may be worth crafting a custom tool based on the Mimikatz\nsource code, rather than opting to take along the full suite.\n\nTo finish off the post I will also explore some additional methods of loading arbitrary DLL’s within lsass, which can\nhopefully be combined with the code examples demonstrated.\n\n_Note: This post uses Mimikatz source code heavily as well as the countless hours dedicated to it by its developer(s)._\n_This effort should become more apparent as you see undocumented structures which are suddenly revealed when_\n_[browsing through code. Thanks to Mimikatz, Benjamin Delpy and](https://twitter.com/gentilkiwi)_ _[Vincent Le Toux for their awesome work.](https://twitter.com/mysmartlogon)_\n\n## So, how does this “sekurlsa::wdigest” magic actually work?\n\nSo as mentioned, in this post we will look at is WDigest, arguably the feature that Mimikatz became most famous\nfor. WDigest credential caching was of course enabled by default up until Windows Server 2008 R2, after which\ncaching of plain-text credentials was disabled.\n\nWhen reversing an OS component, I usually like to attach a debugger and review how it interacts with the OS during\nruntime. Unfortunately in this case this isn’t going to be just as simple as attaching WinDBG to lsass, as pretty\nquickly you’ll see Windows grind to a halt before warning you of a pending reboot. Instead we’ll have to attach to the\nkernel and switch over to the lsass process from Ring-0. If you have never attached WinDBG to the kernel before,\n[check out one of my previous posts on how to go about setting up a kernel debugger here.](https://blog.xpnsec.com/windows-warbird-privesc/)\n\n\n-----\n\nWith a kernel debugger attached, we need to grab the `EPROCESS address of the lsass process, which is found with`\nthe `!process 0 0 lsass.exe command:`\n\nWith the `EPROCESS address identified ( ffff9d01325a7080 above), we can request that our debug session is`\nswitched to the lsass process context:\n\nA simple `lm will show that we now have access to the WDigest DLL memory space:`\n\nIf at this point you find that symbols are not processed correctly, a `.reload /user will normally help.`\n\nWith the debugger attached, let’s dig into WDigest.\n\n## Diving into wdigest.dll (and a little lsasrv.dll)\n\nIf we look at Mimikatz source code, we can see that the process of identifying credentials in memory is to scan for\n[signatures. Let’s take the opportunity to use a tool which appears to be in vogue at the minute, Ghidra, and see](https://ghidra-sre.org/)\nwhat Mimikatz is hunting for.\n\nAs I’m currently working on Windows 10 x64, I’ll focus on the `PTRN_WIN6_PasswdSet signature seen below:`\n\nAfter providing this search signature to Ghidra, we reveal what Mimikatz is scanning memory for:\n\n\n-----\n\n-----\n\nAbove we have the function `LogSessHandlerPasswdSet . Specifically the signature references just beyond the`\n```\nl_LogSessList pointer. This pointer is key to extracting credentials from WDigest, but before we get ahead of\n\n```\nourselves, let’s back up and figure out what exactly is calling this function by checking for cross references, which\nlands us here:\n\nHere we have `SpAcceptCredentials which is an exported function from WDigest.dll, but what does this do?`\n\n\n-----\n\nThis looks promising as we can see that credentials are passed via this callback function. Let’s confirm that we are\nin the right place. In WinDBG we can add a breakpoint with `bp wdigest!SpAcceptCredentials after which we`\nuse the `runas command on Windows to spawn a shell:`\n\nThis should be enough to trigger the breakpoint. Inspecting the arguments to the call, we can now see credentials\nbeing passed in:\n\n\n-----\n\nIf we continue with our execution and add another breakpoint on `wdigest!LogSessHandlerPasswdSet, we find`\nthat although our username is passed, a parameter representing our password cannot be seen. However, if we look\njust before the call to `LogSessHandlerPasswdSet, what we find is this:`\n\nThis is actually a stub used for Control Flow Guard (Ghidra 9.0.3 looks like it has an improvement for displaying\nCFG stubs), but following along in a debugger shows us that the call is actually to `LsaProtectMemory :`\n\nThis is expected as we know that credentials are stored encrypted within memory. Unfortunately\n```\nLsaProtectMemory isn’t exposed outside of lsass, so we need to know how we can recreate its functionality to\n\n```\ndecrypt extracted credentials. Following with our disassembler shows that this call is actually just a wrapper around\n```\nLsaEncryptMemory :\n\n```\nAnd `LsaEncryptMemory is actually just wrapping calls to` `BCryptEncrypt :`\n\n\n-----\n\nInterestingly, the encryption/decryption function is chosen based on the length of the provided blob of data to be\nencrypted. If the length of the buffer provided is divisible by 8 (donated by the “param_2 & 7” bitwise operation in the\nscreenshot above), then AES is used. Failing this, 3Des is used.\n\nSo we now know that our password is encrypted by `BCryptEncrypt, but what about the key? Well if we look`\nabove, we actually see references to `lsasrv!h3DesKey and` `lsasrv!hAesKey . Tracing references to these`\naddresses shows that `lsasrv!LsaInitializeProtectedMemory is used to assign each an initial value.`\nSpecifically each key is generated based on calls to `BCryptGenRandom :`\n\n\n-----\n\nThis means that a new key is generated randomly each time lsass starts, which will have to be extracted before we\ncan decrypt any cached WDigest credentials.\n\nBack to the Mimikatz source code to confirm that we are not going too far off track, we see that there is indeed a\nhunt for the `LsaInitializeProtectedMemory function, again with a comprehensive list of signatures for differing`\nWindows versions and architectures:\n\nAnd if we search for this within Ghidra, we see that it lands us here:\n\nHere we see a reference to the `hAesKey address. So, similar to the above signature search, Mimikatz is hunting`\nfor cryptokeys in memory.\n\nNext we need to understand just how Mimikatz goes about pulling the keys out of memory. For this we need to refer\nto `kuhl_m_sekurlsa_nt6_acquireKey within Mimikatz, which highlights the lengths that this tool goes to in`\nsupporting different OS versions. We see that `hAesKey and` `h3DesKey (which are of the type`\n```\nBCRYPT_KEY_HANDLE returned from BCryptGenerateSymmetricKey ) actually point to a struct in memory\n\n```\nconsisting of fields including the generated symmetric AES and 3DES keys. This struct can be found documented\nwithin Mimikatz:\n\n\n-----\n\n```\n yp _ _ _ _ {\n  ULONG size;\n  ULONG tag;  // 'UUUR'\n  PVOID hAlgorithm;\n  PKIWI_BCRYPT_KEY key;\n  PVOID unk0;\n} KIWI_BCRYPT_HANDLE_KEY, *PKIWI_BCRYPT_HANDLE_KEY;\n\n```\nWe can correlate this with WinDBG to make sure we are on the right path by checking for the “UUUR” tag\nreferenced above:\n\nAt offset 0x10 we see that Mimikatz is referencing `PKIWI_BCRYPT_KEY which has the following structure:`\n```\ntypedef struct _KIWI_BCRYPT_KEY81 {\n  ULONG size;\n  ULONG tag;  // 'MSSK'\n  ULONG type;\n  ULONG unk0;\n  ULONG unk1;\n  ULONG unk2; \n  ULONG unk3;\n  ULONG unk4;\n  PVOID unk5;  // before, align in x64\n  ULONG unk6;\n  ULONG unk7;\n  ULONG unk8;\n  ULONG unk9;\n  KIWI_HARD_KEY hardkey;\n} KIWI_BCRYPT_KEY81, *PKIWI_BCRYPT_KEY81;\n\n```\nAnd sure enough, following along with WinDBG reveals the same referenced tag:\n\nThe final member of this struct is a reference to the Mimikatz named `KIWI_HARD_KEY, which contains the`\nfollowing:\n```\ntypedef struct _KIWI_HARD_KEY {\n  ULONG cbSecret;\n  BYTE data[ANYSIZE_ARRAY]; // etc...\n} KIWI_HARD_KEY, *PKIWI_HARD_KEY;\n\n```\nThis struct consists of the the size of the key as `cbSecret, followed by the actual key within the` `data field. This`\nmeans we can use WinDBG to extract this key with:\n\nThis gives us our `h3DesKey which is 0x18 bytes long consisting of`\n```\nb9 a8 b6 10 ee 85 f3 4f d3 cb 50 a6 a4 88 dc 6e ee b3 88 68 32 9a ec 5a .\n\n```\nKnowing this, we can follow the same process to extract `hAesKey :`\n\n\n-----\n\nNow that we understand just how keys are extracted, we need to hunt for the actual credentials cached by WDigest.\nLet’s go back to the `l_LogSessList pointer we discussed earlier. This field corresponds to a linked list, which we`\ncan walk through using the WinDBG command `!list -x \"dq @$extret\" poi(wdigest!l_LogSessList) :`\n\nThe structure of these entries contain the following fields:\n```\ntypedef struct _KIWI_WDIGEST_LIST_ENTRY {\n  struct _KIWI_WDIGEST_LIST_ENTRY *Flink;\n  struct _KIWI_WDIGEST_LIST_ENTRY *Blink;\n  ULONG  UsageCount;\n  struct _KIWI_WDIGEST_LIST_ENTRY *This;\n  LUID LocallyUniqueIdentifier;\n} KIWI_WDIGEST_LIST_ENTRY, *PKIWI_WDIGEST_LIST_ENTRY;\n\n```\nFollowing this struct are three `LSA_UNICODE_STRING fields found at the following offsets:`\n\n0x30 - Username\n0x40 - Hostname\n0x50 - Encrypted Password\n\nAgain we can check that we are on the right path with WinDBG using a command such as:\n\n\n-----\n\n```\n        @ p ( g _ g )\n\n```\nThis will dump cached usernames as:\n\nAnd finally we can dump encrypted password using a similar command:\n```\n!list -x \"db poi(@$extret+0x58)\" poi(wdigest!l_LogSessList)\n\n```\nAnd there we have it, all the pieces required to extract WDigest credentials from memory.\n\nSo now that we have all the information needed for the extraction and decryption process, how feasible would it be\nto piece this together into a small standalone tool outside of Mimikatz? To explore this I’ve created a heavily\n[commented POC which is available here. When executed on Windows 10 x64 (build 1809), it provides verbose](https://gist.github.com/xpn/e3837a4fdee8ea1b05f7fea5e7ea9444)\ninformation on the process of extracting creds:\n\n\n-----\n\nBy no means should this be considered OpSec safe, but it will hopefully give an example of how we can go about\ncrafting alternative tooling.\n\nNow that we understand how WDigest cached credentials are grabbed and decrypted, we can move onto another\narea affecting the collection of plain-text credentials, “UseLogonCredential”.\n\nSo as we know, with everyone running around dumping cleartext credentials, Microsoft decided to disable support\nfor this legacy protocol by default. Of course there will be some users who may be using WDigest, so to provide the\noption of re-enabling this, Microsoft pointed to a registry key of\n```\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest\\UseLogonCredential .\n\n```\nToggling this from ‘0’ to ‘1’ forces WDigest to start caching credentials again, which of course meant that pentesters\nwere back in the game… however there was a catch, toggling this setting required a reboot of the OS, and I’ve yet\nto meet a client who would allow this outside of a test environment.\n\nThe obvious question is… why do you need to reboot the machine for this to take effect?\n\nEdit: As pointed out by GentilKiwi, a reboot isn’t required for this change to take effect. I’ve added a review of why\nthis is at the end of this section.\n\nLet’s take a look at `SpAcceptCredentials again, and after a bit of hunting we find this:`\n\n\n-----\n\nHere we can clearly see that there is a check for two conditions using global variables. If `g_IsCredGuardEnabled`\nis set to `1, or` `g_fParameter_UseLogonCredential is set to` `0, we find that the code path taken is via`\n```\nLogSessHandlerNoPasswordInsert rather than the above LogSessHandlerPasswdSet call. As the name\n\n```\nsuggests, this function caches the session but not the password, resulting in the behaviour we normally encounter\nwhen popping Windows 2012+ boxes. It’s therefore reasonable to assume that this variable is controlled by the\nabove registry key value based on its name, and we find this to be the case by tracing its assignment:\n\nBy understanding what variables within WDigest.dll control credential caching, can we subvert this without updating\nthe registry? What if we update that `g_fParameter_UseLogonCredential parameter during runtime with our`\ndebugger?\n\nResuming execution, we see that cached credentials are stored again:\n\n\n-----\n\nOf course most things are possible when you have a kernel debugger hooked up, but if you have a way to\n[manipulate lsass memory without triggering AV/EDR (see our earlier Cylance blog post for one example of how you](https://www.mdsec.co.uk/2019/03/silencing-cylance-a-case-study-in-modern-edrs/)\nwould do this), then there is nothing stopping you from crafting a tool to manipulate this variable. Again I’ve created\n[a heavily verbose tool to demonstrate how this can be done which can be found here.](https://gist.github.com/xpn/163360379f3cce2443a7b074f0a173b8)\n\nThis example will hunt for and update the `g_fParameter_UseLogonCredential value in memory. If you are`\noperating against a system protected with Credential Guard, the modifications required to also update this value are\ntrivial and left as an exercise to the reader.\n\nWith our POC executed, we find that WDigest has now been re-enabled without having to set the registry key,\nallowing us to pull out credentials as they are cached:\n\nAgain this POC should not be considered as OpSec safe, but used as a verbose example of how you can craft your\nown.\n\nNow of course this method of enabling WDigest comes with risks, mainly the `WriteProcessMemory call into lsass,`\nbut if suited to the environment it offers a nice way to enable WDigest without setting a registry value. There are also\nother methods of acquiring plain-text credentials which may be more suited to your target outside of WDigest\n(memssp for one, which we will review in a further post).\n\nEdit: As pointed out by GentilKiwi, a reboot is not required for `UseLogonCredential to take effect… so back to the`\ndisassembler we go.\n\nReviewing other locations referencing the registry value, we find `wdigest!DigestWatchParamKey which monitors`\na number of keys including:\n\n[The Win32 API used to trigger this function on update is RegNotifyKeyChangeValue:](https://docs.microsoft.com/en-us/windows/desktop/api/winreg/nf-winreg-regnotifychangekeyvalue)\n\nAnd if we add a breakpoint on `wdigest!DigestWatchParamKey in WinDBG, we see that this is triggered as we`\nattempt to add a `UseLogonCredential :`\n\n\n-----\n\n## Bonus Round - Loading an arbitrary DLL into LSASS\n\nSo while digging around with a disassemler I wanted to look for an alternative way to load code into lsass while\navoiding potentially hooked Win32 API calls, or by loading an SSP. After a bit of disassembly, I came across the\nfollowing within `lsasrv.dll :`\n\nThis attempt to call `LoadLibraryExW on a user provided value can be found within the function`\n```\nLsapLoadLsaDbExtensionDll and allows us to craft a DLL to be loaded into the lsass process, for example:\nBOOL APIENTRY DllMain( HMODULE hModule,\n            DWORD ul_reason_for_call,\n            LPVOID lpReserved\n           )\n{\n  switch (ul_reason_for_call)\n  {\n  case DLL_PROCESS_ATTACH:\n    // Insert l33t payload here\n    break;\n  }\n  // Important to avoid BSOD\n  return FALSE;\n}\n\n```\nIt is important that at the end of the `DllMain function, we return` `FALSE to force an error on` `LoadLibraryEx .`\nThis is to avoid the subsequent call to `GetProcAddress . Failing to do this will result in a BSOD on reboot until the`\nDLL or registry key is removed.\n\nWith a DLL crafted, all that we then need to do is create the above registry key:\n```\nNew-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NTDS -Name LsaDbExtPt -Value \"C:\\xpnsec.dll\"\n\n```\nLoading of the DLL will occur on system reboot, which makes it a potential persistence technique for privileged\ncompromises, pushing your payload straight into lsass (as long as PPL isn’t enabled of course).\n\n## Bonus Round 2 - Loading arbitrary DLL into LSASS remotely\n\nAfter some further hunting, a similar vector to that above was found within samsrv.dll. Again a controlled registry\nvalue is loaded into lsass by a LoadLibraryEx call:\n\n\n-----\n\nAgain we can leverage this by adding a registry key and rebooting, however triggering this case is a lot simpler as it\ncan be fired using SAMR RPC calls.\n\nLet’s have a bit of fun by using our above WDigest credential extraction code to craft a DLL which will dump\ncredentials for us.\n\nTo load our DLL, we can use a very simple Impacket Python script to modify the registry and add a key to\n```\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\NTDS\\DirectoryServiceExtPt pointing to our DLL hosted on an\n\n```\nopen SMB share, and then trigger the loading of the DLL using a call to `hSamConnect RPC call. The code looks`\nlike this:\n\nAnd in practice, we can see credentials pulled from memory:\n\n[asciicast](https://asciinema.org/a/VwaStfgka8FHmHWhXjmBmu8zV)\n\n[The code for the DLL used can be found here, which is a modification of the earlier example.](https://gist.github.com/xpn/12a6907a2fce97296428221b3bd3b394)\n\nSo hopefully this post has given you an idea as to how WDigest credential caching works and how Mimikatz goes\nabout pulling and decrypting passwords during `\"sekurlsa::wdigest\" . More importantly I hope that it will help`\nanyone looking to craft something custom for their next assessment. I’ll be continuing by looking at other areas\nwhich are commonly used during an engagement, but if you have any questions or suggestions, give me a shout at\nthe usual places.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-05-10 - Exploring Mimikatz - Part 1 - WDigest.pdf"
    ],
    "report_names": [
        "2019-05-10 - Exploring Mimikatz - Part 1 - WDigest.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536103,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653690981,
    "ts_modification_date": 1653690981,
    "files": {
        "pdf": "https://archive.orkl.eu/4ab3773af4830c3e87b2bac1917aed09432a5d81.pdf",
        "text": "https://archive.orkl.eu/4ab3773af4830c3e87b2bac1917aed09432a5d81.txt",
        "img": "https://archive.orkl.eu/4ab3773af4830c3e87b2bac1917aed09432a5d81.jpg"
    }
}