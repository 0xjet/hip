{
    "id": "7aea6689-6c38-408a-986f-be63897270ba",
    "created_at": "2023-01-12T15:02:09.733068Z",
    "updated_at": "2025-03-27T02:16:01.130812Z",
    "deleted_at": null,
    "sha1_hash": "ea87280badef9caab84a0b0433a30d2dd107ead5",
    "title": "2021-07-15 - Adjusting the Anchor",
    "authors": "",
    "file_creation_date": "2022-05-28T23:13:22Z",
    "file_modification_date": "2022-05-28T23:13:22Z",
    "file_size": 479688,
    "plain_text": "# Adjusting the Anchor\n\n**kryptoslogic.com/blog/2021/07/adjusting-the-anchor/**\n\n[Authored by: Kryptos Logic Vantage Team on Thursday, July 15, 2021](https://twitter.com/kryptoslogic)\n\nTags: [anchor](https://www.kryptoslogic.com/blog/tag/anchor)\n\n## Overview\n\nAnchorDNS is a backdoor used by the TrickBot actors to target selected high value victims. It has been seen\ndelivered by both TrickBot and Bazar1 malware campaigns .2 AnchorDNS is particularly difficult to track given\nthat it is deployed only post-infection and that too only after a period of reconnaissance, once the malware\noperators have established that the target is of special interest.\n\n\nFollowing analysis of AnchorDNS samples published in recent reporting23, we have observed that the C2\ncommunications protocol of AnchorDNS has changed. We also see the use of another Anchor component\ncalled AnchorAdjuster. The newer variants contain a modification to the structure of the messages sent to\nthe C2, and have added additional encryption routines when creating the DNS queries. Data received from\nthe C2 is now encoded, thereby making the traffic less obvious.\n\nIn this post we analyze the role that AnchorAdjuster plays and outline the changes made to the\ncommunication protocol by the recent AnchorDNS samples.\n\n## AnchorAdjuster\n\nAnchorAdjuster is a tool that is used to modify an AnchorDNS sample with an updated config and the\nvictim’s UUID. The tool is executed by an external command and has been seen being run by CobaltStrike .2\n\nA valid series of arguments need to be passed to the AnchorAdjuster for it to execute succesfully. If\narguments are not passed, the tool outputs a message onto the console detailing the arguments required:\n```\nusing:\nanchorAdjuster* --source=<source file> --target=<target file> --domain=<domain name> \n  --period=<recurrence interval, minutes, default value 15>-guid\n\n```\nBelow is a description of the arguments:\n\n\n-----\n\n|Argument Argument|Description Description|Requirements Requirements|\n|---|---|---|\n|--source|AnchorDNS sample with a blank config|Required|\n|--target|Name to save the modified AnchorDNS sample|Required|\n|--domain|Domain C2s to save as config|Required|\n|--period|Interval between each cycle of DNS queries; default is 15 minutes|Optional|\n|--lasthope|Number of communication attempts; default is 100|Optional|\n|-guid|Flag for initializing the Victim’s UUID in the sample|Required|\n\n\nThe AnchorAdjuster tool works as follows:\n\nFirstly, if it finds a 16 byte string of `AAAAAAAAAAAAAAAA in the AnchorDNS bot, it rewrites it with a` `UUID`\nthat it generates by calling `CoCreateGuid . This creates a` `UUID unique to the victim machine. The string`\n```\nAAAAAAAAAAAAAAAA acts as a placeholder for the UUID and is typically stored in the .rand section.\n\n```\nSecondly, if it finds a 66 byte string of all `B s, it overwrites this string with XOR encoded C2s. The C2s are`\nthe values that were passed to the AnchorAdjuster’s `--domain argument. The XOR key used is a`\nhardcoded hex value `0x23 .`\n\nFinally, using the name passed to the `--target argument, the tool creates a new AnchorDNS bot with`\nthese modifications.\n\nBelow is an example standard output log from the tool after successful execution:\n```\nsource file size 347648\nguid: 743E900F5861EF468E120559E9D23EF8, shift 0x00053C00(343040)\ndomain: shift 0x00053A04(342532)\nOK\n\n```\nThis technique reuses an AnchorDNS sample to be able to communicate to new C2s that it provides,\nwithout having to re-compile an entirely new AnchorDNS binary. This also helps the threat actors to hide any\nnew C2s created, especially if the AnchorDNS sample were to be discovered by a threat researcher.\n\n## AnchorDNS\n\nAnchorDNS communicates to its C2 servers using DNS Tunnelling. Using the DNS protocol for command &\ncontrol benefits AnchorDNS because such requests are often allowed to pass through firewalls. Using this\nmethod, AnchorDNS is able to exfiltrate data to its C2s in the form of DNS queries. The data is encoded and\nmade to appear as subdomains. In addition, the C2 can communicate back to the bot by sending information\nin the form of DNS A records whereby the data is reconstructed by the bot based on AnchorDNS’s specific\nformat.\n\n## Review on how AnchorDNS works\n\nTo get a better grasp on what new changes have been implemented to this DNS communication, this section\nwill do a quick high-level review on how AnchorDNS works.\n\n\n-----\n\n1. Upon initial execution, AnchorDNS gains persistence on the machine by creating a scheduled task that\n\nis set to run every 15 minutes.\n\nThe frequency of the scheduled task can be modified again by the bot if the C2 sends a\ncommand with instructions to do so.\n2. Each run cycle involves a series of commands transmitted as DNS queries between the bot and the\n\nC2.\n\nInitial beacon message.\nRequest from the bot for command to be executed.\nRequest from the bot for a payload (if the command requires one).\nSend report on the command’s execution.\n\n## Preparing the messages for the C2\n\nThe name of the bot at the start of the message has changed from `anchor_dns to` `stickseed . This new`\nname is very different from that of the name used in the past variants .4 One possible explanation is that\n```\ntick in stickseed represents the Windows API GetTickCount and seed for a pseudorandom\n\n```\nnumber generator, the two functions that we see being frequently used in the new variant.\n\nThe `GUID created by the Bot is recorded by the C2 to keep track of the different infected machines. The`\nformat of the `GUID is as follows:`\n```\n<Computer_Name>_W<major version><minor version><version build number>.<16 bytes UUID>\n\n```\nThe 16 byte `UUID is hardcoded in the` `.rand section of the AnchorDNS PE file. If there are no 16 bytes in`\nthe `.rand section or if there is a string` `AAAAAAAAAAAAAAAA in that section, the bot skips making any DNS`\nqueries.\n\nExample `GUID :`\n```\nADMINWIN10_W629200.1BDD88D8278746A68CE4BCF8DCF27B7E\n\n```\nBelow is a summary of the messages and the command sent to the C2:\n\n**C2**\n**Command** **Description** **Info sent by New Variant** **Info sent by Previous Variant**\n\n0 Register Bot `/stickseed/<GUID>/0/<Windows` `/anchor_dns/<GUID>/0/<Windows`\n```\n               OS Type>/1001/<Bot IP>/<32 OS Type>/1001/<Bot IP>/<32\n               random hex bytes>/<32 random random hex bytes>/<32 random\n               alphanumeric characters>/ alphanumeric characters>/\n\n```\n1 Request Bot `/stickseed/<GUID>/1/<32 random` `/anchor_dns/<GUID>/1/<32 random`\ncommand `alphanumeric characters>/` `alphanumeric characters>/`\n\n5 Request `/stickseed/<GUID>/5/<filename>` `/anchor_dns/<GUID>/5/<filename>`\nFile\n\n10 Send result `/stickseed/<GUID>/10/<Bot` `/anchor_dns/<GUID>/10/<Bot`\nof Bot `Command>/<Bot Command` `Command>/<Bot Command`\ncommand `ID>/<Result of Command` `ID>/<Result of Command`\n```\n               execution>/ execution>/\n```\nexecution\n\n## The DNS Queries\n\n|C2 Command|Description|Info sent by New Variant|Info sent by Previous Variant|\n|---|---|---|---|\n|0|Register Bot|/stickseed/<GUID>/0/<Windows OS Type>/1001/<Bot IP>/<32 random hex bytes>/<32 random alphanumeric characters>/|/anchor_dns/<GUID>/0/<Windows OS Type>/1001/<Bot IP>/<32 random hex bytes>/<32 random alphanumeric characters>/|\n|1|Request Bot command|/stickseed/<GUID>/1/<32 random alphanumeric characters>/|/anchor_dns/<GUID>/1/<32 random alphanumeric characters>/|\n|5|Request File|/stickseed/<GUID>/5/<filename>|/anchor_dns/<GUID>/5/<filename>|\n|10|Send result of Bot command execution|/stickseed/<GUID>/10/<Bot Command>/<Bot Command ID>/<Result of Command execution>/|/anchor_dns/<GUID>/10/<Bot Command>/<Bot Command ID>/<Result of Command execution>/|\n\n\n-----\n\nEach message above, made by the AnchorDNS bot, to send to the C2 involves a sequence of 3 types of\nDNS queries .5 This order is still maintained in the new variants. The table below shows a summary of the\nsequence of DNS queries made:\n\n**Query**\n**Order** **Info Sent** **Info Received**\n\n0 Send info including command Receive IP record from C2\n\n1 Convert IP to identifier and send to C2 Receive IP record from C2\n\n2 Convert IP to size; send identifier and size to Receive data in the form of multiple IP\nC2 records\n\n### Crafting the Queries\n\nThe new variants make changes to the way in which the queries are crafted.\n\n**Old Variant:**\n\nTo better understand the changes made, this section will briefly review how the queries were crafted in the\nprevious variants. Each query would contain information about the query type and a 16 byte UUID. The\nquery type would inform the C2 on what type of message it is receiving and the UUID helps it keep track of\nthe queries. If the crafted query is type 0, the message gets divided into parts. This is to ensure that the\nlength of the query remains under 255 characters. Finally, the queries are XOR’ed with the key `0xb9 . This`\nis the only encoding we see in the previous variants.\n\nThe table below summarizes the queries crafted in the old variants :6\n\n**Query** **Query**\n**Order** **Type** **Old Variant Format** **Encoding**\n\n0 0 `0<UUID><(BYTE)Current Part><(BYTE)Total Parts>` xor with\n```\n             <Divided Message> 0xb9\n\n```\n1 1 `1<UUID><(DWORD)Identifier>` xor with\n```\n                                               0xb9\n\n```\n2 2 `2<UUID><(DWORD)Identifier><(DWORD)Size>` xor with\n```\n                                               0xb9\n\n```\n**New Variant:**\n\nIn the new variant, before a query is crafted, the message in each DNS query type is XOR’ed with the key\n```\nUnited States of America (USA) . After encoding the message, a 16 byte UUID is generated for each\n\n```\nquery type (like the previous variant, the UUID is for the C2 to keep track of the query) and is further\nencoded with a custom Base32 algorithm using the custom dictionary\n```\ndghbcijklmnfqrwxyz23stuopaev4569 .\n\n```\nThe bot then calculates if the message needs to be divided into parts for all 3 DNS query types (in the\nprevious variant we see this for only the query type 0).\n\nBelow is a python function that calculate the number of parts a message would get divided into and the size\nof each part:\n\n|Query Order|Info Sent|Info Received|\n|---|---|---|\n|0|Send info including command|Receive IP record from C2|\n|1|Convert IP to identifier and send to C2|Receive IP record from C2|\n|2|Convert IP to size; send identifier and size to C2|Receive data in the form of multiple IP records|\n\n|Query Order|Query Type|Old Variant Format|Encoding|\n|---|---|---|---|\n|0|0|0<UUID><(BYTE)Current Part><(BYTE)Total Parts> <Divided Message>|xor with 0xb9|\n|1|1|1<UUID><(DWORD)Identifier>|xor with 0xb9|\n|2|2|2<UUID><(DWORD)Identifier><(DWORD)Size>|xor with 0xb9|\n\n\n-----\n\n```\n p\ndef get_parts(msg_len: int, c2_len: int) -> list():\n  blocks = list()\n  foo = 5 * (0xba - 0x1a - c2_len - 8)\n  fee = ((foo & 7) + foo) >> 3\n  faa = fee * 0.85\n  if faa > (fee - 5):\n    faa = (fee - 5) * 0.85\n  i, count = 0, 0\n  while i < msg_len:\n    block_sz = msg_len - i\n    if (msg_len - i) > fee:\n      rand = random.randint(0,0x7fff)\n      fii = fee - 5\n      if count:\n        fii = fee\n      block_sz = int(((rand * (fii - faa)) / 32767.0) + faa)\n    i += block_sz\n    count += 1\n    blocks.append(block_sz)\n  return blocks\n\n```\nIn the new variant, the DNS query types are labeled differently (but still follow the same order as the\nprevious):\n\n**Query Order** **Query Type** **Message**\n\n0 `0x0001` `/stickseed/<GUID>/<C2 Command>/<Info if any>/`\n\n1 `0xfffe` `<Identifier DWORD>`\n\n2 `0xffff` `<Identifier DWORD><Size in DWORD of data received>`\n\nFor each divided message part, additional information is appended. The image below gives an example of a\nmessage for DNS query type 0x0001 and how each divided part is crafted:\n\n|Query Order|Query Type|Message|\n|---|---|---|\n|0|0x0001|/stickseed/<GUID>/<C2 Command>/<Info if any>/|\n|1|0xfffe|<Identifier DWORD>|\n|2|0xffff|<Identifier DWORD><Size in DWORD of data received>|\n\n\n-----\n\n**Message being built for the queries**\n\nThe resulting data is encoded with a custom Base32 algorithm and the encoded Base32 UUID is appended\nat the end. So for example, the message parts above would result in the following types of DNS queries\nbeing made:\n```\nefkezwpdxpsq3lsdv2mp3u5kl.mppdslkiaohiqmhplaekp.rrzynhijic42cljjandescbf4nim\n  .anoopcsmswhzpqeyphgvzre3oqsz.ygndzp3glhsnojidcddddjddddddabb.ygacsziqpmpqcvdkb2zhu2gjzg\n    .domain.com\npnuctkdw5ntjcbrnxhcqy2txz3gjzo.cftgod2flrzglesnzlcbfqildx9ntdbqgns\n  .nisgziha3eljwgntmtnhnqrdnuwb2cjgfoch.ldddlddddqddddhdpby.ygacsziqpmpqcvdkb2zhu2gjzg\n    .domain.com\ns2sw3tcn3nc6guihblvwuudfc22wytzdhz.cjyipjnvlqihggnyhn26chizt4jdcksya\n  .dzbyb6gxnyvgdgdddygdddydjlqd.ygacsziqpmpqcvdkb2zhu2gjzg.domain.com\n\n```\n\n-----\n\n### Query Responses\n\nThe query responses for each DNS query type have been slightly modified. Before the start of making the 3\ntypes of DNS queries, the bot tries to resolve the C2 domain to an IP address. This IP address is used as a\ncheck by the bot to confirm if the C2 has received the message. Below is a table on what each response\nmeans.\n\n**C2 IP Record**\n**Response** **Description**\n\n`255.255.255.255` Retry, cannot reach\n\n<C2_IP> Message received by C2, send next message part of the query type\n\n`239.255.255.255` Sleep and retry\n\nSingle IP For query type `0xfffe, the IP is the identifier`\n\nMultiple IPs For query type `0xffff, the IPs form as a structure for the Bot to parse to`\ndata\n\nAs with the previous version, the DNS query type `0xffff responds with multiple IP records. These`\nrecords form a particular structure (that has been reverse engineered before56), whereby the final message\nis constructed. The change seen is that the resulting data built from the IP records is `xor encoded. The`\nkey to decode the message is `Miguel de Cervantes Saavedra .`\n\n## Conclusion\n\nDespite their simplicity, the changes seen in AnchorDNS are still effective in evading detection. The use of\nAnchorAdjuster allows the threat actors to modify the AnchorDNS backdoor in-place, providing a stealthy\nway to add fresh C2s that have been created for new targets. The actors behind AnchorDNS continue to\nactively develop their toolset, increasing flexibility and raising the barrier for detection.\n\n## IOCs\n\n|C2 IP Record Response|Description|\n|---|---|\n|255.255.255.255|Retry, cannot reach|\n|<C2_IP>|Message received by C2, send next message part of the query type|\n|239.255.255.255|Sleep and retry|\n|Single IP|For query type 0xfffe , the IP is the identifier|\n|Multiple IPs|For query type 0xffff , the IPs form as a structure for the Bot to parse to data|\n\n|SHA256|Description|\n|---|---|\n|cbff159d0b178734248209ae70565d09dddf397ea4e897bf99206ddd74673e6f|AnchorDNS 64-bit DLL|\n|a8a8c66b155fcf9bfdf34ba0aca98991440c3d34b8a597c3fdebc8da251c9634|AnchorDNS 64-bit DLL|\n|9fdbd76141ec43b6867f091a2dca503edb2a85e4b98a4500611f5fe484109513|AnchorDNS 64-bit DLL|\n|ba801f1c2e2c5f5cd961e887cb0776f2d5cee8d17164f29b138a8952dd162165|AnchorDNS 64-bit DLL|\n|0d6a10df6eeb1dbb88b4d625873ed13daa367e165374a72daa16170af3ee31a0|AnchorDNS 64-bit DLL|\n|f93b838dc89e7d3d47b1225c5d4a7b706062fd8a0f380b173c099d0570814348|AnchorAdjuster 64-bit EXE|\n|3ab8a1ee10bd1b720e1c8a8795e78cdc09fec73a6bb91526c0ccd2dc2cfbc28d|AnchorAdjuster 64-bit EXE|\n\n\n-----\n\n**SHA256** **Description**\n\nc1ae70683da042792a504847b426a55cdcbca80dca12517f581a4e089a1f8932 AnchorAdjuster 64-bit\nEXE\n\nC2s\n```\nfarfaris[.]com\nkalarada[.]com\nxyskencevli[.]com\nsluaknhbsoe[.]com\njetbiokleas[.]com\nnyhgloksa[.]com\n\n## References\n\n```\n|c1ae70683da042792a504847b426a55cdcbca80dca12517f581a4e089a1f8932|AnchorAdjuster 64-bit EXE|\n|---|---|\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-15 - Adjusting the Anchor.pdf"
    ],
    "report_names": [
        "2021-07-15 - Adjusting the Anchor.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535729,
    "ts_updated_at": 1743041761,
    "ts_creation_date": 1653779602,
    "ts_modification_date": 1653779602,
    "files": {
        "pdf": "https://archive.orkl.eu/ea87280badef9caab84a0b0433a30d2dd107ead5.pdf",
        "text": "https://archive.orkl.eu/ea87280badef9caab84a0b0433a30d2dd107ead5.txt",
        "img": "https://archive.orkl.eu/ea87280badef9caab84a0b0433a30d2dd107ead5.jpg"
    }
}