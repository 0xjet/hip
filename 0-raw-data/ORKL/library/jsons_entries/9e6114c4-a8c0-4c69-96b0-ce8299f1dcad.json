{
    "id": "9e6114c4-a8c0-4c69-96b0-ce8299f1dcad",
    "created_at": "2023-01-12T14:58:50.353152Z",
    "updated_at": "2025-03-27T02:06:09.907893Z",
    "deleted_at": null,
    "sha1_hash": "b9b756b59ff7071a3cd5615825648e02cfcfd954",
    "title": "2020-05-24 - Examining Smokeloader’s Anti Hooking technique",
    "authors": "",
    "file_creation_date": "2022-05-28T04:00:56Z",
    "file_modification_date": "2022-05-28T04:00:56Z",
    "file_size": 338516,
    "plain_text": "# Examining Smokeloader’s Anti Hooking technique\n\n**[malwareandstuff.com/examining-smokeloaders-anti-hooking-technique/](https://malwareandstuff.com/examining-smokeloaders-anti-hooking-technique/)**\n\n[Published by hackingump on May 24, 2020](https://malwareandstuff.com/author/klopsch/)\n\n\nMay 24, 2020\n\n\nHooking is a technique to intercept function calls/messages or events passed between\nsoftware, or in this case malware. The technique can be used for malicious, as well as\ndefensive cases.\n\nRootkits for example can hook API calls to make themselves invisible from analysis tools,\nwhile we as defenders can use hooking to gain more knowledge of malware or build\ndetection mechanisms to protect customers.\n\n\n-----\n\nCybersecurity continues to be a game of cat and mouses, and while we try to build\nprotections, blackhats will always try to bypass these protection mechanisms. Today I want\nto show you how SmokeLoader bypasses hooks on `ntdll.dll and how Frida can be used`\nto hook library functions.\n\n[The bypass was also already explained in a blog article from Checkpoint[1] written by Israel](https://research.checkpoint.com/2019/2019-resurgence-of-smokeloader/)\nGubi. It also covers a lot more than I do regarding Smokeloader, so it is definitely worth\nreading too.\n\n## Hooking with Frida\n\nIf you’ve read my previous blog articles about QBot, you are familiar with the process\n[iteration and AV detection[3]. It iterates over processes and compares the process name with](https://malwareandstuff.com/an-old-enemy-diving-into-qbot-part-2/)\nentries in a black list containing process names of common AV products. If one process\nname matches with an entry, QBot quits its execution.\n\nFrida is a Dynamic Instrumentation Toolkit which can be used to write dynamic analysis\nscripts in high level languages, in this case JavaScript. If you want to know more about this\n[technology, I advice you to read to visit this website[4] and read its documentation.](https://frida.re/)\n\nWe can write a small Frida script to hook the `lstrcmpiA function in order to investigate`\nwhich process names are in the black list.\n\n\n-----\n\n```\ndef main():\n  \"\"\"Main.\"\"\"\n  # argv[1] is our malware sample\n  pid = frida.spawn(sys.argv[1])\n  sess = frida.attach(pid)\n  script = sess.create_script(\"\"\"\n    console.log(\"[+] Starting Frida script\")\n    var lstrcmpiA = ptr(\"0x76B43E8E\")\n    console.log(\"[+] Hooking lstrcmpiA at \" + lstrcmpiA)\n    Interceptor.attach(lstrcmpiA, {\n      onEnter: function(args) {\n        console.log(\"[+][+] Called strcmpiA\");\n        console.log(\"[+][+] Arg1Addr = \" + args[0]);\n        console.log(\"[+][+] Buffer\");\n        pretty_print(args[0], 0x30);\n        console.log(\"[+][+] Arg2Addr = \" + args[1]);\n        console.log(\"[+][+] Buffer\");\n        pretty_print(args[1], 0x30);\n      },\n      onLeave: function(retval) {\n        console.log(\"[+][+] Returned from strcmpiA\")\n      }\n    });\n    function pretty_print(addr, sz) {\n      var bufptr = ptr(addr);\n      var bytearr = Memory.readByteArray(bufptr, sz);\n      console.log(bytearr);\n    };\n    \"\"\")\n  script.load()\n  frida.resume(pid)\n  sys.stdin.read()\n  sess.detach()\n\n```\nWe attach to the malicious process and hook the `lstrcmpiA function at static address.`\nWhen analysing malware, we have (most of the time) the privilege to control and adjust our\nenvironment as much as we want. If you turn off `ASLR and use snapshots, using Frida with`\nstatic pointers is pretty convenient, because most functions will always have the same\naddress. However, it’s also possible to calculate the addresses dynamically. `lstrcmpiA`\nhas 2 arguments, which are both pointers of type `LPSTR . So we just resolve the pointers, fill`\n```\n0x30 bytes starting at pointer address into a ByteArray and print it.\n\n```\n\n-----\n\nResult of Frida Script\n\n## Smokeloader’s Anti Hooking technique\n\nSo how does Smokeloader bypass hooks? Well it can do it atleast for the `ntdll.dll`\nlibrary. During execution Smokeloader retrieves the Temp folder path and generates a\nrandom name. If a file with the generated name already exists in the temp folder, it is deleted\nwith `DeleteFileW .`\n\n\n-----\n\ndrltrace output DeleteFileW call, deleting 9A26.tmp in Temp Folder\nNext the original `ntdll.dll file is copied from` `system32 to the temp folder with the exact`\nname it just generated. This leads to a copy of this mentioned library being placed in the\ntemp directory.\n\nMeta data of disguised\n\nntdll.dll\n\n\n-----\n\nExport functions of the disguised ntdll file\nInstead of loading the real `ntdll.dll file, the copy is loaded into memory by calling`\n```\nLdrLoadDll .\n\n```\n9A26.tmp as ntdll.dll\nMost AV vendors, as well as analysts probably implemented their hooks on `ntdll.dll, so`\nthe references to the copied `ntdll.dll file will be missed.`\n\nSmokeloader continues to call functions from this copied DLL, using for example function\ncalls like `NtQueryInformationProcess to detect wether a debugger is attached to it.`\n\n## Final Words\n\nWhile analysing SmokeLoader at work, I stumbled across this AntiHook mechanism, which I\nhaven’t seen before, so I wanted to share it here :-).\n\nI’ve also only scratched on the surface of what Frida is capable of. I might work on\nsomething more complex next time.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-24 - Examining Smokeloader’s Anti Hooking technique.pdf"
    ],
    "report_names": [
        "2020-05-24 - Examining Smokeloader’s Anti Hooking technique.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535530,
    "ts_updated_at": 1743041169,
    "ts_creation_date": 1653710456,
    "ts_modification_date": 1653710456,
    "files": {
        "pdf": "https://archive.orkl.eu/b9b756b59ff7071a3cd5615825648e02cfcfd954.pdf",
        "text": "https://archive.orkl.eu/b9b756b59ff7071a3cd5615825648e02cfcfd954.txt",
        "img": "https://archive.orkl.eu/b9b756b59ff7071a3cd5615825648e02cfcfd954.jpg"
    }
}