{
    "id": "394152a4-2f97-4bae-8034-af001d1ccd72",
    "created_at": "2022-10-25T16:48:24.785386Z",
    "updated_at": "2025-03-27T02:09:06.527672Z",
    "deleted_at": null,
    "sha1_hash": "996ff970eccc5d7a891ee5f3835c225043b7e800",
    "title": "10-03-2015-PatrickWardle.indd",
    "authors": "",
    "file_creation_date": "2015-03-17T10:59:47Z",
    "file_modification_date": "2015-03-17T10:59:47Z",
    "file_size": 11911958,
    "plain_text": "# Covering the global threat landscape\n\n\n## DYLIB HIJACKING ON OS X\n_Patrick Wardle_\nSynack, USA\n\n_(This paper was presented at CanSecWest 2015.)_\n\nDLL hijacking is a well known class of attack which was\nalways believed only to affect the Windows OS. However,\nthis paper will show that OS X is similarly vulnerable to\ndynamic library hijacks. By abusing various features and\nundocumented aspects of OS X’s dynamic loader, attackers\nneed only to ‘plant’ specially crafted dynamic libraries to\nhave malicious code automatically loaded into vulnerable\napplications. Using this method, such attackers can perform\na wide range of malicious and subversive actions, including\nstealthy persistence, load-time process injection, security\nsoftware circumvention, and a Gatekeeper bypass (affording\nopportunities for remote infection). Since this attack\nabuses legitimate functionality of the OS, it is challenging\nto prevent and unlikely to be patched. However, this\npaper will present techniques and tools that can uncover\nvulnerable binaries as well as detect if a hijacking has\noccurred.\n\n### BACKGROUND\n\nBefore detailing the dynamic library (dylib) hijacking attack\non OS X, dynamic link library (DLL) hijacking on Windows\nwill briefl y be reviewed. As the two attacks are conceptually\nquite similar, examining the well-understood Windows attack\ncan help in gaining an understanding of the former.\n\nDLL hijacking on Windows is best explained by Microsoft:\n\n‘When an application dynamically loads a dynamic link\nlibrary (DLL) without specifying a fully qualifi ed path\nname, Windows tries to locate the DLL by searching\na well-defi ned set of directories. If an attacker gains\ncontrol of one of the directories, they can force the\napplication to load a malicious copy of the DLL instead\nof the DLL that it was expecting.’ [1]\n\nTo reiterate, the default search behaviour of the Windows\nloader is to search various directories (such as the\napplication’s directory or the current working directory)\nbefore the Windows system directory. This can be\nproblematic if an application attempts to load a system\nlibrary via an insuffi ciently qualifi ed path (i.e. just by its\nname). In such a scenario, an attacker may ‘plant’ a malicious\nDLL (the name of which matches that of the legitimate\nsystem DLL) in one of the primary search directories. With\nthis malicious DLL in place, the Windows loader will fi nd the\n\n\nattacker’s library before the legitimate DLL and blindly load\nit into the context of the vulnerable application.\n\nThis is illustrated in Figures 1 and 2, where a vulnerable\napplication (Figure 1) is hijacked by a malicious DLL that\nhas been planted in the primary search directory (Figure 2).\n\n_Figure 1: Loading the legitimate system DLL._\n\n_Figure 2: Loading the attacker’s malicious DLL._\n\nDLL hijacking attacks initially gained notoriety in 2010\nand quickly grabbed the attention of both the media and\nmalicious attackers. Also known as ‘binary planting’,\n‘insecure library loading’ or ‘DLL preloading’, the discovery\nof this vulnerability is often attributed to H.D. Moore [2, 3].\nHowever, the NSA was actually the fi rst to note this fl aw,\n12 years prior to Moore, in 1998. In the NSA’s unclassifi ed\n‘Windows NT Security Guidelines’, the organization both\ndescribes and warns of DLL hijacking:\n\n‘It is important that penetrators can’t insert a “fake”\nDLL in one of these directories where the search fi nds it\nbefore a legitimate DLL of the same name.’ [4]\n\nTo an attacker, DLL hijacking affords many useful scenarios.\nFor example, such attacks can allow a malicious library to\nstealthily be persisted (without modifying the registry or\nother components of the OS), privileges to be escalated, and\neven provides the means for remote infection.\n\nMalware authors were fairly quick to realize the benefi ts of\nDLL hijacking. In a blog post entitled ‘What the fxsst?’ [5],\n_Mandiant researchers described how they had uncovered_\nvarious unrelated malware samples all named ‘fxsst.dll’.\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\n_Figure 3: Carberp abusing a DLL hijack to bypass UAC._\n\n\nUpon closer inspection, they found that the samples were\nall exploiting a DLL hijacking vulnerability in the Windows\nshell (Explorer.exe), that provided a stealthy method of\npersistence. Specifi cally, as Explorer.exe was installed in\nC: \\Windows, planting a library named fxsst.dll in the same\ndirectory would result in the persistence of the malicious\nDLL as the loader searched the application’s directory before\nthe system directory where the legitimate fxsst.dll lived.\n\nAnother example of malware using a DLL hijack can be\nfound within the leaked source code for the banking trojan\n‘Carberp’ [6]. The source code shows the malware bypassing\nUser Account Control (UAC) via a DLL hijack of\nsysprep.exe (see Figure 3). This binary is an auto-elevated\nprocess, meaning that it requires no UAC prompt to gain\nelevated status. Unfortunately, it was found to be vulnerable\nto a DLL hijacking attack and would load a maliciously\nplanted DLL (named cryptbase.dll) into its elevated process\ncontext [7].\n\nThese days, DLL hijacking on Windows is somewhat\nuncommon. Microsoft was swift to respond to attacks,\npatching vulnerable applications and detailing how others\ncould avoid this issue (i.e. simply by specifying an absolute,\nor fully qualifi ed path for imported DLLs) [8]. Moreover,\nOS-level mitigations were introduced, which if enabled via the\nSafeDllSearchMode and/or CWDIllegalInDllSearch registry\nkeys, stop the majority of DLL hijackings generically.\n\n### DYLIB HIJACKING ON OS X\n\nIt has always been assumed that dynamic library hijacking\nwas a Windows-only problem. However, as one astute\n_StackOverfl ow user pointed out in 2010, ‘any OS which_\nallows for dynamic linking of external libraries is\ntheoretically vulnerable to this’ [9]. It took until 2015 for\nhim to be proved correct – this paper will reveal an equally\ndevastating dynamic library hijack attack affecting OS X.\n\nThe goal of the research presented here was to determine\nwhether OS X was vulnerable to a dynamic library attack.\n\n\nSpecifi cally, the research sought to answer the question:\ncould an attacker plant a malicious OS X dynamic library\n(dylib) such that the OS’s dynamic loader would load\nit automatically into a vulnerable application? It was\nhypothesized that, much like DLL hijacking on Windows,\nsuch an attack on OS X would provide an attacker with a\nmyriad of subversive capabilities. For example, stealthy\npersistence, load-time process injection, security software\ncircumvention, and perhaps even ‘remote’ infection.\n\nIt should be noted that several constraints were placed\nupon this undertaking. First, success was constrained\nby disallowing any modifi cation to the system – except\nfor the creation of fi les (and if necessary folders). In\nother words, the research ignored attack scenarios that\nrequired the subverting of existing binaries (e.g. patching)\nor modifi cations to existing OS confi guration fi les (e.g.\n‘auto-run’ plists, etc.). As such attacks are well known and\ntrivial both to prevent and to detect, they were ignored. The\nresearch also sought a method of hijack that was completely\nindependent of the user’s environment. OS X provides\nvarious legitimate means to control the environment in\na manner that could coerce the loader to load malicious\nlibraries automatically into a target process. These\nmethods, such as setting the DYLD_INSERT_LIBRARIES\nenvironment variable, are user-specifi c and, again, well\nknown and easy to detect. As such, they were of little\ninterest and were ignored.\n\nThe research began with an analysis of the OS X dynamic\nlinker and loader, dyld. This binary, found within /usr/bin,\nprovides standard loader and linker functionality including\nfi nding, loading and linking dynamic libraries.\n\nAs Apple has made dyld open source [10], analysis was\nfairly straightforward. For example, reading the source code\nprovided a decent understanding of dyld’s actions as an\nexecutable is loaded and its dependent libraries are loaded\nand linked in. The following briefl y summarizes the initial\nsteps taken by dyld (focusing on those that are relevant to the\nattack described in this paper):\n\n\n-----\n\n1. As any new process is started, the kernel sets the\nuser-mode entry point to point to __dyld_start\n(dyldStartup.s). This function simply sets up the stack\nthen jumps to dyldbootstrap::start(), which in turn calls\nthe loader’s _main().\n\n2. Dyld’s _main() function (dyld.cpp) invokes link(),\nwhich then calls an ImageLoader object’s link() method\nto kick off the linking process for the main executable.\n\n3. The ImageLoader class (ImageLoader.cpp) exposes\nmany functions that dyld calls in order to perform\nvarious binary image loading logic. For example,\nthe class contains a link() method. When called, this\ninvokes the object’s recursiveLoadLibraries() method to\nperform the loading of all dependent dynamic libraries.\n\n4. The ImageLoader’s recursiveLoadLibraries() method\ndetermines all required libraries and invokes the\ncontext.loadLibrary() function on each. The context\nobject is simply a structure of function pointers that\nis passed around between methods and functions. The\nloadLibrary member of this structure is initialized with\nthe libraryLocator() function (dyld.cpp), which simply\ncalls the load() function.\n\n5. The load() function (dyld.cpp) calls various helper\nfunctions within the same fi le, named loadPhase0()\nthrough to loadPhase5(). Each function is responsible\nfor handling a specifi c task of the load process, such as\nresolving paths or dealing with environment variables\nthat can affect the load process.\n\n6. After loadPhase5(), the loadPhase6() function\nfi nally loads (maps) the required dylibs from the fi le\nsystem into memory. It then calls into an instance of\nthe ImageLoaderMachO class in order to perform\nMach-O-specifi c loading and linking logic on each dylib.\n\nWith a basic understanding of dyld’s initial loading logic,\nthe research turned to hunting for logic that could be abused\nto perform a dylib hijack. Specifi cally, the research was\ninterested in code in the loader that didn’t error out if a dylib\nwasn’t found, or code that looked for dylibs in multiple\nlocations. If either of these scenarios was realized within\nthe loader, it was hoped that an OS X dylib hijack could be\nperformed.\n\nThe initial scenario was investigated fi rst. In this case, it\nwas hypothesized that if the loader could handle situations\nwhere a dylib was not found, an attacker (who could\nidentify such situations) could place a malicious dylib in\nthis presumed location. From then on, the loader would\nnow ‘fi nd’ the planted dylib and blindly load the attacker’s\nmalicious code.\n\nRecall that the loader calls the ImageLoader class’s\nrecursiveLoadLibraries() method to both fi nd and load all\nrequired libraries. As shown in Figure 4, the loading code\n\n\nVIRUS BULLETIN  www.virusbtn.com\n\nis wrapped in a try/catch block to detect dylibs that fail to\nload.\n\n_Figure 4: Error logic for dylib load failures._\n\nUnsurprisingly, there is logic to throw an exception (with a\nmessage) if a library fails to load. Interestingly though, this\nexception is only thrown if a variable named ‘required’ is set\nto true. Moreover, the comment in the source code indicates\nthat failure to load ‘weak’ libraries is OK. This seems to\nindicate that some scenario exists where the loader is OK\nwith missing libraries – perfect!\n\nDigging deeper into the loader’s source code revealed\nwhere this ‘required’ variable is set. Specifi cally,\nthe doGetDependentLibraries() method of the\nImageLoaderMacho class parses the load commands\n(described below) and sets the variable based on whether\nor not the load command is of type LC_LOAD_WEAK_\nDYLIB.\n\nLoad commands are an integral component of the Mach-O\nfi le format (OS X’s native binary fi le format). Embedded\nimmediately following the Mach-O header, they provide\nvarious commands to the loader. For example, there are load\ncommands to specify the memory layout of the binary, the\ninitial execution state of the main thread, and information\nabout the dependent dynamic libraries for the binary. To\nview the load commands of a compiled binary, a tool such as\nMachOView [11] or /usr/bin/otool (with the -l command-line\nfl ag) can be used (see Figure 6).\n\nThe code in Figure 5 shows the loader iterating over all the\nload commands within a binary, looking for those that specify\na dylib import. The format of such load commands (e.g.\nLC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB, etc.) can\nbe found in the mach-o/loader.h fi le.\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\n_Figure 5: Setting the ‘required’ variable (src fi le?)._\n\n_Figure 6: Dumping Calculator.app’s load commands with MachOView._\n\nimported via LC_LOAD_WEAK_DYLIB are optional (i.e.\n‘weak’). In the case of the former (LC_LOAD_DYLIB),\nan exception will be thrown if the required dylib is not\nfound, causing the loader to abort and terminate the process.\nHowever, in the latter case (LC_LOAD_WEAK_DYLIB), the\ndylib is optional. If such a ‘weak’ dylib is not found, no harm\nis done, and the main binary will still be able to execute.\n\n_Figure 7: The format of the LC_LOAD_* load commands._\n\n\nFor each dylib that an executable was dynamically linked\nagainst, it will contain an LC_LOAD_* (LC_LOAD_DYLIB,\nLC_LOAD_WEAK_DYLIB, etc.) load command. As the\nloader code in Figures 4 and 5 illustrates, LC_LOAD_DYLIB\nload commands specify a required dylib, while libraries\n\n\n_Figure 8: Attempting to load a ‘weak’ dylib (LC_LOAD__\n_WEAK_DYLIB)._\n\nThis loader logic fulfi lled the fi rst hypothetical hijack\nscenario, and as such, provided a dylib hijack attack on OS X.\nNamely, as illustrated in Figure 9, if a binary specifi es a weak\n\n\n-----\n\nimport that is not found, an attacker can place a malicious\ndylib in this presumed location. From then on, the loader will\n‘fi nd’ the attacker’s dylib and blindly load this malicious code\ninto the process space of the vulnerable binary.\n\n_Figure 9: Hijacking an application via a malicious ‘weak’_\n_dylib._\n\nRecall that another hijack attack was hypothesized if a\nscenario existed where the loader searched for dynamic\nlibraries in multiple locations. In this case, it was thought that\nan attacker would be able to place a malicious dylib in one\nof the primary search directories (if the legitimate dylib was\nfound elsewhere). It was hoped that the loader would then\nfi nd the attacker’s malicious dylib fi rst (before the legitimate\none), and thus naively load the attacker’s malicious library.\n\nOn OS X, load commands such as LC_LOAD_DYLIB\nalways specify a path to the dynamic library (as opposed\nto Windows, where just the name of the library may be\nprovided). Because a path is provided, dyld generally does\nnot need to search various directories to fi nd the dynamic\nlibrary. Instead, it can simply go directly to the specifi ed\ndirectory and load the dylib. However, analysis of dyld’s\nsource code uncovered a scenario in which this generality did\nnot hold.\n\nLooking at the loadPhase3() function in dyld.cpp revealed\nsome interesting logic, as shown in Figure 10.\n\n\nVIRUS BULLETIN  www.virusbtn.com\n\nDyld will iterate over an rp->paths vector, dynamically\nbuilding paths (held within the ‘newPath’ variable) which are\nthen loaded via the loadPhase4() function. While this does\nseem to fulfi l the requirement of the second hijack scenario\n(i.e. dyld looking in multiple locations for the same dylib), a\ncloser examination was required.\n\nThe comment on the fi rst line of dyld’s source in Figure\n10 mentions the term ‘@rpath.’ According to Apple\ndocumentation, this is a special loader keyword (introduced\nin OS X 10.5, Leopard) that identifi es a dynamic library as\na ‘run-path-dependent library’ [12]. Apple explains that a\nrun-path dependent library ‘is a dependent library whose\ncomplete install name (path) is not known when the library\nis created’ [12]. Other online documentation such as [13]\nand [14] provides more detail, describing the role of these\nlibraries and explaining how the @rpath keyword enables:\n‘frameworks and dynamic libraries to fi nally be built only\nonce and be used for both system-wide installation and\nembedding without changes to their install names, and\nallowing applications to provide alternate locations for a\ngiven library, or even override the location specifi ed for a\ndeeply embedded library’ [14].\n\nWhile this feature allows software developers to deploy\ncomplex applications more easily, it can also be abused to\nperform a dylib hijack. This is true since in order to make use\nof run-path-dependent libraries, ‘an executable provides a list\nof run-path search paths, which the dynamic loader traverses\nat load time to fi nd the libraries’ [12]. This is realized in code\nin various places within dyld, including the code snippet that\nwas presented in Figure 10.\n\nSince run-path dependent libraries are relatively novel and\nsomewhat unknown, it seemed prudent to provide an example\nof building both a legitimate run-path-dependent library and a\nsample application that links against it.\n\nA run-path-dependent library is a normal dylib whose install\nname is prefi xed with ‘@rpath’. To create such a library in\nXcode one can simply set the dylib’s installation directory to\n‘@rpath’, as shown in Figure 11.\n\n_Figure 11: Building a run-path-dependent library._\n\n\nOnce the run-path-dependent library was compiled,\nexamination of the LC_ID_DYLIB load command (which\n_Figure 10: Loading ‘rpath’ dependent libraries._ contains identifying information about the dylib) showed the\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\nrun-path of the dylib. Specifi cally, the ‘name’ (path) within\nthe LC_ID_DYLIB load command contained the dylib’s\nbundle (rpathLib.framework/ Versions/A/rpathLib), prefi xed\nwith the ‘@rpath’ keyword (see Figure 12).\n\n_Figure 12: ‘@rpath’ embedded in the dylib’s ‘install name’_\n_(path)._\n\nBuilding an application that linked against a\nrun-path-dependent library was fairly straightforward as well.\nFirst, the run-path-dependent library was added to the ‘Link\nBinary With Libraries’ list in Xcode. Then a list of run-path\nsearch directories was added to the ‘Runpath Search Paths’\nlist. As will be shown, these search directories are traversed\nby the dynamic loader at load time in order to locate the\nrun-path-dependent libraries.\n\n_Figure 13: Linking in a @rpath’d dylib and specifying the_\n_run path search paths._\n\nOnce the application was built, dumping its load commands\nrevealed various commands associated with the run-path\nlibrary dependency. A standard LC_LOAD_DYLIB load\ncommand was present for the dependency on the run-pathdependent dylib, as shown in Figure 14.\n\n_Figure 14: The dependency on the @rpath’d dylib._\n\nIn Figure 14, note that the install name (i.e. path) to the\nrun-path-dependent dylib is prefi xed with ‘@rpath’ and\nmatches the name value from the LC_ID_DYLIB load\ncommand of the run-path-dependent dylib (see Figure 12).\nThis application’s embedded LC_LOAD_DYLIB load\n\n\ncommand with the run-path-dependent dylib tells the loader,\n‘I depend on the rpathLib dylib, but when built, I didn’t know\nexactly where it would be installed. Please use my embedded\nrun-path search paths to fi nd it and load it!’\n\nThe run-path search paths that were entered into the\n‘Runpath Search Paths’ list in Xcode generated LC_RPATH\nload commands – one for each search directory. Dumping\nthe load commands of the compiled application revealed\nthe embedded LC_RPATH load commands, as shown in\nFigure 15.\n\n_Figure 15: The embedded run-path search paths (directories)._\n\nWith a practical understanding of run-path-dependent dylibs\nand an application that linked against one, it was easy to\nunderstand dyld’s source code which was responsible for\nhandling this scenario at load time.\n\nWhen an application is launched, dyld will parse the\napplication’s LC_LOAD_* load commands in order to load\nand link all dependent dylibs. To handle run-path-dependent\nlibraries, dyld performs two distinct steps: it extracts all\nembedded run-path search paths and then uses this list to fi nd\nand load all run-path-dependent libraries.\n\nIn order to extract all embedded run-path search paths, dyld\ninvokes the getRPaths() method of the ImageLoader class.\nThis method (invoked by the recursiveLoadLibraries()\nmethod) simply parses the application for all LC_RPATH\nload commands. For each such load command, it extracts the\nrun-path search path and appends it to a vector (i.e. a list), as\nshown in Figure 16.\n\n_Figure 16: Extracting and saving all embedded run-path_\n_search paths._\n\n\n-----\n\nWith a list of all embedded run-path search paths, dyld can\nnow ‘resolve’ all dependent run-path-dependent libraries.\nThis logic is performed in the loadPhase3() function in\ndyld.cpp. Specifi cally, the code (shown in Figure 17) checks\nto see if a dependent library’s name (path) is prefi xed with the\n‘@rpath’ keyword. If so, it iterates over the list of extracted\nrun-path search paths, replacing the ‘@rpath’ keyword in the\nimport with the current search path. Then it attempts to load\nthe dylib from this newly resolved directory.\n\n_Figure 17: Searching run-path search directories for_\n_@rpath’d dylibs._\n\nIt is important to note that the order of the directories that\ndyld searches is deterministic and matches the order of the\nembedded LC_RPATH load commands. Also, as is shown in\nthe code snippet in Figure 17, the search continues until the\ndependent dylib is found or all paths have been exhausted.\n\nFigure 18 illustrates this search conceptually. The loader (dyld)\ncan been seen searching the various embedded run-path search\npaths in order to fi nd the required run-path-dependent dylib.\nNote that in this example scenario, the dylib is found in the\nsecond (i.e. non-primary) search directory (see Figure 18).\n\n_Figure 18: Dyld searching multiple run-path search_\n_directories._\n\n\nVIRUS BULLETIN  www.virusbtn.com\n\nThe astute reader will recognize that this loader logic opens\nup yet another avenue for a dylib hijack attack. Specifi cally,\nif an application is linked against a run-path-dependent\nlibrary, has multiple embedded run-path search paths, and the\nrun-path-dependent library is not found in a primary search\npath, an attacker can perform a hijack. Such a hijack may\nbe accomplished simply by ‘planting’ a malicious dylib into\nany of the primary run-path search paths. With the malicious\ndylib in place, any time the application is subsequently run,\nthe loader will fi nd the malicious dylib fi rst, and load it\nblindly (see Figure 19).\n\n_Figure 19: Hijacking an application via a malicious ‘@rpath’_\n_dylib._\n\nTo summarize the fi ndings so far: an OS X system is vulnerable\nto a hijacking attack given the presence of any application that:\n\n1. Contains an LC_LOAD_WEAK_DYLIB load\ncommand that references a non-existent dylib.\n\nor\n\n2. Contains both an LC_LOAD*_DYLIB load command\nthat references a run-path-dependent library (‘@rpath’)\nand multiple LC_RPATH load commands, with the runpath-dependent library not found in a primary run-path\nsearch path.\n\nThe remainder of this paper will fi rst walk through a\ncomplete dylib hijack attack, then present various attack\nscenarios (persistence, load-time process injection, ‘remote’\ninfection etc.), before concluding with some possible\ndefences to counter such an attack.\n\nIn order to assist the reader in gaining a deeper understanding\nof dylib hijacking, it seems prudent to detail the trials, errors,\nand ultimate success of a hijack attack. Armed with this\nknowledge it will be trivial to understand attack automation,\nattack scenarios, and practical defences.\n\nRecall the previously described sample application\n(‘rPathApp.app’) that was created in order to illustrate linking\nagainst a run-path-dependent dylib. This application will be\nthe target of the hijack.\n\nA dylib hijack is only possible against a vulnerable\napplication (that is to say, one that fulfi ls either of the\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\ntwo previously described hijack conditions). Since the\nexample application (rPathApp.app) links against a\nrun-path-dependent dylib, it may be vulnerable to the\nsecond hijack scenario. The simplest way to detect such a\nvulnerability is to enable debug logging in the loader, then\nsimply run the application from the command line. To enable\nsuch logging, set the DYLD_PRINT_RPATHS environment\nvariable. This will cause dyld to log its @rpath expansions\nand dylib loading attempts. Viewing this output should\nquickly reveal any vulnerable expansions (i.e. a primary\nexpansion that points to a non-existent dylib), as shown in\nFigure 20.\n\n_Figure 20: The vulnerable (test) application, rPathApp._\n\nFigure 20 shows the loader fi rst looking for a required dylib\n(rpathLib) in a location where it does not exist. As was\nshown in Figure 19, in this scenario, an attacker could plant a\nmalicious dylib in this primary run-path search path and the\nloader will then load it blindly.\n\nA simple dylib was created to act as a malicious hijacker\nlibrary. In order to gain automatic execution when loaded,\nthe dylib implemented a constructor function. Such a\nconstructor is executed automatically by the operating\nsystem when the dylib is loaded successfully. This is a nice\nfeature to make use of, since generally code within a dylib\nisn’t executed until the main application calls into it via some\nexported function.\n\n_Figure 21: A dylib’s constructor will automatically be_\n_executed._\n\nOnce compiled, this dylib was renamed to match the target\n(i.e. legitimate) library: rpathlib. Following this, the necessary\ndirectory structure (Library/One/rpathLib.framework/\nVersions/A/) was created and the ‘malicious’ dylib was\ncopied in. This ensured that whenever the application was\nlaunched, dyld would now fi nd (and load) the hijacker dylib\nduring the search for the run-path dependent dylib.\n\n\n_Figure 22: The ‘malicious’ dylib placed in the primary_\n_run-path search path._\n\nUnfortunately, this initial hijack attempt failed and the\napplication crashed miserably, as shown in Figure 23.\n\n_Figure 23: Success! Then crash and burning._\n\nThe good news, though, was that the loader found and\nattempted to load the hijacker dylib (see the ‘RPATH\nsuccessful expansion…’ log message in Figure 23). And\nalthough the application crashed, this was preceded by an\ninformative and verbose exception, thrown by dyld. The\nexception seemed self explanatory: the version of the hijacker\ndylib was not compatible with the required (or expected)\nversion. Digging into the loader’s source code revealed the\ncode that triggered this exception, as shown in Figure 24.\n\n_Figure 24: Dyld extracting and comparing compatibility_\n_version numbers._\n\n\n-----\n\nAs can be seen, the loader invokes the doGetLibraryInfo()\nmethod to extract compatibility and current version numbers\nfrom the LC_ID_DYLIB load command of the library that\nis being loaded. This extracted compatibility version number\n(‘minVersion’) is then checked against the version that\nthe application requires. If it is too low, an incompatibility\nexception is thrown.\n\nIt was quite trivial to fi x the compatibility issue (and thus\nprevent the exception) by updating the version numbers in\nXcode, and then recompiling, as shown in Figure 25.\n\n_Figure 25: Setting the compatibility and current version_\n_numbers._\n\nDumping the LC_ID_DYLIB load command of the\nrecompiled hijacker dylib confi rmed the updated (and now\ncompatible) version numbers, as shown in Figure 26.\n\n_Figure 26: Embedded compatibility and current version_\n_numbers._\n\nThe updated hijacker dylib was re-copied into the\napplication’s primary run-path search directory. Relaunching\nthe vulnerable application again showed the loader ‘fi nding’\nthe hijacker dylib and attempting to load it. Alas, although\nthe dylib was now seen as compatible (i.e. the version\nnumber checks passed), a new exception was thrown and the\napplication crashed once again, as shown in Figure 27.\n\n_Figure 27: ‘Symbol not found’ exception._\n\n\nVIRUS BULLETIN  www.virusbtn.com\n\nOnce again, the exception was quite verbose, explaining\nexactly why the loader threw it, and thus killed the\napplication. Applications link against dependent libraries\nin order to access functionality (such as functions,\nobjects, etc.) that are exported by the library. Once a\nrequired dylib is loaded into memory, the loader will\nattempt to resolve (via exported symbols) the required\nfunctionality that the dependent library is expected to\nexport. If this functionality is not found, linking fails and\nthe loading and linking process is aborted, thus crashing\nthe process.\n\nThere were various ways to ensure that the hijacker\ndylib exported the correct symbols, such that it would be\nfully linked in. One naive approach would have been to\nimplement and export code directly within the hijacker\ndylib to mimic all the exports of the target (legitimate)\ndylib. While this would probably have succeeded, it\nseemed complex and dylib specifi c (i.e. targeting another\ndylib would have required other exports). A more elegant\napproach was simply to instruct the linker to look elsewhere\nfor the symbols it required. Of course, that elsewhere was\nthe legitimate dylib. In this scenario, the hijacker dylib\nwould simply acts as a proxy or ‘re-exporter’ dylib, and as\nthe loader would follow its re-exporting directives, no linker\nerrors would be thrown.\n\n_Figure 28: Re-exporting to the legitimate dylib._\n\nIt took some effort to get the re-exportation working\nseamlessly. The fi rst step was to return to Xcode and add\nseveral linker fl ags to the hijacker dylib project. These fl ags\nincluded ‘-Xlinker’, ‘reexport_library’, and then the path to\nthe target library which contained the actual exports that the\nvulnerable application was dependent upon.\n\n_Figure 29: Required linker fl ags to enable re-exporting._\n\nThese linker fl ags generated an embedded LC_REEXPORT_\nDYLIB load command that contained the path to the target\n(legitimate) library, as shown in Figure 30.\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\n_Figure 30: Embedded LC_REEXPORT_DYLIB load_\n_command._\n\nHowever, all was not well. Since the re-export target of the\nhijacker dylib was a run-path-dependent library, the name\nfi eld in the embedded LC_REEXPORT_DYLIB (extracted\nfrom the legitimate dylib’s LC_ID_DYLIB load command)\nbegan with ‘@rpath’. This was problematic since, unlike\nLC_LOAD*_DYLIB load commands, dyld does not resolve\nrun-path dependent paths in LC_REEXPORT_DYLIB load\ncommands. In other words, the loader will try to load\n‘@rpath/rpathLib.framework/Versions/A/rpathLib’ directly\nfrom the fi le system. This, of course, would clearly fail.\n\nThe solution was to resolve the embedded ‘@rpath’ path,\nproviding the full path of the target library in the LC_\nREEXPORT_DYLIB load command. This was accomplished\nwith one of Apple’s developer tools: install_name_tool.\nTo update the embedded install name (path) in the LC_\nREEXPORT_DYLIB load command, the tool was executed\nwith the -change fl ag, the existing name (within the LC_\nREEXPORT_DYLIB), the new name, and fi nally the path to\nthe hijacker dylib, as shown in Figure 31.\n\n_Figure 31: Using install_tool_name to update the embedded_\n_name (path)._\n\nWith the path in the LC_REEXPORT_DYLIB load command\nupdated correctly, the hijacked dylib was re-copied into the\napplication’s primary run-path search directory, and then\nthe application was re-executed. As shown in Figure 32, this\nfi nally resulted in success.\n\nTo summarize: since the rPathApp application linked against\na run-path-dependent library which was not found in the\ninitial run-path search directory, it was vulnerable to a dylib\nhijack attack. Planting a specially compatible malicious\ndylib in the initial search path directory caused the loader to\nload the hijacker dylib blindly each time the application was\n\n\n_Figure 32: Successfully dylib hijacking a vulnerable_\n_application._\n\nexecuted. Since the malicious dylib contained the correct\nversioning information as well as re-exporting all symbols to\nthe legitimate dylib, all the required symbols were resolved,\nthus ensuring no functionality within the application was lost\nor broken.\n\n### ATTACKS\n\nWith a solid understanding of dylib hijacking on OS X behind\nus, it is now time to illustrate some real-life attack scenarios\nand provide some practical defences.\n\nAdvanced adversaries understand the importance of\nautomating as many components of an attack as possible.\nSuch automation increases scale and effi ciency, freeing the\nattacker to focus on more demanding or complex aspects of\nthe attack.\n\nThe fi rst component of the hijack attack that was automated\nwas the discovery of vulnerable applications. A Python\nscript, dylibHijackScanner.py (available for download at\n\n[15]), was created to accomplish this task. After gathering\neither a list of running processes or all executables on the\nfi le system, the script intelligently parses the binaries’\nMach-O headers and load commands. To detect binaries\nthat may be hijacked via weak dylibs, the script looks for\nLC_LOAD_WEAK_DYLIB load commands that reference\nnon-existent dylibs. Automatically detecting binaries that\nmay be hijacked due to non-existent @rpath’d imports was a\nlittle more complex. First, the script looks for a binary with at\nleast one LC_LOAD*_DYLIB load command that references\na run-path-dependent dylib. If such a load command is found,\nthe script continues parsing the binary’s load commands\nlooking for multiple LC_RPATHs. In the case that both these\nprerequisites hold true, the script checks to see whether the\nrun-path-dependent library import is found in a primary\nrun-path search path. If the library does not exist, the script\nalerts the user that the binary is vulnerable. Executing the\n\n\n-----\n\nscanner script revealed a surprising number of vulnerable\napplications, including (as expected) the vulnerable test\napplication, rPathApp.app.\n\n_Figure 33: Automatically detecting vulnerable applications._\n\nAs can be seen in Figure 33, the scanner script found nearly\n150 vulnerable binaries just on the author’s work laptop!\nInterestingly, the majority of vulnerable applications fell into\nthe more complex (from a prerequisite standpoint) ‘multiple\nrpath’ category. Due to space constraints, the full list of\nvulnerable applications cannot be shown here. However,\nTable 1 lists several of the more widespread or wellrecognized applications that were found by the scanner script\nto be vulnerable to a dylib hijack.\n\n**Application** **Company** **Vulnerability**\n\niCloud Photos Apple rpath import\n\nXcode Apple rpath import\n\nWord Microsoft rpath & weak import\n\nExcel Microsoft rpath & weak import\n\nGoogle Drive Google rpath import\n\nJava Oracle rpath import\n\nGPG Keychain GPG Tools rpath import\n\nDropbox (garcon) Dropbox rpath import\n\n_Table 1: Common vulnerable applications._\n\nWith an automated capability to uncover vulnerable\napplications, the next logical step was to automate the creation\nof compatible hijacker dylibs. Recall that two components of\nthe hijacker dylib had to be customized in order to perform\na hijack successfully. First, the hijacker dylib’s versioning\nnumbers had to be compatible with the legitimate dylib.\nSecond (in the case of the rpath hijack), the hijacker dylib also\nhad to contain a re-export (LC_REEXPORT_DYLIB) load\ncommand that pointed to the legitimate dylib, ensuring that all\nrequired symbols were resolvable.\n\nIt was fairly straightforward to automate the customization\nof a generic dylib to fulfi l these two prerequisites. A second\nPython script, createHijacker.py (also available for download\n\n\nVIRUS BULLETIN  www.virusbtn.com\n\nat [15]), was created to perform this customization. First,\nthe script fi nds and parses the relevant LC_ID_DYLIB load\ncommand within the target dylib (the legitimate dylib which\nthe vulnerable application loads). This allows the necessary\ncompatibility information to be extracted. Armed with this\ninformation, the hijacker dylib is similarly parsed, until its\nLC_ID_DYLIB load command is found. The script then\nupdates the hijacker’s LC_ID_DYLIB load command with\nthe extracted compatibility information, thus ensuring a\nprecise compatibility versioning match. Following this, the\nre-export issue is addressed by updating the hijacker dylib’s\nLC_REEXPORT_DYLIB load command to point to the\ntarget dylib. While this could have been achieved by updating\nthe LC_REEXPORT_DYLIB load command manually, it\nproved far easier simply to execute the install_name_tool\ncommand.\n\nFigure 34 shows the Python script automatically confi guring\na generic hijacker dylib in order to exploit the vulnerable\nexample application, rpathApp.app.\n\n_Figure 34: Automated hijacker creation._\n\nDylib hijacking can be used to perform a wide range of\nnefarious actions. This paper covers several of these,\nincluding persistence, load-time process injection, bypassing\nsecurity products, and even a Gatekeeper bypass. These\nattacks, though highly damaging, are all realized simply\nby planting a malicious dylib which abuses legitimate\nfunctionality provided by the OS loader. As such, they are\ntrivial to accomplish yet unlikely to be ‘patched out’ or even\ndetected by personal security products.\n\nUsing dylib hijacking to achieve stealthy persistence is one\nof the most advantageous uses of the attack. If a vulnerable\napplication is started automatically whenever the system\nis rebooted or the user logs in, a local attacker can perform\na persistent dylib hijack to gain automatic execution of\nmalicious code. Besides a novel persistence mechanism, this\n\n|Application|Company|Vulnerability|\n|---|---|---|\n|iCloud Photos|Apple|rpath import|\n|Xcode|Apple|rpath import|\n|Word|Microsoft|rpath & weak import|\n|Excel|Microsoft|rpath & weak import|\n|Google Drive|Google|rpath import|\n|Java|Oracle|rpath import|\n|GPG Keychain|GPG Tools|rpath import|\n|Dropbox (garcon)|Dropbox|rpath import|\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\nscenario affords the attacker a fairly high level of stealth.\nFirst, it simply requires the planting of a single fi le – no\nOS components (e.g. startup confi guration fi les or signed\nsystem binaries) are modifi ed. This is important since such\ncomponents are often monitored by security software or are\ntrivial to verify. Second, the attacker’s dylib will be hosted\nwithin the context of an existing trusted process, making it\ndiffi cult to detect as nothing will obviously appear amiss.\n\nOf course, gaining such stealthy and elegant persistence\nrequires a vulnerable application that is automatically\nstarted by the OS. Apple’s iCloud Photo Stream Agent\n(/Applications/iPhoto.app/Contents/Library/LoginItems/\nPhotoStreamAgent.app) is started automatically whenever a\nuser logs in, in order to sync local content with the cloud. As\nluck would have it, the application contains multiple run-path\nsearch directories and several @rpath imports that are not\nfound in the primary run-path search directory. In other\nwords, it is vulnerable to a dylib hijack attack.\n\n_Figure 35: Apple’s vulnerable Photo Stream Agent._\n\nUsing the createHijacker.py script, it was trivial to confi gure\na malicious hijacker dylib to ensure compatibility with the\ntarget dylib and application. It should be noted that in this\ncase, since the vulnerable import (‘PhotoFoundation’) was\nfound within a framework bundle, the same bundle structure\nwas recreated in the primary run-path search directory\n(/ Applications/iPhoto.app/Contents/Library/LoginItems/).\nWith the correct bundle layout and malicious hijacker dylib\n(renamed as ‘PhotoFoundation’) placed within the primary\nrun-path search directory, the loader found and loaded the\nmalicious dylib whenever the iCloud Photo Stream Agent\nwas started. Since this application was executed by the OS,\nthe hijacker dylib was stealthily and surreptitiously persisted\nacross reboots.\n\n_Figure 36: Hijacking Apple’s Photo Stream Agent for_\n_persistence._\n\nAs a fi nal note on persistence, if no vulnerable applications are\nfound to be started automatically by the OS, any vulnerable\napplication commonly started by the user (such as a browser,\n\n\nor mail client) may be targeted as well. Alternatively, a\nlegitimate vulnerable application could easily be made\npersistent in a variety of ways (for example registering it as\na Login Item, etc.), then persistently exploited. Although this\nlatter scenario increases the visibility of the attack, the attacker\ndylib would, of course, prevent any UI from being displayed.\nThus, it’s unlikely that the majority of users would notice a\nlegitimate (Apple) binary automatically being started (and\nexploited) in the background.\n\nProcess injection, or coercing an external process into\nloading a dynamic library, is another useful attack scenario of\ndylib hijacking. In the context of this paper, ‘injection’ refers\nto load-time injection (i.e. whenever the process is started)\nas opposed to run-time injection. While the latter is arguably\nmore powerful, the former is far simpler and often achieves\nthe same level of damage.\n\nUsing dylib hijacking to coerce an external process into\npersistently loading a malicious dylib is a powerful and\nstealthy technique. As with the other dylib hijack attack\nscenarios, it does not require any modifi cations to OS\ncomponents or binaries (e.g. patching the target process’s\non-disk binary image). Moreover, since the planted dylib\nwill persistently and automatically be loaded into the\ntarget process space each time the process is started, an\nattack no longer needs a separate monitoring component\n(to detect when the target process is started, then inject a\nmalicious dylib). Also, since the attacker simply requires a\nmalicious hijacker dylib to be planted, it neatly side-steps the\ncomplexities of run-time process injection. Finally, as this\ninjection technique abuses legitimate functionality provided\nby the OS loader, it is unlikely to be detected by personal\nsecurity products (which often attempt to prevent remote\nprocess injection by monitoring ‘inter-process’ APIs).\n\nXcode is Apple’s ‘Integrated Development Environment’\n(IDE) application. It is used by developers to write both\n_OS X and iOS applications. As such, it is a juicy target_\nfor an advanced adversary who may wish to inject\ncode into its address space to surreptitiously infect the\ndeveloper’s products (i.e. as a creative autonomous malware\npropagation mechanism). Xcode and several of its various\nhelper tools and utilities are vulnerable to dylib hijack\nattacks. Specifi cally, run-path-dependent dylibs, such as\nDVTFoundation are not found in Xcode’s primary run-path\nsearch directories (see Figure 37).\n\nThe process injection hijack against Xcode was fairly\nstraightforward to complete. First, a hijacker dylib was\nconfi gured, such that its versioning information was\ncompatible and it re-exported all symbols to the legitimate\nDVTFoundation. Then, the confi gured hijacker dylib was\ncopied to /Applications/Xcode.app/Contents/Frameworks/\nDVTFoundation.framework/Versions/A/ (Frameworks/\nbeing the primary run-path search directory). Now, whenever\n\n\n-----\n\n_Figure 37: Apple’s vulnerable IDE, Xcode._\n\nXcode was started, the malicious code was automatically\nloaded as well. Here, it was free to perform actions such as\nintercepting compile requests and surreptitiously injecting\nmalicious source or binary code into the fi nal products.\n\nAs Ken Thompson noted in his seminal work ‘Refl ections on\nTrusting Trust’ [16], when you can’t trust the build process or\ncompiler, you can’t even trust the code that you create.\n\n_Figure 38: Process ‘injection’ via dylib hijacking._\n\nBesides persistence and load-time process injection, dylib\nhijacking can be used to bypass personal security products.\nSpecifi cally, by leveraging a dylib hijack attack, an attacker\ncan coerce a trusted process into automatically loading\nmalicious code, then perform some previous blocked or\n‘alertable’ action, now without detection.\n\nPersonal security products (PSPs) seek to detect malicious\ncode via signatures, heuristic behavioural analysis, or simply\nby alerting the user whenever some event occurs. Since\ndylib hijacking is a novel technique that abuses legitimate\nfunctionality, both signature-based and heuristic-based\nproducts are trivial to bypass completely. However, security\nproducts, such as fi rewalls, that alert the user about any\noutgoing connections from an unknown process, pose more\nof a challenge to an attacker. Dylib hijacking can trivially\nthwart such products as well.\n\nPersonal fi rewalls are popular with OS X users. They often\ntake a somewhat binary approach, fully trusting outgoing\nnetwork connections from known processes, while alerting\nthe user to any network activity originating from unknown\nor untrusted processes. While this is an effective method for\ndetecting basic malware, advanced attackers can trivially\nbypass these products by exploiting their Achilles heel:\ntrust. As mentioned, generally these products contain default\nrules, or allow the user to create blanket rules for known,\ntrusted processes (e.g. ‘allow any outgoing connection from\nprocess X’). While this ensures that legitimate functionality\nis not broken, if an attacker can introduce malicious code\n\n\nVIRUS BULLETIN  www.virusbtn.com\n\ninto the context of a trusted process, the code will inherit the\nprocess’s trust, and thus the fi rewall will allow its outgoing\nconnections.\n\n_GPG Tools [17] is a message encryption suite for OS X that_\nprovides the ability to manage keys, send encrypted mail,\nor, via plug-ins, enable cryptographic services to arbitrary\napplications. Unfortunately, its products are susceptible to\ndylib hijacking.\n\n_Figure 39: GPG Tools’ vulnerable keychain app._\n\nAs GPG Keychain requires various Internet functionality (e.g.\nto look up keys on keyservers), it’s likely to have an ‘allow\nany outgoing connection’ rule, as shown in Figure 40.\n\n_Figure 40: Access rule for GPG Keychain._\n\nUsing a dylib hijack, an attacker can target the GPG\n_Keychain application to load a malicious dylib into its_\naddress space. Here, the dylib will inherit the same level\nof trust as the process, and thus should be able to create\noutgoing connections without generating an alert. Testing\nthis confi rmed that the hijacker dylib was able to access the\nInternet in an uninhibited manner (see Figure 41).\n\nDefensive-minded individuals may correctly point out\nthat, in this scenario, GPG Keychain’s fi rewall rule could\nbe tightened to mitigate this attack, by only allowing\noutgoing connections to specifi c remote endpoints (e.g.\nknown key servers). However, there are a myriad of other\nvulnerable applications that may be hijacked to access the\nnetwork in a similarly uninhibited manner. Or, in the case\nof the Little Snitch fi rewall, the inclusion of a system-level\nundeletable fi rewall rule allowing any connection from\nany process to talk to iCloud.com endpoints is more than\nenough for a full bypass (i.e. using a remote iCloud iDrive\nas a C&C server).\n\nSo far, the dylib attack scenarios described here have all been\nlocal. While they are powerful, elegant and stealthy, they all\nrequire existing access to a user’s computer. However, dylib\nhijacking can also be abused by a remote attacker in order to\nfacilitate gaining initial access to a remote computer.\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\n_Figure 41: Bypassing a personal fi rewall (LittleSnitch) via dylib hijacking._\n\nThere are a variety of ways to infect Mac computers, but the\nsimplest and most reliable is to deliver malicious content\ndirectly to end target(s). The ‘low-tech’ way is to coerce the\nuser into downloading and installing the malicious content\nmanually. Attackers creatively employ a range of techniques\nto accomplish this, such as providing ‘required’ plug-ins (to\nview content), fake updates or patches, fake security tools\n(‘rogue’ AV products), or even infected torrents.\n\n_Figure 43: Man-in-the-middling a software download._\n\nReaders may be thinking, ‘hey, it’s 2015, most software\nshould be downloaded via secure channels, right?’\nUnfortunately, even today, the majority of third-party OS\n_X software is distributed insecurely. For example, of the_\nsoftware found installed in the author’s dock, 66% was\ndistributed insecurely.\n\n\n_Figure 42: Masked malicious content._\n\nIf the user is tricked into downloading and running any of\nthis malicious content, they could become infected. While\n‘low tech’, the success of such techniques should not be\nunderestimated. In fact, when a rogue security program\n(Mac Defender) was distributed by such means, hundreds\nof thousands of OS X users were infected, with over 60,000\nalone contacting AppleCare in order to resolve the issue\n\n[18].\n\nRelying on trickery to infect a remote target will probably\nnot work against more computer-savvy individuals. A more\nreliable (though far more advanced) technique relies on\nman-in-the-middling users’ connections as they download\nlegitimate software. Due to the constraints of the Mac\n_App Store, most software is still delivered via developer_\nor company websites. If such software is downloaded\nvia insecure connections (e.g. over HTTP), an attacker\nwith the necessary level of network access may be able\nto infect the download in transit. When the user then\nruns the software, they will become infected, as shown in\nFigure 43.\n\n\n_Figure 44: Software (in the author’s dock) that was_\n_distributed over HTTP._\n\nMoreover, further research uncovered that all major thirdparty OS X security products were similarly distributed\ninsecurely (see Figure 45).\n\n_Apple is well aware of these risks, and since version OS X_\n_Lion (10.7.5), Mac computers have shipped with a built-in_\nsecurity product, named Gatekeeper, that is designed to\ncounter these attack vectors directly.\n\nThe concept of Gatekeeper is simple, yet highly effective:\nblock any untrusted software from executing. Behind the\nscenes, things are a little more complex, but for the purposes\nof this discussion, a higher-level overview suffi ces. When\nany executable content is downloaded, it is tagged with a\n‘quarantined’ attribute. The fi rst time such content is set to\nrun, Gatekeeper verifi es the software. Depending on the\nuser’s settings, if the software is not signed with a known\n_Apple developer ID (default), or from the Mac App Store,_\n_Gatekeeper will disallow the application from executing._\n\nWith Gatekeeper automatically installed and enabled on\nall modern versions of OS X, tricking users into installing\n\n\n-----\n\n_Figure 45: Insecure downloads of major OS X security_\n_products._\n\n_Figure 46: Gatekeeper in action._\n\nmalicious software or infecting insecure downloads (which\nwill break digital signatures) is essentially fully mitigated.\n(Of course, an attacker could attempt to obtain a valid Apple\ndeveloper certifi cate, then sign their malicious software.\nHowever, Apple is fairly cautious about handing out such\ncertifi cates, and moreover, has an effective certifi cate\nrevocation process that can block certifi cates if any abuse is\ndiscovered. Also, if Gatekeeper is set to only allow software\nfrom the Mac App Store, this abuse scenario is impossible.)\n\nUnfortunately, by abusing a dylib hijack, an attacker can\nbypass Gatekeeper to run unsigned malicious code – even\nif the user’s settings only allow Apple-signed code from the\n_Mac App Store. This (re)opens the previously discussed attack_\nvectors and puts OS X users at risk once again.\n\n\nVIRUS BULLETIN  www.virusbtn.com\n\nConceptually, bypassing Gatekeeper via dylib hijacking\nis straightforward. While Gatekeeper fully validates the\ncontents of software packages that are being executed (e.g.\neverything in an application bundle), it does not verify\n‘external’ components.\n\n_Figure 47: Theoretical dmg/zip that would bypass_\n_Gatekeeper._\n\nNormally this isn’t a problem – why would a downloaded\n(legitimate) application ever load relatively external code?\n(Hint: relative, yet external content.)\n\nAs Gatekeeper only verifi es internal content, if an Applesigned or Mac App Store application contains a relative\nexternal reference to a hijackable dylib, an attacker can\nbypass Gatekeeper. Specifi cally, the attacker can create (or\ninfect in transit) a .dmg or .zip fi le with the necessary folder\nstructure to contain the malicious dylib in the externally\nreferenced relative location. When the legitimate application\nis executed by the unsuspecting user, Gatekeeper will verify\nthe application bundle then (as it is trusted, and unmodifi ed)\nallow it to execute. During the loading process, the dylib\nhijack will be triggered and the externally referenced\nmalicious dylib will be loaded – even if Gatekeeper is set to\nonly allow code from the Mac App Store!\n\nFinding a vulnerable application that fulfi ls the necessary\nprerequisites was fairly easy. Instruments.app is an Applesigned ‘Gatekeeper approved’ application that expects to be\ninstalled within a sub-directory of Xcode.app. As such, it\ncontains relative references to dylibs outside of its application\nbundle; dylibs that can be hijacked.\n\n_Figure 48: Apple’s vulnerable Instruments app._\n\nWith a vulnerable trusted application, a malicious .dmg\nimage was created that would trigger the Gatekeeper bypass.\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\nFirst, the Instruments.app was placed into the image. Then\nan external directory structure was created that contained\nthe malicious dylib (CoreSimulator.framework/Versions/A/\nCoreSimulator).\n\n_Figure 49: Malicious .dmg image._\n\nTo make the malicious .dmg more ‘believable’, the external\nfi les were set to hidden, a top level alias (with a custom icon)\nwas created to point to Instruments.app, the background was\nchanged, and the entire image was made read-only (so that it\nwould automatically be displayed when double-clicked). The\nfi nal product is shown in Figure 50.\n\nThis malicious (though seemingly benign) .dmg fi le was\nthen ‘deployed’ (uploaded to a public URL) for testing\npurposes. When downloaded via Safari and then executed,\n_Gatekeeper’s standard ‘this is downloaded from the Internet’_\nmessage window was initially shown. It is important to note\nthat this alert is shown for any content downloaded from the\nInternet, and thus is not unusual.\n\nOnce this message window was dismissed, the malicious\ncode was surreptitiously loaded along with the legitimate\napplication. This, of course, should not have been allowed as\n_Gatekeeper’s settings were at the maximum (only allow apps_\nfrom the Mac App Store) (see Figure 51).\n\n\n_Figure 50: The fi nalized malicious .dmg image._\n\nAs the malicious dylib was loaded and executed before\nthe application’s main method, the dylib could ensure that\nnothing appeared out of the ordinary. For example, in this\ncase where the malicious .dmg masquerades as a Flash\ninstaller, the dylib can suppress Instruments.app’s UI, and\ninstead spawn a legitimate Flash installer.\n\nWith the ability to bypass Gatekeeper and load unsigned\nmalicious code, attackers can return to their old habits\nof tricking users into installing fake patches, updates\nor installers, fake AV products, or executing infected\npirated applications. Worse yet, advanced adversaries with\nnetworking-level capabilities (who can intercept insecure\nconnections) can now arbitrarily infect legitimate software\ndownloads. Neither have to worry Gatekeeper any more.\n\n### DEFENCES\n\nDylib hijacking is a powerful new attack class against OS\n_X, that affords both local and remote attackers a wide range_\nof malicious attack scenarios. Unfortunately, despite being\ncontacted multiple times, Apple has shown no interest in\naddressing any of the issues described in this paper. Granted,\n\n\n_Figure 51: Bypassing Gatekeeper via a dylib hijack._\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\n\n_Figure 52: Objective-see’s DHS scanner._\n\n\nthere appears to be no easy fi x for the core issue of dylib\nhijacking as it abuses the legitimate functionality of the OS.\nHowever, it is the opinion of the author that Gatekeeper\nshould certainly be fi xed in order to prevent unsigned\nmalicious code from executing.\n\nUsers may wonder what they can do to protect themselves.\nFirst, until Gatekeeper is fi xed, downloading untrusted, or\neven legitimate software via insecure channels (e.g. via the\nInternet over HTTP) is not advised. Refraining from this will\nensure that remote attackers will be unable to gain initial\naccess to one’s computer via the attack vector described in\nthis paper. Due to the novelty of dylib hijacking on OS X, it\nis unlikely (though not impossible) that attackers or OS X\nmalware are currently abusing such attacks locally. However,\nit can’t hurt to be sure!\n\nTo detect local hijacks, as well as to reveal vulnerable\napplications, the author created a new application named\n_Dynamic Hijack Scanner (or DHS). DHS attempts to uncover_\nhijackers and vulnerable targets by scanning all running\nprocesses of the entire fi le-system. The application can be\ndownloaded from objective-see.com.\n\n### CONCLUSION\n\nDLL hijacking is a well known attack class that affects the\n_Windows OS. Until now, OS X was assumed to be immune_\nto such attacks. This paper countered that assumption,\nillustrating a similar OS X attack, dubbed ‘dylib hijacking’.\nBy abusing weak or run-path-dependent imports, found\n\n\nwithin countless Apple and third-party applications, this\nattack class opens up a multitude of attack scenarios to both\nlocal and remote attackers. From stealthy local persistence\nto a Gatekeeper bypass that provides avenues for remote\ninfections, dylib hijacking is likely to become a powerful\nweapon in the arsenal of OS X attackers. And while Apple\nappears apathetic toward this novel attack, secure software\ndownloads and tools such as DHS can ensure that OS X users\nremain secure... for now.\n\n### REFERENCES\n\n[1] Secure loading of libraries to prevent DLL\npreloading attacks. http://blogs.technet.com/cfsfi le.ashx/__key/CommunityServer-ComponentsPostAttachments/00-03-35-14-21/Secure-loading-oflibraries-to-prevent-DLL-Preloading.docx.\n\n[2] DLL hijacking. http://en.wikipedia.org/wiki/\nDynamic-link_library#DLL_hijacking.\n\n[3] Dynamic-Link Library Hijacking.\nhttp://www.exploit-db.com/wp-content/themes/\nexploit/docs/31687.pdf.\n\n[4] Windows NT Security Guidelines.\nhttp://www.autistici.org/loa/pasky/NSAGuideV2.PDF.\n\n[5] What the fxsst? https://www.mandiant.com/blog/\nfxsst/.\n\n[6] Leaked Carberp source code. https://github.com/\nhzeroo/Carberp.\n\n\n-----\n\nVIRUS BULLETIN  www.virusbtn.com\n\n[7] Windows 7 UAC whitelist: Proof-of-concept source\ncode. http://www.pretentiousname.com/misc/W7E_\nSource/win7_uac_poc_details.html.\n\n[8] Microsoft Security Advisory 2269637; Insecure\nLibrary Loading Could Allow Remote Code\nExecution. https://technet.microsoft.com/en-us/\nlibrary/security/2269637.aspx.\n\n[9] What is dll hijacking? http://stackoverfl ow.com/\na/3623571/3854841.\n\n[10] OS X loader (dyld) source code.\nhttp://www.opensource.apple.com/source/dyld.\n\n[11] MachOView. http://sourceforge.net/projects/\nmachoview/.\n\n[12] Run-Path Dependent Libraries.\nhttps://developer.apple.com/library/\nmac/documentation/DeveloperTools/\nConceptual/DynamicLibraries/100-Articles/\nRunpathDependentLibraries.html.\n\n[13] Using @rpath: Why and How. http://www.dribin.\norg/dave/blog/archives/2009/11/15/rpath/.\n\n[14] Friday Q&A 2012-11-09: dyld: Dynamic Linking On\nOS X. https://www.mikeash.com/pyblog/friday-qa2012-11-09-dyld-dynamic-linking-on-os-x.html.\n\n[15] dylibHijackScanner.py & createHijacker.py.\nhttps://github.com/synack/.\n\n[16] Refl ections on Trusting Trust.\nhttp://cm.bell-labs.com/who/ken/trust.html.\n\n[17] GPG Tools. https://gpgtools.org/.\n\n[18] Apple support to infected Mac users: ‘You cannot\nshow the customer how to stop the process’.\nhttps://nakedsecurity.sophos.com/2011/05/24/applesupport-to-infected-mac-users-you-cannot-show-thecustomer-how-to-stop-the-process.\n\n\n**Editor: Martijn Grooten**\n\n**Chief of Operations: John Hawes**\n\n**Security Test Engineers: Scott James, Tony Oliveira, Adrian Luca**\n\n**Sales Executive: Allison Sketchley**\n\n**Editorial Assistant: Helen Martin**\n\n**Consultant Technical Editors: Dr Morton Swimmer, Ian Whalley**\n\n**© 2015 Virus Bulletin Ltd, The Pentagon, Abingdon Science**\n**Park, Abingdon, Oxfordshire OX14 3YP, England.**\n**Tel: +44 (0)1235 555139. Fax: +44 (0)1865 543153**\n**Email: editorial@virusbtn.com**\n**Web: http://www.virusbtn.com/**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.virusbulletin.com/uploads/pdf/magazine/2015/vb201503-dylib-hijacking.pdf"
    ],
    "report_names": [
        "vb201503-dylib-hijacking.pdf"
    ],
    "threat_actors": [
        {
            "id": "f276b8a6-73c9-494a-8ab2-13e2f1da4c53",
            "created_at": "2022-10-25T16:07:24.441133Z",
            "updated_at": "2025-03-27T02:02:10.231958Z",
            "deleted_at": null,
            "main_name": "Achilles",
            "aliases": [],
            "source_name": "ETDA:Achilles",
            "tools": [
                "RDP",
                "Remote Desktop Protocol"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716504,
    "ts_updated_at": 1743041346,
    "ts_creation_date": 1426589987,
    "ts_modification_date": 1426589987,
    "files": {
        "pdf": "https://archive.orkl.eu/996ff970eccc5d7a891ee5f3835c225043b7e800.pdf",
        "text": "https://archive.orkl.eu/996ff970eccc5d7a891ee5f3835c225043b7e800.txt",
        "img": "https://archive.orkl.eu/996ff970eccc5d7a891ee5f3835c225043b7e800.jpg"
    }
}