{
    "id": "d4036402-e050-4326-8cc7-8c0fabbeb895",
    "created_at": "2023-01-12T15:00:11.318256Z",
    "updated_at": "2025-03-27T02:05:53.696563Z",
    "deleted_at": null,
    "sha1_hash": "22fc63b93d567746f75b3a6ec088a245aa78fe0e",
    "title": "2007-04-03 - A Case Study of the Rustock Rootkit and Spam Bot",
    "authors": "",
    "file_creation_date": "2022-05-27T22:36:31Z",
    "file_modification_date": "2022-05-27T22:36:31Z",
    "file_size": 790413,
    "plain_text": "# A Case Study of the Rustock Rootkit and Spam Bot\n\n**[usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html)**\n\nIn this paper we present a case study of the steps leading up to the extraction of the spam\nbot payload found within a backdoor rootkit known as Backdoor.Rustock.B or SpamMailbot.c. Following the extraction of the spam module we focus our analysis on the steps\nnecessary to decrypt the communications between the command and control server and\ninfected hosts. Part of the discussion involves a method to extract the encryption key from\nwithin the malware binary and use that to decrypt the communications. The result is a better\nunderstanding of an advanced botnet communications scheme.\n\n[In this analysis we examine a backdoor rootkit known as Backdoor.Rustock.B [7] or Spam-](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#symantec1)\n[Mailbot.c [8] but hereafter referred to simply as rustock. While work has been done to](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#mcafee1)\n[deobfuscate the malware and study the rootkit [7,9], little information is available about the](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#symantec1)\nfunctionality of the spam bot that is contained within rustock. We are particularly interested in\nthe communications between the command and control (C&C) server and infected hosts\nsince they provide a glimpse into an advanced botnet communications scheme. The\nremainder of this paper presents a case study of the steps necessary to extract and reverse\nengineer the spam bot component.\n\nFirst, we provide some information gleaned from observing the network traffic produced by\nthe bot. Then, we walk through the three phases of deobfuscation leading to the extraction of\nthe spam bot component. Next, we describe the reverse engineering of the spam bot leading\nup to the extraction of the session encryption key from memory that makes it possible to\ndecrypt the C&C communications between client and server. Finally we summarize a sample\ndecrypted C&C communication session between client and server.\n\nThe key exchange phase is similar in all C&C sessions we observed. The HTTP POST from\nthe client contains a 96-byte encrypted payload and is sent to the login.php page on the\nserver. This is followed by a response from the server containing a 16-byte payload.\n\n\n-----\n\nThe instruction phase of the C&C communications consists of a variable number of HTTP\nPOSTs from the client and corresponding responses from the server. The size of the\npayloads contained within these packets is also variable and therefore assumed to be\ndependent upon the variable nature of the underlying C&C instructions.\n\nIn addition to the information we gained through observation of the network traffic the people\nat Symantec helped us recognize that the encryption algorithm used to encrypt the data was\nRC4.\n\nAs shown in Figure 2, the malware contains four main components: the initial\ndeobfuscation routine, the rootkit loader, the rootkit, and the spam module.\n\n**Figure 2: Overview of the lzx32.sys malware. In our analysis we break it down into four**\n_parts: A. The first deobfuscation routine, B. The rootkit loader which contains the second_\n_deobfuscation routine, C. The rootkit containing the third deobfuscation routine, and D. The_\n_spam module._\n\n[IDA Pro 5.0 Standard Edition [10], an interactive disassembly tool is used to study the code.](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#ida1)\n[A useful plug-in to the disassembly tool called idax86emu [11] is also employed to](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#idax86emu1)\ndeobfuscate the malware. The plug-in tool emulates the x86 CPU instruction set and can\n\n\n-----\n\nmodify the disassembly as it walks through the obfuscated code.\n\nUsing the emulator, we follow the deobfuscation routine to address 0x000114AF. At this\naddress, the deobfuscated code looks different and makes more sense than the code prior to\nrunning through deobfuscation, see Figure 3 . This is the beginning of the rootkit loader.\n\n**Figure 3: View of the disassembled code at the rootkit loader's entrypoint before and after**\n_deobfuscation._\n\nAfter a careful study of the code contained within the rootkit loader, we learn it takes the\nfollowing steps:\n\nSearches for the ntoskernl.exe image in memory and imports the functions:\n```\nExAllocatePool, ZwQuerySystemInformation, ExFreePool, and stricmp.\n\n```\nUsing these imported functions, the malware allocates a chunk of memory of about 34k\n(0x8800 bytes) and deobfuscates the memory chunk starting at address 0x00011926 into\nthe allocated memory. The deobfuscation routine used at this stage (DOBF Routine 2 in\nFigure 2 ) can be recognized by the parameters passed to the function; they are the\naddress of the encrypted 0x8800 bytes embedded in the binary and the address of the\n```\n0x8800 bytes of newly allocated memory. The deobfuscation routine is called at\n0x00011593. The deobfuscated memory turns out to be another PE executable, which is\n\n```\nthen mapped back to location 0x00011926. This executable is the embedded rootkit\ncomponent that we will discuss in section .\n\n\n-----\n\nUsing the PE header of the embedded rootkit component starting at 0x00011926, the\nrootkit loader sets up the import tables by using the strings table located within the\ndeobfuscated rootkit component. Some example function names are ZwEnumerateKey,\n```\nZwCreateKey, and ZwQueryKey. These functions will be used by the rootkit component\n\n```\nlater to hide itself. The rootkit loader then does any necessary relocation using the relocation\nsection of the embedded binary.\n\nSince the rookit component is now decoded and mapped into the malware, its PE header\nis no longer needed. Therefore, in an attempt to defeat RAM forensics, the rootkit loader\ndeletes the MZ and PE signatures bytes from the decoded rootkit executable from memory\nbefore passing control to the embedded rootkit binary.\n\nThe rootkit loader now jumps to 0x00011D92, the entry point of the rootkit component,\nwhich will be discussed next.\n\nA pointer to an object representing the original malware driver file, i.e. lzx32.sys. It\nappears that this object is created by the Windows operating system when driver files are\nloaded into memory as a service.\n\nThe registry path pointing to the registry key that loaded the malware driver file into the\noperating system. This path is Unicode encoded.\nKnowing that the first argument is a pointer to the file object representing the original\nmalware driver file is key in understanding how a modular component can be loaded and\nexecuted by the rootkit component.\n\nAfter storing the two arguments in global variables, a system thread is created. This thread\nhas the following functionality:\n\nCreates a handle to the rootkit kernel driver named: \\BaseNamedObjects\\\n```\n{DC5E72A0-6D41-47E4-C56D-024587F4523B} (Since this handle name is hard-coded\n\n```\ninto the binary, it may serve as a way to detect the presence of the rootkit module).\n\nChecks whether the loaded malware driver file is stored in an Alternate Data Stream\n(ADS).\n\nDeletes all sub-keys in the hive:\n```\nHKLM\\system\\CurrentControlSet\\Enum\\Root\\Legacy_lzx32.sys\n\n```\nReplaces the registry functions to hide the registry key created to load the malware at\nboot.\n\nCreates a notify routine using PsSetCreateProcessNotifyRoutine which gets called\nfor all process activity. This notify routine creates at most two threads to inject the spam\ncomponent into the services.exe process. By doing this, the malware ensures its survivability.\n\nThe rootkit then replaces the ZwQuerySystemInformation, and\n```\nZwTerminateProcess functions.\n\n```\nThe same routine that injects the spam component discussed in step 5 is called at this\npoint to start the spam component. This routine will be discussed in detail next.\n\n\n-----\n\nThe spam component is encrypted and appended to the original driver file lzx32.sys. The\nrootkit uses the first argument to extract this encrypted executable. One way to detect the\npresence of the appended component is to parse the PE header of the original malware\ndriver file. By so doing, one will notice that there is additional data past the end of the PE\nexecutable. To extract and decrypt the appended data, the rootkit takes the following steps:\n\nReads the last four bytes of the original file, this is the size of the encrypted and\ncompressed executable, we will call it bot_compressed_size.\n\nMoves the file pointer back by bot_compressed_size + 4, and reads in four bytes\nthat represent the xor key.\n\nReads in the next four bytes after the xor key, this is the uncompressed size of the\nappended file, we will call it bot_uncompressed_size.\n\nThe xor key is then used to xor-decrypt the data four bytes at a time, starting from the\nbyte after bot_uncompressed_size.\n\nAllocates and uses a memory chunk of size bot_uncompressed_size, the xordecrypted data is then deobfuscated using deobfuscation routine 3 (DOBF Routine 3 is the\nsame as DOBF Routine 2).\nThe resulting file is another PE executable that is the modular spam bot component. To\nproperly extract this module, it is important to use the size variables detailed above. Using\nthe wrong sizes results in an incomplete spam module.\n\nIt was previously mentioned that the spam module is injected into the services.exe\nprocess, this is another step taken by the malware to thwart detection. The rootkit\ncomponent follows these steps to inject the module into the services.exe process:\n\nFinds the process ID of services.exe by using the ZwQuerySystemInformation\nAPI function to return all system thread and process information and searching the returned\nresults. Once found the process ID is stored in a global variable.\n\nCreates another copy of the services.exe process.\nSets up networking capabilities by hooking the tcpip.sys, wanarp.sys, and\n```\nndis.sys driver functions.\n\n```\nExtracts, decrypts, and deobfuscates the spam module as described above.\nMaps the spam module into non-paged allocated memory.\nCalls KeAttachProcess to switch the memory context to the services.exe process.\nThe rootkit then sets up an asynchronous procedural call that provides a method to run\nthe spam module code.\nThe RC4 encryption algorithm consists of two main parts, the key-scheduling algorithm, and\n[the pseudo-random generation algorithm [12]. To generate the keystream the two algorithms](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#schneier1)\nmake use of an internal state consisting of two parts, a permutation of all 256 possible bytes,\nand two 8-bit index pointers. By comparing the two functions found within the assembly code\n[with a C code implementation of RC4 [13], we are able to determine that the assembly](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#rc41)\nfunctions are direct implementations of the two algorithms that make up RC4. Additionally,\nthe struct stored in global memory is the secret internal state consisting of a 256 byte char\n\n\n-----\n\narray and two index pointers into the array. The function containing the key-scheduling\nalgorithm is called once during login.php. This function initializes the internal state\nvariable and stores it in the global struct. The session key itself is not stored in global\nmemory and is therefore difficult to extract. Fortunately, having the internal state variables is\nas good as having the original key generated by the infected host.\n\nThe code snippet in Figure 4 is from the IDA pro disassembly and shows the instructions\nleading up to the storage of the global struct containing the state variables. We have named\nthe global struct g_prepped_session_key.\n\n**Figure 4: Disassbled code for the routine that stores the prepared session key in a global**\n_struct. The hex equivalent of the first 4-bytes of the highlighted code is used to generate a_\n_signature that will be used later to extract the prepared key._\n\nThe instruction jz short loc_405CE4 is the instruction that precedes the code that\nprepares the session key and stores it in global memory. Converting this instruction and\nsubsequent instructions to hexadecimal results in a unique signature 0x74 0x11 0xA1\n```\n0x64 that we will use later to search and extract from memory the internal state variables\n\n```\nused to decrypt the encrypted network communications.\n\n[We used Microsoft's User Mode Process Dumper [14] to dump the memory space of the](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#userdump1)\n```\nservices.exe process to a file. Timing of the memory dump is critical since it must occur\n\n```\nafter the key exchange and instruction phases of the C&C session but before the next key\nexchange. Because the client typically initiates another C&C session with the server every\n\n\n-----\n\nfew minutes it is important to keep track of the various sessions and the corresponding\nmemory dumps. In order to prevent the possibility of the state variable being overwritten one\ncould use a remote kernel debugger to break execution after the C&C session has\ncompleted rather than dumping the memory. The disadvantage of this method is that it\naffects the timing of subsequent C&C sessions and could be noticed by the server.\n\nOnce we have a memory dump and a corresponding network capture of the C&C session,\n[we load the memory dump into Microsoft's windbg [15]. The log file shown in Figure 5](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#windbg1)\nenumerates the steps we took to extract the key. First, we locate the signature isolated in the\nprevious section (0x74 0x11 0xA1 0x64). Next, we disassemble several instructions\nstarting at the memory address we just found. The mov instruction at address 0x00d35cd3\nloads a pointer to the struct containing the RC4 state variables, so to find the key we simply\ndereference the pointer. Finally we dump the state variables to a file.\n\n**Figure 5: windbg log file with comments. This shows how to extract the RC4 state variables**\n_from memory._\n\n\n-----\n\nTo decrypt the captured C&C session we use the global struct we have extracted from the\nmemory dump containing the state variables. We modify the C code implementation of\n[RC4 [13] to read the key-scheduling state variables from disk rather then generating a new](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#rc41)\ninstance. For us to decrypt the communication we need to apply the RC4\nencryption/decryption function (pseudo random generation algorithm) to the POST message\nfrom the client followed by the response from the server. This keeps the state variables\nsynchronized and allows us to decrypt both sides of the communication. Each exchange\nconsisting of a POST to data.php and reply from the server can be decrypted separately\nsince the state variable is copied from the global struct to the stack each time.\n\nOne thing to note is that the first fourteen bytes of the client message are ignored when\nencrypting the message. This was noticed during the static analysis of the spam module. In\norder to keep the state variables synchronized, we also must ignore the first fourteen bytes\nof the message.\n\nTable 1 is a summary of a sample C&C session we decrypted and consists of seven data\nexchanges. The client initiates the conversation by sending the \"kill.txt\" string for which the\nserver responds with a list of processes to terminate and files to delete from the client. Some\nexamples of processes are CAPP.exe, syswire.exe, Ravmond.exe. Some examples of\nfiles are m_hook.sys, comdlj32.dll, and secure32.html. Web searches for the\nprocesses and file names indicate that these are other malicious programs that the client\nmay be infected with. This provides a way to eliminate other infections that may conflict with\nthis bot.\n\n**Table 1:Summary of decrypted C&C communications between the infected client and the**\n_server._\n\n\n-----\n\n**Message** **Message Contents or Summary**\n\nClient 1 \"kill.txt\"\n\nServer 1 Server response specifies processes to terminate and files to delete from\nthe client\n\nClient 2 Information about the client\n\nServer 2 Information for the client about the client and file names to create or request\nfor subsequent communications with the server\n\nClient 3 \"neutral.txt\"\n\nServer 3 List of domain names to query for mail servers to use\n\nClient 4 \"unlucky.txt\"\n\nServer 4 List of SMTP server responses that indicate failure\n\nClient 5 \"tmpcode.bin\"\n\nServer 5 Binary data that specifies the formatting of spam message to be sent by the\nclient\n\nClient 6 \"tmpcode.bin\"\n\nServer 6 Binary data including spam content\n\nClient 7 \"-\"\n\nServer 7 List of target email addresses\n\n**Ken Chiang, Levi Lloyd**\n**Sandia National Laboratories**\n**Livermore, CA 94550**\n```\nkchiang@sandia.gov llloyd@sandia.gov\n\n```\nNext, the client sends information about itself to the server including bandwidth, OS version,\nSMTP availability (if outbound TCP/25 is allowed), if it is a virtual machine, and if it is\nblacklisted on a DNS blacklist. The server responds with additional information including the\nclient's external IP address, machine name, task id that the server assigns to the client for a\ngiven spamming job, whether an update of the client is available, and names of additional\ncommand strings that the client can use for subsequent communications. An example of the\ncommand strings are \"filesnames=neutral.txt\" and \"unluckystrings=unlucky.txt\".\n\n\n-----\n\nThe next packet sent by the client is neutral.txt, this request results in a list of domain\nnames from the server. The client puts these domain names in a double-linked list and\nqueries them for the presence of mail servers.\n\nThe fourth client request in this session is \"unlucky.txt\". This request results in a list of error\nmessages that an SMTP server could return. Some examples are \"Please use your provider\nSMTP\" and \"your mail rejected\"\n\nIn the fifth and sixth exchange, the client sends the request string \"tmpcode.bin\" and the\nserver responds with binary code and spam content that is used by the client to generate\nspam messages that are dynamic in nature to bypass spam filters.\n\nFinally, in the last session, the client send a single dash (\"-\") to which the server responds\nwith a list of email addresses where spam messages will be sent.\n\nBased on our observation that the starting address of the deobfuscated code changed\nbetween versions of lzx32.sys as well as different obfuscation techniques we conclude\nthat the outer most binary packer/obfuscator was changed. It is likely that the reason for this\nis that the authors of the code were attempting to avoid antivirus detection as well as to\nincrease the amount of time that it takes to deobfuscate the code. Our technique for\ndeobfuscation was not affected much by the different techniques since we step through the\ncode using an emulator.\n\nOur analysis of the C&C communications indicates ordinary spam bot functionality. Aside\nfrom this functionality the spam module also has the ability to download and execute\narbitrary code. This could be used for other nefarious purposes. In addition, the modular\ndesign of the rootkit and embedded spam module makes it easy to update the spam module.\nDuring our experiments, we observed multiple updates to the spam module. These updates\nwere confined to changes of C&C server domain names and search terms used to build the\nspam, but it indicates that it would be simple for those controlling the botnet to update the\nmodule with other features.\n\nFuture work is also needed to better understand the details of the rustock rootkit. Since our\nfocus was on getting to the spam module, we did not do a detailed analysis on the rootkit\n[itself. Further details can be found in [9]. One element of the rootkit that needs more analysis](https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/index.html#boldewin1)\nis the alternative behavior exhibited when the malware driver detects that it is not stored in\nan ADS.\n\nAdditional work should be done to automate the key extraction and C&C decryption. One\nway to do this would be to continually monitor the network traffic from an infected client.\nAnytime a post to login.php is seen, a remote procedure call could be initiated to the\ninfected host to dump the memory space of the services.exe process. Given the network\ncaptures and memory dumps it would be easy to write a script to extract the key from the\ndumps and decrypt the C&C communications in a way similar to our method.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2003 - 2009/2007-04-03 - A Case Study of the Rustock Rootkit and Spam Bot.pdf"
    ],
    "report_names": [
        "2007-04-03 - A Case Study of the Rustock Rootkit and Spam Bot.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535611,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653690991,
    "ts_modification_date": 1653690991,
    "files": {
        "pdf": "https://archive.orkl.eu/22fc63b93d567746f75b3a6ec088a245aa78fe0e.pdf",
        "text": "https://archive.orkl.eu/22fc63b93d567746f75b3a6ec088a245aa78fe0e.txt",
        "img": "https://archive.orkl.eu/22fc63b93d567746f75b3a6ec088a245aa78fe0e.jpg"
    }
}