{
    "id": "b114cf47-0a73-4d1d-8579-d3cc144a9bdb",
    "created_at": "2023-01-12T15:05:52.633143Z",
    "updated_at": "2025-03-27T02:05:38.418827Z",
    "deleted_at": null,
    "sha1_hash": "e9c9d714a12d193ccf8ed29cb4715ff4ab41c5cf",
    "title": "2016-09-13 - H1N1- Technical analysis reveals new capabilities",
    "authors": "",
    "file_creation_date": "2022-05-28T18:21:46Z",
    "file_modification_date": "2022-05-28T18:21:46Z",
    "file_size": 1661614,
    "plain_text": "# H1N1: Technical analysis reveals new capabilities\n\n**[blogs.cisco.com/security/h1n1-technical-analysis-reveals-new-capabilities](https://blogs.cisco.com/security/h1n1-technical-analysis-reveals-new-capabilities)**\n\nJosh Reynolds September 13, 2016\n\n[This blog is the first in a 3 part series that will provide an in-depth technical analysis on the](http://blogs.cisco.com/tag/h1n1-malware)\nH1N1 malware. I’ll be looking at how H1N1 has evolved, its obfuscation, analyzing its\nexecution including new information stealing and user account control bypass capabilities,\nand finally exploring how we are both using and influencing security tools with this research.\n\n## Overview\n\nThrough the use of general characteristics exhibited by malware authors we are able to\nbroadly categorize and positively identify malicious samples. These characteristics,\n[discussed in The General Behavior of Ransomware are indexed in a database, which allows](https://blogs.cisco.com/security/the-general-behavior-of-ransomware)\nus to identify patterns, outliers and obtain greater visibility and insight into various threats.\n\n## H1N1’s evolution: past and present\n\nThese data sets provide insight into the ever-growing attack vectors that affect our\ncustomers, which include malware delivery mechanisms. In this blog series we highlight\nnewly added functionality to a malware variant that started out as being a ‘loader’ (strictly\nprovides capabilities of loading other more complex malware variants) known as H1N1, and\nhas now evolved into an information stealing variant.\n\nThroughout the data mining exercises conducted by my colleagues and I on the AMP Threat\nGrid Research & Efficacy Team (RET) we have observed a widely distributed campaign\nusing VBA macros to infect machines with a variant of information-stealing malware. Based\non the initial characteristics observed by AMP Threat Grid we believed these malicious\ndocuments were distributing a Ransomware variant; however, we later found the dropped\nexecutables to be a variant of the H1N1 loader. H1N1 is a loader malware variant that has\nbeen known to deliver Pony DLLs and Vawtrak executables to infected machines. Upon\ninfection, H1N1 previously only provided loading and system information reporting\ncapabilities.1,2\n\n## Key findings from our analysis include:\n\nUnique obfuscation techniques\nA novel DLL hijacking vulnerability resulting in a User Account Control bypass\nAdded information stealing capabilities\nSelf-propagation/lateral movement capabilities\n\n\n-----\n\n## Background\n\nH1N1 has added a plethora of new functionality in comparison to earlier reports. Throughout\nthis blog series we will be analyzing the capabilities of H1N1 including: obfuscation, a User\nAccount Control (UAC) bypass, information stealing, data exfiltration, loader/dropper, and\nself-propagation/lateral movement techniques used by this variant.1,2\n\n## Infection Vector\n\nThe use of Visual Basic macros is nothing new, however, in recent months they have\nbecome one of the most popular infection vectors for all malware types, especially for\nRansomware campaigns. These macros vary in sophistication from performing the download\nand execution of hosted binaries, to dropping the binaries themselves. In this campaign we\nsee the latter where the document ships an entire encoded binary within the text box of a\nVBA macro form. All documents throughout this campaign have used a common naming\nconvention in the following formats:\n\n_[domain]_card_screenshot.doc_\n_confirmation_[random integers].doc_\n_bank_confirmation_[random integers].doc_\n_debit_request_[random integers].doc_\n_creditcard_statement_[random integers].doc_\n_insurance_[random integers].doc_\n_inventory_list_[random integers].doc_\n_debt_[random integers].doc_\n\nThe domains for the first format observed include the financial, energy, communications,\nmilitary and government sectors. Unsurprisingly, these documents are delivered through\nspear-phishing e-mail campaigns. A number of subject headings can be observed in\nVirusTotal:\n\nFigure 1.0:\n\nAttached e-mail subject headings in VirusTotal for identified documents\n\n\n-----\n\nAlthough the specified domain in the filename differentiates between targets, the lure\nmessage within the phishing e-mail does not vary drastically, for example:\n\nFigure 2.0:\n\nExample phishing message within attached e-mail\nThe remaining formats appear to simply seem enticing enough to open being related finance,\ncorporate or personal information.\n\nUpon opening the document, the attacker attempts to social engineer the user into executing\nthe malicious macro content by stating it will adjust to their version of Microsoft Word:\n\n\n-----\n\nFigure 3.0: Social engineering content of document to open macros\n\n## Dropper Obfuscation\n\nThe VBA macro is highly obfuscated, making use of many VBA tricks to hide its true intent.\nThese include the use of string functions: StrReverse, Ucase, Lcase, Right, Mid, and Left.\nFor example, the following gets the %temp% path:\n\n\n-----\n\nFigure 4.0:\n\nString obfuscation mechanisms to get %temp%\nMid is used here to produce “.Scripting”, Ucase and StrReverse are used to produce\n“FIleSystemObject”, which is used to create a VBA FileSystemObject, that is then used with\nGetSpecialFolder, and some basic arithmetic resulting in “2” to get %temp%.As mentioned,\nthe binary to be executed is extracted from a VBA form text box:\n\nFigure 5.0:\n\nVBA form containing obfuscated PE within text box\nThe text box content is set into a variable, which is then passed off to a de-obfuscation\nfunction. The core de-obfuscation functionality is a two steps process. The first is an XOR\nloop with a fixed byte key of 0xE, which produces a base64 encoded portable executable\n(PE):\n\nFigure 6.0: XOR decoding/de-obfuscation loop\n\nThe second is a VBA implementation of base64 that decodes it to produce a final Portable\nExecutable (PE):\n\n\n-----\n\nFigure 7.0:\n\nVBA Base64 implementation\nThe de-obfuscated executable is then written to %temp% and executed. We can follow the\nexecution flow through the use of process visualization in AMP Threat Grid. What this\nprovides is graphed process interactions (child-parent relationships) for the entirety of the\nrun. In the case of the H1N1 malicious document, it is very apparent that WINWORD.EXE is\nexecuting a separate binary:\n\n\n-----\n\nFigure 8.0:\n\nProcess graph showing execution of dropped executable from Microsoft Word\n\n## Unpacking\n\nThe binary has a total of three routines responsible for unpacking and injection. The first\nroutine injects via the following steps:\n\nUnpacking algorithm unpacks code to be written\n\nCreates a suspended process of the executable written to %temp% from the document\nwith CreateProcessA\n\nWrites to that image with WriteProcessMemory\n\n\n-----\n\nUses GetThreatContext, SetThreadContext and ResumeThread to execute at the EP\nof the unpacked executable. On the call to WriteProcessMemory we see the lpBuffer\naddress points to a complete PE, as is indicated by the MZ header:\n\n9.0: First MZ\n\nfrom WriteProcessMemory lpBuffer argument\nWe can then dump this to disk for analysis of the next unpacking stage. The next routine\nmakes use of the injection method used by Duqu to write its unpacked image :3\n\nCreateProcessW is called to create a suspended ‘Explorer.exe’ process\nUse the handle from PROCESS_INFORMATION produced by CreateProcessW with\nZwQueryInformationProcess to get Explorer.exe PEB and ImageBaseAddress\nAllocate and write up to 500 bytes of of the Explorer.exe process using\nReadProcessMemory\nGet actual image size from PE header, allocated this size, and write entire Explorer.exe\nimage into memory\nUse UnMapViewOfSection with ImageBaseAddress and process handle of\nExplorer.exe from step 2 to un-map the current section in order to avoid\nSTATUS_CONFLICTING_ADDRESSES upon mapping of the new section\n\n\n-----\n\nOverwrite image sections of Explorer.exe with unpacked (of the current step)\nexecutable code\nUse MapViewOfSection to map the manipulated Explorer.exe using the process handle\nfrom step 2\nCall ResumeThread to start execution of unpacked code (of the current step)\n\nIn order to continue to trace the execution of this code (to what we discovered was more\nunpacking code) we wrote 0xEBFE (relative JMP to offset 0) to the entry point of the newly\nwritten Explorer.exe. This causes Explorer.exe to spin until we can attach to this process with\na debugger.\n\nBreaking on the first VirtualAlloc performed by the injected process enabled us to see a large\nallocation occur, and setting a breakpoint on writing to this memory location makes it\napparent that an entire DLL is written to this memory location by the (current) unpacking\ncode:\n\nFigure 10.0: Upack MZ to be injected\n\nLooking at the PE header the string “UpackByDwing” is apparent which indicates that this\npacker is being used on the final binary. Opening up this code with a disassembler (in this\ncase IDA Pro) showed the following jump that could not be followed when the functions were\ngraphed:\n\n\n-----\n\nFigure 11.0:\n\nFunction graph for final Upack unpacking stage\nThere is an infamous POPAD prior to this jump, which for those seasoned unpackers, is\nindicative of leading to the OEP of an unpacked binary due to restoring of the register state\nprior to the unpacked code being called. If a breakpoint is set on the OEP identified and we\ncontinue to trace through the injected code within Explorer.exe, it becomes clear that this\naddress is eventually called from the unpacking code. At this point, once the breakpoint is\nhit, we can dump the unpacked binary to disk.\n\nOne final hurdle is required in order to get an independent executable that can be debugged.\nWhen the binary is written and jumped to, a pointer argument is passed on the stack that is\nlater dereferenced within the binary. This is provided when the binary is unpacked from the\ninjected Explorer.exe, however a null pointer is passed when the binary is executed\nindependently. This argument points to a size value of 0x31DB used for a call to VirtualAlloc.\nWe can edit the unpacked code in-line to point to a known address with this value:\n\nFigure 12.0: In\nline edits to allow independent binary execution\n\n## Analysis\n\nI’m only going to cover the obfuscation techniques used by H1N1 in this blog. The remaining\nanalysis of H1N1 will be posted in my next blog.\n\n## Obfuscation\n\nUpon opening the binary in a disassembler (in this case IDA Pro) we see that imports are\nresolved dynamically using hashing of DLLs and exports, and a string obfuscation technique\nused throughout the binary.\n\n\n-----\n\n## String Obfuscation\n\nThe string obfuscation technique makes use of SUB, XOR, and ADD with fixed DWORD\nvalues, and the result of each step using is stored using STOSD. The result of each\noperation is then used as the input (within EAX) for each subsequent step. For example:\n\nFigure 13.0:\n\nString obfuscation technique example\nThe result of these operations produces the path to the WOW64 version of svchost.exe.\nWe’ve written an IDAPython script to automatically decode these strings from a provided\naddress starting with the XORing of EAX, performing operations on the DWORDs involved\nup to a certain “depth” (as strings vary in length), and adding the resulting string as a\ncomment next to the next instruction head.4\n\n## Import Obfuscation (via Import Hashing)\n\nHashed imports can be resolved by hashing the library export names ourselves. Import\nname strings are obfuscated using the technique mentioned above, and export names from\neach library are hashed by walking the export table and performing a simple XOR and ROL\nloop over each name:\n\nfor(i = 0; i < strlen(export_name); i++) {\n\nr = rol32(r, 7);\n\nr ^= export_name[i];\n\n}\n\n\nWe’ve replicated the hashing algorithm and all exports can be hashed from a given DLL.\nThese hash values can be mapped within IDA using a C header file generated by our python\nscript.5\n\n\n-----\n\n## To be continued…\n\nIn the next blog I’ll provide the analysis of H1N1’s execution. Stay tuned!\n\n[1] [https://www.proofpoint.com/tw/threat-insight/post/hancitor-ruckguv-reappear](https://www.proofpoint.com/tw/threat-insight/post/hancitor-ruckguv-reappear)\n\n[2] [https://www.arbornetworks.com/blog/asert/wp-content/uploads/2015/06/blog_h1n1.pdf](https://www.arbornetworks.com/blog/asert/wp-content/uploads/2015/06/blog_h1n1.pdf)\n\n[3] [http://blog.w4kfu.com/tag/duqu](http://blog.w4kfu.com/tag/duqu)\n\n[4] [https://communities.cisco.com/docs/DOC-69444](https://communities.cisco.com/docs/DOC-69444)\n\n[5] [https://communities.cisco.com/docs/DOC-69443](https://communities.cisco.com/docs/DOC-69443)\n\nShare:\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-09-13 - H1N1- Technical analysis reveals new capabilities.pdf"
    ],
    "report_names": [
        "2016-09-13 - H1N1- Technical analysis reveals new capabilities.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535952,
    "ts_updated_at": 1743041138,
    "ts_creation_date": 1653762106,
    "ts_modification_date": 1653762106,
    "files": {
        "pdf": "https://archive.orkl.eu/e9c9d714a12d193ccf8ed29cb4715ff4ab41c5cf.pdf",
        "text": "https://archive.orkl.eu/e9c9d714a12d193ccf8ed29cb4715ff4ab41c5cf.txt",
        "img": "https://archive.orkl.eu/e9c9d714a12d193ccf8ed29cb4715ff4ab41c5cf.jpg"
    }
}