{
    "id": "f3b7eb90-3ac9-4637-b408-fa6c9315497d",
    "created_at": "2023-01-12T15:06:51.258285Z",
    "updated_at": "2025-03-27T02:16:34.680152Z",
    "deleted_at": null,
    "sha1_hash": "e6cba48b1d0e26c1d18d188f1c8ff4d2220fac9f",
    "title": "2022-08-24 - MagicWeb- NOBELIUM’s post-compromise trick to authenticate as anyone",
    "authors": "",
    "file_creation_date": "2022-09-01T10:22:48Z",
    "file_modification_date": "2022-09-01T10:22:48Z",
    "file_size": 5164531,
    "plain_text": "# MagicWeb: NOBELIUM’s post-compromise trick to authenticate as anyone\n\n**[microsoft.com/security/blog/2022/08/24/magicweb-nobeliums-post-compromise-trick-to-authenticate-as-anyone/](https://www.microsoft.com/security/blog/2022/08/24/magicweb-nobeliums-post-compromise-trick-to-authenticate-as-anyone/)**\n\nAugust 24, 2022\n\n**Updated August 26, 2022: Added instructions to** enable collection of AD FS event logs in order to search for Event ID 501, and added a\nnew resource for AD FS audit logging in Microsoft Sentinel.\n\nMicrosoft security researchers have discovered a post-compromise capability we’re calling MagicWeb, which is used by a threat actor we track\nas NOBELIUM to maintain persistent access to compromised environments. NOBELIUM remains highly active, executing multiple campaigns\nin parallel targeting government organizations, non-governmental organizations (NGOs), intergovernmental organizations (IGOs), and think\ntanks across the US, Europe, and Central Asia. The Microsoft Threat Intelligence Center (MSTIC) assesses that MagicWeb was likely\ndeployed during an ongoing compromise and was leveraged by NOBELIUM possibly to maintain access during strategic remediation steps\nthat could preempt eviction.\n\nNOBELIUM has used abuse of identities and credentialed access as a method for maintaining persistence, and a specialized capability like\n[MagicWeb is not novel for the actor: in September 2021, Microsoft disclosed a post-exploitation capability named FoggyWeb with methods and](https://www.microsoft.com/security/blog/2021/09/27/foggyweb-targeted-nobelium-malware-leads-to-persistent-backdoor/)\nintent similar to MagicWeb. FoggyWeb was capable of exfiltrating the configuration database of compromised AD FS servers,\n[decrypting token-signing certificates and](https://docs.microsoft.com/windows-server/identity/ad-fs/design/token-signing-certificates) [token-decryption certificates, and downloading and executing additional malware components.](https://docs.microsoft.com/windows-server/identity/ad-fs/design/certificate-requirements-for-federation-servers)\nMagicWeb goes beyond the collection capabilities of FoggyWeb by facilitating covert access directly. MagicWeb is a malicious DLL that allows\nmanipulation of the claims passed in tokens generated by an Active Directory Federated Services (AD FS) server. It manipulates the user\nauthentication certificates used for authentication, not the signing certificates used in attacks like Golden SAML.\n\nNOBELIUM was able to deploy MagicWeb by first gaining access to highly privileged credentials and moving laterally to gain administrative\nprivileges to an AD FS system. This is not a supply chain attack. The attacker had admin access to the AD FS system and replaced a\nlegitimate DLL with their own malicious DLL, causing malware to be loaded by AD FS instead of the legitimate binary. The backdoor was\ndiscovered by Microsoft’s Detection and Response Team (DART) in coordination with MSTIC and Microsoft 365 Defender Research during an\nongoing incident response investigation. Microsoft is sharing this information with consent from the client. At the time of this investigation,\nMagicWeb appears to be highly targeted.\n\nLike domain controllers, AD FS servers can authenticate users and should therefore be treated with the same high level of security. Customers\n[can defend against MagicWeb and other backdoors by implementing a holistic security strategy including the AD FS hardening guidance. In](https://docs.microsoft.com/windows-server/identity/ad-fs/design/best-practices-for-secure-planning-and-deployment-of-ad-fs)\nthe case of this specific discovery, MagicWeb is one step of a much larger intrusion chain that presents unique detection and prevention\nscenarios.\n\nWith all critical infrastructure such as AD FS, it is important to ensure attackers do not gain administrative access. Once attackers gain\nadministrative access, they have many options for further system compromise, activity obfuscation, and persistence. We recommend that any\nsuch infrastructure is isolated, accessible only by dedicated admin accounts, and regularly monitored for any changes. Other security\nmeasures that can prevent this and other attacks include credential hygiene to prevent lateral movement. AD FS is an on-premises server, and\nas with all on-premises servers, deployments can get out of date and/or go unpatched, and they can be impacted by local environment\n[compromises and lateral movement. For these reasons, migration to a cloud-based identity solution such as Azure Active Directory for](https://docs.microsoft.com/azure/active-directory/manage-apps/migrate-adfs-apps-to-azure)\nfederated authentication is recommended for the robust security it provides. See the mitigation section below for more information. Though we\nassess the capability to be in limited use, Microsoft anticipates that other actors could adopt similar methodologies and therefore recommends\ncustomers review hardening and mitigation guidance provided in this blog.\n\n## How MagicWeb subverts authentication\n\nMagicWeb is a post-compromise malware that can only be deployed by a threat actor after gaining highly privileged access to an environment\nand moving laterally to an AD FS server. To achieve their goal of maintaining persistent access to an environment by validating authentication\nfor any user account on the AD FS server, NOBELIUM created a backdoored DLL by copying the legitimate\n_[Microsoft.IdentityServer.Diagnostics.dll file used in AD FS operations. The legitimate version of this file is catalog signed by Microsoft and is](https://docs.microsoft.com/windows-hardware/drivers/install/catalog-files)_\n\n\n-----\n\no a y oaded by t e S se e at sta tup to p o de debugg g capab t es O U s bac doo ed e s o o t e e s u s g ed e\nthreat actor’s highly privileged access that allowed them to access the AD FS server meant they could have performed any number of actions\nin the environment, but they specifically chose to target an AD FS server to facilitate their goals of persistence and information theft during their\noperations.\n\nAfter gaining administrative access to an AD FS server via elevation of privilege and lateral movement, the loading of NOBELIUM’s malicious\n_Microsoft.IdentityServer.Diagnostics.dll into the AD FS process is possible by editing C:\\Windows\\AD_\n_FS\\Microsoft.IdentityServer.Servicehost.exe.config to specify a different public token, which controls what loads into the AD FS process when it_\n[is started. Because AD FS is a .NET application, it loads the DLLs specified in the config file from the Global Assembly Cache (GAC). By](https://docs.microsoft.com/dotnet/framework/app-domains/gac)\nchanging the token in the configuration, the adversary directed AD FS to load in the malicious DLL. The interception and manipulation of\nclaims by MagicWeb enables the actor to generate tokens that allow the adversary to bypass AD FS policies (role policies, device policies, and\nnetwork policies) and sign in as any user with any claims, including multifactor authentication (MFA).\n\nFigure\n\n1. C:\\Windows\\AD FS\\Microsoft.IdentityServer.Servicehost.exe.config being set to load Microsoft.IdentityServer.Diagnostics.dll\n\nFigure\n\n2. NOBELIUM uses a different public token than the legitimate Microsoft.IdentityServer.Diagnostics.dll, telling AD FS to look for a different file\n\n\n-----\n\nin the GAC Figure 3. Close\n\nup from Microsoft.IdentityServer.Servicehost.exe.config showing MagicWeb’s malicious PublicKeyToken compared to the PublicKeyToken of\nthe legitimate version of the DLL\n\nFigure\n\n4. The directories in the GAC on a server infected with MagicWeb; the malicious Microsoft.IdentityServer.Diagnostics.dll file and the legitimate\none are located in different directories\nTo understand how NOBELIUM can subvert the AD FS process with the MagicWeb malware, it’s important to understand how AD FS claims\nwork. AD FS extends the ability to use single sign-on functionality available within a single security or enterprise boundary to internet-facing\napplications to provide customers, partners, and suppliers a streamlined user experience while accessing an organization’s web-based\n[applications. AD FS relies on claims-based authentication to validate the identity of the user and their authorization claims. These claims are](https://docs.microsoft.com/dynamics365/customerengagement/on-premises/deploy/configure-the-ad-fs-server-for-claims-based-authentication)\npackaged into a token that can be used for authentication. MagicWeb injects itself into the claims process to perform malicious actions outside\nthe normal roles of an AD FS server.\n\nFigure\n\n5. How the AD FS claims pipeline issues a token for a user entering a federated application\nSecurity Assertion Markup Language (SAML) uses x509 certificates to establish trust relationships between identity providers and services and\nto sign and decrypt tokens. These x509 certificates contain enhanced key usage (EKU) values that specify what applications the certificate\nshould be used for. For instance, an EKU containing an Object Identifier (OID) value of 1.3.6.1.4.1.311.20.2.2 would allow for the use of a\nSmartCard logon. Organizations can create custom OIDs to further narrow certificate usage.\n\nMagicWeb’s authentication bypass comes from passing a non-standard Enhanced Key Usage OID that is hardcoded in the MagicWeb\nmalware during an authentication request for a specified User Principal Name. When this unique hard coded OID value is encountered,\nMagicWeb will cause the authentication request to bypass all standard AD FS processes (including checks for MFA) and validate the user’s\nclaims. MagicWeb is manipulating the user authentication certificates used in SAML sign-ins, not the signing certificates for a SAML claim\nused in attacks like Golden SAML.\n\n\n-----\n\nFigure 6. Example of a user certificate accepted by\n\nMagicWeb; the highlighted numbers under “Unknown Key Usage” is one of two OIDs hardcoded into MagicWeb\n\n\n-----\n\nFigure 7. Example of a user certificate chain, which\n\nshows an invalid digital signature but still works for authentication\nNOBELIUM uses unique tradecraft per target, so it’s highly likely that the OIDs and public tokens are unique per target as well. We’ve redacted\nthese OIDs and tokens in this report. Please see the hunting guidance section for information on how to look for variants related to this attack.\n\n## How to mitigate this threat\n\nNOBELIUM’s ability to deploy MagicWeb hinged on having access to highly privileged credentials that had administrative access to the AD FS\nservers, giving them the ability to perform whatever malicious activities they wanted to on the systems they had access to.\n\nIt’s critical to treat your AD FS servers as a [Tier 0 asset, protecting them with the same protections you would apply to a domain controller or](https://docs.microsoft.com/microsoft-identity-manager/pam/tier-model-for-partitioning-administrative-privileges)\nother critical security infrastructure. AD FS servers provide authentication to configured relying parties, so an attacker who gains administrative\naccess to an AD FS server can achieve total control of authentication to configured relying parties (include Azure AD tenants configured to use\nthe AD FS server). Practicing credential hygiene is critical for protecting and preventing the exposure of highly privileged administrator\n[accounts. This especially applies on more easily compromised systems like workstations with controls like logon restrictions and preventing](https://docs.microsoft.com/microsoft-identity-manager/pam/tier-model-for-partitioning-administrative-privileges)\nlateral movement to these systems with controls like the Windows Firewall.\n\nMigration to Azure Active Directory (Azure AD) authentication is recommended to reduce the risk of on-premises compromises moving laterally\nto your authentication servers. Customers can use the following references on migration:\n\n## Advanced hunting queries\n\n### Recommended hunting guidance\n\nHave Inventory Certificate Issuance policies in your Public Key Infrastructure (PKI) environment, including all EKU attributes used in the\nenvironment and compare to known OID values.\n[Hunt across Windows Event Logs by enabling AD FS verbose logging. Enable security auditing to allow collection of the AD FS event](https://docs.microsoft.com/windows-server/identity/ad-fs/troubleshooting/ad-fs-tshoot-logging)\nlogs, and specifically look for Event ID 501. This event specifies all the EKU attributes on a claim. Hunt across these logs to look for EKU\nvalues which your PKI infrastructure isn’t configured to issue.\n\n\n-----\n\noo o po tab e e ecutab e es t e G C o S d ecto es o you syste s t at a e t s g ed by c oso t a d spect t ese es\nor [submit them for analysis.](https://www.microsoft.com/wdsi/filesubmission)\nPerform an audit of your exclusion settings to be sure that the AD FS and GAC are included in scans. Many organizations exclude the\nAD FS directories from security software scanning because of performance degradation concerns.\n\n### Microsoft Sentinel\n\n[Microsoft Sentinel customers who have enabled verbose mode logging for ADFS can use this query to look for suspicious OIDs:](https://docs.microsoft.com/windows-server/identity/ad-fs/troubleshooting/ad-fs-tshoot-logging)\n[https://github.com/Azure/Azure-Sentinel/tree/master/Detections/SecurityEvent/ADFSAbnormalEnhancedKeyUsageAttribute-OID.yaml.](https://github.com/Azure/Azure-Sentinel/tree/master/Detections/SecurityEvent/ADFSAbnormalEnhancedKeyUsageAttribute-OID.yaml)\n\n[NOTE: It’s important to enable the proper connector in Sentinel with the correct Event collection. Refer to this post for more details on AD FS](https://techcommunity.microsoft.com/t5/microsoft-sentinel-blog/enabling-ad-fs-security-auditing-and-shipping-event-logs-to/ba-p/3610464)\nAudit logging collection in Sentinel.\n\n### Searching for unsigned files in the GAC\n\nThe legitimate Microsoft.IdentityServer.Diagnostics.dll is [catalog signed by Microsoft. Catalog signing is a method Windows uses for validating](https://docs.microsoft.com/windows-hardware/drivers/install/catalog-files)\ncode integrity different from [Authenticode, and is used for offline validation rather than runtime enforcement of running only signed code. The](https://docs.microsoft.com/windows-hardware/drivers/install/authenticode)\ncatalog signing on this file means the file may appear to be unsigned on the file properties pane and in file integrity checkers, security tools,\nand online malware repositories. The scripts below allow you to look for unsigned binaries and understand both catalog-signed binaries and\nAuthenticode-signed binaries.\n\n**Surface unsigned DLLs in GAC using Microsoft 365 Defender**\n\nThis query surfaces unsigned DLLs in the GAC folder created within the last 60 days.\n```\nDeviceFileEvents\n\n| where Timestamp between( ago(60d)..now() )\n\n| where FolderPath has @\"C:\\Windows\\Microsoft.NET\\assembly\\GAC_MSIL\\Microsoft.IdentityServer.\"\n\n  and FileName endswith \".dll\"\n\n| join (\n\n    DeviceFileCertificateInfo\n\n    | where not(IsSigned)\n\n) on SHA1\n\n```\n**Enumerate non-Microsoft signed DLLs in the GAC using PowerShell**\n\nBelow is an example script that could be used to enumerate non-Microsoft signed DLLs in the relevant GAC folder, where servers.txt is a list of\nservers you wish to scan. Because the legitimate Microsoft.IdentityServer.Diagnostics.dll is catalog signed, signing won’t appear when viewing\nfile properties, but it will show in PowerShell querying and on load of the DLL.\n```\n$servers = get-content -Path (path to file)\\servers.txt\n\nForeach ($server in $servers) {\n\nWrite-Output \"Processing server: $server\"\n\nInvoke-Command -ComputerName $server {Get-ChildItem -Filter \"*.dll\" -Recurse \"C:\\Windows\\Microsoft.NET\\assembly\\GAC_MSIL\\\" | getauthenticodesignature | ft}\n\n}\n\n## Detections\n\n### Microsoft Defender Antivirus\n\n```\nMicrosoft Defender Antivirus provides detection for this threat under the following malware name:\n\nTrojan:MSIL/MagicWeb.A!dha\n\n### Microsoft Defender for Endpoint\n\nMicrosoft Defender for Endpoint customers may see the following alert as an indication of possible attack:\n\nADFS persistent backdoor detected\n\n## Indicators of compromise (IOCs)\n\nMicrosoft isn’t sharing IOCs on this NOBELIUM activity at this time. However, NOBELIUM frequently customizes infrastructure and capabilities\nper campaign, minimizing operational risk should their campaign specific attributes be discovered. If MagicWeb is identified in your\nenvironment, it’s unlikely to match any static IOCs from other targets such as a SHA-256 value. It’s recommended to use the hunting guidance\nprovided above to investigate your environment.\n\n## Technical analysis of MagicWeb\n\n\n-----\n\nO U as od ed t e eg t ate _c oso t de t tySe_ _e_ _ag ost cs d by add g_ a c ous code to t e ace og c ass o t e\n_Microsoft.IdentityServer.Diagnostics namespace/type._\n\nThe header section of the TraceLog class from the legitimate Microsoft.IdentityServer.Diagnostics.dll is shown below:\n\nFigure\n\n8. The header section of the TraceLog class of Microsoft.IdentityServer.Diagnostics namespace/type from the legitimate\n_Microsoft.IdentityServer.Diagnostics.dll_\nMeanwhile, the header section of the TraceLog class from NOBELIUM’s backdooredversion of Microsoft.IdentityServer.Diagnostics.dll is\nshown below:\n\n\n-----\n\nFigure\n\n9. The header section of the TraceLog class of Microsoft.IdentityServer.Diagnostics namespace from NOBELIUM’s backdoored version of\n_Microsoft.IdentityServer.Diagnostics.dll_\nIn the backdoored version of the code, as shown above, NOBELIUM has added a static constructor for the TraceLog class. A [static constructor](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/static-constructors)\nis used to initialize any static data, or to perform a particular action that needs to be performed only once. It’s called automatically before the\nfirst instance is created or any static members are referenced.\n\nThe malicious static constructor gets executed once before the first instance of the TraceLog class is created. Given that new instances of the\nTraceLog class is created in various locations in this DLL, the execution of the malicious static constructor is guaranteed to occur as soon as\nthe DLL is loaded for the first time (which would be upon startup of the AD FS server after the malicious changes to\n_Microsoft.IdentityServer.Servicehost.exe.config described above)._\n\nNOBELIUM’s malicious static constructor contains a reference to the Initialize() method from a class named AuthLog.\n\nFigure 10. Reference to\n\nthe Initialize() method from a class named AuthLog in the malicious static constructor\nThe AuthLog class is a brand-new and malicious class that’s been added to the DLL by NOBELIUM.\n\n\n-----\n\nFigure\n\n11. The Initialize() method of the AuthLog class\nAs shown above, the Initialize() method references a class named RuntimeHelper, yet another class added to the DLL by the actor. The\nprimary purpose of the RuntimeHelper class and its OverloadMethod() method is to hook legitimate AD FS related methods at runtime. By\nhooking the legitimate AD FS methods, the backdoor is capable of intercepting calls to the legitimate methods to instead invoke its own custom\nmethods.\n\nThe screenshot above shows the following legitimate AD FS methods being hooked by MagicWeb:\n\n\n**Target assembly/DLL** **Target type** **Target method to**\n**hook**\n\n\n**Malicious**\n**(actor intr**\n\n\n_Microsoft.IdentityServer.IdentityModel.dll_ _Microsoft.IdentityModel.X509CertificateChain_ _Build_ _BeginBuild_\n\n_Microsoft.IdentityServer.WebHost.dll_ _Microsoft.IdentityServer.WebHost.WrappedHttpListenerRequest_ _GetClientCertificate_ _BeginGetC_\n\n_Microsoft.IdentityServer.WebHost.dll_ _Microsoft.IdentityServer.WebHost.Proxy.ProxyConfigurationData_ _EndpointConfiguration_ _BeginEndp_\n\n_Microsoft.IdentityServer.Service.dll_ _Microsoft.IdentityServer.Service.IssuancePipeline.PolicyEngine_ _ProcessClaims_ _BeginProc_\n\n### Hook method: BeginBuild()\n\nMagicWeb’s BeginBuild() method is used to hook the legitimate target method Build() (from Microsoft.IdentityServer.IdentityModel.dll).\n\nFigure 12. MagicWeb’s\n\n_BeginBuild() method_\nThe BeginBuild() method first calls the MagicWeb’s helper method ValidateX509Extensions().\n\nIf the helper method ValidateX509Extensions() returns true, BeginBuild() returns true.\n\nIf ValidateX509Extensions() returns false, or an exception is thrown by calling ValidateX509Extensions(), BeginBuild() invokes and returns the\nvalue returned by the legitimate Build() method from Microsoft.IdentityServer.IdentityModel.dll.\n\nThis means that before the legitimate target method Build() from the legitimate Microsoft.IdentityServer.IdentityModel.dll gets an opportunity to\ninspect/build a certificate, MagicWeb’s hook method first inspects the certificate and returns true if the helper method\n_ValidateX509Extensions() returns true._\n\nThis allows the attacker to subvert the normal certificate inspection/build process by introducing a custom certificate inspection/build method\nthat’s invoked before the legitimate Build() method is invoked\n\n\n-----\n\n### e pe et od a date 509 te s o s()\n\nMagicWeb’s helper method ValidateX509Extensions() is called by BeginBuild() and other methods.\n\nFigure 13. Helper method\n\n_ValidateX509Extensions()_\n_ValidateX509Extensions() returns false if the X509 certificate passed to the method is null or the Microsoft Cryptographic API certificate_\ncontext handle/pointer isn’t set.\n\nNext, the method enumerates the extensions in the X509 certificate passed to the method. If an enumerated extension is of type\n_X509EnhancedKeyUsageExtension, the method iterates the OIDs of the extension, calculating the MD5 hash of each OID (using a custom_\nhash computation helper method ComputeHash() that leverages the .NET MD5 class).\n\nIf the MD5 hash value of the OID matches one of the two following hardcoded MD5 values, the method returns true (this methodology is used\nto check if one of the two OID values below are present in the extension):\n\n_67F5BD28A842A1C9[REDACTED] (MD5 hash value corresponding to the OID_\nvalue 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED])\n_6E3466296D2F63D[REDACTED] (MD5 hash value corresponding to the OID value_\n_1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED])_\n\nIf none of the OID values are present, the method returns false.\n\nThis helper method returns true if the certificate passed to the method contains one of the two magic OID values listed above.\n\n### Hook method: BeginGetClientCertificate()\n\nFigure\n\n14. MagicWeb’s BeginGetClientCertificate() method, used to hook the legitimate target method GetClientCertificate() (from\n_Microsoft.IdentityServer.WebHost.dll)_\nTo retrieve the client’s X509 certificate, this method first calls the legitimate GetClientCertificate() method from\n_Microsoft.IdentityServer.WebHost.dll. Next, the hook method calls the helper method ValidateX509Extensions() to determine whether the client_\ncertificate contains one of the two “magic” OID values. If the client certificate contains one of the two OID values, the hook method:\n\n\n-----\n\nObta s t e _adapte e d o t e cu e t object\nObtains the _request field from the _adapter object\nSets the value of the m_ClientCertificateError field (from the _request object) to 0\n\nThis means that regardless of what the legitimate method GetClientCertificate() (from Microsoft.IdentityServer.WebHost.dll) sets the\n_m_ClientCertificateError field to, if a client certificate contains one of the magic OID values, the hook method overwrites or sets the_\n_m_ClientCertificateError field to 0._\n\nBy using this technique, the hook method appears to be influencing the normal behavior of the application to treat or accept a non-valid client\ncertificate as a valid certificate.\n\n### Hook method: BeginProcessClaims()\n\nFigure\n\n15. The BeginProcessClaims() method of MagicWeb, used to hook the legitimate target method ProcessClaims() (from\n_Microsoft.IdentityServer.Service.dll)_\nThe hook method first indirectly invokes the legitimate ProcessClaims() method by invoking the ProcessClaims() method of the AuthLog class.\n\nOn line 198 in figure 16, the hook method calls MagicWeb’s helper method GetClaims(), passing in the processed identity object returned by\ninvoking the legitimate ProcessClaims() method.\n\nFigure\n\n16. The GetClaims() helper method\nAs shown above, the GetClaims() method accepts an identity object as a parameter. The method then initializes three variables named type,\n_type2, and type3 with values obtained from the RuntimeHelper’s static field/array named types:_\n\nFigure 17. The three variables initialized with values\n\nThe types field contains the following values:\n\n\n-----\n\nFigure\n\n18. Values in the types field\nThe assemblyByName2 variable above contains an assembly object representing the legitimate assembly\n_Microsoft.IdentityServer.IdentityModel.dll (if not already loaded, the RuntimeHelper class loads the assembly into the current application_\ndomain). By calling the GetType() method, RunHelper initializes the member of the types field/array with .NET types from the\n_Microsoft.IdentityServer.IdentityModel.dll assembly._\n\nReturning to the GetClaims() method and the initialization of type, type2, and type3 the variables type, type2, and type3 get initialized with the\nfollowing type objects from Microsoft.IdentityServer.IdentityModel.dll:\n\ntype: Microsoft.IdentityModel.Claims.IClaimsIdentity type object\ntype2: Microsoft.IdentityModel.Claims.ClaimCollection type object\ntype3: Microsoft.IdentityModel.Claims.Claim type object\n\nNext, the GetClaims() method retrieves the Claims property of the Microsoft.IdentityModel.Claims.IclaimsIdentity identity object. It also\nretrieves the number of claims (of type Microsoft.IdentityModel.Claims.ClaimCollection) present in the Claims property:\n\nFigure 19. GetClaims()\n\nretrieving the Claims property\n_GetClaims() then enumerates the claims (of type Microsoft.IdentityModel.Claims.Claim), retrieving the string containing each claim and the_\ncorresponding claim type:\n\nFigure\n\n20. GetClaims() enumerating the claims, retrieving the strings, and storing in list\nAs shown above, the claim string and claim type string are then stored in a list named list. This list of claims and their corresponding claim\ntypes is then returned to the caller of the GetClaims() method, BeginProcessClaims().\n\nReturning to the BeginProcessClaims() method, after retrieving the claims using the GetClaims() method, the hook method\n_BeginProcessClaims() searches the claims list for presence of a claim with claim type of_\n_http://schemas.microsoft.com/claims/authnmethodsreferences:_\n\nFigure\n\n21. BeginProcessClaims() searching the claims list for a specific claim\nAs shown on line 198 above, the claim(s) of type http://schemas.microsoft.com/claims/authnmethodsreferences (if any) is stored in a list\nnamed list. If claim of type http://schemas.microsoft.com/claims/authnmethodsreferences is present and its value is set to\n_http://schemas.microsoft.com/claims/multipleauthn, the hook method returns the IclaimsIdentity object returned by the legitimate target method_\n_ProcessClaims() (from Microsoft.IdentityServer.Service.dll) on line 191 of the hook method._\n\nThis behavior ensures that if MFA is already satisfied, then the hook method simply acts as a pass-through method and doesn’t affect the\nnormal behavior of the claim processing pipeline.\n\nIf a claim of type http://schemas.microsoft.com/claims/authnmethodsreferences is not present or its value is not set to\n_http://schemas.microsoft.com/claims/multipleauthn, the hook method proceeds to perform additional checks on the unprocessed claims (that_\nis, the claims contained in the unprocessed identity object identity passed to the hook method). Once again, the hook method obtains a list of\nclaims by calling the GetClaims() helper method. As mentioned above, instead of calling the GetClaims() helper method with the processed\nidentity object returned by invoking the legitimate ProcessClaims() method (stored in the result variable on line 191), the hook method calls the\n_GetClaims() helper method with the unprocessed identity object identity passed to the hook method:_\n\n\n-----\n\nFigure\n\n22. The hook method calling GetClaims()\nOn line 204, the hook method enumerates the value of each claim and uses the ComputeHash() helper method to calculate the MD5 hash\nvalue of each claim value (from the unprocessed identity object). It then checks if the MD5 value of any of the claims equals the MD5 hash\nvalue 6E3466296D2F63DE[REDACTED]. This hash value is the only element of a hardcoded hash list named oidMFAHashes (that is, this list\ncan be expanded to include other hash values of interest):\n\nFigure 23. Hardcoded hash\n\nlist containing the MD5 hash value of a magic OID valuea\nIf none of the claims have a value with MD5 hash value of 6E3466296D2F63DE[REDACTED], on line 206, the method simply returns the\n_processed identity object returned by the legitimate target method ProcessClaims() (from Microsoft.IdentityServer.Service.dll) on line 191 of the_\nhook method. As previously discussed, the hash value 6E3466296D2F63DE[REDACTED] corresponds to the OID value\n_1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED]._\n\nHence, the hook method enumerates the claims and if a claim with value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.\n\n_[REDACTED].[REDACTED].[REDACTED].[REDACTED] isn’t present on the claim list, the hook method simply acts as a pass-through method_\nand doesn’t affect the normal behavior of claim processing pipeline.\n\nIf by this point in the execution cycle the hook method hasn’t returned yet, it means one of the claims contains the OID value\n_1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED] (otherwise, according to_\nthe logic described in the paragraph above, the hook method would’ve returned).\n\nProceeding with confirmation that one of the claims contains the OID value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.\n\n_[REDACTED].[REDACTED].[REDACTED].[REDACTED], the hook method proceeds to the section that represents the main purpose of_\nMagicWeb, to perform claim injection.\n\nFigure 24. Main section\n\nof the code responsible for the claim injection process\nBefore describing the code responsible for the claim injection process, it’s important to revisit what’s already stored in the list and claims\nvariables:\n\n_list: As mentioned before, the hook method invokes the legitimate method ProcessClaims() to process the incoming identity object. The_\nprocessed identity object (stored in result on line 191) is then passed to the GetClaims() helper method to obtain a list of claim type/value\npairs extracted from the processed identity object (line 198). After obtaining the claim type/value pairs, the claim(s) of type\n_http://schemas.microsoft.com/claims/authnmethodsreferences (if any) are stored in a list named list (line 198)._\n\nFigure\n\n25. The list variable\n_claims: As mentioned above, this variable is used to store a list of claim type/value pairs extracted from the unprocessed identity object:_\n\nFigure\n26. The claims variable\nWith this information in mind (and the fact that one of the claims contains the OID value\n_1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED]), once again here’s the_\nfirst part of the claim injection code:\n\n\n-----\n\nFigure\n\n27. Part of the claim injection code\nAs shown above, if list is empty (that is, the processed identity object contained no claim type/value pairs of type\n_http://schemas.microsoft.com/claims/authnmethodsreferences), the hook method instead turns to claims (containing the list of all claim_\ntype/value pairs extracted from the unprocessed identity object) and searches for claim type/value pairs of type\n_http://schemas.microsoft.com/claims/authnmethodsreferences in the claims list. If the claims list contains one or more claim type/value pairs of_\ntype http://schemas.microsoft.com/claims/authnmethodsreferences, the hook method uses the claim information to add an identical claim of\ntype http://schemas.microsoft.com/claims/authnmethodsreferences to the processed identity object (line 213 above).\n\nUsing this method, if after passing the identity object to the legitimate ProcessClaims() method, no claim of type\n_http://schemas.microsoft.com/claims/authnmethodsreferences is returned by the legitimate method, the hook method manually adds a_\nfraudulent claim of type http://schemas.microsoft.com/claims/authnmethodsreferences to the list of claims returned to the caller of the hooked\nlegitimate method ProcessClaims().\n\nAs shown above, to add the fraudulent claim to the list of claims, the hook method calls a helper method named AddClaim().\n\nFigure\n\n28. The helper method\nLike the code in the helper method GetClaims(), AddClaims() initializes two variables with the following type objects:\n\n_type: Microsoft.IdentityModel.Claims.IClaimsIdentity type object_\n_type2: Microsoft.IdentityModel.Claims.ClaimCollection type object_\n\nOn line 235, AddClaims() gets the constructor for type Microsoft.IdentityModel.Claims.Claim and invokes the constructor (passing in the claim\ntype and value from the caller of AddClaim()) to instantiate a new Claim object.\n\nFigure\n\n29. The legitimate internal constructor from Microsoft.IdentityModel.Claims.Claim\nThe legitimate internal constructor from Microsoft.IdentityModel.Claims.Claim, retrieved and invoked by AddClaim(), invokes the internal\nconstructor Claim (overloaded method) with the following method parameters:\n\n\n-----\n\nFigure\n\n30. The internal constructor Claim\nAfter instantiating a new Claim object, AddClaim() uses the Add() method from type Microsoft.IdentityModel.Claims.ClaimCollection to add the\nnew claim to the identity object passed to AddClaim() by its caller (in this case, the new claim is added to the identity object containing the list\nof claims returned by the call to the legitimate method ProcessClaims()).\n\nFigure 31. The legitimate\n\nmethod Add() from type Microsoft.IdentityModel.Claims.ClaimCollection, invoked by AddClaim() (line 245)\nRevisiting the claim injection code in the hook method BeginProcessClaims() (and recalling the fact that one of the claims contains the OID\nvalue 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED]), here’s the second\npart of the claim injection code:\n\nFigure\n\n32. Second part of the claim injection code\nRecall that list contains claim type/value pairs of type http://schemas.microsoft.com/claims/authnmethodsreferences extracted from the\nprocessed identity object. If none of the claims in list have the value http://schemas.microsoft.com/claims/multipleauthn, the hook method\nproceeds to call AddClaim() to add a fraudulent claim of type http://schemas.microsoft.com/claims/authnmethodsreferences and value\n_http://schemas.microsoft.com/claims/multipleauthn to the list of claims returned to the caller of the hooked legitimate method ProcessClaims()._\n\nUsing the fraudulent claim injection techniques described above, if a claim with the Magic OID value\n_1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED] is presented to AD FS,_\nregardless of how the legitimate hooked method ProcessClaims() handles the claim, the BeginProcessClaims() hook function ensures that a\nclaim with value http://schemas.microsoft.com/claims/multipleauthn is returned to the caller of the legitimate hooked method ProcessClaims().\n\n### Hook method:BeginEndpointConfiguration()\n\nThe backdoor BeginEndpointConfiguration() method, used to hook the legitimate target method EndpointConfiguration() (from\n_Microsoft.IdentityServer.WebHost.dll) is shown below:_\n\n\n-----\n\nFigure\n\n33. BeginEndpointConfiguration() method\nThe enumType variable is initialized with RuntimeHelper.types[0] which is a Microsoft.IdentityServer.WebHost.Proxy.CertificateValidation type\nobject. The PropertyInfo variables propertyInfo, propertyInfo2, and propertyInfo3 are initialized with property objects retrieved from ‘properties’\nfield/array of RuntimeHelper:\n\n_propertyInfo: CertificateValidation property from type Microsoft.IdentityServer.WebHost.Proxy.ProxyEndpoint of_\n_Microsoft.IdentityServer.WebHost.dll_\n_propertyInfo2: Path property from type Microsoft.IdentityServer.WebHost.Proxy.ProxyEndpoint of Microsoft.IdentityServer.WebHost.dll_\n_propertyInfo3: Endpoints property from type Microsoft.IdentityServer.WebHost.Proxy.ProxyEndpointConfiguration of_\n_Microsoft.IdentityServer.WebHost.dll_\n\nNext, the hook method retrieves the value of the Endpoint property of the value object that the legitimate EndpointConfiguration() method was\ncalled with. The Endpoint property holds a collection of ProxyEndpoint objects. The hook method enumerates the ProxyEndpoint objects and\n[for each object, it checks if the value of the CertificateValidation enum is set to ‘1’ which signifies ‘SSL’. If the CertificateValidation enum for a](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adfspip/e54f1e02-800b-45b1-8a3e-818b4a7368c3)\n_ProxyEndpoint object is set to ‘1’/’SSL’, on line 165, the hook method overwrites the value of the CertificateValidation enum with ‘0’ which_\nsignifies ‘None’. To ensure the change is reflected, the hook method then overwrites the Endpoint property of the value object with the updated\n_Endpoint property containing the overwritten CertificateValidation enum values (that is, ‘SSL’ overwritten with ‘None’)._\n\nBehaving as a true hook method, on line 179, the method calls the legitimate EndpointConfiguration() method but with the modified ‘value’\nobject. Hence, when the legitimate EndpointConfiguration() method is invoked during the normal operation of AD FS, this hook method\nintercepts the call and, before passing the object to the legitimate EndpointConfiguration() method was invoked with, it overwrites\nthe CertificateValidation value of each ProxyEndpoint object and only then it calls the legitimate EndpointConfiguration() method but now with\nmodified CertificateValidation value(s), changed from ‘SSL’ to ‘None’.\n\nThe purpose of overwriting CertificationValidation value to ‘None’ (wherever it’s ‘SSL’) is to allow WAP to pass the request with the specific\nmalicious certificate to AD FS for further authentication processing. According to\n_Microsoft.IdentityServer.ProxyService/TLSClientReqeustHandler, WAP stops sending the current request from client to AD FS if_\n_CertificateValidation is ‘1’ (‘SSL’) and the client certificate has an error during validation._\n\n## References\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-24 - MagicWeb- NOBELIUM’s post-compromise trick to authenticate as anyone.pdf"
    ],
    "report_names": [
        "2022-08-24 - MagicWeb- NOBELIUM’s post-compromise trick to authenticate as anyone.pdf"
    ],
    "threat_actors": [
        {
            "id": "b43e5ea9-d8c8-4efa-b5bf-f1efb37174ba",
            "created_at": "2022-10-25T16:07:24.36191Z",
            "updated_at": "2025-03-27T02:02:10.1909Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "Dark Halo",
                "Nobelium",
                "SolarStorm",
                "StellarParticle",
                "UNC2452"
            ],
            "source_name": "ETDA:UNC2452",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "70872c3a-e788-4b55-a7d6-b2df52001ad0",
            "created_at": "2023-01-06T13:46:39.18401Z",
            "updated_at": "2025-03-27T02:00:03.01553Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "DarkHalo",
                "StellarParticle",
                "NOBELIUM",
                "Solar Phoenix",
                "Midnight Blizzard"
            ],
            "source_name": "MISPGALAXY:UNC2452",
            "tools": [
                "SNOWYAMBER",
                "HALFRIG",
                "QUARTERRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "1d3f9dec-b033-48a5-8b1e-f67a29429e89",
            "created_at": "2022-10-25T15:50:23.739197Z",
            "updated_at": "2025-03-27T02:00:55.536417Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "UNC2452",
                "NOBELIUM",
                "StellarParticle",
                "Dark Halo"
            ],
            "source_name": "MITRE:UNC2452",
            "tools": [
                "Sibot",
                "Mimikatz",
                "Cobalt Strike",
                "AdFind",
                "GoldMax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "a241a1ca-2bc9-450b-a07b-aae747ee2710",
            "created_at": "2024-06-19T02:03:08.150052Z",
            "updated_at": "2025-03-27T02:05:17.409596Z",
            "deleted_at": null,
            "main_name": "IRON RITUAL",
            "aliases": [
                "Blue Dev 5 ",
                "BlueBravo ",
                "Cloaked Ursa ",
                "CozyLarch ",
                "Dark Halo ",
                "Midnight Blizzard ",
                "NOBELIUM ",
                "StellarParticle ",
                "UNC2452 ",
                "APT29"
            ],
            "source_name": "Secureworks:IRON RITUAL",
            "tools": [
                " Cobalt Strike",
                " EnvyScout",
                " GoldFinder",
                " GoldMax",
                " NativeZone",
                " RAINDROP",
                " SUNBURST",
                " Sibot",
                " TEARDROP",
                " VaporRage",
                "Brute Ratel C4"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "20d3a08a-3b97-4b2f-90b8-92a89089a57a",
            "created_at": "2022-10-25T15:50:23.548494Z",
            "updated_at": "2025-03-27T02:00:55.49688Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "APT29",
                "IRON RITUAL",
                "IRON HEMLOCK",
                "NobleBaron",
                "Dark Halo",
                "NOBELIUM",
                "UNC2452",
                "YTTRIUM",
                "The Dukes",
                "Cozy Bear",
                "CozyDuke",
                "SolarStorm",
                "Blue Kitsune",
                "UNC3524",
                "Midnight Blizzard"
            ],
            "source_name": "MITRE:APT29",
            "tools": [
                "PinchDuke",
                "ROADTools",
                "WellMail",
                "CozyCar",
                "Mimikatz",
                "Tasklist",
                "OnionDuke",
                "FatDuke",
                "POSHSPY",
                "EnvyScout",
                "SoreFang",
                "GeminiDuke",
                "GoldMax",
                "FoggyWeb",
                "SDelete",
                "PolyglotDuke",
                "AADInternals",
                "MiniDuke",
                "SeaDuke",
                "Sibot",
                "RegDuke",
                "CloudDuke",
                "GoldFinder",
                "AdFind",
                "PsExec",
                "NativeZone",
                "Systeminfo",
                "ipconfig",
                "Impacket",
                "Cobalt Strike",
                "PowerDuke",
                "QUIETEXIT",
                "HAMMERTOSS",
                "BoomBox",
                "CosmicDuke",
                "WellMess",
                "VaporRage",
                "LiteDuke"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "46b3c0fc-fa0c-4d63-a38a-b33a524561fb",
            "created_at": "2023-01-06T13:46:38.393409Z",
            "updated_at": "2025-03-27T02:00:02.822155Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "The Dukes",
                "Minidionis",
                "Grizzly Steppe",
                "G0016",
                "Blue Kitsune",
                "BlueBravo",
                "SeaDuke",
                "Cloaked Ursa",
                "YTTRIUM",
                "ATK7",
                "Nobelium",
                "UAC-0029",
                "Group 100",
                "COZY BEAR",
                "IRON HEMLOCK",
                "TA421",
                "ITG11"
            ],
            "source_name": "MISPGALAXY:APT29",
            "tools": [
                "QUARTERRIG",
                "SNOWYAMBER",
                "HALFRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f27790ff-4ee0-40a5-9c84-2b523a9d3270",
            "created_at": "2022-10-25T16:07:23.341684Z",
            "updated_at": "2025-03-27T02:02:09.74554Z",
            "deleted_at": null,
            "main_name": "APT 29",
            "aliases": [
                "APT 29",
                "ATK 7",
                "Blue Dev 5",
                "BlueBravo",
                "Cloaked Ursa",
                "CloudLook",
                "Cozy Bear",
                "Dark Halo",
                "Earth Koshchei",
                "Grizzly Steppe",
                "Group 100",
                "ITG11",
                "Iron Hemlock",
                "Iron Ritual",
                "Midnight Blizzard",
                "Minidionis",
                "Nobelium",
                "NobleBaron",
                "Operation Ghost",
                "Operation Office monkeys",
                "Operation StellarParticle",
                "SilverFish",
                "Solar Phoenix",
                "SolarStorm",
                "StellarParticle",
                "TEMP.Monkeys",
                "The Dukes",
                "UNC2452",
                "UNC3524",
                "Yttrium"
            ],
            "source_name": "ETDA:APT 29",
            "tools": [
                "7-Zip",
                "ATI-Agent",
                "AdFind",
                "Agentemis",
                "AtNow",
                "BEATDROP",
                "BotgenStudios",
                "CEELOADER",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobalt Strike",
                "CobaltStrike",
                "CosmicDuke",
                "Cozer",
                "CozyBear",
                "CozyCar",
                "CozyDuke",
                "Danfuan",
                "EnvyScout",
                "EuroAPT",
                "FatDuke",
                "FoggyWeb",
                "GeminiDuke",
                "Geppei",
                "GoldFinder",
                "GoldMax",
                "GraphDrop",
                "GraphicalNeutrino",
                "GraphicalProton",
                "HAMMERTOSS",
                "HammerDuke",
                "LOLBAS",
                "LOLBins",
                "LiteDuke",
                "Living off the Land",
                "MagicWeb",
                "Mimikatz",
                "MiniDionis",
                "MiniDuke",
                "NemesisGemina",
                "NetDuke",
                "OnionDuke",
                "POSHSPY",
                "PinchDuke",
                "PolyglotDuke",
                "PowerDuke",
                "QUIETEXIT",
                "ROOTSAW",
                "RegDuke",
                "Rubeus",
                "SNOWYAMBER",
                "SPICYBEAT",
                "SUNSHUTTLE",
                "SeaDaddy",
                "SeaDask",
                "SeaDesk",
                "SeaDuke",
                "Sharp-SMBExec",
                "SharpView",
                "Sibot",
                "Solorigate",
                "SoreFang",
                "TinyBaron",
                "WINELOADER",
                "WellMail",
                "WellMess",
                "cobeacon",
                "elf.wellmess",
                "reGeorg",
                "tDiscoverer"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536011,
    "ts_updated_at": 1743041794,
    "ts_creation_date": 1662027768,
    "ts_modification_date": 1662027768,
    "files": {
        "pdf": "https://archive.orkl.eu/e6cba48b1d0e26c1d18d188f1c8ff4d2220fac9f.pdf",
        "text": "https://archive.orkl.eu/e6cba48b1d0e26c1d18d188f1c8ff4d2220fac9f.txt",
        "img": "https://archive.orkl.eu/e6cba48b1d0e26c1d18d188f1c8ff4d2220fac9f.jpg"
    }
}