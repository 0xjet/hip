{
    "id": "06c3ccfa-682e-43ff-a2ec-a10aafd89359",
    "created_at": "2023-01-12T14:59:16.542934Z",
    "updated_at": "2025-03-27T02:06:04.391546Z",
    "deleted_at": null,
    "sha1_hash": "5f6559865af1db96a5a2c5df5aca6d217b105144",
    "title": "2022-08-03 - Reversing Golang Developed Ransomware- SNAKE",
    "authors": "",
    "file_creation_date": "2022-09-01T10:23:05Z",
    "file_modification_date": "2022-09-01T10:23:05Z",
    "file_size": 3938744,
    "plain_text": "# Reversing Golang Developed Ransomware: SNAKE\n\n**[0ffset.net/reverse-engineering/analysing-snake-ransomware/](https://www.0ffset.net/reverse-engineering/analysing-snake-ransomware/)**\n\n3 August 2022\n\n[Gabriele Orini](https://www.0ffset.net/author/greenplan/)\n3rd August 2022\nNo Comments\n\n## Introduction\n\nSnake Ransomware (or EKANS Ransomware) is a Golang ransomware which in the past\nhas affected several companies such as Enel and Honda. The MD5 hashing of the analyzed\nsample is [ED3C05BDE9F0EA0F1321355B03AC42D0. This sample in particular is](https://app.any.run/tasks/ad3d809f-e197-4091-9b93-b6d68368c05b/)\n[obfuscated with Gobfuscate, an open source obfuscation project available on Github.](https://github.com/unixpickle/gobfuscate)\n\nLet’s start by quickly summarizing the functionality of the malware:\n\nFirst, the sample checks the domain to which the infected host belongs to, before\ncontinuing execution\nNext, it checks whether the computer is a Backup Domain Controller or Primary\nDomain Controller, and if so will only drop the ransom note, rather than encrypting the\nmachine\nSNAKE will then isolate the host machine from the network by leveraging the netsh tool\nThe shadow copies on the system are deleted using WMI\nSNAKE attempts to terminate any running AV, EDR, and SIEM components\n\n\n-----\n\nFinally, local files on the system are encrypted\n\nFor each file, a unique AES encryption key is generated, which is later encrypted\nwith an RSA-2048 public key and stored within the encrypted file.\n\nLet’s start reversing this sample with IDA!\n\n## Static Analysis\n\nThere are some differences of Go from other languages to keep in mind:\n\nFunctions can return multiple values.\nFunction parameters are passed on the stack.\nStrings are typically a sequence of bytes with a fixed length, that are not null\nterminated; the string is represented by a structure formed by a pointer to a byte array,\nand the length of the string.\nThe constants are stored in one large buffer and sorted by length.\nMany stack manipulations are present within the binaries, that can make the analysis\ncomplex.\n\n### Obfuscation\n\nOpening the sample with IDA we immediately notice that the function names are very\nobfuscated:\n\nGobfuscate obfuscates\n\nalmost all function names within the binary\n\n\n-----\n\n[Performing a quick search, I found that the malware is obfuscated with Gobfuscate. This](https://github.com/unixpickle/gobfuscate)\nproject performs obfuscation of several components: Global names, Package names, Struct\nmethods, and Strings.\n\nEach string in the binary is replaced by a function call. Each function contains two arrays that\nare xored to get the original string. When implementing the decryption function, keep in mind\nthat there are different ways in which these arrays are passed to the function\n**runtime.stringtoslicebyte – either via a variable, a pointer or a hardcoded value).**\n\nAnalyzing the sample, you will usually find the call to a main function that contains a large\nnumber of other calls within it, where each subroutine performs decryption of only one string.\nSometimes only the decryption operations are found within these subroutines, other times\nadditional operations are performed on the decrypted string.\n\nString Decryption\n\nFunctions\n\nString Decryption Functions\n\nAs mentioned, the string encryption is fairly basic, XORing the contents of two arrays\ntogether to retrieve the final string.\n\n\n-----\n\nLoading the two arrays for decryption\n\nXORing the arrays together to get the decrypted string\nDue to the simplicity of the algorithm, we can develop a simple Python script utilising some\nregular expressions to locate and decrypt 90% of the encrypted strings within the binary! The\nscript can be found at the end of this post.\n```\nstartDecryptFunction = b\"\\x64\\x8B\\x0D\\x14\\x00\\x00\\x00\"\n\nsliceStr = b\"(\" + b\"\\x8D.....\\x89.\\$\\x04\\xC7\\x44\\$\\b....\" + b\")\"\n\nxorLoop = b\"\\x0F\\xB6<\\)1\\xFE(\\x83|\\x81)\\xFD\"\n\n```\nWith the majority of the strings decrypted, let’s continue the analysis!\n\n### Check Environment\n\nOne of the first operations I perform when analyzing malware in GO is to jump to the\n**main.init function.**\n\nThe main.init is generated for each package by the compiler to initialise all other packages\nthat this sample relies on, as well as the global variables; analysing this function is very\nimportant because it allows us to understand a large amount of the malware’s functionality\nand speed up subsequent analysis.\n\n\n-----\n\nIn the main.init function we can find, for example, references to encryption: AES, RSA,\n**SHA1, X509. In addition, there are several functions for decryption of strings and function**\nnames.\n\nInitialisations\n\nperformed within main.init function\n\nAPI function decryption and loading through NewProc\nNow we move on to analyze the main.main function. One of the first activities the malware\nperforms is to check the environment before continuing with encryption.\n\n\n-----\n\nCall to CheckEnvironment within main.main\nThe function CheckEnvironment starts by attempting to resolve the hostname\n**mds.honda.com and compare the returned value with 172[.]108[.]71[.]153.This check is**\nused to confirm that the infected machine is part of the correct domain. In fact, it is important\nto remember that this ransomware is deployed at the end of the infection chain by other\nloaders, and thus it is likely custom-built for the victim.\n\nResolving hostname via DNS\n\n\n-----\n\nComparing resolved address to hardcoded address\nAfter the first environment check, the malware executes the API calls CoInitializeEx,\n**CoInitializeSecurity and CoCreateInstance to instantiate an object of the SWbemLocator**\ninterface. Using the SWbemLocator object, SNAKE then invokes the method\n**SWbemLocator::ConnectServer and obtains a pointer to an SWbemServices object.**\nFinally, with this object, it will execute ExecQuery with the following query:\n```\nselect DomainRole from Win32_ComputerSystem\n\n```\nIn an attempt to determine whether the infected computer is a server or a workstation.\n\nDecryption of object used to perform WMI query\n\nDecryption of WMI query to retrieve DomainRole\nAfter making the query, the malware only continues execution if the DomainRole value is\nequal to or less than 3.\n\n\n-----\n\nExecution of WMI query and checking of result\nAccording to [Microsoft documentation, the integers returned by the call correspond to](https://docs.microsoft.com/en-us/dotnet/api/microsoft.powershell.commands.domainrole?view=powershellsdk-1.1.0)\ndifferent values:\n\n**VALUE** **MEANING**\n\n0 Standalone Workstation\n\n1 Member Workstation\n\n2 Standalone Server\n\n3 Member Server\n\n4 Backup Domain Controller\n\n5 Primary Domain Controller\n\nTherefore, the malware performs the infection only if the role obtained of the computer is\n**Standalone Workstation, Member Workstation, Standalone Server, or Member Server.**\n\nIf this check is successful, the mutex Global\\EKANS is created, and presuming the mutex is\ncreated successfully, the sample continues executing.\n\n\n-----\n\nExecution\n\nflow depending on the result of the DomainRole\nIf, on the other hand, the computer role is either a backup domain controller or primary\ndomain controller, a ransom note is dropped to C:\\Users\\Public\\Desktop, and files are not\nencrypted. Within the ransom note is an email on how to contact the threat actors, with the\nemail used in this sample being CarrolBidell@tutanota.com.\n\n\n-----\n\nRansom note\nWhen analyzing Go developed programs, two functions to pay attention to are NewLazyDll\n(essentially LoadLibrary), and NewProc (as you may have guessed, basically\nGetProcAddress). With the use of Gobfuscate to obfuscate this sample, the names of the\nlibraries and API functions to be passed to the described functions. Pointers to the loaded\nlibraries/functions are stored within DWORDs for later reference.\n\nFor example, we can see in the sample we have the function that performs the decryption of\na function name before calling LazyDLL.NewProc:\n\nAPI function decryption and loading via NewProc\nA pointer to the function is saved in a DWORD, so that we can trace to see where the\nfunction is called within the binary.\n\n\n-----\n\nCross references for API functions\n\nExecution of previously loaded API function\n\n### Endpoint Isolation\n\nAfter the function CheckEnvironment has finished, the strings “netsh advfirewall set\n**allprofiles state on” and “netsh advfirewall set allprofiles firewallpolicy**\n**blockinbound,blockoutbound” are decrypted and executed via cmd.run. The first**\ncommand enables Windows Firewall for all network profiles, while the second blocks all\nincoming and outgoing connections. This is fairly unusual behaviour for ransomware, which\ntypically performs lateral movement across a network to infect additional machines.\n\n\n-----\n\nDecryption of netsh commands to alter the firewall\n\nExecution of above commands through os.exec\n\n### Terminate Process and Services\n\nPrior to encryption, the ransomware terminates a number of processes, to reduce the\namount of interference with the encryption (for example any open file handles), as well as\ndisable any running EDR/SIEM software on the machine.\n\n\n-----\n\nDecryption of target processes to be terminated\nProcesses are terminated using syscall.OpenProcess and syscall.TerminateProcess\ncalls. In order for SNAKE to retrieve the PIDs of the target processes, the usual calls of\nCreateToolhelp32Snapshot, Process32FirstW, and Process32NextW are performed.\n\nTerminating processes with OpenProcess and TerminateProcess\n\n\n-----\n\nIn addition to terminating processes, the ransomware stops more than 200 services related\nto EDR, SIEM, AV, etc.\n\nDecryption of target service names to be terminated\nIn order to terminate services, the following API function calls are made:\n\n**OpenSCManagerA: gets a service control manager handle for subsequent calls.**\n**EnumServicesStatusEx: enumeration of services.**\n**OpenServiceW: gets a service handle for subsequent calls.**\n**QueryServiceStatusEx: check the status of services.**\n**ControlService: used to stop the service (flag SERVICE_CONTROL_STOP).**\n\nTermination of services using OpenService and ControlService\n\n### Shadow Copy Deletion\n\n\n-----\n\nThe ransomware executes the WMI query **SELECT FROM Win32_ShadowCopy to get**\nthe IDs of Shadow Copies and will always use WMI for deletion (remember that there are\nmany ways to perform shadow copy deletion).\n\nIn addition to the Wbemscripting.SWbemLocator object,\n**WbemScripting.SWbemNamedValueSet is also created.**\n\nFor deletion, SNAKE uses the DeleteInstance method by passing the ID of previously\nobtained Shadow Copies.\n\nDecryption of WbemScripting.SWbemNamedValueSet\n\nDecryption of WMI Query\n\nDecryption of WMI namespace\n\n### Encryption Process\n\nSNAKE first encrypts all the various files by initializing 8 go-routines (runtime.newproc),\nbefore beginning to rename the files.\n\n\n-----\n\nThe offset of the function that does the encryption is passed to runtime.newproc\n(OffsetStartEncryption).\n\nInitialisation of go-routines prior to file renaming function\nBefore beginning encryption of the file, it’s checked that it has not already been encrypted by\nchecking for the presence of the string EKANS at the end of the file.\n\nChecking if file is\n\nalready encrypted\nIf the file hasn’t yet been encrypted and the files are among those to be encrypted (there is\nan allowlist and a denylist), encryption is initiated, which takes care of:\n\n\n-----\n\nGenerating AES key for each file; this key is encrypted with an RSA public key in\nOAEP Mode.\nEncryption of file via AES in CTR mode, with Random Key (32 bytes) and Random IV\n(16 bytes).\nA random 5 character is appended to the file extension of encrypted files.\nAdds data to the end of the file: encrypted AES Key, IV and EKANS string.\n\nKey generation, encryption, and metadata being added to file\nAfter instantiating the CTR cipher with cipher.NewCTR, encryption is performed with the\n**XORKeyStream method of that class.**\n\nThe function reads 0x19000 bytes at a time and after encryption the file is rewritten using\n**WriteAt.**\n\nGenerating the buffer to hold bytes read from the file\n\n\n-----\n\nEncrypting buffer data and overwriting file\nAfter finishing the encryption, three more writes are performed on the file:\n\nAdding metadata to the file\nIt’s easy to see that in the last one the string EKANS is written (which is used to determine if\nthe file has already been encrypted), while it is much more complex to figure out what is\nwritten in the first two. As a result, let’s jump over to a debugger.\n\nObserving metadata being written to end of file using a debugger\nThe first write adds the following to the file:\n\nThe encrypted AES Key\n\n\n-----\n\nThe random IV\nThe path of encrypted file\n\nThe AES Key for each file is encrypted with a public RSA key. After decryption, the public\nkey is parsed with pem.decode and x509.ParsePKCS1PublicKey.\n\nDecryption of RSA public key\n\n\n-----\n\nParsing of the RSA key\nThe first parameter of the EncryptOAEP function must be the hash function, which in this\ncase is sha1:\n\nEncryptOAEP Function\n\n\n-----\n\nCall to EncryptOAEP function\nVarious extensions, file and folders are excluded for file encryption, also using a regex.\n\n**Partially excluded Files:**\n\n**Iconcache.db** **Ntuser.dat** **Desktop.ini**\n\n**Ntuser.ini** **Usrclass.dat** **Usrclass.dat.log1**\n\n**Usrclass.dat.log2** **Bootmgr** **Bootnxt**\n\n**Ntuser.dat.log1** **Ntuser.dat.log2** **Boot.ini**\n\n**ctfmon.exe** **bootsect.bak** **ntdlr**\n\n**Partially excluded extensions:**\n\n**Exe** **Dll** **Sys**\n\n**Mui** **Tmp** **Lnk**\n\n**config** **settingcontent-ms** **Tlb**\n\n**Olb** **Bfl** **ico**\n\n**regtrans-ms** **devicemetadata-ms** **Bat**\n\n**Cmd** **Ps1**\n\n**Excluded Paths:**\n\n**\\ProgramData**\n\n**\\Users\\All Users**\n\n**\\Temp\\**\n\n**\\AppData\\**\n\n**\\Boot**\n\n**\\Local Settings**\n\n\n-----\n\n**\\Recovery**\n\n**\\Program Files**\n\n**\\System Volume Information**\n\n**\\$Recycle.Bin**\n\n**.+\\\\Microsoft\\\\(User Account Pictures|Windows\\\\(Explorer|Caches)|Device**\n\nAnd that just about wraps up this post on the SNAKE Ransomware!\n\n### Decryption Script\n\n\n-----\n\n```\n#!/usr/bin/env python3\n\nimport re, struct, pefile, sys\n\npe = None\n\nimageBase = None\n\n\ndef GetRVA(va):\n\n  return pe.get_offset_from_rva(va - imageBase)\n\n\ndef GetVA(raw):\n\n  return imageBase + pe.get_rva_from_offset(raw)\n\ndef main():\n\n  global pe, imageBase\n\n  filename = sys.argv[1]\n\n  with open(filename, 'rb') as sample:\n\n    data = bytearray(sample.read())\n\n  pe = pefile.PE(filename)\n\n  imageBase = pe.OPTIONAL_HEADER.ImageBase\n\n  startDecryptFunction = b\"\\x64\\x8B\\x0D\\x14\\x00\\x00\\x00\"\n\n  sliceStr = b\"(\" + b\"\\x8D.....\\x89.\\$\\x04\\xC7\\x44\\$\\b....\" + b\")\"\n\n  xorLoop = b\"\\x0F\\xB6<\\)1\\xFE(\\x83|\\x81)\\xFD\"\n\n  regex = startDecryptFunction + b\".{10,100}\" + sliceStr + b\".{10,100}\" + sliceStr\n+ b\".{10,100}\" + xorLoop\n\n  pattern = re.compile(regex, re.MULTILINE|re.DOTALL)\n\n  found = pattern.finditer(bytes(data))\n\n  for m in found:\n\n    va = GetVA(m.start())\n\n    funcVA = GetVA(m.start())\n\n    str1VA = struct.unpack(\"<L\", data[m.start(1) + 2 : m.start(1) + 2 + 4])[0]\n\n    str1Len = struct.unpack(\"<L\", data[m.start(1) + 0xE : m.start(1) + 0xE + 4])\n[0]\n\n    str2VA = struct.unpack(\"<L\", data[m.start(2) + 2 : m.start(2) + 2 + 4])[0]\n\n    str1RVA = GetRVA(str1VA)\n\n    str2RVA = GetRVA(str2VA)\n\n```\n\n-----\n\n```\n    decrypted = \"\"\n\n    for i in range(str1Len):\n\n      decrypted += chr ( ( data[str2RVA+i] ^ (data[str1RVA+i] + i * 2)) & 0xFF)\n\n    print(f\"## (hex(funcVA)) - {decrypted}\")\n\n\nif __name__ == \"__main__\":\n\n     main()\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-03 - Reversing Golang Developed Ransomware- SNAKE.pdf"
    ],
    "report_names": [
        "2022-08-03 - Reversing Golang Developed Ransomware- SNAKE.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535556,
    "ts_updated_at": 1743041164,
    "ts_creation_date": 1662027785,
    "ts_modification_date": 1662027785,
    "files": {
        "pdf": "https://archive.orkl.eu/5f6559865af1db96a5a2c5df5aca6d217b105144.pdf",
        "text": "https://archive.orkl.eu/5f6559865af1db96a5a2c5df5aca6d217b105144.txt",
        "img": "https://archive.orkl.eu/5f6559865af1db96a5a2c5df5aca6d217b105144.jpg"
    }
}