{
    "id": "2ba6f26f-7d37-473f-95bd-9fca03042bbc",
    "created_at": "2023-01-12T15:07:24.755305Z",
    "updated_at": "2025-03-27T02:05:33.005921Z",
    "deleted_at": null,
    "sha1_hash": "f422f903b3a7366c09fd7ccd803bc312ef0a81d8",
    "title": "2022-12-03 - Nighthawk DLL Payload Configuration Parser",
    "authors": "",
    "file_creation_date": "2022-12-29T00:28:04Z",
    "file_modification_date": "2022-12-29T00:28:04Z",
    "file_size": 392347,
    "plain_text": "# CAPEv2/Nighthawk.py at master · kevoreilly/CAPEv2 · GitHub\n\n**[github.com/kevoreilly/CAPEv2/blob/master/modules/processing/parsers/CAPE/Nighthawk.py](https://github.com/kevoreilly/CAPEv2/blob/master/modules/processing/parsers/CAPE/Nighthawk.py)**\n\nkevoreilly\n\nimport contextlib\n\nimport gzip\n\nimport itertools\n\nimport json\n\nimport struct\n\nimport pefile\n\nimport regex as re\n\nfrom Crypto.Cipher import AES\n\nDESCRIPTION = \"NightHawk C2 DLL configuration parser.\"\n\nAUTHOR = \"Nikhil Ashok Hegde <@ka1do9>\"\n\n\n-----\n\ndef _decode_str(encoded_string, plaintext_alphabet, ciphertext_alphabet):\n\n\"\"\"\n\nThis function implements the substitution cipher that Nighthawk uses.\n\nEncoded strings are decoded.\n\nBorrowed from https://www.proofpoint.com/us/blog/threat-insight/nighthawk-and-comingpentest-tool-likely-gain-threat-actor-notice\n\nwhich is no longer available, but here's an archive link:\n\nhttps://web.archive.org/web/20221128090619/https://www.proofpoint.com/us/blog/threatinsight/nighthawk-and-coming-pentest-tool-likely-gain-threat-actor-notice\n\n:param encoded_string: String encoded with Nighthawk substitution cipher\n\n:type encoded_string: <class 'bytes'>\n\n:param plaintext_alphabet: Plaintext alphabet used in the substitution cipher\n\n:type plaintext_alphabet: <class 'bytes'>\n\n:param ciphertext_alphabet: Ciphertext alphabet used in the substitution cipher\n\n:type ciphertext_alphabet: <class 'bytes'>\n\n:return: Decoded string\n\n:rtype: str\n\n\"\"\"\n\ndecoded_string_list = []\n\nfor enc_str in bytes(encoded_string, \"utf-8\"):\n\nif enc_str in ciphertext_alphabet:\n\ndecoded_string_list.append(chr(plaintext_alphabet[ciphertext_alphabet.find(enc_str)]))\n\nelse:\n\ndecoded_string_list.append(chr(enc_str))\n\nreturn \"\".join(decoded_string_list)\n\n\n-----\n\ndef decode_config_strings(decrypted_config, plaintext_alphabet, ciphertext_alphabet,\nconfig):\n\n\"\"\"\n\nThis function implements the substitution cipher that Nighthawk uses.\n\nEncoded strings are decoded.\n\n:param decrypted_config: Decrypted Nighthawk config\n\n:type decrypted_config: dict\n\n:param plaintext_alphabet: Plaintext alphabet used in the substitution cipher\n\n:type plaintext_alphabet: <class 'bytes'>\n\n:param ciphertext_alphabet: Ciphertext alphabet used in the substitution cipher\n\n:type ciphertext_alphabet: <class 'bytes'>\n\n:return: JSON with decoded strings\n\n:rtype: dict\n\n\"\"\"\n\nfor k in decrypted_config:\n\ndecoded_string = _decode_str(k, plaintext_alphabet, ciphertext_alphabet)\n\nif isinstance(decrypted_config[k], dict):\n\nconfig[decoded_string] = decrypted_config[k].copy()\n\nelse:\n\nconfig[decoded_string] = decrypted_config[k]\n\ndel config[k]\n\nif isinstance(decrypted_config[k], dict):\n\nconfig[decoded_string] = decode_config_strings(\n\ndecrypted_config[k], plaintext_alphabet, ciphertext_alphabet, config[decoded_string]\n\n)\n\n\n-----\n\nelif isinstance(decrypted_config[k], str):\n\nconfig[decoded_string] = _decode_str(decrypted_config[k], plaintext_alphabet,\nciphertext_alphabet)\n\nif isinstance(decrypted_config[k], list):\n\nconfig[decoded_string] = []\n\nfor s in decrypted_config[k]:\n\nconfig[decoded_string].append(_decode_str(s, plaintext_alphabet, ciphertext_alphabet))\n\nreturn config\n\ndef _get_section_data(data, section_name):\n\n\"\"\"\n\nFunction to return data belonging to `section_name` section in PE `data`\n\n:param data: Nighthawk DLL contents\n\n:type data: <class 'bytes'>\n\n:param section_name: Name of section whose data is to be retrieved\n\n:type section_name: str\n\n:return: section data\n\n:rtype: <class 'bytes'> or None\n\n\"\"\"\n\npe = None\n\nwith contextlib.suppress(Exception):\n\npe = pefile.PE(data=data, fast_load=False)\n\nif pe is None:\n\nreturn None\n\nfor section in pe.sections:\n\n\n-----\n\nif section.Name.strip(b\"\\x00\") == section_name:\n\nreturn section.get_data()\n\nreturn None\n\ndef _alphabet_heuristics(alphabets):\n\n\"\"\"\n\nThis function implements heuristics to determine if an identified alphabet\n\nstring is actually an alphabet. These heuristics are purely based on my\n\nobservations.\n\n:param alpha: Possible alphabet strings\n\n:type alpha: list of <class 'bytes'>\n\n:return: set of possible alphabet bytestrings\n\n:rtype: set of <class 'bytes'>\n\n\"\"\"\n\ncandidates = {}\n\nfinalists = set()\n\nfor alpha in alphabets:\n\nnum_whitespace = len(re.split(b\"\\s+\", alpha))\n\nif num_whitespace > 3:\n\n# I've observed alphabets usually have num_whitespace == 2\n\ncontinue\n\nnum_unique_chars = len(set(alpha))\n\nif num_unique_chars < 15:\n\n# I've observed that alphabets have large number of unique characters\n\n\n-----\n\n# Random low threshold, though\n\ncontinue\n\nif num_unique_chars not in candidates:\n\ncandidates[num_unique_chars] = set()\n\ncandidates[num_unique_chars].add(alpha)\n\n# I've observed that the plaintext and ciphertext alphabets both have the\n\n# same number of num_unique_chars\n\nfor _, alphabets_ in candidates.items():\n\nif len(alphabets_) > 1:\n\nfinalists.update(alphabets_)\n\nreturn finalists\n\ndef get_possible_alphabet(data):\n\n\"\"\"\n\nNighthawk is known to encode strings using a simple substitution cipher.\n\nDecoding requires knowing the plaintext and ciphertext alphabets used.\n\n:param data: Nighthawk DLL contents\n\n:type data: <class 'bytes'>\n\n:return: Permutation of possible plaintext and ciphertext alphabets\n\n:rtype: <class 'itertools.permutations'> or None\n\n\"\"\"\n\nalphabets_regex = b\"[\\w\\s!\\\\\\\"\\#\\$%\\&'\\(\\)\\*\\+,\\-\\./:;<=>\\?@\\[\\]\\^_`\\{\\}\\~\\|]{86}\\x00\"\n\nalphabets_regexc = re.compile(alphabets_regex)\n\n# Alphabets are known to exist in the .rdata section, so just search there\n\n\n-----\n\nrdata_data = _get_section_data(data, b\".rdata\")\n\nmatches = alphabets_regexc.findall(rdata_data)\n\nif matches:\n\nalphabets = _alphabet_heuristics(matches)\n\nif alphabets:\n\n# At this point, I have candidate alphabet strings but I don't know\n\n# which is the plaintext alphabet and which is ciphertext alphabet\n\n# To brute force, I'll calculate different permutations of length 2\n\nreturn itertools.permutations(alphabets, 2)\n\nreturn None\n\ndef decrypt_config(encrypted_config, decryption_key):\n\n\"\"\"\n\nNighthawk config is gzip compressed and then encrypted with AES-128 CBC mode.\n\n:param encrypted_config: Encrypted config data\n\n:type encrypted_config: <class 'bytes'>\n\n:param decryption_key: Config decryption key\n\n:type decryption_key: <class 'bytes'>\n\n:return: decrypted config\n\n:rtype: dict or None\n\n\"\"\"\n\ncipher = AES.new(decryption_key, AES.MODE_CBC, IV=16 * b\"\\x00\")\n\ngzip_config = cipher.decrypt(encrypted_config)\n\nif gzip_config[:2] != b\"\\x1F\\x8B\":\n\n\n-----\n\n# gzip magic signature is b'\\x1F\\x8B' at offset 0\n\nreturn None\n\n# I've noticed gzip_config containing additional data at the end.\n\n# Below statements truncate gzip_config to the rightmost b'\\x00\\x00'\n\n# which is gzip end-of-stream marker\n\ni = gzip_config.rindex(b\"\\x00\\x00\")\n\ngzip_config = gzip_config[: i + 2]\n\nconfig = gzip.decompress(gzip_config).decode(\"utf-8\")\n\nreturn json.loads(config)\n\ndef get_encoded_config(profile_section_contents):\n\n\"\"\"\n\nThe contents of Nighthawk DLL .profile section contain 4 components:\n\n1. Keying method\n\n2. Config decryption key (optional)\n\n2. Size of configuration\n\n3. Encrypted configuration\n\nAt this point, it is confirmed that the keying method == 0 and config\n\ndecryption key is available in the .profile section.\n\n:param data: Nighthawk DLL .profile section contents\n\n:type data: <class 'bytes'>\n\n:return: Encrypted config data\n\n:rtype: <class 'bytes'> or None\n\n\"\"\"\n\n\n-----\n\nconfig_size = struct.unpack(\"<I\", profile_section_contents[17:21])[0]\n\nif config_size > (len(profile_section_contents) - 1 - 16 - 4):\n\n# max config size == size of .profile section - keying method 1 byte - 16\n\n# bytes config decryption key - 4 bytes config size field.\n\n# Actual config size cannot be greater than max possible config size\n\nreturn None\n\nreturn profile_section_contents[21 : 21 + config_size]\n\ndef get_decryption_key(profile_section_contents):\n\n\"\"\"\n\nThe contents of Nighthawk DLL .profile section contain 4 components:\n\n1. Keying method\n\n2. Config decryption key (optional)\n\n2. Size of configuration\n\n3. Encrypted configuration\n\n:param data: Nighthawk DLL .profile section contents\n\n:type data: <class 'bytes'>\n\n:return: Config decryption key\n\n:rtype: <class 'bytes'> or None\n\n\"\"\"\n\nkeying_method = profile_section_contents[0]\n\nif keying_method == 0:\n\n# Config decryption key is embedded in .profile section contents\n\nreturn profile_section_contents[1:17]\n\nreturn None\n\n\n-----\n\ndef get_profile_section_contents(data):\n\n\"\"\"\n\nNighthawk DLLs are known to contain a .profile section which contains\n\nconfiguration information.\n\n:param data: Nighthawk DLL contents\n\n:type data: <class 'bytes'>\n\n:return: .profile section contents\n\n:rtype: <class 'bytes'> or None\n\n\"\"\"\n\nreturn _get_section_data(data, b\".profile\")\n\ndef extract_config(data):\n\n\"\"\"\n\nConfiguration extractor for Nighthawk DLL\n\n:param data: Nighthawk DLL contents\n\n:type data: <class 'bytes'>\n\n:return: Decrypted and decoded config\n\n:rtype: dict or None\n\n\"\"\"\n\n# Will contain the final config that is passed to CAPEv2\n\ncfg = {}\n\nprofile_section_contents = get_profile_section_contents(data)\n\nif profile_section_contents is None:\n\n\n-----\n\nreturn None\n\ndecryption_key = get_decryption_key(profile_section_contents)\n\nif decryption_key is None:\n\nreturn None\n\nconfig = get_encoded_config(profile_section_contents)\n\ndecrypted_config = decrypt_config(config, decryption_key)\n\n# decrypt_config is the decrypted configuration, but key and values strings\n\n# are still encoded and need to be decoded. Nighthawk is known to encode\n\n# strings using a simple substitution cipher. The real challenge is to extract\n\n# the ciphertext and plaintext alphabet from the DLL\n\npossible_alphabets = get_possible_alphabet(data)\n\nfor plaintext_alphabet, ciphertext_alphabet in possible_alphabets:\n\nconfig_ = decode_config_strings(decrypted_config, plaintext_alphabet,\nciphertext_alphabet, decrypted_config.copy())\n\nif \"implant-config\" in config_:\n\n# This is a heuristic and may fail in future versions\n\ncfg[\"Plaintext Alphabet\"] = plaintext_alphabet\n\ncfg[\"Ciphertext Alphabet\"] = ciphertext_alphabet\n\ncfg[\"Config AES-128 CBC Decryption Key\"] = decryption_key\n\ncfg[\"Implant Config\"] = config_\n\nbreak\n\nreturn cfg\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-12-03 - Nighthawk DLL Payload Configuration Parser.pdf"
    ],
    "report_names": [
        "2022-12-03 - Nighthawk DLL Payload Configuration Parser.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536044,
    "ts_updated_at": 1743041133,
    "ts_creation_date": 1672273684,
    "ts_modification_date": 1672273684,
    "files": {
        "pdf": "https://archive.orkl.eu/f422f903b3a7366c09fd7ccd803bc312ef0a81d8.pdf",
        "text": "https://archive.orkl.eu/f422f903b3a7366c09fd7ccd803bc312ef0a81d8.txt",
        "img": "https://archive.orkl.eu/f422f903b3a7366c09fd7ccd803bc312ef0a81d8.jpg"
    }
}