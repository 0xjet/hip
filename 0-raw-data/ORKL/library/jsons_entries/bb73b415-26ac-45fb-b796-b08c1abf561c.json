{
    "id": "bb73b415-26ac-45fb-b796-b08c1abf561c",
    "created_at": "2023-01-12T14:59:34.161406Z",
    "updated_at": "2025-03-27T02:05:42.378779Z",
    "deleted_at": null,
    "sha1_hash": "26ed2d457667e228ef3e7a8ccea76e86b27eb0f3",
    "title": "2019-03-23 - Reverse Engineering Gootkit with Ghidra Part I",
    "authors": "",
    "file_creation_date": "2022-05-28T17:48:39Z",
    "file_modification_date": "2022-05-28T17:48:39Z",
    "file_size": 1389380,
    "plain_text": "# Reverse Engineering Gootkit with Ghidra Part I\n\n**dannyquist.github.io/gootkit-reversing-ghidra/**\n\n## Open Malware - Danny Quist\n\nReverse Engineering and 3D Printing - Danny Quist\n\n[Blog](https://dannyquist.github.io/) [About](https://dannyquist.github.io/about)\nDanny Quist\n\nMarch 23, 2019\n\n[Ghidra is pretty handy for looking at malware. This series of post is an informal overview of](https://ghidra-sre.org/)\nwhat I do. Gootkit is a great implant to learn the functionality of Ghidra. Gootkit is a NodeJS\nserver with packaged Javascript implementing the implant functionality. There are lots of\nlibraries linked into the main executable including Node, OpenSSL, and many more. As a\nreverse engineer it is difficult to identify and identify open libraries. In this post, I will go\nthrough my analysis process to use and understand Ghidra’s functionality.\n\nI will first begin by basic code analysis, and understanding how to rename variables and\ntypes. I am going to avoid dynamic analysis initially, because dynamic analysis is something\nthat you can buy or implement cheaply enough. In a real-world scenario I typically start\ndynamic analysis using a range of tools, then delve into the code as a secondary step.\n\n\n-----\n\nThe purpose is to learn Ghidra, not to do a great job at reverse engineering all of Gootkit. It is\nhighly informal, and meant to be that way.\n\n## Ghidra All the Things!\n\n[There are now a few tutorials available on installing and configuring Ghidra Ghidra. Create a](https://dannyquist.github.io/ghidra-re/)\nnew project, and then import the decrypted rbody32 sample into the project. The sample I\nwill be using is:\n```\n$ shasum rbody32.x.dec\n6170e1658404a9c2655c13acbe1a2ad17b17feae\n\n```\nIt is a decoded version of the file downloaded from a compromised Gootkit site. While\nGootkit is the topic for this blog, this process can be applied generally to anything else.\n\nYour import summary should look a lot like this:\n\n\n-----\n\n_Figure 1: Ghidra import summary for the relevant Gootkit example_\n\n## Ghidra Import Summaries\n\nImport summaries tell you critically important facts about the sample that you’re looking at.\nThe key thing to remember is that Ghidra is primarily a source code reverse engineering tool.\nThere are a few salient bits to draw your attention to:\n\n\n-----\n\nFirst, compiler identification. In this case Ghidra identifies `VisualStudio:unknown as the`\nlikely compiler. This makes sense, as it is based off of a NodeJS, which is a C++ program,\nand Visual Studio is the compiler of choice for Windows. Knowing the compiler is important\nlater when you’re puzzling through some obtuse assembly code, trying to figure out if the\ncompiler generated some weird code, or the malware author was being tricky. Ghidra is\nexcellent about identifying and categorizing compiler generated nonsense, and saves a\nbunch of time.\n\nSecond, `Compiler ID appears to be the the platform that the compiler was run on. As you`\nlook at more assembly code, you’ll get a good idea of how each of them generate code for\nstandard C and C++ programming patterns. My indicator when looking at code is whether or\nnot it was hand-rolled assembly, or is compiler generated. Typically hand-rolled, artisinally\ncrafted assembly is a good indication that there are shenanigans afoot. Hand coded\nassembly can be significantly more difficult to understand, where a compiler will try to do\nthings the same way.\n\nWhy do I care so much about compiler produced versus hand-coded assembly? As an\nanalyst, you have a budget of time and attention that you can focus on every bit of code.\nDuring an investigation I tend to hit a point of diminishing returns where fatigue sets in, and I\nstart to miss critically important details. The code placed around checking return values and\nstack canaries is something I spend way too much time classifying in a sample. If a tool can\nidentify that, I can label it as not important and go on with life. If the tool does not identify\nthat, or more likely I get drawn in anyway, there are all sorts of suspicious APIs that are very\ndistracting. `ExitProcess, anything thread related, etc.`\n\nAdditional information is an excellent resource too. Looking at the high-level DLLs the\nsample is using can give you an idea of what the functionality is going to be.\n\n## Existing Gootkit Research\n\nLargely this document will consist of reproducing the already existing Gootkit analyses.\nGootkit is served from a compromised host and runs a small command and control server.\nThe user is tricked/hacked into downloading a compromised PDF/DOC/implant, which then\ncontacts the call-home server. Generally if you see `.*/rbody32 or` `.*/rbody320 in the`\nURL, you’ve most likely got the right sample.\n\n[@jgegeny has a copy of the extracted JavaScript files. The functionality signatures, and](https://github.com/jgegeny/gootkit-xswkit-js)\noverall path to success depends on understanding the JavaScript. I will focus on trying to\nextract them.\n\nIn general the things you need to know about Gootkit:\n\n1. It’s based on a all-in-one compiled version of a NodeJS application. If you ever needed\n\na more clear and present indication that Node is evil, look no further\n\n\n-----\n\n2. It has a second DLL inside of it to handle password and credential harvesting.\n3. All of the functionality exists as JavaScript files, which we would like to decode and\n\nobtain.\n\n## Analyzing Gootkit\n\n Analysis Goals\n\n1. Generate new indicators of compromise\n2. Find attribution information for the authors\n3. Show the functionality of Ghidra\n4. Extract all the Javascript code\n\n## Assumptions\n\n1. There is Javascript hiding inside Gootkit, and is a good source for IOCs.\n2. The JavaScript files are probably compressed or encrypted.\n3. The Password Grabber DLL is also embedded in this binary\n\nDouble-click the `rbody32.x.dec inside of the project view and enjoy the 1337 dragon`\ngraphic animation. The answer to “would you like to analyze now?” is always yes.\n\nThe Answer is Always Yes Figure 2: An exercise in clicking the Yes button until something\n_happens_\n\n\n-----\n\n_Figure 3: Be sure to select ‘Aggressive Instruction Finder’ and bravely ignore all the_\n_warnings._\n\n## Ghidra Analysis Options\n\nFigure 3 shows the analysis options that Ghidra has available. Similar to IDA, you should\nmost likely ignore these individual settings and just accept the defaults. (The exception being\n```\nAggressive Instruction Finder )\n\n```\nLooking at some of the default options, there are all sorts of goodies available. I’ll go through\nmy favorites so far:\n\n\n-----\n\n1. Apply Data Archives - Search for embedded archive formats, and display information\n\nabout them. Have a blob of zip/base64/lznt1 data you find? Ghidra looks for these as\nwell and calls them out.\n2. Embedded Media - More often than not, especially if your sample is trying to\n\nimpersonate a benign program, you’ll find media or other sheisty information\nembedded. This will create bookmarks for you to later use and analyze.\n3. Windows .* - All of the internal things that Windows compilers use to make life difficult.\n\nPreviously these all had to be waded through individually. Now Ghidra will figure them\nout, add salient information to the analysis, and generally save you time.\n\nHopefully in the time it took you to read the above, your analysis is finished. Let’s jump right\ninto analyzing the GUI and starting to use our workflow.\n\n## GUI Overview\n\nAfter all the analysis is completed, you should be presented with the business end of Ghidra,\nit’s GUI. Take in the Windows 95 era Java Swing GUI, and remember a time when you could\nhot-patch the page fault handler without the Windows kernel immediately labeling you as a\nmalcontent.\n\n\n-----\n\n_Figure 4: First view of the GUI with annotations._ _Clean version without the annotations can_\n_be found here_\n\n## Enable Entropy Visualization\n\nThis is a cool trick that saved me a lot of time. Enable entropy visualization. Click the drop\ndown menu on the top right of the Listing view, and select “Show Entropy.”\n\n_Figure 5: Click the pulldown to enable entropy visualization_\n\n\n-----\n\nEntropy, or the measure of randomness is useful for identifying encrypted or compressed\nportions of the executable. This is probably a good time for you to learn some math if you’re\nnot already familiar. [Wikipedia provides a good overview of Entropy if you’re into that sort of](https://en.wikipedia.org/wiki/Entropy_(information_theory))\nthing. All you need to know is that the higher the entropy (red in this case) means that there\nis likely a compressed, or encrypted blob of data. Goal 4 of our analysis goals is to extract\nthe compressed JavaScript, so this is a good place to start looking.\n\nEntropy does not always mean compressed or encoded data, nor does it mean that all\nencoded or compressed data is high entropy. All things being equal, it does mean something\nyou should take a look at. In general, it’s a good place to start looking and I appreciate that\nGhidra includes this as a default option.\n\n_Figure 6: The code listing with the high-entropy portions_\n\n## Analysis: Find the Embedded Code Part 1 - A Failure\n\nNow that we have a good entropy visualization, let’s try and take a shortcut to finding the\ncompressed code.\n\n## Inspect the High Entropy Areas\n\n\n-----\n\nIf you click next to the red area in the executable, you should see a reference to the entropy\nbeing somewhere close to 8 in the tool-tip pop up. Select as close to the top as you can, then\nscroll the code view up until you see references to functions. Why functions? Because the\naddress cross-references (XREFs) can contain random data, and not necessarily what\nyou’re looking for. Code references are where the executable is looking at that specific\naddress. From here we will inspect all of the XREFs and look for anything that looks like\nencryption.\n\nWhat does encryption code look like? This is a hard question. One way to answer that is to\ncompile a bunch of encryption reference code, and look at what code is generated. In the\nend a couple of rules-of-thumb apply:\n\n## How to find encoding, encryption, and obfuscation the hard way\n\n1. Is there an xor with differing operands? `xor eax, 0x42 would be an example, and`\n```\n   xor eax, eax would not.\n\n```\n2. Are there lots of shift instructions in the same code? The `shl and` `shr instructions`\n\nbeing the most notable\n3. There’s a noticeable loop structure\n4. Data is modified, and stored somewhere else in the program\n\nWith an eye on those details, I will inspect each of the listed cross references to see if I can\ninfer what the compressed code is.\n\nThe first reference occurs at address 0x100f56f9 inside of FUN_100f56b0, and is a good\nexample of what we are not looking for.\n\n\n-----\n\n_Figure 7: FUN_100f56b0 assembly view and its decompilation_\n\n## Rename Global Variables and Functions Using ADD\n\nThe first thing to do is to change the name of `DAT_104af3ed to something more noticeable.`\n[Since reverse engineering is all about abductive reasoning, I’m going to assume (abduct)](https://en.wikipedia.org/wiki/Abductive_reasoning)\nthat this is compressed or encrypted code. If any facts present themselves that contradict\nthis assumption, I will modify my assumption and subsequently change the variable name to\nmatch my new assumption. Abductive reasoning is a good lifestyle choice, but that’s a highly\npersonal matter. In the grand effort to increase global information entropy, confusion, and\nmake a slightly offensive joke I call it Abductive Data Describer (ADD) workflow.\n\n## Gaze Upon the Magnificence of the Decompiler\n\nYou should notice that the decompilation window now has code in it. You may also notice\nthat there are no `goto s in this code. Further inspection will reveal that aside from`\nautomatically assigned labels, the code looks more or less reasonable. When I first reversed\n[Gootkit with Ghidra and saw this decompilation, I had a very Jodie Foster in Contact moment](https://www.youtube.com/watch?v=RHBPnmXBm0g)\nwhen I first saw the decompiler working. Decompiler quality is informally judged by how\nmany `goto s produced instead of the more common if/else/switch/throw/catch statements.`\nC and C++ developers are threatened from birth against using `goto s, except in some very`\nnarrow circumstances, so a decompiler using them is akin to taking a shortcut. In practice I\nhave found that once you fully fill out the types of all the variables, the decompiler outputs\nlegible C code. Programming idioms and patterns matter, so it’s a good idea to study them.\n\nLet’s rename a variable using our ADD workflow:\n\n\n-----\n\n_Figure 8: Rename the variable pointing to the high-entropy code to something more_\n_descriptive_\n\n## Rename your Functions\n\nThis function is most likely not what we are looking for, however we have invested some time\nin looking at it. It’s a good idea to rename the function any time you have a high-level\nconcept you’re looking for. My names tend to be pretty descriptive, and describe both my\nconfidence in and the contents of the function. I use uncertain names like\n```\nsome_xors_and_bitshifts to imply how much time I’ve spent on it. Later I’ll change it to\n\n```\nsomething more specific if I spend more time on it, like `high_entropy_flag_mod() and`\nactually know what it’s function is.\n\nThere is no xor instructions, and there is no loop. Likely this is a helper function that is\nlooking at the flags of the data. It’s a good idea to rename functions with your best guess\n(ADD), so I’m going to do that. I’ve also relabeled this function as\n```\nhigh_entropy_flag_mod() .\n\n```\n\n-----\n\n## Rename your variables\n\nIf you figure out the types used in a code sample, you can redefine those as well using\n```\nCTRL-L, or right-clicking and selecting ‘Retype Variable’. The more correct information you\n\n```\nprovide about the types, the more accurate the decompiler output will be.\n\nNext function! To get back to the data view, click the left arrow button until you see the view\nagain. This works similar to the `escape key in IDA and Binary Ninja. If you renamed the`\nfunction, your listing should look like this:\n\n_Figure 8: The updated code listing once you have renamed the referencing function_\n\nNotice that all but one of the functions has been renamed, reducing how many functions you\nneed to analyze. There is only one remaining, `FUN100f7680 and it bears inspection. The`\ndecompiler shows that a lot of our encryption qualifications are met: xors, bit shifting, and\neven a `do {} while () loop! Upon further inspection, the only xor in the code is at the`\nvery top of the function. This is a trick that Visual Studio uses to prevent stack based buffer\noverflows called a Canary. If you see an xor at the beginning of a function, this is most likely\nwhat it is. Similarly, there will be a subsequent function call that reverses the process, and\nexits the program.\n\nFurther inspection of the function shows that this is just a flag checking algorithm inside of a\nloop. Rename the function (I used `high_entropy_loop_flag_check() ) and move on. A`\ngood next step is to look at the XREFs for the function, and look at the parent code. I only\nsaw one XREF `FUN_100f7bc0 so that is the next target.`\n\n## Inferring Functionality using API Calls\n\nThe first thing I noticed about `FUN_100f7bc0 are the API calls being made. These function`\ncalls give us an idea about what the program is being used for. Looking up API calls on\nMSDN will give you an idea about what the developer is doing.\n\n**API Call (MSDN)** **Typical Usage**\n\n[WaitForSingleObject](https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) Wait until the specified object is available or times out. Typically\nused to implement a Mutex, Semaphore, or other multiprocess\nprimitives\n\n\n-----\n\n**API Call (MSDN)** **Typical Usage**\n\n[MultiByteToWideChar](https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) Convert a multi-byte character to a ‘wide’ character. Unicode in\nWindows is full of pain and misery due to an early Windows\ndesign decision to ignore Unicode\n\n[WriteConsoleW](https://docs.microsoft.com/en-us/windows/console/writeconsole) Write a buffer to the console. The `W stands for ‘wide’. An` `A at`\nthe end would indicate an ascii string\n\n[GetLastError](https://msdn.microsoft.com/en-us/library/windows/desktop/ms679360.aspx) Why did my last function return an error? The Linux pattern is to\nuse `errno then bitteryly complain about reentrancy issues`\n\n_Table 1: A listing of API calls found in FUN_100f6bc0_\n\n## Conclusion: This is OpenSSL\n\nI quickly came to the realization that despite my initial hopes, this is not a decryption function.\nI follow a similar renaming process for all of the referenced functions, until everything is\nrenamed. This particular branch of code seems to focus on outputting data to the terminal.\n\nSometimes you win, and sometimes you lose. I figured out I was in the wrong area when I\nscrolled a bit further down in listing and saw this jump out at me:\n\nSince the implant portion of Gootkit is packaged Javascript with an embedded NodeJS\nserver, which uses OpenSSL, this is likely just a statically linked copy of the OpenSSL code.\nIn other words, a false lead.\n\n## Next Steps\n\nIn the next post, I will go over Ghidra’s binary diffing feature and see if it can help identify\nembedded libraries.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-03-23 - Reverse Engineering Gootkit with Ghidra Part I.pdf"
    ],
    "report_names": [
        "2019-03-23 - Reverse Engineering Gootkit with Ghidra Part I.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535574,
    "ts_updated_at": 1743041142,
    "ts_creation_date": 1653760119,
    "ts_modification_date": 1653760119,
    "files": {
        "pdf": "https://archive.orkl.eu/26ed2d457667e228ef3e7a8ccea76e86b27eb0f3.pdf",
        "text": "https://archive.orkl.eu/26ed2d457667e228ef3e7a8ccea76e86b27eb0f3.txt",
        "img": "https://archive.orkl.eu/26ed2d457667e228ef3e7a8ccea76e86b27eb0f3.jpg"
    }
}