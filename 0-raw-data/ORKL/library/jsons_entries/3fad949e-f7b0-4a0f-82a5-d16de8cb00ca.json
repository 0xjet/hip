{
    "id": "3fad949e-f7b0-4a0f-82a5-d16de8cb00ca",
    "created_at": "2023-01-12T15:03:13.220609Z",
    "updated_at": "2025-03-27T02:06:11.975389Z",
    "deleted_at": null,
    "sha1_hash": "a2bd6c5033df861de6d80ad9d9b96cf50f6f2577",
    "title": "2022-06-23 - The curious tale of a fake Carrier.app",
    "authors": "",
    "file_creation_date": "2022-07-02T23:19:24Z",
    "file_modification_date": "2022-07-02T23:19:24Z",
    "file_size": 1837887,
    "plain_text": "# The curious tale of a fake Carrier.app\n\n**googleprojectzero.blogspot.com/2022/06/curious-case-carrier-app.html**\n\nPosted by Ian Beer, Google Project Zero\n\nNOTE: This issue was CVE-2021-30983 was fixed in iOS 15.2 in December 2021.\n\nTowards the end of 2021 Google's Threat Analysis Group (TAG) shared an iPhone app with me:\n\nApp splash screen showing the Vodafone carrier logo and the text \"My Vodafone\" (not the legitimate Vodadone app)\n\n[Although this looks like the real My Vodafone carrier app available in the App Store, it didn't come from the App Store and is not the real](https://apps.apple.com/gb/app/my-vodafone/id370901726)\napplication from Vodafone. TAG suspects that a target receives a link to this app in an SMS, after the attacker asks the carrier to disable the\ntarget's mobile data connection. The SMS claims that in order to restore mobile data connectivity, the target must install the carrier app and\nincludes a link to download and install this fake app.\n\nThis sideloading works because the app is signed with an enterprise certificate, which can be purchased for $299 via the Apple Enterprise\ndeveloper program. This program allows an eligible enterprise to obtain an Apple-signed embedded.mobileprovision file with the\nProvisionsAllDevices key set. An app signed with the developer certificate embedded within that mobileprovision file can be sideloaded on\nany iPhone, bypassing Apple's App Store review process. While we understand that the Enterprise developer program is designed for\ncompanies to push \"trusted apps\" to their staff's iOS devices, in this case, it appears that it was being used to sideload this fake carrier app.\n\n[In collaboration with Project Zero, TAG has published an additional post with more details around the targeting and the actor. The rest of this](https://blog.google/threat-analysis-group/italian-spyware-vendor-targets-users-in-italy-and-kazakhstan/)\nblogpost is dedicated to the technical analysis of the app and the exploits contained therein.\n\n## App structure\n\nThe app is broken up into multiple frameworks. InjectionKit.framework is a generic privilege escalation exploit wrapper, exposing the\nprimitives you'd expect (kernel memory access, entitlement injection, amfid bypasses) as well as higher-level operations like app installation,\nfile creation and so on.\n\n\n-----\n\nAgent.framework is partially obfuscated but, as the name suggests, seems to be a basic agent able to find and exfiltrate interesting files from\nthe device like the Whatsapp messages database.\n\nSix privilege escalation exploits are bundled with this app. Five are well-known, publicly available N-day exploits for older iOS versions. The\nsixth is not like those others at all.\n\nThis blog post is the story of the last exploit and the month-long journey to understand it.\n\n## Something's missing? Or am I missing something?\n\nAlthough all the exploits were different, five of them shared a common high-level structure. An initial phase where the kernel heap was\nmanipulated to control object placement. Then the triggering of a kernel vulnerability followed by well-known steps to turn that into something\nuseful, perhaps by disclosing kernel memory then building an arbitrary kernel memory write primitive.\n\nThe sixth exploit didn't have anything like that.\n\n[Perhaps it could be triggering a kernel logic bug like Linuz Henze's Fugu14 exploit, or a very bad memory safety issue which gave fairly direct](https://github.com/LinusHenze/Fugu14)\nkernel memory access. But neither of those seemed very plausible either. It looked, quite simply, like an iOS kernel exploit from a decade\nago, except one which was first quite carefully checking that it was only running on an iPhone 12 or 13.\n\nIt contained log messages like:\n\nprintf(\"Failed to prepare fake vtable: 0x%08x\", ret);\n\nwhich seemed to happen far earlier than the exploit could possibly have defeated mitigations like KASLR and PAC.\n\nShortly after that was this log message:\n\nprintf(\"Waiting for R/W primitives...\");\n\nWhy would you need to wait?\n\nThen shortly after that:\n\nprintf(\"Memory read/write and callfunc primitives ready!\");\n\nUp to that point the exploit made only four IOConnectCallMethod calls and there were no other obvious attempts at heap manipulation. But\nthere was another log message which started to shed some light:\n\nprintf(\"Unexpected data read from DCP: 0x%08x\", v49);\n\n## DCP?\n\nIn October 2021 Adam Donenfeld tweeted this:\n\n\n-----\n\nDCP is the \"Display Co-Processor\" which ships with iPhone 12 and above and all M1 Macs.\n\n[There's little public information about the DCP; the most comprehensive comes from the Asahi linux project which is porting linux to M1 Macs.](https://asahilinux.org/)\nIn their [August 2021 and](https://asahilinux.org/2021/08/progress-report-august-2021/) [September 2021 updates they discussed their DCP reverse-engineering efforts and the open-source DCP client](https://asahilinux.org/2021/10/progress-report-september-2021/)\nwritten by [@alyssarzg. Asahi describe the DCP like this:](https://twitter.com/alyssarzg)\n\nOn most mobile SoCs, the display controller is just a piece of hardware with simple registers. While this is true on the M1 as well, Apple\ndecided to give it a twist. They added a coprocessor to the display engine (called DCP), which runs its own firmware (initialized by the system\nbootloader), and moved most of the display driver into the coprocessor. But instead of doing it at a natural driver boundary… they took half of\ntheir macOS C++ driver, moved it into the DCP, and created a remote procedure call interface so that each half can call methods on C++\nobjects on the other CPU!\n\n[https://asahilinux.org/2021/08/progress-report-august-2021/](https://asahilinux.org/2021/08/progress-report-august-2021/)\n\nThe Asahi linux project reverse-engineered the API to talk to the DCP but they are restricted to using Apple's DCP firmware (loaded by iBoot)\n\n- they can't use a custom DCP firmware. Consequently their documentation is limited to the DCP RPC API with few details of the DCP\ninternals.\n\n## Setting the stage\n\nBefore diving into DCP internals it's worth stepping back a little. What even is a co-processor in a modern, highly integrated SoC (System-ona-Chip) and what might the consequences of compromising it be?\n\nYears ago a co-processor would likely have been a physically separate chip. Nowadays a large number of these co-processors are integrated\nalong with their interconnects directly onto a single die, even if they remain fairly independent systems. We can see in this M1 die shot from\n[Tech Insights that the CPU cores in the middle and right hand side take up only around 10% of the die:](https://www.techinsights.com/blog/two-new-apple-socs-two-market-events-apple-a14-and-m1)\n\n\n-----\n\nM1 die-shot from techinsights.com with possible location of DCP added\n\n[https://www.techinsights.com/blog/two-new-apple-socs-two-market-events-apple-a14-and-m1](https://www.techinsights.com/blog/two-new-apple-socs-two-market-events-apple-a14-and-m1)\n\n[Companies like SystemPlus perform](https://www.systemplus.fr/) [very thorough analysis of these dies. Based on their analysis the DCP is likely the rectangular region](https://www.systemplus.fr/wp-content/uploads/2020/12/SP20608-Apple-M1-System-on-Chip-Sample.pdf)\nindicated on this M1 die. It takes up around the same amount of space as the four high-efficiency cores seen in the centre, though it seems to\nbe mostly SRAM.\n\nWith just this low-resolution image it's not really possible to say much more about the functionality or capabilities of the DCP and what level of\nsystem access it has. To answer those questions we'll need to take a look at the firmware.\n\n## My kingdom for a .dSYM!\n\nThe first step is to get the DCP firmware image. iPhones (and now M1 macs) use .ipsw files for system images. An .ipsw is really just a\n.zip archive and the Firmware/ folder in the extracted .zip contains all the firmware for the co-processors, modems etc. The DCP firmware is\nthis file:\n\nFirmware/dcp/iphone13dcp.im4p\n\nThe im4p in this case is just a 25 byte header which we can discard:\n\n$ dd if=iphone13dcp.im4p of=iphone13dcp bs=25 skip=1\n\n$ file iphone13dcp\n\niphone13dcp: Mach-O 64-bit preload executable arm64\n\nIt's a Mach-O! Running nm -a to list all symbols shows that the binary has been fully stripped:\n\n$ nm -a iphone13dcp\n\n\n-----\n\niphone13dcp: no symbols\n\nFunction names make understanding code significantly easier. From looking at the handful of strings in the exploit some of them looked like\nthey might be referencing symbols in a DCP firmware image (\"M3_CA_ResponseLUT read: 0x%08x\" for example) so I thought perhaps there\nmight be a DCP firmware image where the symbols hadn't been stripped.\n\nSince the firmware images are distributed as .zip files and Apple's servers support range requests with a bit of python and the\n[partialzip tool we can relatively easily and quickly get every beta and release DCP firmware. I checked over 300 distinct images; every single](https://github.com/marcograss/partialzip)\none was stripped.\n\nGuess we'll have to do this the hard way!\n\n## Day 1; Instruction 1\n\n$ otool -h raw_fw/iphone13dcp\n\nraw_fw/iphone13dcp:\n\nMach header\n\nmagic   cputype  cpusubtype caps filetype ncmds sizeofcmds flags\n\n0xfeedfacf 0x100000C 0     0x00 5    5   2240    0x00000001\n\nThat cputype is plain arm64 (ArmV8) without pointer authentication support. The binary is fairly large (3.7MB) and IDA's autoanalysis detects\nover 7000 functions.\n\nWith any brand new binary I usually start with a brief look through the function names and the strings. The binary is stripped so there are no\nfunction name symbols but there are plenty of C++ function names as strings:\n\nThe cross-references to those strings look like this:\n\nlog(0x40000001LL,\n\n\"UPBlock_ALSS.cpp\",\n\n341,\n\n\"%s: capture buffer exhausted, aborting capture\\n\",\n\n\"void IOMFB::UPBlock_ALSS::send_data(uint64_t, uint32_t)\");\n\nThis is almost certainly a logging macro which expands __FILE__, __LINE__ and __PRETTY_FUNCTION__. This allows us to start\nrenaming functions and finding vtable pointers.\n\n## Object structure\n\nFrom the Asahi linux blog posts we know that the DCP is using an Apple-proprietary RTOS called RTKit for which there is very little public\ninformation. There are some strings in the binary with the exact version:\n\n\n-----\n\nADD X8, X8, #aLocalIphone13d@PAGEOFF ; local iphone13dcp.release\n\nADD X9, X9, #aRtkitIos182640@PAGEOFF ; \"RTKit_iOS-1826.40.9.debug\"\n\nThe code appears to be predominantly C++. There appear to be multiple C++ object hierarchies; those involved with this vulnerability look a\nbit like IOKit C++ objects. Their common base class looks like this:\n\nstruct __cppobj RTKIT_RC_RTTI_BASE\n\n{\n\nRTKIT_RC_RTTI_BASE_vtbl *__vftable /*VFT*/;\n\nuint32_t refcnt;\n\nuint32_t typeid;\n\n};\n\n(These structure definitions are in the format IDA uses for C++-like objects)\n\nThe RTKit base class has a vtable pointer, a reference count and a four-byte Run Time Type Information (RTTI) field - a 4-byte ASCII\nidentifier like BLHA, WOLO, MMAP, UNPI, OSST, OSBO and so on. These identifiers look a bit cryptic but they're quite descriptive once you\nfigure them out (and I'll describe the relevant ones as we encounter them.)\n\nThe base type has the following associated vtable:\n\nstruct /*VFT*/ RTKIT_RC_RTTI_BASE_vtbl\n\n{\n\nvoid (__cdecl *take_ref)(RTKIT_RC_RTTI_BASE *this);\n\nvoid (__cdecl *drop_ref)(RTKIT_RC_RTTI_BASE *this);\n\nvoid (__cdecl *take_global_type_ref)(RTKIT_RC_RTTI_BASE *this);\n\nvoid (__cdecl *drop_global_type_ref)(RTKIT_RC_RTTI_BASE *this);\n\nvoid (__cdecl *getClassName)(RTKIT_RC_RTTI_BASE *this);\n\nvoid (__cdecl *dtor_a)(RTKIT_RC_RTTI_BASE *this);\n\nvoid (__cdecl *unk)(RTKIT_RC_RTTI_BASE *this);\n\n};\n\n## Exploit flow\n\nThe exploit running in the app starts by opening an IOKit user client for the AppleCLCD2 service. AppleCLCD seems to be the application\nprocessor of IOMobileFrameBuffer and AppleCLCD2 the DCP version.\n\nThe exploit only calls 3 different external method selectors on the AppleCLCD2 user client: 68, 78 and 79.\n\nThe one with the largest and most interesting-looking input is 78, which corresponds to this user client method in the kernel driver:\n\n\n-----\n\nIOReturn\n\nIOMobileFramebufferUserClient::s_set_block(\n\nIOMobileFramebufferUserClient *this,\n\nvoid *reference,\n\nIOExternalMethodArguments *args)\n\n{\n\nconst unsigned __int64 *extra_args;\n\nu8 *structureInput;\n\nstructureInput = args->structureInput;\n\nif ( structureInput && args->scalarInputCount >= 2 )\n\n{\n\nif ( args->scalarInputCount == 2 )\n\nextra_args = 0LL;\n\nelse\n\nextra_args = args->scalarInput + 2;\n\nreturn this->framebuffer_ap->set_block_dcp(\n\nthis->task,\n\nargs->scalarInput[0],\n\nargs->scalarInput[1],\n\nextra_args,\n\nargs->scalarInputCount - 2,\n\nstructureInput,\n\nargs->structureInputSize);\n\n} else {\n\nreturn 0xE00002C2;\n\n}\n\n}\n\nthis unpacks the IOConnectCallMethod arguments and passes them to:\n\nIOMobileFramebufferAP::set_block_dcp(\n\nIOMobileFramebufferAP *this,\n\ntask *task,\n\nint first_scalar_input,\n\nint second_scalar_input,\n\nconst unsigned __int64 *pointer_to_remaining_scalar_inputs,\n\nunsigned int scalar_input_count_minus_2,\n\nconst unsigned __int8 *struct_input,\n\nunsigned __int64 struct_input_size)\n\n\n-----\n\nThis method uses some autogenerated code to serialise the external method arguments into a buffer like this:\n\narg_struct:\n\n{\n\nstruct task* task\n\nu64 scalar_input_0\n\nu64 scalar_input_1\n\nu64[] remaining_scalar_inputs\n\nu64 cntExtraScalars\n\nu8[] structInput\n\nu64 CntStructInput\n\n}\n\nwhich is then passed to UnifiedPipeline2::rpc along with a 4-byte ASCII method identifier ('A435' here):\n\nUnifiedPipeline2::rpc(\n\n'A435',\n\narg_struct,\n\n0x105Cu,\n\n&retval_buf,\n\n4u);\n\nUnifiedPipeline2::rpc calls DCPLink::rpc which calls AppleDCPLinkService::rpc to perform one more level of serialisation which packs the\nmethod identifier and a \"stream identifier\" together with the arg_struct shown above.\n\nAppleDCPLinkService::rpc then calls rpc_caller_gated to allocate space in a shared memory buffer, copy the buffer into there then signal to\nthe DCP that a message is available.\n\nEffectively the implementation of the IOMobileFramebuffer user client has been moved on to the DCP and the external method interface is\nnow a proxy shim, via shared memory, to the actual implementations of the external methods which run on the DCP.\n\n## Exploit flow: the other side\n\nThe next challenge is to find where the messages start being processed on the DCP. Looking through the log strings there's a function which\nis clearly called ​​rpc_callee_gated - quite likely that's the receive side of the function rpc_caller_gated we saw earlier.\n\nrpc_callee_gated unpacks the wire format then has an enormous switch statement which maps all the 4-letter RPC codes to function\npointers:\n\n\n-----\n\nswitch ( rpc_id )\n\n{\n\ncase 'A000':\n\ngoto LABEL_146;\n\ncase 'A001':\n\nhandler_fptr = callback_handler_A001;\n\nbreak;\n\ncase 'A002':\n\nhandler_fptr = callback_handler_A002;\n\nbreak;\n\ncase 'A003':\n\nhandler_fptr = callback_handler_A003;\n\nbreak;\n\ncase 'A004':\n\nhandler_fptr = callback_handler_A004;\n\nbreak;\n\ncase 'A005':\n\nhandler_fptr = callback_handler_A005;\n\nbreak;\n\nAt the the bottom of this switch statement is the invocation of the callback handler:\n\nret = handler_fptr(\n\nmeta,\n\nin_struct_ptr,\n\nin_struct_size,\n\nout_struct_ptr,\n\nout_struct_size);\n\nin_struct_ptr points to a copy of the serialised IOConnectCallMethod arguments we saw being serialized earlier on the application processor:\n\n\n-----\n\narg_struct:\n\n{\n\nstruct task* task\n\nu64 scalar_input_0\n\nu64 scalar_input_1\n\nu64[] remaining_scalar_inputs\n\nu32 cntExtraScalars\n\nu8[] structInput\n\nu64 cntStructInput\n\n}\n\nThe callback unpacks that buffer and calls a C++ virtual function:\n\n\n-----\n\nunsigned int\n\ncallback_handler_A435(\n\nu8* meta,\n\nvoid *args,\n\nuint32_t args_size,\n\nvoid *out_struct_ptr,\n\nuint32_t out_struct_size\n\n{\n\nint64 instance_id;\n\nuint64_t instance;\n\nint err;\n\nint retval;\n\nunsigned int result;\n\ninstance_id = meta->instance_id;\n\ninstance =\n\nglobal_instance_table[instance_id].IOMobileFramebufferType;\n\nif ( !instance ) {\n\nlog_fatal(\n\n\"IOMFB: %s: no instance for instance ID: %u\\n\",\n\n\"static T *IOMFB::InstanceTracker::instance\"\n\n\"(IOMFB::InstanceTracker::tracked_entity_t, uint32_t)\"\n\n\" [T = IOMobileFramebuffer]\",\n\ninstance_id);\n\n}\n\nerr = (instance-16)->vtable_0x378( // virtual call\n\n(instance-16),\n\nargs->task,\n\nargs->scalar_input_0,\n\nargs->scalar_input_1,\n\nargs->remaining_scalar_inputs,\n\nargs->cntExtraScalars,\n\nargs->structInput,\n\nargs->cntStructInput);\n\nretval = convert_error(err);\n\nresult = 0;\n\n*(_DWORD *)out_struct_ptr = retval;\n\nreturn result;\n\n}\n\n\n-----\n\nThe challenge here is to figure out where that virtual call goes. The object is being looked up in a global table based on the instance id. We\ncan't just set a breakpoint and whilst emulating the firmware is probably possible that would likely be a long project in itself. I took a hackier\napproach: we know that the vtable needs to be at least 0x380 bytes large so just go through all those vtables, decompile them and see if the\nprototypes look reasonable!\n\nThere's one clear match in the vtable for the UNPI type:\n\nUNPI::set_block(\n\nUNPI* this,\n\nstruct task* caller_task_ptr,\n\nunsigned int first_scalar_input,\n\nint second_scalar_input,\n\nint *remaining_scalar_inputs,\n\nuint32_t cnt_remaining_scalar_inputs,\n\nuint8_t *structure_input_buffer,\n\nuint64_t structure_input_size)\n\nHere's my reversed implementation of UNPI::set_block\n\n\n-----\n\nUNPI::set_block(\n\nUNPI* this,\n\nstruct task* caller_task_ptr,\n\nunsigned int first_scalar_input,\n\nint second_scalar_input,\n\nint *remaining_scalar_inputs,\n\nuint32_t cnt_remaining_scalar_inputs,\n\nuint8_t *structure_input_buffer,\n\nuint64_t structure_input_size)\n\n{\n\nstruct block_handler_holder *holder;\n\nstruct metadispatcher metadisp;\n\nif ( second_scalar_input )\n\nreturn 0x80000001LL;\n\nholder = this->UPPipeDCP_H13P->block_handler_holders;\n\nif ( !holder )\n\nreturn 0x8000000BLL;\n\nmetadisp.address_of_some_zerofill_static_buffer = &unk_3B8D18;\n\nmetadisp.handlers_holder = holder;\n\nmetadisp.structure_input_buffer = structure_input_buffer;\n\nmetadisp.structure_input_size = structure_input_size;\n\nmetadisp.remaining_scalar_inputs = remaining_scalar_inputs;\n\nmetadisp.cnt_remaining_sclar_input = cnt_remaining_scalar_inputs;\n\nmetadisp.some_flags = 0x40000000LL;\n\nmetadisp.dispatcher_fptr = a_dispatcher;\n\nmetadisp.offset_of_something_which_looks_serialization_related = &off_1C1308;\n\nreturn metadispatch(holder, first_scalar_input, 1, caller_task_ptr, structure_input_buffer, &metadisp, 0);\n\n}\n\nThis method wraps up the arguments into another structure I've called metadispatcher:\n\n\n-----\n\nstruct __attribute__((aligned(8))) metadispatcher\n\n{\n\nuint64_t address_of_some_zerofill_static_buffer;\n\nuint64_t some_flags;\n\n__int64 (__fastcall *dispatcher_fptr)(struct metadispatcher *, struct BlockHandler *, __int64, _QWORD);\n\nuint64_t offset_of_something_which_looks_serialization_related;\n\nstruct block_handler_holder *handlers_holder;\n\nuint64_t structure_input_buffer;\n\nuint64_t structure_input_size;\n\nuint64_t remaining_scalar_inputs;\n\nuint32_t cnt_remaining_sclar_input;\n\n};\n\nThat metadispatcher object is then passed to this method:\n\nreturn metadispatch(holder, first_scalar_input, 1, caller_task_ptr, structure_input_buffer, &metadisp, 0);\n\nIn there we reach this code:\n\nblock_type_handler = lookup_a_handler_for_block_type_and_subtype(\n\na1,\n\nfirst_scalar_input, // block_type\n\na3);        // subtype\n\nThe exploit calls this set_block external method twice, passing two different values for first_scalar_input, 7 and 19. Here we can see that\nthose correspond to looking up two different block handler objects here.\n\nThe lookup function searches a linked list of block handler structures; the head of the list is stored at offset 0x1448 in the\nUPPipeDCP_H13P object and registered dynamically by a method I've named add_handler_for_block_type:\n\nadd_handler_for_block_type(struct block_handler_holder *handler_list,\n\nstruct BlockHandler *handler)\n\nThe logging code tells us that this is in a file called IOMFBBlockManager.cpp. IDA finds 44 cross-references to this method, indicating that\nthere are probably that many different block handlers. The structure of each registered block handler is something like this:\n\n\n-----\n\nstruct __cppobj BlockHandler : RTKIT_RC_RTTI_BASE\n\n{\n\nuint64_t field_16;\n\nstruct handler_inner_types_entry *inner_types_array;\n\nuint32_t n_inner_types_array_entries;\n\nuint32_t field_36;\n\nuint8_t can_run_without_commandgate;\n\nuint32_t block_type;\n\nuint64_t list_link;\n\nuint64_t list_other_link;\n\nuint32_t some_other_type_field;\n\nuint32_t some_other_type_field2;\n\nuint32_t expected_structure_io_size;\n\nuint32_t field_76;\n\nuint64_t getBlock_Impl;\n\nuint64_t setBlock_Impl;\n\nuint64_t field_96;\n\nuint64_t back_ptr_to_UPPipeDCP_H13P;\n\n};\n\nThe RTTI type is BLHA (BLock HAndler.)\n\nFor example, here's the codepath which builds and registers block handler type 24:\n\n\n-----\n\nBLHA_24 = (struct BlockHandler *)CXXnew(112LL);\n\nBLHA_24->__vftable = (BlockHandler_vtbl *)BLHA_super_vtable;\n\nBLHA_24->block_type = 24;\n\nBLHA_24->refcnt = 1;\n\nBLHA_24->can_run_without_commandgate = 0;\n\nBLHA_24->some_other_type_field = 0LL;\n\nBLHA_24->expected_structure_io_size = 0xD20;\n\ntypeid = typeid_BLHA();\n\nBLHA_24->typeid = typeid;\n\nmodify_typeid_ref(typeid, 1);\n\nBLHA_24->__vftable = vtable_BLHA_subclass_type_24;\n\nBLHA_24->inner_types_array = 0LL;\n\nBLHA_24->n_inner_types_array_entries = 0;\n\nBLHA_24->getBlock_Impl = BLHA_24_getBlock_Impl;\n\nBLHA_24->setBlock_Impl = BLHA_24_setBlock_Impl;\n\nBLHA_24->field_96 = 0LL;\n\nBLHA_24->back_ptr_to_UPPipeDCP_H13P = a1;\n\nadd_handler_for_block_type(list_holder, BLHA_24);\n\nEach block handler optionally has getBlock_Impl and setBlock_Impl function pointers which appear to implement the actual setting and\ngetting operations.\n\nWe can go through all the callsites which add block handlers; tell IDA the type of the arguments and name all the getBlock and\nsetBlock implementations:\n\n\n-----\n\nYou can perhaps see where this is going: that s looking like really quite a lot of reachable attack surface! Each of those\nsetBlock_Impl functions is reachable by passing a different value for the first scalar argument to IOConnectCallMethod 78.\n\nThere's a little bit more reversing though to figure out how exactly to get controlled bytes to those setBlock_Impl functions:\n\n## Memory Mapping\n\nThe raw \"block\" input to each of those setBlock_Impl methods isn't passed inline in the IOConnectCallMethod structure input. There's another\nlevel of indirection: each individual block handler structure has an array of supported \"subtypes\" which contains metadata detailing where to\nfind the (userspace) pointer to that subtype's input data in the IOConnectCallMethod structure input. The first dword in the structure input is\nthe id of this subtype - in this case for the block handler type 19 the metadata array has a single entry:\n\n<2, 0, 0x5F8, 0x600>\n\nThe first value (2) is the subtype id and 0x5f8 and 0x600 tell the DCP from what offset in the structure input data to read a pointer and size\nfrom. The DCP then requests a memory mapping from the AP for that memory from the calling task:\n\nreturn wrap_MemoryDescriptor::withAddressRange(\n\n*(void*)(structure_input_buffer + addr_offset),\n\n*(unsigned int *)(structure_input_buffer + size_offset),\n\ncaller_task_ptr);\n\nWe saw earlier that the AP sends the DCP the struct task pointer of the calling task; when the DCP requests a memory mapping from a user\ntask it sends those raw task struct pointers back to the AP such that the kernel can perform the mapping from the correct task. The memory\nmapping is abstracted as an MDES object on the DCP side; the implementation of the mapping involves the DCP making an RPC to the AP:\n\nmake_link_call('D453', &req, 0x20, &resp, 0x14);\n\nwhich corresponds to a call to this method on the AP side:\n\nIOMFB::MemDescRelay::withAddressRange(unsigned long long, unsigned long long, unsigned int, task*, unsigned long*, unsigned long long*)\n\nThe DCP calls ::prepare and ::map on the returned MDES object (exactly like an IOMemoryDescriptor object in IOKit), gets the mapped\npointer and size to pass via a few final levels of indirection to the block handler:\n\na_descriptor_with_controlled_stuff->dispatcher_fptr(\n\na_descriptor_with_controlled_stuff,\n\nblock_type_handler,\n\nimportant_ptr,\n\nimportant_size);\n\nwhere the dispatcher_fptr looks like this:\n\n\n-----\n\na_dispatcher(\n\nstruct metadispatcher *disp,\n\nstruct BlockHandler *block_handler,\n\n__int64 controlled_ptr,\n\nunsigned int controlled_size)\n\n{\n\nreturn block_handler->BlockHandler_setBlock(\n\nblock_handler,\n\ndisp->structure_input_buffer,\n\ndisp->structure_input_size,\n\ndisp->remaining_scalar_inputs,\n\ndisp->cnt_remaining_sclar_input,\n\ndisp->handlers_holder->gate,\n\ncontrolled_ptr,\n\ncontrolled_size);\n\n}\n\nYou can see here just how useful it is to keep making structure definitions while reversing; there are so many levels of indirection that it's\npretty much impossible to keep it all in your head.\n\nBlockHandler_setBlock is a virtual method on BLHA. This is the implementation for BLHA 19:\n\nBlockHandler19::setBlock(\n\nstruct BlockHandler *this,\n\nvoid *structure_input_buffer,\n\nint64 structure_input_size,\n\nint64 *remaining_scalar_inputs,\n\nunsigned int cnt_remaining_scalar_inputs,\n\nstruct CommandGate *gate,\n\nvoid* mapped_mdesc_ptr,\n\nunsigned int mapped_mdesc_length)\n\nThis uses a Command Gate (GATI) object (like a call gate in IOKit to serialise calls) to finally get close to actually calling the setBlock_Impl\nfunction.\n\nWe need to reverse the gate_context structure to follow the controlled data through the gate:\n\n\n-----\n\nstruct __attribute__((aligned(8))) gate_context\n\n{\n\nstruct BlockHandler *the_target_this;\n\nuint64_t structure_input_buffer;\n\nvoid *remaining_scalar_inputs;\n\nuint32_t cnt_remaining_scalar_inputs;\n\nuint32_t field_28;\n\nuint64_t controlled_ptr;\n\nuint32_t controlled_length;\n\n};\n\nThe callgate object uses that context object to finally call the BLHA setBlock handler:\n\ncallback_used_by_callgate_in_block_19_setBlock(\n\nstruct UnifiedPipeline *parent_pipeline,\n\nstruct gate_context *context,\n\nint64 a3,\n\nint64 a4,\n\nint64 a5)\n\n{\n\nreturn context->the_target_this->setBlock_Impl)(\n\ncontext->the_target_this->back_ptr_to_UPPipeDCP_H13P,\n\ncontext->structure_input_buffer,\n\ncontext->remaining_scalar_inputs,\n\ncontext->cnt_remaining_scalar_inputs,\n\ncontext->controlled_ptr,\n\ncontext->controlled_length);\n\n}\n\n## SetBlock_Impl\n\nAnd finally we've made it through the whole callstack following the controlled data from IOConnectCallMethod in userspace on the AP to the\nsetBlock_Impl methods on the DCP!\n\nThe prototype of the setBlock_Impl methods looks like this:\n\n\n-----\n\nsetBlock_Impl(struct UPPipeDCP_H13P *pipe_parent,\n\nvoid *structure_input_buffer,\n\nint *remaining_scalar_inputs,\n\nint cnt_remaining_scalar_inputs,\n\nvoid* ptr_via_memdesc,\n\nunsigned int len_of_memdesc_mapped_buf)\n\nThe exploit calls two setBlock_Impl methods; 7 and 19. 7 is fairly simple and seems to just be used to put controlled data in a known location.\n19 is the buggy one. From the log strings we can tell that block type 19 handler is implemented in a file called UniformityCompensator.cpp.\n\n[Uniformity Compensation is a way to correct for inconsistencies in brightness and colour reproduction across a display panel. Block type 19](https://www.benq.com/en-us/knowledge-center/knowledge/screen-uniformity.html)\nsets and gets a data structure containing this correction information. The setBlock_Impl method calls UniformityCompensator::set and\nreaches the following code snippet where controlled_size is a fully-controlled u32 value read from the structure input and\nindirect_buffer_ptr points to the mapped buffer, the contents of which are also controlled:\n\nuint8_t* pages = compensator->inline_buffer; // +0x24\n\nfor (int pg_cnt = 0; pg_cnt < 3; pg_cnt++) {\n\nuint8_t* this_page = pages;\n\nfor (int i = 0; i < controlled_size; i++) {\n\nmemcpy(this_page, indirect_buffer_ptr, 4 * controlled_size);\n\nindirect_buffer_ptr += 4 * controlled_size;\n\nthis_page += 0x100;\n\n}\n\npages += 0x4000;\n\n}\n\nThere's a distinct lack of bounds checking on controlled_size. Based on the structure of the code it looks like it should be restricted to be less\nthan or equal to 64 (as that would result in the input being completely copied to the output buffer.) The compensator->inline_buffer buffer is\ninline in the compensator object. The structure of the code makes it look that that buffer is probably 0xc000 (three 16k pages) large. To verify\nthis we need to find the allocation site of this compensator object.\n\nIt's read from the pipe_parent object and we know that at this point pipe_parent is a UPPipeDCP_H13P object.\n\nThere's only one write to that field, here in UPPipeDCP_H13P::setup_tunables_base_target:\n\ncompensator = CXXnew(0xC608LL);\n\n...\n\nthis->compensator = compensator;\n\nThe compensator object is a 0xc608 byte allocation; the 0xc000 sized buffer starts at offset 0x24 so the allocation has enough space for\n0xc608-0x24=0xC5E4 bytes before corrupting neighbouring objects.\n\nThe structure input provided by the exploit for the block handler 19 setBlock call looks like this:\n\n\n-----\n\nstruct_input_for_block_handler_19[0x5F4] = 70; // controlled_size\n\nstruct_input_for_block_handler_19[0x5F8] = address;\n\nstruct_input_for_block_handler_19[0x600] = a_size;\n\nThis leads to a value of 70 (0x46) for controlled_size in the UniformityCompensator::set snippet shown earlier. (0x5f8 and 0x600 correspond\nto the offsets we saw earlier in the subtype's table: <2, 0, 0x5F8, 0x600>)\n\nThe inner loop increments the destination pointer by 0x100 each iteration so 0x46 loop iterations will write 0x4618 bytes.\n\nThe outer loop writes to three subsequent 0x4000 byte blocks so the third (final) iteration starts writing at 0x24 + 0x8000 and writes a total of\n0x4618 bytes, meaning the object would need to be 0xC63C bytes; but we can see that it's only 0xc608, meaning that it will overflow the\nallocation size by 0x34 bytes. The RTKit malloc implementation looks like it adds 8 bytes of metadata to each allocation so the next object\nstarts at 0xc610.\n\nHow much input is consumed? The input is fully consumed with no \"rewinding\" so it's 3*0x46*0x46*4 = 0xe5b0 bytes. Working backwards\nfrom the end of that buffer we know that the final 0x34 bytes of it go off the end of the 0xc608 allocation which means +0xe57c in the input\nbuffer will be the first byte which corrupts the 8 metadata bytes and +0x8584 will be the first byte to corrupt the next object:\n\nThis matches up exactly with the overflow object which the exploit builds:\n\nv24 = address + 0xE584;\n\nv25 = *(_DWORD *)&v54[48];\n\nv26 = *(_OWORD *)&v54[32];\n\nv27 = *(_OWORD *)&v54[16];\n\n*(_OWORD *)(address + 0xE584) = *(_OWORD *)v54;\n\n*(_OWORD *)(v24 + 16) = v27;\n\n*(_OWORD *)(v24 + 32) = v26;\n\n*(_DWORD *)(v24 + 48) = v25;\n\nThe destination object seems to be allocated very early and the DCP RTKit environment appears to be very deterministic with no ASLR.\nAlmost certainly they are attempting to corrupt a neighbouring C++ object with a fake vtable pointer.\n\n\n-----\n\nUnfortunately for our analysis the trail goes cold here and we can't fully recreate the rest of the exploit. The bytes for the fake DCP C++ object\nare read from a file in the app's temporary directory (base64 encoded inside a JSON file under the exploit_struct_offsets key) and I don't have\na copy of that file. But based on the flow of the rest of the exploit it's pretty clear what happens next:\n\n## sudo make me a DART mapping\n\nThe DCP, like other coprocessors on iPhone, sits behind a DART (Device Address Resolution Table.) This is like an SMMU (IOMMU in the\nx86 world) which forces an extra layer of physical address lookup between the DCP and physical memory. DART was covered in great detail\nin Gal Beniamini's Over The Air - Vol. 2, Pt. 3 blog post.\n\nThe DCP clearly needs to access lots of buffers owned by userspace tasks as well as memory managed by the kernel. To do this the DCP\nmakes RPC calls back to the AP which modifies the DART entries accordingly. This appears to be exactly what the DCP exploit does: the\nD45X family of DCP->AP RPC methods appear to expose an interface for requesting arbitrary physical as well as virtual addresses to be\nmapped into the DCP DART.\n\nThe fake C++ object is most likely a stub which makes such calls on behalf of the exploit, allowing the exploit to read and write kernel\nmemory.\n\n## Conclusions\n\nSegmentation and isolation are in general a positive thing when it comes to security. However, splitting up an existing system into separate,\nintercommunicating parts can end up exposing unexpected code in unexpected ways.\n\nWe've had discussions within Project Zero about whether this DCP vulnerability is interesting at all. After all, if the\nUniformityCompensator code was going to be running on the Application Processors anyway then the Display Co-Processor didn't really\nintroduce or cause this bug.\n\nWhilst that's true, it's also the case that the DCP certainly made exploitation of this bug significantly easier and more reliable than it would\nhave been on the AP. Apple has invested heavily in memory corruption mitigations over the last few years, so moving an attack surface from\na \"mitigation heavy\" environment to a \"mitigation light\" one is a regression in that sense.\n\nAnother perspective is that the DCP just isn't isolated enough; perhaps the intention was to try to isolate the code on the DCP such that even\nif it's compromised it's limited in the effect it could have on the entire system. For example, there might be models where the DCP to AP RPC\ninterface is much more restricted.\n\nBut again there's a tradeoff: the more restrictive the RPC API, the more the DCP code has to be refactored - a significant investment.\nCurrently, the codebase relies on being able to map arbitrary memory and the API involves passing userspace pointers back and forth.\n\nI've discussed in recent posts how attackers tend to be ahead of the curve. As the curve slowly shifts towards memory corruption exploitation\ngetting more expensive, attackers are likely shifting too. We saw that in the [logic-bug sandbox escape used by NSO and we see that here in](https://googleprojectzero.blogspot.com/2022/03/forcedentry-sandbox-escape.html)\nthis memory-corruption-based privilege escalation that side-stepped kernel mitigations by corrupting memory on a co-processor instead. Both\nare quite likely to continue working in some form in a post-memory tagging world. Both reveal the stunning depth of attack surface available\nto the motivated attacker. And both show that defensive security research still has a lot of work to do.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-06-23 - The curious tale of a fake Carrier.app.pdf"
    ],
    "report_names": [
        "2022-06-23 - The curious tale of a fake Carrier.app.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535793,
    "ts_updated_at": 1743041171,
    "ts_creation_date": 1656803964,
    "ts_modification_date": 1656803964,
    "files": {
        "pdf": "https://archive.orkl.eu/a2bd6c5033df861de6d80ad9d9b96cf50f6f2577.pdf",
        "text": "https://archive.orkl.eu/a2bd6c5033df861de6d80ad9d9b96cf50f6f2577.txt",
        "img": "https://archive.orkl.eu/a2bd6c5033df861de6d80ad9d9b96cf50f6f2577.jpg"
    }
}