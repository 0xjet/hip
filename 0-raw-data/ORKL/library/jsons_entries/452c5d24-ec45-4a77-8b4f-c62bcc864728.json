{
    "id": "452c5d24-ec45-4a77-8b4f-c62bcc864728",
    "created_at": "2023-01-12T15:00:05.698212Z",
    "updated_at": "2025-03-27T02:05:35.666814Z",
    "deleted_at": null,
    "sha1_hash": "5bd089c2b5a9c285464ca0fa3dec5e8f7e79798c",
    "title": "2018-08-20 - Interesting hidden threat since years -",
    "authors": "",
    "file_creation_date": "2022-05-28T17:54:07Z",
    "file_modification_date": "2022-05-28T17:54:07Z",
    "file_size": 537210,
    "plain_text": "# Interesting hidden threat since years ?\n\n**[marcoramilli.com/2018/08/20/interesting-hidden-threat-since-years/](https://marcoramilli.com/2018/08/20/interesting-hidden-threat-since-years/)**\n\nView all posts by marcoramilli August 20, 2018\n\nToday I’d like to share the following reverse engineering path since it ended up to be more\ncomplex respect what I thought. The full path took me about hours work and the sample\ncovers many obfuscation steps and implementation languages. During the analysis time only\nreally few Antivirus (6 out of 60) were able to “detect” the sample. Actually none really\ndetected it, but some AVs triggered “generic unwanted software” signature, without being\nable to really figure it out. As usually I am not going to show you who was able to detect it\ncompared to the one who wasn’t, since I wont ending on wrong a declarations such as (for\nexample): “Marco said that X is better than Y”. Anyway, having the hash file I believe it\nwould be enough to search for such information.\n\nAntiVirus Coverage\n\nThe Sample (SHA256:\ne5c67daef2226a9e042837f6fad5b338d730e7d241ae0786d091895b2a1b8681) presents\nitself as a JAR file. The first thought that you might have as experienced malware reverse\n\n\n-----\n\nengineer would be: Ok, another byte code reversing night, easy.. just put focus and debug\non it…”. BUT surprisingly when you decompile the sample you read the following class !\n\nStage1: JAR invoking JavaScript\n\nA Java Method that invokes (through evals) an embedded “Javascript” file ! This is totally\ninteresting stuff :D. Let’s follow up on stages and see where it goes. The extracted Javascript\n(stage 2) looks like the following image. The “OOoo00” obfuscation technique have been\nused. Personally I do not like this obfuscation technique it’s harder to reverse respect to\ndifferent obfuscation techniques, even the CTR-F takes confused on substrings, but we need\nto figure out what it does, so let’s try to manually substitute every string and watch-out for\nmatching substrings (in order words %s/OOoo00/varName/g wont work at all.\n\nStage 2: evaluated Javacript (obfuscated)\n\nManually substitution takes “forever” if you do not have a substitution framework which asks\nyou for a string, it replace such string (and not a substring) and eventually represents the\n\n\n-----\n\nnew beautified JavaScript. After many substitutions (I really have no idea how many :D) you\nland on a quite readable JavaScript as the following one (click on it to make it bigger).\n\nStage 2: Manually Deobfuscated JavaScript\n\nWhat is interesting (at least in my personal point of view) is the way the attacker (ab)used the\nJS-JVM integration. JavaScript takes the Java context by meaning it might use Java\nfunctions calling contextual java classes. In this stage the JavaScript is loading an encrypted\ncontent from the original JAR, using a KEY decrypts such a content and finally loads it\n(Dynamic Class Loader) on memory in order to fire it up as a new Java code. The used\nencryption algorithm is AES and everything we need to decrypt is in this file, so let’s build up\na simple python script to print our decryption parameters. The following image shows the\ndecoding script made to easily reconstruct AES-KEY and surrounded parameters. NB: The\nwritten python code is not for production, is not protected and full of imprecisions. I made it\nup just for decode AES key and such, so don’t judge it, take it as a known weak but working\ndirty code.\n\n\n-----\n\nPython Script to Decode AES-KEY\n\nWe now have every decoding parameter, we just need to decrypt the classes by using the\nfollowing data:\n\nClassName\nResource (a.k.a package in where it will be contextualised)\nByte to be decrypted\nSecret Key\nByte Length to be decrypted\n\nA Simple Java Decrypter has been developed following the original Malware code. Once run,\nthe following code was decrypted.\n\n\n-----\n\nStage 3 Decrypted JavaClass\n\nHere my favourite point. As you might appreciate from the previous image we are facing a\nnew stage (Stage 3). What is interesting about this new stage is in the way it reflect the old\ncode. It is a defacto replica of the Stage 2. We have new classes to be decrypted (red tag on\nthe image), the same algorithm (orange label on the image), a new KEY (this time is not\nderived by algorithm as was in Stage 2 but simply in clear text, orange tag on the image) and\nthe same reflective technique in which attacker dynamically loads memory decrypted content\non Java.loader and uses it to decrypt again a further step, and after that it replies the code\nagain and again. There is an interesting difference although, this stage builds up a new in\nmemory stage (let’s call Stage 4) by adding static GZIpped contents at the end of encrypted\nsection (light blue tag on image). By using that technique the attacker can reach as many\ndecryption stages as he desires.\nAt the end of the decryption loop (which took a while, really ) the sample saves (or drops\nfrom itself, if you wish) an additional file placed in AppData – Local – Temp named:\n_ARandomDecimalNumber.class. This .class is actually a JAR file carrying a whole function\nset. The final stage before ending up runs the following command:\n**java -jar _ARandomDecimalNumber.class**\nThe execution of such a command drops on local HardDrive (AppData-Local-Temp) three\nnew files named: RetrieveRandomNumber.vbs (2x) and RandomName.reg. The following\nimage represents a simple ‘cat’ command on the just dropped files.\n\nOn Final Stage VBS Run Files\n\n\n-----\n\nIt s quite funny to see the attacker needed a new language script (he already needed Java,\nas original entry point, Javascript as payload decrypt and now he is using VBS ! ) to query\n**WMI in order to retrieve installed AntiVirus and Installed Firewall information. Significative**\nthe choice to use a .reg file to enumerate tons of security tools that have been widely used\nby analysts to analyse Malware. The attacker enumerates 571 possible analysis tools that\nshould not be present on the target machine (Victim). Brave, but not neat at all (on my\npersonal point of view). The sample does not evade the system but it forces the System\n**Kill of such a process independently if they are installed or not, just like Brute force Killing**\n**process. The samples enters in a big loop where it launches 571 sigKill one for each**\nenumerated (.reg) analysis program. It copies through xcopy.exe the entire Java VM into\n**AppData-Roaming-Oracle and by changing local environment classpath uses it to perform**\nthe following actions. It finally drops and executes another payload called “plugins”.\nThe following image shows plugins and initial new stage JAR stage.\n\nFinal Droppe Files (_RandomDec and plugins)\n\nAt a first sight experienced Malware reverser engineer would notice that the original sample\nfinally drops a AdWind/JRat Malware having as a main target to steal files and personal\ninformation from victims. While the AdWind/JRat is not interesting per-se since widely\nanalysed, this new way to deliver AdWind/JRat, it is definitely fascinating me. The attacker\nmixed up Obfuscation **Techniques, Decryption** **Techniques, File–less** **abilities, Multi**\n**Language** **Stages and Evasions* Techniques in order to deliver this AdWind/JRat version.**\nMultiple programming styles have been found during the analysis path. Each Stage\nbelonging with specific programming language is atomic by meaning that could be run\nseparately and each following stage could easily consume its outputs. All these indicators\nmake me believe the original Sample has been built by using Malware builder, which BTW,\nperfectly fits the AdWind philosophy to run as a service platform.\n[A final consideration is about timing. Checking the VirusTotal details (remembering that only](https://www.virustotal.com/#/file/e5c67daef2226a9e042837f6fad5b338d730e7d241ae0786d091895b2a1b8681/details)\n6 on 60 AV were able to say the original JAR was malicious or unwanted) you might notice\nhe following time line.\n\n\n-----\n\nDetection Time Line (VirusTotal)\n\nVT shows the first time it captured that hash (sha256): it was on 2016. But then the fist\nsubmission is on 2018-08-14 few days ago. In such a date (2018-08-14) only 6 out of 60\ndetected a suspicious (malicious) behaviour and triggered on red state. But what about the\n**almost 2 years between December 2016 and August 2018 ? If we assume the Malware**\n**is 2 years old, was it silent until now (until my submission) ? Have we had technology**\n**two years ago to detect such a threat ? Or could it be a targeted attack that took**\n**almost 2 years before being deployed ?**\nI currently have no answers to such a questions, hope you might find some.\n*Actually not really an evasion technique, more likely a toolset mitigation.\n**IoC**\nYou will not find Command and Controls (c2) and dropping url because: (i) dropping url/s\nwas/were not found: the sample auto-extracts contents from itself. (ii) No C2 during the\ndelivery stage. Of course AdWind/JRat does C2 but, as explained, the analyst did not\nfollowed on the analysis of AdWind/JRat since well-known malware.\nhash:\n\ne5c67daef2226a9e042837f6fad5b338d730e7d241ae0786d091895b2a1b8681\n(Original)\n97d585b6aff62fb4e43e7e6a5f816dcd7a14be11a88b109a9ba9e8cd4c456eb9\n(_RandomDec..)\n9da575dd2d5b7c1e9bab8b51a16cde457b3371c6dcdb0537356cf1497fa868f6\n(Retreive1)\n45bfe34aa3ef932f75101246eb53d032f5e7cf6d1f5b4e495334955a255f32e7\n(Retreive2)\n296a0ed2a3575e02ba22e74fd5f8740af4f72b629e4e50643ac0c156694a5f3c (.reg)\n32d28c43af1afc977b96436b7f638fba15188e6120eeaefa1ad91fb82015fd80 (plugins)\n\nFile Paths:\n\n..AppData/Local/Temp/_ARandomDecimalNumber.class\n..AppData/Local/Temp/RetreiveRandomNumber.vbs\n..AppData/Local/Temp/RetreiveRandomNumber.vbs\n\n\n-----\n\n..AppData/Local/Temp/RandomNabe.reg\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-08-20 - Interesting hidden threat since years -.pdf"
    ],
    "report_names": [
        "2018-08-20 - Interesting hidden threat since years -.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535605,
    "ts_updated_at": 1743041135,
    "ts_creation_date": 1653760447,
    "ts_modification_date": 1653760447,
    "files": {
        "pdf": "https://archive.orkl.eu/5bd089c2b5a9c285464ca0fa3dec5e8f7e79798c.pdf",
        "text": "https://archive.orkl.eu/5bd089c2b5a9c285464ca0fa3dec5e8f7e79798c.txt",
        "img": "https://archive.orkl.eu/5bd089c2b5a9c285464ca0fa3dec5e8f7e79798c.jpg"
    }
}