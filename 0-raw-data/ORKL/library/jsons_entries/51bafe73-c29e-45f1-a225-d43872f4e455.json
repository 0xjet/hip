{
    "id": "51bafe73-c29e-45f1-a225-d43872f4e455",
    "created_at": "2023-01-12T15:00:36.360747Z",
    "updated_at": "2025-03-27T02:08:40.441719Z",
    "deleted_at": null,
    "sha1_hash": "0651ea572915fc7078d5c0a90c3f3ad5a7c80b8c",
    "title": "2018-09-19 - Hex-Rays Microcode API vs. Obfuscating Compiler",
    "authors": "",
    "file_creation_date": "2022-05-28T18:26:47Z",
    "file_modification_date": "2022-05-28T18:26:47Z",
    "file_size": 2531894,
    "plain_text": "# Hex-Rays Microcode API vs. Obfuscating Compiler\n\n**hexblog.com/**\n\n**This is a guest entry written by Rolf Rolles from** **Mobius** **Strip** **[Reverse Engineering.](http://www.msreverseengineering.com/)**\n**His views and opinions are his own, and not those of Hex-Rays. Any technical or**\n**maintenance issues regarding the code herein should be directed to him.**\n\nIn this entry, we’ll investigate an in-the-wild malware sample that was compiled by an\nobfuscating compiler to hinder analysis. We begin by examining its obfuscation techniques\nand formulating strategies for removing them. Following a brief detour into the Hex-Rays\nCTREE API, we find that the newly-released microcode API is more powerful and flexible for\nour task. We give an overview of the microcode API, and then we write a Hex-Rays plugin to\nautomatically remove the obfuscation and present the user with a clean decompilation.\n\nThe plugin is open [source and weighs in at roughly 4KLOC of heavily-commented C++.](https://github.com/RolfRolles/HexRaysDeob)\nAdditionally, we are also releasing a helpful plugin for aspiring microcode plugin developers\n[called the Microcode Explorer, which will also be distributed with the Hex-Rays SDK in](https://github.com/RolfRolles/HexRaysDeob/blob/master/MicrocodeExplorer.cpp)\nsubsequent releases. In brief, for the sample we’ll explore in this entry, its assembly\nlanguage code looks like this:\n\n\n-----\n\nThat function’s Hex-Rays decompilation looks like this:\n\n\n-----\n\nOnce our deobfuscation plugin is installed, it will automatically rewrite the decompilation to\nlook like this:\n\n\n-----\n\n## Initial Investigation\n\nThe [sample we’ll be examining was given to me by a student in my](https://www.virustotal.com/#/file/0ac399bc541be9ecc4d294fa3545bbf7fac4b0a2d72bce20648abc7754b3df24/detection) SMT-based binary\nanalysis class. The binary looks clean at first. IDA’s navigation bar doesn’t immediately\nindicate tell-tale signs of obfuscation:\n\n\n-----\n\nThe binary is statically linked with the ordinary Microsoft Visual C runtime, indicating that it\nwas compiled with Visual Studio:\n\nAnd finally, the binary has a RICH header, indicating that it was linked with the Microsoft\nLinker:\n\nThus far, the binary seems normal. However, nearly any function’s assembly and\ndecompilation listings immediately tells a different tale, as shown in the figures at the top of\nthis entry. We can see constants with high entropy, redundant computations that an ordinary\ncompiler optimization would have removed, and an unusual control flow structure.\n\n## Pattern-Based Obfuscation\n\nIn the decompilation listing, we see repeated patterns:\n\n\n-----\n\nThe underlined terms are identical. With a little thought, we can determine that the\nunderlined sequence always evaluates to 0 at run-time, because:\n```\n   x is either even or odd, and x-1 has the opposite parity\n\n```\nAn even number times an odd number is always even\nEven numbers have their lowest bit clear\nThus, AND by `1 produces the value` `0`\n\nThat the same pattern appears repeatedly is an indication that the obfuscating compiler has\na repertoire of patterns that it introduces into the code prior to compilation.\n\n## Opaque Predicates\n\nAnother note about the previous figure is that the topmost occurrence of the `x*(x-1) & 1`\npattern is inside of an `if -statement with an AND-compound conditional. Given that this`\nexpression always evaluates to zero, the AND-compound will fail and the body of the ifstatement will never execute. This is a form of obfuscation known as opaque predicates:\nconditional branches that in fact are not conditional, but can only evaluate one way or the\nother at runtime.\n\n## Control-Flow Flattening\n\nThe obfuscated functions exhibit unusual control flow. Each contains a `switch statement in`\n[a loop (though the “switch statement” is compiled via binary search instead of with a table).](http://www.msreverseengineering.com/blog/2014/6/23/switch-as-binary-search-part-0)\nThis is evidence of a well-known form of obfuscation called “control flow flattening”. In brief, it\nworks as follows:\n\n\n-----\n\n1. Assign a number to each basic block.\n2. The obfuscator introduces a block number variable, indicating which block should\n\nexecute.\n3. Each block, instead of transferring control to a successor with a branch instruction as\n\nusual, updates the block number variable to its chosen successor.\n4. The ordinary control flow is replaced with a switch statement over the block number\n\nvariable, wrapped inside of a loop.\n\nThe following animation illustrates the control-flow flattening process:\n\nHere’s the assembly language implementation of control flow flattening switch for a small\nfunction.\n\n\n-----\n\nOn the first line, `var_1C — the block number variable mentioned above — is initialized to`\nsome random-looking number. Immediately following that is a series of comparisons of\n```\nvar_1C against other random-looking numbers. ( var_1C is copied into var_20, and\nvar_20 is used for comparisons after the first.) The targets of these equality comparisons\n\n```\nare the original function’s basic blocks. Each one updates `var_1C to indicate which block`\n\n\n-----\n\nshould execute next, before branching back to the code just shown, which will then perform\nthe equality comparisons and select the corresponding block to execute. For blocks with one\nsuccessor, the obfuscator simply assigns `var_1C to a constant value, as in the following`\nfigure.\n\nFor blocks with two possible successors (such as if-statements), the obfuscator introduces\nx86 `CMOV instructions to set` `var_1C to one of two possible values, as shown below:`\n\nGraphically, each function looks like this:\n\n\n-----\n\n-----\n\nIn the figure above, the red and orange nodes are the switch-as-binary-search\nimplementation. The blue nodes are the original basic blocks from the function (subject to\nfurther obfuscation). The purple node at the bottom is the loop back to the beginning of the\nswitch-as-binary-search construct (the red node).\n\n## Odd Stack Manipulations\n\nFinally, we can also see that the obfuscator manipulates the stack pointer in unusual ways.\nParticularly, it uses `__alloca_probe to reserve stack space for function arguments and`\nlocal variables, where a normal compiler would, respectively, use the `push instruction and`\nreserve space for all local variables at once in the prologue.\n\n\n-----\n\nIDA has built-in heuristics to determine the numeric argument to `__alloca_probe and`\ntrack the effects of these calls upon the stack pointer. However, the output of the obfuscator\nleaves IDA unable to determine the numeric argument, so IDA cannot properly track the\nstack pointer.\n\n### Aside: Where did this Binary Come From?\n\n[I am not entirely sure how this binary was produced. Obfuscator-LLVM also uses pattern-](https://github.com/obfuscator-llvm/obfuscator/wiki)\nbased obfuscation and control flow flattening, but Obfuscator-LLVM has different patterns\nthan this sample, and there are some superficial differences with how control flow flattening\nis implemented. Also, Obfuscator-LLVM does not generate opaque predicates, nor the\n```\nalloca -related obfuscation. And, needless to say, the fact that the binary includes the\n\n```\nMicrosoft CRT and a RICH header is also puzzling. If you have any further information about\nthis binary, please contact me.\n\n\n-----\n\n[Update: following discussions on twitter with an Obfuscator-LLVM developer and another](https://twitter.com/RolfRolles/status/1042375000588599296)\nknowledgeable individual, in fact, the obfuscating compiler in question is Obfuscator-LLVM,\nwhich has been integrated with the Microsoft Visual Studio toolchain. The paragraph above\nfalsely stated that Obfuscator-LLVM used different patterns and did not insert opaque\npredicates. The author regrets these errors. In theory, the plugin we develop in this entry\nmight work for other binaries produced by the same compilation process, or even for\nObfuscator-LLVM in general, but this theory has not been tested and no guarantees are\noffered.\n\n## Plan of Attack\n\nNow that we’ve seen the obfuscation techniques, let’s break them.\n\nA maxim I’ve learned doing deobfuscation is that the best results come from working at the\nsame level of abstraction that the obfuscator used. For obfuscators that work on the\nassembly-language level, historically my best results have come in using techniques that\nrepresent the obfuscated code in terms of assembly language. For obfuscators that work at\nthe source- or compiler internal-level, my best results have come from using a decompiled\nrepresentation. So, for this obfuscator, a Hex-Rays plugin seemed among our best options.\n\nThe investigation above illuminated four obfuscation techniques for us to contend with:\n\nPattern-based obfuscation\nOpaque predicates\nAlloca-related stack manipulation\nControl flow flattening\n\nThe first two techniques are implemented via pattern substitutions inside of the obfuscating\ncompiler. Pattern-based deobfuscation techniques, for all their downsides, tend to work well\nwhen the obfuscator itself employed a repertoire of patterns — especially a limited one — as\nseems to be the case here. So, we will attack these via pattern matching and replacement.\n\nThe `alloca -related stack manipulation is the simplest technique to bypass. The`\nobfuscator’s non-standard constructs have thwarted IDA’s ordinary analysis surrounding calls\nto `__alloca_probe, and hence the obfuscation prevented IDA from properly accounting for`\nthe stack differentials induced by these calls. To break this, we will let Hex-Rays do most of\nthe work for us. For every function that calls `__alloca_probe, we will use the API to`\ndecompile it, and then at every call site to `__alloca_probe, we will extract the numeric`\nvalue of its sole argument. Finally, we will use this information to create proper stack\n[displacements within the disassembly listing. The code for this is very straightforward.](https://github.com/RolfRolles/HexRaysDeob/blob/master/AllocaFixer.cpp)\n\nAs for control flow flattening, this is the most complicated of the transformations above. We’ll\nget back to it later.\n\n\n-----\n\n## First Approach: Using the CTREE API\n\nI began my deobfuscation by examining the decompilation of the obfuscated functions and\ncataloging the obfuscated patterns therein. The following is a partial listing:\n\n[Though I later switched to the Hex-Rays microcode API, I started with the CTREE API, the](https://www.hex-rays.com/products/ida/7.1/index.shtml)\none that has been available since the first releases of the Hex-Rays SDK. It is overall simpler\nthan the microcode API, and has IDAPython bindings where the microcode API currently\ndoes not.\n\nThe CTREE API provides a data structure representation of the decompiled code, from\nwhich the decompilation listing that is presented to the user is generated. Thus, there is a\ndirect, one-to-one correspondence between the decompilation listing and the CTREE\nrepresentation. For example, an if-statement in the decompilation listing corresponds to a\nCTREE data structure of type `cif_t, which contains a pointer to a CTREE data structure`\nof type `cexpr_t representing the` `if -statement’s conditional expression, as well as a`\npointer to a CTREE data structure of type `cinsn_t representing the body of the` `if -`\nstatement.\n\nWe will need to know how our patterns are represented in terms of CTREE data structures.\nTo assist us, the VDS5 sample plugin from the Hex-Rays SDK helpfully displays the graph of\n[a function’s CTREE data structures. (The third-party plugin HexRaysCodeXplorer](https://github.com/REhints/HexRaysCodeXplorer)\nimplements this functionality in terms of IDA’s built-in graphing capabilities, whereas the\nVDS5 sample uses the external WinGraph viewer.) The following figure shows decompilation\noutput (in the top left) and its corresponding CTREE representation in graphical form.\nHopefully the parallels between them are clear\n\n\n-----\n\nTo implement our pattern-based deobfuscation rules, we simply need to write functions to\nlocate instances within the function’s CTREE of the data types associated with the\nobfuscated patterns, and replace them with CTREE versions of their deobfuscated\nequivalents. For example, to match the `(x-1) * x & 1` pattern we saw before, we\ndetermine the CTREE representation and write an `if -statement that matches it, as follows:`\n\n\n-----\n\n(\nIn practice, these rules should be written more generically when possible. I.e., multiplication\nand bitwise AND are commutative; the pattern matching code should be able to account for\n[this, and match terms with the operands swapped. Also, see the open-source project HRAST](https://github.com/sibears/HRAST)\nfor an IDAPython framework that offers a less cumbersome approach to pattern-matching\nand replacement.)\n\nThe only point of subtlety in replacing obfuscated CTREE elements with deobfuscated\nequivalents is that each CTREE expression has associated type information, and we must\ncarefully ensure that our replacements are of the proper type. The easiest solution is simply\nto copy the type information from the CTREE expression we’re replacing.\n\n## First Major CTREE Issue: Compiler Optimizations\n\nCataloging the patterns and writing match and replace functions for them was\nstraightforward. However, after having done so, the decompilation showed obvious\nopportunities for improvement by application of standard compiler optimizations, as shown in\nthe following animation.\n\nThis perplexed me at first. I knew that Hex-Rays already implemented these compiler\noptimizations, so I was confused that they weren’t being applied in this situation. Igor\nSkochinsky suggested that, while Hex-Rays does indeed implement these optimizations, that\nthey take place during the microcode phase of decompilation, and that these optimizations\n\n\n-----\n\ndon t happen anymore once the CTREE representation has been generated. Thus, I would\neither have to port my plugin to the microcode world, or write these optimizations myself on\nthe CTREE level. I set the issue aside for the time being and continued with the other parts\nof the project.\n\n## Control Flow Unflattening via the CTREE API\n\nNext, I began working on the control flow unflattening portion. I envisioned this taking place\nin three stages. My final solution included none of these steps, so I won’t devote a lot of print\nspace to my early plan. But, I’ll discuss the original idea, and the issues that lead me to my\nfinal solution.\n\n1. Starting from the switch-as-binary-search implementation, rebuild an actual `switch`\n\nstatement (rather than a mess of nested `if and` `goto statements).`\n2. Examine how each switch case updates the block number variable to recover the\n\noriginal control flow graph. I.e., each update to the block number variable corresponds\nto an edge from one block to its numbered target.\n3. Given the control flow graph, reconstruct high-level control flow structures such as\n\nloops, `if / else statements,` `break,` `continue,` `return, and so on.`\n\nI began by writing a CTREE-based component to reconstruct switch statements from\nobfuscated functions. The basic idea — inspired by the assembly language implementation\n— is to identify the variable that represents the block number to execute, find equality\ncomparisons of this variable against constant numbers, and extract these numbers (these\nare the case labels) as well the address of the code that executes if the comparison matches\n(these are the bodies of the case statements).\n\nThis proved more difficult than I expected. Although the assembly language implementations\nhad a predictable structure, Hex-Rays had applied transformations to the high-level control\nflow which made it difficult to extract the information I was after, as we can see in the\nfollowing figure.\n\n\n-----\n\nWe see above the introduction of a strange `while loop in the inner` `switch, and the final`\n```\nif -statement has been inverted to a != conditional rather than a == conditional, which\n\n```\nmight seem a more logical translation of the assembly code. The example above doesn’t\nshow it, but sometimes Hex-Rays rebuilds small `switch statements that cover portions of`\nthe larger `switch . Thus, our` `switch reconstruction logic must take into account that`\nthese transformations might have taken place.\n\nFor ordinary decompilation tasks, these transformations would have been valuable\nimprovements to the output; but in my unusual situation, it meant my switch recovery\nalgorithm was basically fighting against these transformations. My first attempt at rebuilding\nswitches had a lot of cumbersome corner cases, and overall did not work very well.\n\n## Control Flow Reconstruction\n\nStill, I pressed on. I started thinking about how to rebuild high-level control flow structure\n( if statements, `while loops,` `returns, etc.) from the recovered control flow graph.`\nWhile it seemed like a fun challenge, I quickly realized that Hex-Rays obviously already\nincludes this functionality. Could I re-use Hex-Rays’ existing algorithms to do that?\n\nAnother conversation with Igor lead to a similar answer as before: in order to take advantage\nof Hex-Rays’ built-in control flow structuring algorithms, I would need to operate at the\nmicrocode level instead of the CTREE level. At this point, all of my issues seemed to be\n\n\n-----\n\npointing me toward the newly-available microcode API. I bit the bullet and started over with\nthe project using the microcode API.\n\n## Overview of the Hex-Rays Microcode API\n\nMy first order of business was to read the SDK’s `hexrays.hpp, which now includes the`\nmicrocode API. I’ll summarize some of my findings here; I have provided some more,\noptional information in an appendix.\n\nAt Igor’s suggestion, I compiled the VDS9 plugin included with the Hex-Rays SDK. This\nplugin demonstrates how to generate microcode for a given function (using the\n```\ngen_microcode() API) and print it to the output window (using mbl_array_t::print() ).\n\n## Microcode API Data Structures\n\n```\nFor my purposes, the most important things to understand about the microcode API were\nfour key data structures:\n\n1. `minsn_t, microcode instructions.`\n2. `mop_t, operands for microcode instructions.`\n3. `mbl_array_t, which contains the graph for the microcode function.`\n4. `mblock_t, the basic blocks within the microcode graph, which contain the`\n\ninstructions, and the edges between the blocks.\n\nFor the first two points, Ilfak has given an overview presentation about the microcode\ninstruction set. For the second two points, he has [published a blog entry showing graphically](http://www.hexblog.com/?p=1232)\nhow all of these data structures relate to one another. Aspiring microcode API plugin\ndevelopers would do well to read those entries; the latter includes many nice figures such as\nthis one:\n\n\n-----\n\n## Microcode Maturity\n\nAs Hex-Rays internally optimizes and transforms the microcode, it moves through so-called\n“maturity phases”, indicated by an enumerated element of type `mba_maturity_t . For`\nexample, immediately after generation, the microcode is said to be at maturity\n```\nMMAT_GENERATED . After local optimizations have been performed, the microcode moves to\n\n```\n\n-----\n\nmaturity `MMAT_LOCOPT . After performing analysis of function calls (such as deciding which`\npushes onto the stack correspond to which called function), the microcode moves to maturity\n```\nMMAT_CALLS . When generating microcode via the gen_microcode() API, the user can\n\n```\nspecify the desired maturity level to which the microcode should be optimized.\n\n## The Microcode Explorer Plugin\n\nExamining the microcode at various levels of maturity is an informative and impressive\nundertaking that I recommend for all would-be microcode API plugin developers. It sheds\nlight on which transformations take place in which order, and the textual output is easy to\ncomprehend. At the start of this project, I spent a good bit of time reading through microcode\ndumps at various levels of maturity.\n\nThough the microcode dump output is very nice and easy to read, its output does not show\nthe low-level details of how the microcode instructions and operands are represented —\nwhich is critical information for writing microcode plugins. As such, to understand the lowlevel representation, I wrote functions to dump `minsn_t instructions and` `mop_t operands`\nin textual form.\n\nFor the benefit of would-be microcode plugin developers, I created a plugin I call the\n[Microcode Explorer. With your cursor within a function, run the plugin. It will ask you to select](https://github.com/RolfRolles/HexRaysDeob/blob/master/MicrocodeExplorer.cpp)\na decompiler maturity level:\n\n\n-----\n\nOnce the user makes a selection, the plugin shows a custom viewer in IDA with the\nmicrocode dump at the selected maturity level.\n\nThe microcode dump is mostly non-interactive, but it does offer the user two additional\nfeatures. First, pressing `G in the custom viewer will display a graph of the entire microcode`\nrepresentation. For example:\n\nSecond, the Microcode Explorer can display the graph for a selected microinstruction and its\noperands, akin to the VDS5 plugin we saw earlier which displayed a graph of a function’s\nCTREE representation. Simply position your cursor on any line in the viewer and press the\n\n\n-----\n\n```\nI key.\n\n```\nThe appendix discusses the microcode instruction set in more detail, and I recommend that\naspiring microcode API plugin developers read it.\n\n## Pattern Deobfuscation with the Microcode API\n\nOnce I had a basic handle on the microcode API instruction set, I began by porting my\nCTREE-level pattern matching and replacement code to the microcode API. This was more\nlaborious due to the more elaborate nature of the microcode API, and the fact I had to write it\nin C++ instead of Python. All in all, the porting process was mostly straightforward. The code\n[can be found here, and here’s an example of a pattern match and replacement.](https://github.com/RolfRolles/HexRaysDeob/blob/master/PatternDeobfuscate.cpp)\n\n\n-----\n\nAlso, I needed to know how to integrate my pattern replacement with the rest of Hex-Rays’\ndecompiler infrastructure. It was easy enough to write and test my pattern replacement code\nagainst the data returned by the `gen_microcode() API, but doing so has no effect on the`\ndecompilation listing that the user ultimately sees (since the decompiler calls\n```\ngen_microcode() internally, and we don’t have access to the mbl_array_t that it\n\n```\ngenerates).\n\nThe VDS10 SDK sample illustrates how to integrate pattern-replacement into the Hex-Rays\ninfrastructure. In particular, the SDK defines an “instruction optimizer” data type called\n```\noptinsn_t . The virtual method optinsn_t::func() is given a microinstruction as input.\n\n```\nThat method must inspect the provided microinstruction and try to optimize it, returning a\nnon-zero value if it can. Once the user installs their instruction optimizer with the SDK\n\n\n-----\n\nfunction `install_optinsn_handler(), their custom optimizer will be called periodically by`\nthe Hex-Rays decompiler kernel, thus achieving integration that ultimately affects the user’s\nview of the decompilation listing.\n\nYou may recall that a major impetus for moving the pattern-matching to the microcode world\nwas that, after the replacements had been performed, Hex-Rays had an opportunity to\nimprove the code further via standard compiler optimizations. We showed what we expected\nthe result of such optimizations would be, but no optimizations had been applied when we\nwrote our pattern-replacement with the CTREE API. By moving to the microcode world, now\nwe do get the compiler optimizations we desire.\n\nAfter installing our pattern-replacement hook, here’s the decompilation listing for the compiler\noptimization animation shown earlier:\n\nThat’s exactly the result we had been expecting. Great! I didn’t have to code those\noptimizations myself after all.\n\n### Aside: Tricky Issues with Pattern Replacement in the Microcode World\n\nWhen we wrote our CTREE pattern matching and replacement code, we targeted a specific\nCTREE maturity level, which lead to predictable CTREE data structures implementing the\npatterns. In the microcode world, as discussed more in the appendix, the microcode\nimplementation changes dramatically as it matures. Furthermore, our instruction optimizer\ncallback gets called all throughout the maturity lifecycle. Some of our patterns won’t yet be\nready to match at earlier maturity phases; we’ll have to write our patterns targeting the lowest\nmaturity level at which we can reasonably match them.\n\nWhile porting my CTREE pattern replacement code to the microcode world, at first I also\nadopted my strategy from the CTREE world of generating my pattern replacement objects\nfrom scratch, and inserting them into the microcode atop the terms I wanted to replace.\nHowever, I experienced a lot of difficulty in doing so. Since I was new to the microcode API, I\ndid not have a clear mental picture of what Hex-Rays internally expected about my\nmicrocode objects, which lead to mistakes (internal errors and a few crashes). I quickly\nswitched strategies such that my replacements would modify the existing microinstruction\nand microoperand objects, rather than generating my own, which reduced my burden of\ngenerating correct `minsn_t and` `mop_t objects (since this strategy allowed me to start`\nfrom valid objects).\n\n\n-----\n\n## Control Flow Unflattening, Overview\n\nTo recap, control flow flattening eliminates direct block-to-block control flow transfers. The\nflattening process introduced a “block number variable” which determines the block that\nshould execute at each step of the function’s execution. Each flattened function’s control flow\nstructure has been changed into a switch over the block number variable, which ultimately\nshepherds execution to the correct block. Every block must update the block number\nvariable to indicate the block that should execute next after the current one (where\nconditional branches are implemented via conditional move instructions, updating the block\nnumber variable to the block number of either the taken branch, or of the non-taken branch).\n\nThe control flow unflattening process is conceptually simple. Put simply, our task is to rebuild\nthe direct block-to-block control flows, and in so doing, eliminate the control flow switch\nmechanism. Implementation-wise, unflattening is integrated with the Hex-Rays decompiler\nkernel in a similar fashion to how we integrated pattern-matching. Specifically, we register an\n```\noptblock_t callback object with Hex-Rays, such that our unflattener will be automatically\n\n```\ninvoked by the Hex-Rays kernel, providing a fully automated experience for the user.\n\nThe next chapter will discuss the implementation in more depth.\n\nIn the following subsections, we’ll show an overview of the process pictorially. Just three\nsteps are all we need to remove the control flow flattening. Once we rebuild the original\ncontrol flow transfers, all of Hex-Rays’ existing machinery for control flow restructuring will do\nthe rest of the work for us. This was perhaps my favorite result from this project; all I had to\ndo was re-insert proper control flow transfers, and Hex-Rays did everything else for me\nautomatically.\n\n## Step #1: Determine Flattened Block Number to Hex-Rays Block Number Mapping\n\nOur first task is to determine which flattened block number corresponds to which Hex-Rays\n```\nmblock_t . The following figure is the microcode-level representation for a small function’s\n\n```\ncontrol flow switch:\n\n\n-----\n\nHex-Rays is currently calling the block number variable `ST14_4.4 . If that variable matches`\n```\n0xCBAD6A23, the jz instruction on block @2 transfers control to block @6. Similarly,\n0x25F52EB5 corresponds to block @9, and 0x31B8F0BC corresponds to block @10. The\n\n```\ninformation just described is the mapping between flattened block numbers and Hex-Rays\nblock numbers. (Of course, our plugin will need to extract it automatically.)\n\n## Step #2: Determine Each Flattened Block’s Successors\n\nNext, for each flattened block, we need to determine the flattened block numbers to which it\nmight transfer control. Flattened blocks may have one successor if their original control flow\nwas unconditional, or two potential successors if their original control flow was conditional.\nFirst, here’s the microcode from block @9, which has one successor. (Line 9.3 has been\ntruncated because it was long and its details are immaterial.)\n\n\n-----\n\nWe can see on line 9.4 that this block updates the block number variable to `0xCBAD6A23,`\nbefore executing a `goto back to the control flow switch (on the Hex-Rays block numbered`\n@2). From what we learned in step #1, we know that, by setting the block number variable to\nthis value, the next trip through the control flow switch will execute the Hex-Rays `mblock_t`\nnumbered @6.\n\nThe second case is when a block has two possible successors, as does Hex-Rays block @6\nin the following figure.\n\n\n-----\n\nLine 8.0 updates the block number variable with the value of `eax, before line 8.1 executes`\na `goto back to the control flow switch at Hex-Rays block @2. If the` `jz instruction on line`\n6.4 is taken, then `eax will have the value` `0x31B8F0BC (obtained on line 6.1). If the` `jz`\ninstruction is not taken, then `eax will contain the value` `0x25F52EB5 from the assignment`\non line 7.0. Consulting the information we obtained in step #1, this block will transfer control\nto Hex-Rays block @10 or @9 during the next trip through the control flow switch.\n\n## Step #3: Insert Control Transfers Directly from Source Blocks to Destinations\n\nFinally, now that we know the Hex-Rays `mblock_t numbers to which each flattened block`\nshall pass control, we can modify the control flow instructions in the microcode to point\ndirectly to their successors, rather than going through the control flow switch. If we do this for\nall flattened blocks, then the control flow switch will no longer be reachable, and we can\ndelete it, leaving only the function’s original, unflattened control flow. Continuing the example\nfrom above, in the analysis in step #2, we determined that Hex-Rays block @9 ultimately\ntransferred control to Hex-Rays block @6. Block @9 ended with a `goto statement back to`\nthe control flow switch located on block @2. We simply modify the target of the existing\n```\ngoto statement to point to block @6 instead of block @2, as in the following figure. (Note\n\n```\nthat we also deleted the assignment to the block number variable, since it’s no longer\nnecessary.)\n\nThe case where a block has two potential successors is slightly more complicated, but the\nbasic idea is the same: altering the existing control flow back to the control flow switch to\npoint directly to the Hex-Rays targeted blocks. Here’s Hex-Rays block @6 again, with two\npossible successors.\n\n\n-----\n\nTo unflatten this, we will:\n\n1. Copy the instructions from block @8 onto the end of block @7.\n2. Change the `goto instruction on block @7 (which was just copied from block @8) to`\n\npoint to block @9 (since we learned in step #1 that `0x25F52EB5 corresponds to block`\n@9).\n3. Update the `goto target on block @8 to block @10 (since we learned in step #1 that`\n```\n   0x31B8F0BC corresponds to block @10).\n\n```\nWe can also eliminate the update to the block number variable on line 8.0, and the\nassignments to `eax on lines 6.1 and 7.0.`\n\nThat’s it! As we make these changes for every basic block targeted by the control flow\nswitch, the control flow switch dispatcher will lose all of its incoming references, at which\npoint we can prune it from the Hex-Rays microcode graph, and then the flattening will be\ngone for good.\n\n\n-----\n\n## Control Flow Unflattening, In More Detail\n\nAs always, the real world is messier than curated examples. The remainder of this section\ndetails the practical engineering considerations that go into implementing unflattening as a\nfully-automated procedure.\n\n## Heuristically Identifying Flattened Functions\n\nIt turns out that a few non-library functions within the binary were not flattened. I had enough\nwork to do simply making my unflattening code work for flattened functions, such that I did\nnot need the added hassle of tracking down issues stemming from spurious attempts to\nunflatten non-flattened functions.\n\nThus, I devised a heuristic for determining whether or not a given function was flattened. I\nbasically just asked myself which identifying characteristics the flattened functions have. I\nlooked at the microcode for a control flow switch:\n\nTwo points came to mind:\n\n1. The functions compare one variable — the block number variable — against numeric\n\nconstants in `jz and` `jg instructions`\n\n\n-----\n\n2. Those numeric constants are highly entropic, appearing to have been pseudorandomly\n\ngenerated\n\nWith that characterization, the algorithm for heuristically determining whether a function was\nflattened practically wrote itself.\n\n1. Iterate through all microinstructions within a function. For this, the SDK handily\n\nprovides the `mbl_array_t::for_all_topinsns function, to be used with a class`\ncalled `minsn_visitor_t .`\n2. For every `jz and` `jg instruction that compares a variable to a number, record that`\n\ninformation in a list.\n3. After iteration, choose the variable that had been compared against the largest number\n\nof constants.\n4. Perform an entropy check on the constants. In particular, count the number of bits set\n\nand divide by the total number of bits. If roughly 50% of the bits were set, decide that\nthe function has been flattened.\n\n[You can see the implementation in the code — specifically the](https://github.com/RolfRolles/HexRaysDeob/blob/master/CFFlattenInfo.cpp)\n```\nJZInfo::ShouldBlacklist() method.\n\n## Simplify the Graph Structure\n\n```\nThe flattened functions sometimes have jumps leading directly to other jumps, or sometimes\nthe microcode translator inserts `goto instructions that target other` `goto instructions. For`\nexample, in the following figure, block 4 contains a single `goto instruction to block 8, which`\nin turn has a `goto instruction to block 15.`\n\n\n-----\n\nThese complicate our later book-keeping, so I decided to eliminate `goto -to- goto`\ntransfers. I.e. if block @X ends with a `goto @N instruction, and block @N contains a`\nsingle `goto @M instruction, update the` `goto @N to` `goto @M. In fact, we apply this`\nprocess recursively; if block @M contained a single `goto @P, then we would update`\n```\ngoto @N to goto @P, and so on for any number of chained gotos .\n\n```\nThe Hex-Rays SDK sample VDS11 does what was just described in the last paragraph. My\ncode is similar, but a bit more general, and therefore a bit more complicated. It also handles\nthe case where a block falls through to a block with a single `goto — in this case, it inserts`\na new `goto onto the end of the leading block, with the same destination as the original`\n```\ngoto instruction in the trailing block.\n\n```\n\n-----\n\n## Extract Block Number Information\n\nIn step #1 of the unflattening procedure described previously, we need to know:\n\nWhich variable contains the block number\nWhich block number corresponds to which Hex-Rays microcode block\n\nWhen heuristically determining whether a function appears to have been flattened, we\nalready found the variable with the most conditional comparisons, and the numbers it was\ncompared against. Are we done? No — because as usual, there are complications. Many of\nthe flattened functions use two variables, not one, for block number-related purposes. For\nthose that use two, the function’s basic blocks update a different variable than the one that is\ncompared by the control flow switch construct. I call this the block update variable. and I\nrenamed my terminology for the other one to the block comparison variable. Toward the\nbeginning of the control flow switch, the value of the block update variable is copied into the\nblock comparison variable, after which all subsequent comparisons reference the block\ncomparison variable. For example, see the following figure:\n\nIn the above, block @1 is the function’s prologue. The control flow switch begins on block\n@2. Notice that block @1 assigns a numeric value to a variable called `ST18_4.4 . Note that`\nthe first comparison in the control flow switch, on line 2.3, compares against this variable.\n\n\n-----\n\nNote also that line 2.1 copies that variable into another variable called `ST14_4.4, which is`\nthen used for the subsequent comparisons (as on line 3.1, and all control flow switch\ncomparisons thereafter). Then, the function’s flattened blocks update the variable `ST18_4 :`\n\n(Confusingly, the function’s flattened blocks update both variables — however, only the\nassignment to the block update variable `ST18_4.4 is used. The block comparison variable,`\n```\nST14_4.4, is redefined on line 2.1 above before its value is used.)\n\n```\nSo, we actually have three tasks:\n\n1. Determine which variable is the block comparison variable (which we already have\n\nfrom the entropy check).\n2. Determine if there is a block update variable, and if so, which variable it is.\n3. Extract the numeric constants from the `jz comparisons against the block comparison`\n\nvariable to determine the flattened block number to Hex-Rays `mblock_t number`\nmapping.\n\nI quickly examined all of the flattened functions to see if I could find a pattern as to how to\nlocate the block update variable. It was simple enough: for any variable assigned a numeric\nconstant value in the first block, see if it is later copied into the block comparison variable.\nThere should be only one of these. It was easy to code using similar techniques to the\nentropy check, and it worked reliably.\n\nThe code for reconstructing the flattened Hex-Rays block number mapping is nearly identical\nto the code used for heuristically identifying flattened functions, and so we don’t need to say\nanything in particular about it.\n\n## Unflattening\n\nFrom the above, we now know which variable is the block update variable (or block\ncomparison variable, if there is none). We also know which flattened block number\ncorresponds to which Hex-Rays `mblock_t number. For every flattened block, we need to`\n\n\n-----\n\ndetermine the number to which it sets the block update variable. We walk backwards, from\nthe end of the flattened block region, looking for assignments to the block update variable. If\nwe find an assignment from another variable, we recursively begin tracking the other\nvariable. If we find a number, we’re done.\n\nAs described previously, flattened blocks come in two cases:\n\n1. The flattened block always sets the block update variable to a single value\n\n(corresponding to an unconditional branch).\n2. The flattened block uses an x86 `CMOV instruction to set the block update variable to`\n\none of two possible values (corresponding to a conditional branch).\n\nIn the first case, our job is simply to find one number. For example, the following flattened\nblock falls into case #1 from above:\n\nIn this case, the block update variable is `ST14_4.4 . Our task is to find the numeric`\nassignment on line 9.4. In concert with the flattened block number Hex-Rays `mblock_t`\nnumber mapping we extracted from the previous step, we can now change the `goto on the`\nfinal line to the proper Hex-Rays `mblock_t number.`\n\nThe following flattened block falls into the second case:\n\n\n-----\n\nOur job is to determine that `ST14_4.4 might be updated to either` `0xCBAD6A23 or`\n```\n0x25F52EB5 on lines 6.0 and 7.0, respectively.\n\n### Complication: Flattened Blocks Might Contain Many Hex-Rays Blocks\n\n```\nThis part of the project forced me to contend with a number of complications, some of which\naren’t shown by the examples above.\n\nOne complication is that a flattened block may be implemented by more than one Hex-Rays\n```\nmblock_t as in the first case above, or more than three Hex-Rays mblock_t objects in\n\n```\nthe second case above. In particular, Hex-Rays splits basic blocks on function call\nboundaries — so there may be any number of Hex-Rays `mblock_t objects for a single`\nflattened block. Since we need to work backwards from the end of a flattened region, how do\nwe know where the end of the region is? I solved this problem by computing the function’s\n[dominator tree and finding the block dominated by the flattened block header that branches](https://en.wikipedia.org/wiki/Dominator_(graph_theory))\nback to the control flow switch.\n\n### Complication: Data-Flow Tracking\n\n\n-----\n\nFinding the numeric values assigned to the block update variable ranges from trivial to\n“mathematically hard”. I wound up cheating in the mathematically hard cases.\n\nSometimes Hex-Rays’ constant propagation algorithms make our lives easy by creating a\nmicroinstruction that directly moves a numeric constant into the block update variable. A\nslightly less simple, but still easy, case is when the assignment to the block update variable\ninvolves a number being copied between a few registers or stack variables along the way. As\nlong as there aren’t any errant memory writes to clobber saved values on the stack, it’s easy\nenough to follow the chain of mov instructions backwards back to the original constant value.\n\nTo handle both of these cases, I wrote a function that starts at the bottom of a block and\nsearches for assignments to the block number variable in the backwards direction. For\nassignments from other variables, it resumes searching for assignments to those variables.\nOnce it finally finds a numeric assignment, it succeeds.\n\nHowever, there is a harder case for which the above algorithm will not work. In particular, it\nwill not work when the flattened blocks perform memory writes through pointers, for which\nHex-Rays cannot determine legal pointer value sets. Hex-Rays, quite reasonably, can not\nand does not perform constant propagation across memory values if there are unknown\nwrites to memory in the meantime. Such transformations would break the decompilation\nlisting and cause the analyst not to trust the tool. And yet, this part of the project presents us\nwith the very problem of constant propagation across unknown memory writes.\n\nHere’s an example of the hard case manifesting itself. At the beginning of a flattened block,\nwe see the two destination block numbers being written into registers, and then saved to\nstack variables.\n\nLater on, the flattened block has several memory writes through pointers.\n\n\n-----\n\nFinally, at the end of the block, the destination block numbers — which were spilled to stack\nvariables at the beginning of the flattened block — are then loaded from their stack slots, and\nused in a conditional block number update.\n\nThe problem this presents us is that we need, or Hex-Rays needs, to formally prove that the\nmemory writes in the middle did not overwrite the saved block update numbers. In general,\npointer aliasing is an undecidable problem, meaning it is impossible to write an algorithm to\nsolve every instance of it. So instead, I cheated. When my numeric definition scanner\nencounters an instruction whose memory side effects cannot be bounded, I go to the\nbeginning of the flattened block region and scan forwards looking for numeric assignments to\nthe last variables I was tracking before encountering an unbounded memory reference. I.e.,\nin the three assembly snippets above, I jump to the first one and find the numeric\n\n\n-----\n\nassignments to `var_B4 and` `var_BC . This is a hack; it s unsafe, and could very well break.`\nBut, it happens to work for every function in this sample, and will likely work for every sample\ncompiled by this obfuscating compiler.\n\n## Appendix: More about the Microcode API\n\nWhat follows are some topics about the Microcode API that I thought were important enough\nto write up, but I did not want them to alter the narrative flow. Perhaps you can put off\nreading this appendix until you get around to writing your first microcode plugin.\n\n## The Microcode Verifier\n\nChances are good that if you’re going use the microcode API, you probably will be modifying\nthe microcode objects described in the previous section. This is murky territory for third-party\nplugin developers, especially those of us who are new to the microcode API, since modifying\nthe microcode objects in an illegal fashion can lead to crashes or internal errors.\n\nTo aid plugin developers in diagnosing and debugging issues stemming from illegal\nmodifications, the microcode API offers “verification”, which is accessible in the API through\na method called `mbl_array_t::verify() . (The other objects also support verification, but`\ntheir individual `verify() methods are not currently exposed through the API.) Basically,`\n```\nmbl_array_t::verify() applies a comprehensive set of test suites to the microcode\n\n```\nobjects (such as `mblock_t,` `minsn_t, and` `mop_t ).`\n\nFor one example of verification, Hex-Rays has a set of assumptions about the legal operand\ntypes for its microinstructions. The m_add instruction must have at least two operands, and\nthose operands must be the same size. m_add can optionally store the result in a\n“destination” operand; if this is the case, certain destination types are illegal (e.g., in C, it\ndoes not make any sense to have a number on the left-hand side of an assignment\nstatement, as in `1 = x + y; . The analogous concept in the microcode world, storing the`\nresult of an addition into a number, also does not make sense and should be rejected as\nillegal.)\n\nThe source code for the `verify() methods is included in the Hex-Rays SDK under`\n```\nverifier\\verify.cpp . (There is an analogous version for the CTREE API under\nverifier\\cverify.cpp .) When the verifier detects an illegal condition, it raises a\n\n```\nnumbered “internal error” within IDA, as in the following screenshot. The plugin developer\ncan search for this number within the verifier source code to determine the source of the\nerror.\n\n\n-----\n\nThe verifier source code is, in my opinion, the best and most important source of\ndocumentation about Hex-Rays’ internal expectations. It touches on many different parts of\nthe microcode API, and provides examples of how to call certain API functions that may not\nbe covered by the other example plugins in the SDK. Wading through internal errors, tracking\nthem down in the verifier, and learning Hex-Rays’ expectations about the microcode objects\n(as well as how it verifies them) is a rite of passage for any would-be microcode API plugin\ndeveloper.\n\n## Intermediate Representations and the Microcode Instruction Set\n\nIf you’ve ever studied compilers, you are surely familiar with the notion of an intermediate\nrepresentation. The `minsn_t and` `mop_t data types, taken together, are the intermediate`\nrepresention used in the microcode phase of the Hex-Rays decompiler.\n\nIf you’ve studied compilers at an advanced level, you might be familiar with the idea that\n[compilers frequently use more than one intermediate representation. For example, Muchnick](https://www.amazon.com/Advanced-Compiler-Design-Implementation-Muchnick/dp/1558603204)\ndescribes a compiler archetype using three intermediate representations, that he\nrespectively calls HIR (“high-level” intermediate representation), MIR (“mid-level”), and LIR\n(“low-level”). HIR resembles a high-level language such as C, which supports nested\nexpressions. I.e., in C, one may perform multiple operations in a single statement, such as `a`\n```\n= ((b + c) * d) / e . On the other hand, low-level languages such as LIR or assembly\n\n```\ngenerally can only perform one operation per statement; to represent the same code in a\nlow-level language, we would need at least three statements (ADD, MUL, and DIV). LIR is\nbasically a “pseudo-assembly language”.\n\n\n-----\n\nSo then, given that the Hex-Rays microcode API has only intermediate representation, which\ntype is it — is it closer to HIR, or is it closer to LIR? The answer is, it uses a clever design to\nsimulate both HIR and LIR! As the microcode matures, it is gradually transformed from a\nLIR-like representation, with only one operation per statement, to a HIR-like representation,\nwith arbitrarily many operations per statement. Let’s take a closer look with the microcode\nexplorer.\n\nWhen first generating the microcode (i.e., microcode maturity level `MMAT_GENERATED ), we`\ncan see that the microcode looks a lot like an assembly language. Notice that each\nmicroinstruction has two or three operands apiece, and each operand is something like a\nnumber, register name, or name of a global variable. I.e., this is what we would call LIR in a\ncompiler back-end.\n\nShortly thereafter in the maturity pipeline, in the `MMAT_LOCOPT phase, we can see that the`\nmicrocode representation for the same code in the same function is already quite different. In\nthe figure below, many of the lines in the bottom half have complex expressions inside them,\ninstead of the simple operands we saw just previously. I.e., we are no longer dealing with\nLIR.\n\n\n-----\n\nFinally, at the highest level of microcode maturity, `MMAT_LVARS, the same code has shrunk`\ndown to three lines, with the final one being so long that I had to truncate it to fit it reasonably\ninto the picture:\n\n## Microinstructions and Microoperands\n\nThat’s a pretty impressive trick — supporting multiple varieties of compiler IRs with a single\nset of data types. How did they do it? Let’s look more carefully at the internal representations\nof microinstructions and microoperands to figure it out.\n\nRespectively, microinstructions and microoperands are implemented via the `minsn_t and`\n```\nmop_t classes. Here again is the graph representation for a microinstruction:\n\n```\n\n-----\n\nIn the figure above, the top-level microcode instruction is shown in the topmost node. It is\nrepresented by an instruction of type `m_and, which in this case uses three comma-`\nseparated operands, of type `mop_d (result of another instruction),` `mop_n (a number), and`\n```\nmop_r (destination is a register). The mop_d operand is a compound instruction with two\n\n```\nexpressions joined together with a bitwise OR — thus, it corresponds to a microinstruction of\ntype `m_or, whose operands themselves are respectively the result of bitwise AND and`\nbitwise XOR operands, and as such, these operands are of type `mop_d, instructions`\nrespectively of type `m_and and` `m_xor . The inputs to the AND and XOR operators are all`\nstack variables, i.e., micro-operands of type `mop_S .`\n\nNow we can see how the microcode API supports such dramatic differences in microcode\nrepresentation using the same underlying data structures. Specifically, the example above\nmakes use of the `mop_d microoperand type, which refers to the result of another`\nmicroinstruction. I.e., microinstructions contain microoperands, and microoperands can\ncontain microinstructions (which then contain other microoperands, which may recursively\ncontain other microinstructions, etc). This technique allows the same data structures to\nrepresent both HIR- and LIR-like representations. The initial microcode generation phase\ndoes not generate `mop_d operands. Subsequent maturity transformations introduce them in`\norder to build a higher-level representation.\n\nThe proper name for this language design technique is mutual recursion: where one\ncategory of a grammar refers to another category, and the second refers back to the first. I\nfound this design technique very elegant and clever. Apart from using different data\nstructures at each level of representation, I can’t think of any cleaner ways to accommodate\nmulti-level representations. That said, this type of programming is mostly common only\namong people with serious professional experience with programming language theory and\ncompiler internals. Ordinary developers would do well to study some programming language\ntheory if they want to make good use of the microcode API.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-09-19 - Hex-Rays Microcode API vs. Obfuscating Compiler.pdf"
    ],
    "report_names": [
        "2018-09-19 - Hex-Rays Microcode API vs. Obfuscating Compiler.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bfded1cf-be73-44f9-a391-0751c9996f9a",
            "created_at": "2022-10-25T15:50:23.337107Z",
            "updated_at": "2025-03-27T02:00:55.445946Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "FIN7",
                "GOLD NIAGARA",
                "ITG14",
                "Carbon Spider",
                "ELBRUS",
                "Sangria Tempest"
            ],
            "source_name": "MITRE:FIN7",
            "tools": [
                "Mimikatz",
                "AdFind",
                "JSS Loader",
                "HALFBAKED",
                "REvil",
                "PowerSploit",
                "CrackMapExec",
                "Carbanak",
                "Pillowmint",
                "Cobalt Strike",
                "POWERSOURCE",
                "RDFSNIFFER",
                "SQLRat",
                "Lizar",
                "TEXTMATE",
                "BOOSTWRITE"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "bb8702c5-52ac-4359-8409-998a7cc3eeaf",
            "created_at": "2023-01-06T13:46:38.405479Z",
            "updated_at": "2025-03-27T02:00:02.82533Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "JokerStash",
                "ATK32",
                "G0046",
                "Coreid",
                "Carbanak",
                "Sangria Tempest",
                "CARBON SPIDER",
                "GOLD NIAGARA",
                "G0008",
                "ELBRUS",
                "Carbon Spider"
            ],
            "source_name": "MISPGALAXY:FIN7",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d85adfe3-e1c3-40b0-b8bb-d1bacadc4d82",
            "created_at": "2022-10-25T16:07:23.619566Z",
            "updated_at": "2025-03-27T02:02:09.890982Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "APT-C-11",
                "ATK 32",
                "Gold Niagara",
                "ITG14",
                "TAG-CR1"
            ],
            "source_name": "ETDA:FIN7",
            "tools": [
                "7Logger",
                "Agentemis",
                "Anunak",
                "Astra",
                "BIOLOAD",
                "BIRDWATCH",
                "Bateleur",
                "Boostwrite",
                "CROWVIEW",
                "Carbanak",
                "Cobalt Strike",
                "CobaltStrike",
                "DICELOADER",
                "DNSMessenger",
                "FOWLGAZE",
                "HALFBAKED",
                "JSSLoader",
                "KillACK",
                "LOADOUT",
                "Lizar",
                "Meterpreter",
                "Mimikatz",
                "POWERPLANT",
                "POWERSOURCE",
                "RDFSNIFFER",
                "SQLRAT",
                "Sekur",
                "Sekur RAT",
                "TEXTMATE",
                "Tirion",
                "VB Flash",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535636,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653762407,
    "ts_modification_date": 1653762407,
    "files": {
        "pdf": "https://archive.orkl.eu/0651ea572915fc7078d5c0a90c3f3ad5a7c80b8c.pdf",
        "text": "https://archive.orkl.eu/0651ea572915fc7078d5c0a90c3f3ad5a7c80b8c.txt",
        "img": "https://archive.orkl.eu/0651ea572915fc7078d5c0a90c3f3ad5a7c80b8c.jpg"
    }
}