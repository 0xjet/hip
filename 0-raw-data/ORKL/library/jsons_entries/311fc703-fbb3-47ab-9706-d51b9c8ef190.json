{
    "id": "311fc703-fbb3-47ab-9706-d51b9c8ef190",
    "created_at": "2023-01-12T15:04:38.763019Z",
    "updated_at": "2025-03-27T02:09:18.04555Z",
    "deleted_at": null,
    "sha1_hash": "fb7808e93e7688064dce57a682ed56b34175504a",
    "title": "2021-07-08 - Decoding Cobalt Strike- Understanding Payloads",
    "authors": "",
    "file_creation_date": "2022-05-28T23:13:08Z",
    "file_modification_date": "2022-05-28T23:13:08Z",
    "file_size": 955637,
    "plain_text": "# Decoding Cobalt Strike: Understanding Payloads\n\n**[decoded.avast.io/threatintel/decoding-cobalt-strike-understanding-payloads/](https://decoded.avast.io/threatintel/decoding-cobalt-strike-understanding-payloads/)**\n\nby [Threat Intelligence TeamJuly 8, 202112 min read](https://decoded.avast.io/author/threatintel/)\n\n## Intro\n\n\nJuly 8, 2021\n\n\n[Cobalt Strike threat emulation software is the de facto standard closed-source/paid tool](https://www.cobaltstrike.com/)\nused by infosec teams in many governments, organizations and companies. It is also very\npopular in many cybercrime groups which usually abuse cracked or leaked versions of\nCobalt Strike.\n\nCobalt Strike has multiple unique features, secure communication and it is fully modular\nand customizable so proper detection and attribution can be problematic. It is the main\nreason why we have seen use of Cobalt Strike in almost every major cyber security incident\nor big breach for the past several years.\n\nThere are many great articles about reverse engineering Cobalt Strike software, especially\nbeacon modules as the most important part of the whole chain. Other modules and\npayloads are very often overlooked, but these parts also contain valuable information for\nmalware researchers and forensic analysts or investigators.\n\nThe first part of this series is dedicated to proper identification of all raw payload types and\nhow to decode and parse them. We also share our useful parsers, scripts and yara rules\n[based on these findings back to the community.](https://github.com/avast/ioc/tree/master/CobaltStrike)\n\n## Raw payloads\n\nCobalt Strike’s payloads are based on Meterpreter shellcodes and include many similarities\n[like API hashing (x86 and](https://github.com/rapid7/metasploit-framework/blob/04e8752b9b74cbaad7cb0ea6129c90e3172580a2/external/source/shellcode/windows/x86/src/block/block_api.asm) [x64 versions) or url query checksum8 algo used in http/https](https://github.com/rapid7/metasploit-framework/blob/04e8752b9b74cbaad7cb0ea6129c90e3172580a2/external/source/shellcode/windows/x64/src/block/block_api.asm)\npayloads, which makes identification harder. This particular checksum8 algorithm is also\n[used in other frameworks like Empire.](https://github.com/EmpireProject/Empire/blob/e37fb2eef8ff8f5a0a689f1589f424906fe13055/lib/common/http.py#L55)\n\n\n-----\n\nLet s describe interesting parts of each payload separately.\n\nPayload header x86 variant\n\nDefault 32bit raw payload’s entry points start with typical instruction `CLD (0xFC) followed`\nby `CALL instruction and` `PUSHA (0x60) as the first instruction from API hash algorithm.`\n\nx86 payload\nPayload header x64 variant\n\nStandard 64bit variants start also with `CLD instruction followed by` `AND RSP,-10h and`\n```\nCALL instruction.\n\n```\nx64 payload\n\n\n-----\n\nWe can use these patterns for locating payloads entry points and count other fixed offsets\nfrom this position.\n\nDefault API hashes\n\nRaw payloads have a predefined structure and binary format with particular placeholders for\neach customizable value such as DNS queries, HTTP headers or C2 IP address.\nPlaceholder offsets are on fixed positions the same as hard coded API hash values. The\nhash algorithm is `ROR13 and the final hash is calculated from the API function name and`\nDLL name. The whole algorithm is nicely commented inside assembly code on the\nMetasploit repository.\n\nPython implementation of API hashing algorithm\nWe can use the following regex patterns for searching hardcoded API hashes:\n\nWe can use a known API hashes list for proper payload type identification and known fixed\npositions of API hashes for more accurate detection via Yara rules.\n\n\n-----\n\nPayload identification via known API hashes\nComplete Cobalt Strike API hash list:\n\nAPI hash DLL and API name\n\n0xc99cc96a dnsapi.dll_DnsQuery_A\n\n0x528796c6 kernel32.dll_CloseHandle\n\n0xe27d6f28 kernel32.dll_ConnectNamedPipe\n\n0xd4df7045 kernel32.dll_CreateNamedPipeA\n\n0xfcddfac0 kernel32.dll_DisconnectNamedPipe\n\n0x56a2b5f0 kernel32.dll_ExitProcess\n\n0x5de2c5aa kernel32.dll_GetLastError\n\n0x0726774c kernel32.dll_LoadLibraryA\n\n0xcc8e00f4 kernel32.dll_lstrlenA\n\n0xe035f044 kernel32.dll_Sleep\n\n0xbb5f9ead kernel32.dll_ReadFile\n\n0xe553a458 kernel32.dll_VirtualAlloc\n\n0x315e2145 user32.dll_GetDesktopWindow\n\n0x3b2e55eb wininet.dll_HttpOpenRequestA\n\n0x7b18062d wininet.dll_HttpSendRequestA\n\n0xc69f8957 wininet.dll_InternetConnectA\n\n0x0be057b7 wininet.dll_InternetErrorDlg\n\n0xa779563a wininet.dll_InternetOpenA\n\n\n-----\n\n0xe2899612 wininet.dll_InternetReadFile\n\n0x869e4675 wininet.dll_InternetSetOptionA\n\n0xe13bec74 ws2_32.dll_accept\n\n0x6737dbc2 ws2_32.dll_bind\n\n0x614d6e75 ws2_32.dll_closesocket\n\n0x6174a599 ws2_32.dll_connect\n\n0xff38e9b7 ws2_32.dll_listen\n\n0x5fc8d902 ws2_32.dll_recv\n\n0xe0df0fea ws2_32.dll_WSASocketA\n\n0x006b8029 ws2_32.dll_WSAStartup\n\n[Complete API hash list for Windows 10 system DLLs is available here.](https://github.com/avast/ioc/tree/master/CobaltStrike/api_hashes)\n\nCustomer ID / Watermark\n\nBased on information provided on official web pages, Customer ID is a 4-byte number\nassociated with the Cobalt Strike licence key and since v3.9 is embedded into the payloads\nand beacon configs. This number is located at the end of the payload if it is present.\nCustomer ID could be used for specific threat authors identification or attribution, but a lot of\nCustomer IDs are from cracked or leaked versions, so please consider this while looking at\nthese for possible attribution.\n\n### DNS stager x86\n\nTypical payload size is 515 bytes or 519 bytes with included Customer ID value. The DNS\nquery name string starts on offset 0x0140 (calculated from payload entry point) and the null\nbyte and max string size is 63 bytes. If the DNS query name string is shorter, then is\nterminated with a null byte and the rest of the string space is filled with junk bytes.\n```\nDnsQuery_A API function is called with two default parameters:\n\n```\nParameter Value Constant\n\n[DNS Record Type (wType)](https://docs.microsoft.com/en-us/windows/win32/dns/dns-constants) 0x0010 DNS_TYPE_TEXT\n\n[DNS Query Options (Options)](https://docs.microsoft.com/en-us/windows/win32/dns/dns-constants#dns-query-options) 0x0248 DNS_QUERY_BYPASS_CACHE\n\nDNS_QUERY_NO_HOSTS_FILE\n\nDNS_QUERY_RETURN_MESSAGE\n\nAnything other than the default values are suspicious and could indicate custom payload.\n\n\n-----\n\nPython parsing:\n\nDefault DNS payload API hashes:\n\nOffset Hash value API name\n\n0x00a3 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x00bd 0x0726774c kernel32.dll_LoadLibraryA\n\n0x012f 0xc99cc96a dnsapi.dll_DnsQuery_A\n\n0x0198 0x56a2b5f0 kernel32.dll_ExitProcess\n\n0x01a4 0xe035f044 kernel32.dll_Sleep\n\n0x01e4 0xcc8e00f4 kernel32.dll_lstrlenA\n\nYara rule for DNS stagers:\n\n### SMB stager x86\n\nThe default payload size is 346 bytes plus the length of the pipe name string terminated by\na null byte and the length of the Customer ID if present. The pipe name string is located\nright after the payload code on offset 0x015A in plaintext format.\n\n[CreateNamedPipeA API function is called with 3 default parameters:](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea)\n\nParameter Value Constant\n\n\nOpen Mode\n(dwOpenMode)\n\n\n0x0003 PIPE_ACCESS_DUPLEX\n\n\n-----\n\nPipe Mode (dwPipeMode) 0x0006 PIPE_TYPE_MESSAGE,\nPIPE_READMODE_MESSAGE\n\n\nMax Instances\n(nMaxInstances)\n\nPython parsing:\n\n\n0x0001\n\n\nDefault SMB payload API hashes:\n\nOffset Hash value API name\n\n0x00a1 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x00c4 0xd4df7045 kernel32.dll_CreateNamedPipeA\n\n0x00d2 0xe27d6f28 kernel32.dll_ConnectNamedPipe\n\n0x00f8 0xbb5f9ead kernel32.dll_ReadFile\n\n0x010d 0xbb5f9ead kernel32.dll_ReadFile\n\n0x0131 0xfcddfac0 kernel32.dll_DisconnectNamedPipe\n\n0x0139 0x528796c6 kernel32.dll_CloseHandle\n\n0x014b 0x56a2b5f0 kernel32.dll_ExitProcess\n\nYara rule for SMB stagers:\n\n### TCP Bind stager x86\n\n\n-----\n\nThe payload size is 332 bytes plus the length of the Customer ID if present. Parameters for\nthe bind API function are stored inside the `SOCKADDR_IN structure hardcoded as two`\ndword pushes. The first `PUSH with the sin_addr value is located on offset 0x00C4. The`\nsecond `PUSH contains sin_port and sin_family values and is located on offset 0x00C9 The`\ndefault sin_family value is `AF_INET (0x02).`\n\nPython parsing:\n\nDefault TCP Bind x86 payload API hashes:\n\nOffset Hash value API name\n\n0x009c 0x0726774c kernel32.dll_LoadLibraryA\n\n0x00ac 0x006b8029 ws2_32.dll_WSAStartup\n\n0x00bb 0xe0df0fea ws2_32.dll_WSASocketA\n\n0x00d5 0x6737dbc2 ws2_32.dll_bind\n\n0x00de 0xff38e9b7 ws2_32.dll_listen\n\n0x00e8 0xe13bec74 ws2_32.dll_accept\n\n0x00f1 0x614d6e75 ws2_32.dll_closesocket\n\n0x00fa 0x56a2b5f0 kernel32.dll_ExitProcess\n\n0x0107 0x5fc8d902 ws2_32.dll_recv\n\n0x011a 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x0128 0x5fc8d902 ws2_32.dll_recv\n\n\n-----\n\n0x013d 0x614d6e75 ws2_32.dll_closesocket\n\nYara rule for TCP Bind x86 stagers:\n\n### TCP Bind stager x64\n\nThe payload size is 510 bytes plus the length of the Customer ID if present. The\n```\nSOCKADDR_IN structure is hard coded inside the MOV instruction as a qword and contains\n\n```\nthe whole structure. The offset for the `MOV instruction is 0x00EC.`\n\nPython parsing:\n\nDefault TCP Bind x64 payload API hashes:\n\nOffset Hash value API name\n\n0x0100 0x0726774c kernel32.dll_LoadLibraryA\n\n0x0111 0x006b8029 ws2_32.dll_WSAStartup\n\n\n-----\n\n0x012d 0xe0df0fea ws2_32.dll_WSASocketA\n\n0x0142 0x6737dbc2 ws2_32.dll_bind\n\n0x0150 0xff38e9b7 ws2_32.dll_listen\n\n0x0161 0xe13bec74 ws2_32.dll_accept\n\n0x016f 0x614d6e75 ws2_32.dll_closesocket\n\n0x0198 0x5fc8d902 ws2_32.dll_recv\n\n0x01b8 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x01d2 0x5fc8d902 ws2_32.dll_recv\n\n0x01ee 0x614d6e75 ws2_32.dll_closesocket\n\nYara rule for TCP Bind x64 stagers:\n\n### TCP Reverse stager x86\n\nThe payload size is 290 bytes plus the length of the Customer ID if present. This payload is\nvery similar to TCP Bind x86 and `SOCKADDR_IN structure is hardcoded on the same offset`\nwith the same double push instructions so we can reuse python parsing code from TCP\nBind x86 payload.\n\nDefault TCP Reverse x86 payload API hashes:\n\nOffset Hash value API name\n\n0x009c 0x0726774c kernel32.dll_LoadLibraryA\n\n\n-----\n\n0x00ac 0x006b8029 ws2_32.dll_WSAStartup\n\n0x00bb 0xe0df0fea ws2_32.dll_WSASocketA\n\n0x00d5 0x6174a599 ws2_32.dll_connect\n\n0x00e5 0x56a2b5f0 kernel32.dll_ExitProcess\n\n0x00f2 0x5fc8d902 ws2_32.dll_recv\n\n0x0105 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x0113 0x5fc8d902 ws2_32.dll_recv\n\nYara rule for TCP Reverse x86 stagers:\n\n### TCP Reverse stager x64\n\nDefault payload size is 465 bytes plus length of Customer ID if present. Payload has the\nsame position as the `SOCKADDR_IN structure such as TCP Bind x64 payload so we can`\nreuse parsing code again.\n\nDefault TCP Reverse x64 payload API hashes:\n\nOffset Hash value API name\n\n0x0100 0x0726774c kernel32.dll_LoadLibraryA\n\n0x0111 0x006b8029 ws2_32.dll_WSAStartup\n\n0x012d 0xe0df0fea ws2_32.dll_WSASocketA\n\n0x0142 0x6174a599 ws2_32.dll_connect\n\n0x016b 0x5fc8d902 ws2_32.dll_recv\n\n\n-----\n\n0x018b 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x01a5 0x5fc8d902 ws2_32.dll_recv\n\n0x01c1 0x614d6e75 ws2_32.dll_closesocket\n\nYara rule for TCP Reverse x64 stagers:\n\n### HTTP stagers x86 and x64\n\nDefault x86 payload size fits 780 bytes and the x64 version is 874 bytes long plus size of\nrequest address string and size of Customer ID if present. The payloads include full request\ninformation stored inside multiple placeholders.\n\nRequest address\n\nThe request address is a plaintext string terminated by null byte located right after the last\npayload instruction without any padding. The offset for the x86 version is 0x030C and\n0x036A for the x64 payload version. Typical format is IPv4.\n\nRequest port\n\nFor the x86 version the request port value is hardcoded inside a `PUSH instruction as a`\ndword. The offset for the `PUSH instruction is 0x00BE. The port value for the x64 version is`\nstored inside `MOV r8d, dword instruction on offset 0x010D.`\n\nRequest query\n\nThe placeholder for the request query has a max size of 80 bytes and the value is a\nplaintext string terminated by a null byte. If the request query string is shorter, then the rest\nof the string space is filled with junk bytes. The placeholder offset for the x86 version is\n0x0143 and 0x0186 for the x64 version.\n\nCobalt Strike and other tools such as Metasploit use a trivial checksum8 algorithm for the\nrequest query to distinguish between x86 and x64 payload or beacon.\n\n\n-----\n\nAccording to leaked Java web server source code, Cobalt Strike uses only two checksum\nvalues, 0x5C (92) for x86 payloads and 0x5D for x64 versions. There are also\nimplementations of Strict stager variants where the request query string must be 5\ncharacters long (including slash). The request query checksum feature isn’t mandatory.\n\nPython implementation of checksum8 algorithm:\n\nMetasploit server uses similar values:\n\n[You can find a complete list of Cobalt Strike’s x86 and x64 strict request queries here.](https://github.com/avast/ioc/tree/master/CobaltStrike/checksum8)\n\nRequest header\n\nThe size of the request header placeholder is 304 bytes and the value is also represented\nas a plaintext string terminated by a null byte. The request header placeholder is located\nimmediately after the Request query placeholder. The offset for the x86 version is 0x0193\nand 0x01D6 for the x64 version.\n\nThe typical request header value for HTTP/HTTPS stagers is User-Agent. The Cobalt Strike\nweb server has banned user-agents which start with lynx, curl or wget and return a\nresponse code 404 if any of these strings are found.\n\n\n-----\n\nAPI function `HttpOpenRequestA is called with following dwFlags ( 0x84600200 ):`\n\nPython parsing:\n\nDefault HTTP x86 payload API hashes:\n\nOffset Hash value API name\n\n0x009c 0x0726774c kernel32.dll_LoadLibraryA\n\n0x00aa 0xa779563a wininet.dll_InternetOpenA\n\n0x00c6 0xc69f8957 wininet.dll_InternetConnectA\n\n0x00de 0x3b2e55eb wininet.dll_HttpOpenRequestA\n\n0x00f2 0x7b18062d wininet.dll_HttpSendRequestA\n\n0x010b 0x5de2c5aa kernel32.dll_GetLastError\n\n0x0114 0x315e2145 user32.dll_GetDesktopWindow\n\n0x0123 0x0be057b7 wininet.dll_InternetErrorDlg\n\n0x02c4 0x56a2b5f0 kernel32.dll_ExitProcess\n\n0x02d8 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x02f3 0xe2899612 wininet.dll_InternetReadFile\n\n\n-----\n\nDefault HTTP x64 payload API hashes:\n\nOffset Hash value API name\n\n0x00e9 0x0726774c kernel32.dll_LoadLibraryA\n\n0x0101 0xa779563a wininet.dll_InternetOpenA\n\n0x0120 0xc69f8957 wininet.dll_InternetConnectA\n\n0x013f 0x3b2e55eb wininet.dll_HttpOpenRequestA\n\n0x0163 0x7b18062d wininet.dll_HttpSendRequestA\n\n0x0308 0x56a2b5f0 kernel32.dll_ExitProcess\n\n0x0324 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x0342 0xe2899612 wininet.dll_InternetReadFile\n\nYara rules for HTTP x86 and x64 stagers:\n\n\n-----\n\n### HTTPS stagers x86 and x64\n\nThe payload structure and placeholders are almost the same as the HTTP stagers. The\ndifferences are only in payload sizes, placeholder offsets, usage of `InternetSetOptionA`\nAPI function (API hash 0x869e4675) and different dwFlags for calling the\n```\nHttpOpenRequestA API function.\n\n```\nThe default x86 payload size fits 817 bytes and the default for the x64 version is 909 bytes\nlong plus size of request address string and size of the Customer ID if present.\n\nRequest address\n\nThe placeholder offset for the x86 version is 0x0331 and 0x038D for the x64 payload\nversion. The typical format is IPv4.\n\nRequest port\n\nThe hardcoded request port format is the same as HTTP. The `PUSH offset for the x86`\nversion is 0x00C3. The `MOV instruction for x64 version is on offset 0x0110.`\n\n\n-----\n\nRequest query\n\nThe placeholder for the request query has the same format and length as the HTTP\nversion. The placeholder offset for the x86 version is 0x0168 and 0x01A9 for the x64\nversion.\n\nRequest header\n\nThe size and length of the request header placeholder is the same as the HTTP version.\nOffset for the x86 version is 0x01B8 and 0x01F9 for the x64 version.\n\nAPI function `HttpOpenRequestA is called with following dwFlags ( 0x84A03200 ):`\n```\nInternetSetOptionA API function is called with following parameters:\n\n```\nPython parsing:\n\nDefault HTTPS x86 payload API hashes:\n\n\n-----\n\nOffset Hash value API name\n\n0x009c 0x0726774c kernel32.dll_LoadLibraryA\n\n0x00af 0xa779563a wininet.dll_InternetOpenA\n\n0x00cb 0xc69f8957 wininet.dll_InternetConnectA\n\n0x00e7 0x3b2e55eb wininet.dll_HttpOpenRequestA\n\n0x0100 0x869e4675 wininet.dll_InternetSetOptionA\n\n0x0110 0x7b18062d wininet.dll_HttpSendRequestA\n\n0x0129 0x5de2c5aa kernel32.dll_GetLastError\n\n0x0132 0x315e2145 user32.dll_GetDesktopWindow\n\n0x0141 0x0be057b7 wininet.dll_InternetErrorDlg\n\n0x02e9 0x56a2b5f0 kernel32.dll_ExitProcess\n\n0x02fd 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x0318 0xe2899612 wininet.dll_InternetReadFile\n\nDefault HTTPS x64 payload API hashes:\n\nOffset Hash value API name\n\n0x00e9 0x0726774c kernel32.dll_LoadLibraryA\n\n0x0101 0xa779563a wininet.dll_InternetOpenA\n\n0x0123 0xc69f8957 wininet.dll_InternetConnectA\n\n0x0142 0x3b2e55eb wininet.dll_HttpOpenRequestA\n\n0x016c 0x869e4675 wininet.dll_InternetSetOptionA\n\n0x0186 0x7b18062d wininet.dll_HttpSendRequestA\n\n0x032b 0x56a2b5f0 kernel32.dll_ExitProcess\n\n0x0347 0xe553a458 kernel32.dll_VirtualAlloc\n\n0x0365 0xe2899612 wininet.dll_InternetReadFile\n\nYara rule for HTTPS x86 and x64 stagers:\n\n\n-----\n\nThe next stage or beacon could be easily downloaded via curl or wget tool:\n\n[You can find our parser for Raw Payloads and all according yara rules in our IoC repository.](https://github.com/avast/ioc/tree/master/CobaltStrike)\n\n## Raw Payloads encoding\n\nCobalt Strike also includes a payload generator for exporting raw stagers and payload in\nmultiple encoded formats. Encoded formats support UTF-8 and UTF-16le.\n\nTable of the most common encoding with usage and examples:\n\nEncoding Usage Example\n\nHex VBS, HTA 4d5a9000..\n\n\n-----\n\nHex Array PS1 0x4d, 0x5a, 0x90, 0x00..\n\nHex Veil PY \\x4d\\x5a\\x90\\x00..\n\nDecimal Array VBA -4,-24,-119,0..\n\nChar Array VBS, HTA Chr(-4)&”H”&Chr(-125)..\n\nBase64 PS1 38uqIyMjQ6..\n\ngzip / deflate compression PS1\n\nXor PS1, Raw payloads, Beacons\n\nDecoding most of the formats are pretty straightforward, but there are few things to\nconsider.\n\nValues inside Decimal and Char Array are splitted via “new lines” represented by\n“\\s_\\n” (\\x20\\x5F\\x0A).\nCommon compression algorithms used inside PowerShell scripts are GzipStream and\nraw DeflateStream.\n\nPython decompress implementation:\n\n### XOR encoding\n\nThe XOR algorithm is used in three different cases. The first case is one byte XOR inside\nPS1 scripts, default value is 35 (0x23).\n\nThe second usage is XOR with dword key for encoding raw payloads or beacons inside PE\nstagers binaries. Specific header for xored data is 16 bytes long and includes start offset,\nxored data size, XOR key and four 0x61 junk/padding bytes.\n\n\n-----\n\nPython header parsing:\n\nWe can create Yara rule based on XOR key from header and first dword of encoded data to\nverify supposed values there:\n\nThe third case is XOR encoding with a rolling dword key, used only for decoding\ndownloaded beacons. The encoded data blob is located right after the XOR algorithm code\nwithout any padding. The encoded data starts with an initial XOR key (dword) and the data\nsize (dword xored with init key).\n\nThere are x86 and x64 implementations of the XOR algorithm. Cobalt Strike resource\nincludes xor.bin and xor64.bin files with precompiled XOR algorithm code.\n\nDefault lengths of compiled x86 code are 52 and 56 bytes (depending on used registers)\nplus the length of the junk bytes. The x86 implementation allows using different register\nsets, so the xor.bin file includes more than 800 different precompiled code variants.\n\n\n-----\n\nYara rule for covering all x86 variants with XOR verification:\n\n\n-----\n\nThe precompiled x64 code is 63 bytes long with no junk bytes. There is also only one\nprecompiled code variant.\n\n\n-----\n\nYara rule for x64 variant with XOR verification:\n\n[You can find our Raw Payload decoder and extractor for the most common encodings here.](https://github.com/avast/ioc/tree/master/CobaltStrike)\nIt uses a parser from the previous chapter and it could save your time and manual work. We\nalso provide an IDAPython script for easy raw payload analysis.\n\n\n-----\n\n## Conclusion\n\nAs we see more and more abuse of Cobalt Strike by threat actors, understanding how to\ndecode its use is important for malware analysis.\n\nIn this blog, we’ve focused on understanding how threat actors use Cobalt Strike payloads\nand how you can analyze them.\n\nThe next part of this series will be dedicated to Cobalt Strike beacons and parsing its\nconfiguration structure.\n\n[Tagged ascobalt strike](https://decoded.avast.io/tag/cobalt-strike/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-08 - Decoding Cobalt Strike- Understanding Payloads.pdf"
    ],
    "report_names": [
        "2021-07-08 - Decoding Cobalt Strike- Understanding Payloads.pdf"
    ],
    "threat_actors": [
        {
            "id": "6ad410c7-e291-4327-a54b-281c23f0d4fa",
            "created_at": "2022-10-25T16:07:24.501468Z",
            "updated_at": "2025-03-27T02:02:10.26052Z",
            "deleted_at": null,
            "main_name": "Karakurt",
            "aliases": [],
            "source_name": "ETDA:Karakurt",
            "tools": [
                "7-Zip",
                "Agentemis",
                "AnyDesk",
                "Cobalt Strike",
                "CobaltStrike",
                "FileZilla",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "WinZip",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2af9bea3-b43e-4a6d-8dc6-46dad6e3ff24",
            "created_at": "2022-10-25T16:47:55.853415Z",
            "updated_at": "2025-03-27T02:05:17.401138Z",
            "deleted_at": null,
            "main_name": "GOLD TOMAHAWK",
            "aliases": [
                "Karakurt Lair",
                "Karakurt Team",
                "Karakurt"
            ],
            "source_name": "Secureworks:GOLD TOMAHAWK",
            "tools": [
                " AnyDesk",
                " MEGA",
                " QuickPacket",
                " Rclone",
                " SendGB",
                "7-ZIP"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535878,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653779588,
    "ts_modification_date": 1653779588,
    "files": {
        "pdf": "https://archive.orkl.eu/fb7808e93e7688064dce57a682ed56b34175504a.pdf",
        "text": "https://archive.orkl.eu/fb7808e93e7688064dce57a682ed56b34175504a.txt",
        "img": "https://archive.orkl.eu/fb7808e93e7688064dce57a682ed56b34175504a.jpg"
    }
}