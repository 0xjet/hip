{
    "id": "f8e1ef48-8154-4731-b1da-a98439994011",
    "created_at": "2023-06-05T02:06:03.024338Z",
    "updated_at": "2025-03-27T02:05:33.936852Z",
    "deleted_at": null,
    "sha1_hash": "639bad8ecfa632b2ed8529876e863a52fc52ea50",
    "title": "2013-06-19 - Your Facebook connection is now secured! Thank you for your support!",
    "authors": "",
    "file_creation_date": "2023-06-04T12:48:05Z",
    "file_modification_date": "2023-06-04T12:48:05Z",
    "file_size": 106710,
    "plain_text": "# Your Facebook connection is now secured! Thank you for your support!\n\n**blog.avast.com/2013/06/18/your-facebook-connection-is-now-secured/**\n\n[Jaromír Hořejší 19 Jun 2013](https://blog.avast.com/author/jarom%C3%ADr-ho%C5%99ej%C5%A1%C3%AD)\n\nYour Facebook connection is now secured! Thank you for your support!\n\nThe title of this blog post may make you think that we will discuss the security of your Facebook account. Not this time. However, I\nwill analyze an attack which starts with a suspicious email sent to the victim's email account.\n\nThe incoming email has the following subject, 'Hey <name> your Facebook account has been closed!' or 'Hi <name> your\n**Facebook account is blocked!'. The email has a ZIP file attachment with name <name>.zip, which contains a downloader file**\nnamed <name>.exe. <name> stands for a random user name. After a user downloads and executes the executable file, he is\npresented with the message saying that \"Your Facebook connection is now secured! Thank you for your support!\" It tries to convince\nyou that there was a problem with your Facebook account, which was later successfully solved by executing the application from the\nemail attachment.\n\nLet's look inside the executable file!\n\n\nfbsec01\n\n\n[Unlike many other malware samples, which use various malware cryptors ( see an article about the interesting one), this malware](https://blog.avast.com/2013/05/29/analysis-of-a-self-debugging-sirefef-cryptor/)\nsample does not use any cryptor. Instead, when observing the instruction flow, we notice many useless registry computations and\nmemory operations, which make it harder to analyze the sample. All text strings and names are encrypted in the malicious file and\ndecrypted on the fly, when needed. In the figure below, you can see many registry and memory operations from address 0x408a8c\nto 0x408aca, whose purpose is to make it difficult to understand the original function of the code.\n\n\n-----\n\nfbsec21\n\n\nWhenever I get a suspicious file, I start OllyDbg and begin analyzing the file. In the case of this sample, I loaded it in OllyDbg, made\nit run and the following error message box appeared.\n\n\nfbsec02\n\n\n-----\n\nThen I tried to figure out what could be wrong with the sample I just started to analyze. In the beginning, there is a loop with 0x109\n265 iterations. In each iteration, a new thread is created.\n\n\nfbsec03\n\n\nEach thread executes its own thread function, in which it creates a manual-reset event object ( CreateEventA ), which requires the\nuse of functions ResetEvent or SetEvent to change the event state. Later on, the function WaitForSingleObject with timeout 0x2710\n= 10000 ms = 10 seconds makes the thread wait for setting the state of the event manually. If the state of the event is set or if its\ntimeout expires, a DWORD value at addressOfProcedure is XORed with a certain value unique for each thread. These per-thread\nunique values are taken from arrayOfDwords table, which starts at address 0x422488 ( file offset 0x20a88 ).\n\n\nfbsec04\n\n\n-----\n\nfbsec05\n\n\nAn application then sets events for the four given threads, which causes function WaitForSingleObject to end immediately. DWORD\nat addressOfProcedure is then XORed with the four corresponding values from arrayOfDwords. After these four XOR operations,\naddressOfProcedure contains the address of function which will be called by the main program.\n\n\nfbsec06\n\n\n-----\n\nfbsec07\n\n\nIn our situation, the thread to be woken up are 0xbf, 0xd4x 0xd3x 0xf5. In arrayOfDwords, the thread unique values are stored at\naddresses\n\n0x20a88 + 0xbf*4 = 0x20d84\n\n0x20a88 + 0xd4*4 = 0x20dd8\n\n0x20a88 + 0xd3*4 = 0x20dd4\n\n0x20a88 + 0xf5*4 = 0x20e5c\n\nfrom where we can get per-thread unique values, which after being XORed give us the following result:\n\n0x9329c591 XOR 0xc3b12028 XOR 0x732eb78b XOR 0x23f618f2 = 0x00404ac0\n\nTherefore the next address of execution will be 0x404ac0.\n\n\n-----\n\nfbsec08\n\n\nfbsec09\n\n\nWhile 261 out of 265 created threads are still sleeping (and waiting for the event being set or timeout interval to elapse) just four\nthreads are woken up, and these threads compute the function address which will be called. OllyDbg cannot handle this situation\ncorrectly, computes the wrong destination address and therefore displays the above mentioned error message. After 10 seconds,\n\n\n-----\n\ntimeouts of all threads will elapse and addressOfProcedure will be modified to an invalid address value, however, it will happen after\nthe program already jumped to address 0x404ac0 and DWORD value at addressOfProcedure is no longer important.\n\nAfter executing the procedure from address 0x404ac0, the main program body begins. The program flow can be split into three main\nbranches. At first, the program tries to find out, if it was executed with a command line parameter containing string\nWATCHDOGPROC. If yes, the left (red) branch is chosen. If not, the right (green) branch is executed.\n\n\nfbsec10\n\n\nIf WATCHDOGPROC string in command line parameters was not found, then there is another branch asking if the name of the\ncurrent executable is usfqvololjv.exe. If not, we take the left (red) branch.\n\n\nfbsec11\n\n\nIn this (left) branch, the file copies itself into %APPDATA%\\ltrhborczvnt\\usfqvololjv.exe, executed itself, establishes persistence via\nregistry key, displays the message \"Your Facebook connection is now secured! Thank you for your support! Facebook\" and\nterminates.\n\n\n-----\n\nfbsec12\n\n\n-----\n\nfbsec13\n\n\nThe whole process is repeated again, but now the condition where the current program name is compared with usfqvololjv.exe is\nsatisfied. We can see that usfqvololjv.exe copies itself under another name tjsotyw.exe and executes it with commandline parameter\n\"WATCHDOGPROC usfqvololjv.exe\".\n\n\n-----\n\nfbsec14\n\n\nNow it becomes clear that usfqvololjv.exe is a master process and tjsotyw.exe is a slave process.\n\n\nfbsec15\n\n\nThe master process (usfqvololjv.exe) then continues into an internet communication loop, which generates traffic to seemingly\nlegitimate websites. The URL address is always in format <WORD1><WORD2>.net/forum/search.php?email=\n<EMAIL_ADDRESS>&method=post\n\n\n-----\n\nfbsec16\n\n\nThe only task of the slave process is to check if the master process is running. If not, it restarts the master process. Similarly, if the\nmaster process finds out that the slave process is not running, it restarts the slave process, so both processes keep running all the\ntime, keeping an eye one on another.\n\nDomain names are generated by an algorithm, which uses the value of the current time. It starts with obtaining the current Unix\nepoch time, which is a system for describing time, defined as the number of seconds that have elapsed since 00:00:00 Coordinated\nUniversal Time (UTC), 1 January 1970. This number is then divided by 0x200 = 512. Time is then divided into 512 seconds = 8\nminutes 32 seconds long time chunks.\n\nLet's look at a particular example. For the time interval between \"Fri, 07 Jun 2013 12:45:52 GMT\" and \"Fri, 07 Jun 2013 12:54:23\nGMT\", we get Unix epoch times between 0x51B1D600 and 0x51B1D7FF. After dividing any of the numbers between previously\nmentioned borders by 0x200 = 512, we get the following result.\n\n\n-----\n\nfbsec17\n\n\nThe result (0x28d8eb) is then converted to its binary form and its last 15 binary digits are reordered (LSB bit of 0x28d8eb goes to the\n3rd position, the second LSB bit goes to 9th position, etc...). From the newly reordered 15 binary digits, the first 7 binary digits form a\nnumber, which gives us an index of the first word in the table of words. The last 8 digits form another number, which gives us an\nindex of the second word in the table of words. These two words are then concatenated and a generic top-level domain .net is\nappended. The following picture illustrates how this domain-generation algorithm works.\n\n\nfbsec18\n\n\nThe table of words is constant and encrypted in the original file. There are exactly 384 words in this table. As I mentioned above,\nfrom the current time stamp, a 15 digit number is generated. From this number, the first 7 digits give us 128 possibilities (2^7), last 8\ndigits give us 256 possibilities (2^8), which makes a total of 128 + 256 = 384 words. If we choose one word from the first group and\n\n\n-----\n\none word from the second group, it gives us a total count of 128 256 32768 possible domains, which may be contacted.\n\n\nfbsec19\n\n\nHowever, the domain-generation algorithm does not try to connect to only one website withing a given 8.5 minute time chunk. It tries\n0x55 = 85 domains for numbers following 0x28d8eb, i.e. 0x28d8eb, 0x28d8ec, 0x28d8ed, 0x28d8ee ... 0x28D93f. When all 85\npossibilities are tried, then the time stamp is taken again and the whole process repeats.\n\nWhen a payload is downloaded after a successful connection to the generated domain, it is then written to %TEMP% directory,\nnamed g52<random>arg.exe and executed.\n\n\nfbsec20\n\n\n-----\n\nConclusion:\n\nObfuscation does not need to be done with a cryptor. Filling the code with many useless registry and memory instructions can do the\nsame job.\n\nMalware authors often use domain-generation algorithms. If malware connects to just a few websites to get updates or payloads, it\nis easy to block these domains and make malware ineffective. However, in the case of generating many domain names via domaingeneration algorithms, it is often impossible to block all the randomly generated domains, either because of their huge number or\nbecause of the fact, that some of these domains may be legitimate websites.\n\nSHAs:\nEC8B88A96D1B4917334BDAD7F2E580EAD4D9B71D111A1591BB5B965DA3E27CF6\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2013/2013-06-19 - Your Facebook connection is now secured! Thank you for your support!.pdf"
    ],
    "report_names": [
        "2013-06-19 - Your Facebook connection is now secured! Thank you for your support!.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1685930763,
    "ts_updated_at": 1743041133,
    "ts_creation_date": 1685882885,
    "ts_modification_date": 1685882885,
    "files": {
        "pdf": "https://archive.orkl.eu/639bad8ecfa632b2ed8529876e863a52fc52ea50.pdf",
        "text": "https://archive.orkl.eu/639bad8ecfa632b2ed8529876e863a52fc52ea50.txt",
        "img": "https://archive.orkl.eu/639bad8ecfa632b2ed8529876e863a52fc52ea50.jpg"
    }
}