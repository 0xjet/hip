{
    "id": "71c5fa2a-9b6c-4051-92d9-dd3e7ace37a7",
    "created_at": "2022-10-25T16:48:11.020757Z",
    "updated_at": "2025-03-27T02:17:14.84657Z",
    "deleted_at": null,
    "sha1_hash": "57578072d22b95901e875f19cfb7ead3002d07f1",
    "title": "Operation Dragon Castling: APT group targeting betting companies",
    "authors": "Avast",
    "file_creation_date": "2022-04-03T19:45:59Z",
    "file_modification_date": "2022-04-03T19:45:59Z",
    "file_size": 982179,
    "plain_text": "# Operation Dragon Castling: APT group targeting betting companies\n\n**[decoded.avast.io/luigicamastra/operation-dragon-castling-apt-group-targeting-betting-companies](https://decoded.avast.io/luigicamastra/operation-dragon-castling-apt-group-targeting-betting-companies/)**\n\nMarch 22, 2022\n\n## Introduction\n\nWe recently discovered an `APT campaign we are calling` `Operation Dragon Castling . The campaign is`\ntargeting what appears to be betting companies in `South East Asia, more specifically companies located`\nin `Taiwan, the` `Philippines, and` `Hong Kong . With moderate confidence, we can attribute the campaign`\nto a `Chinese speaking APT group, but unfortunately cannot attribute the attack to a specific group and`\nare not sure what the attackers are after.\n\nWe found notable code similarity between one of the modules used by this APT group (the `MulCom`\n```\nbackdoor ) and the FFRat samples described by the BlackBerry Cylance Threat Research Team in\n\n```\ntheir `2017 report and` `Palo Alto Networks in their` `2015 report. Based on this, we suspect that the`\nFFRat codebase is being shared between several Chinese adversary groups. Unfortunately, this is not\nsufficient for attribution as FFRat itself was never reliably attributed.\n\nIn this blogpost we will describe the malware used in these attacks and the backdoor planted by the APT\ngroup, as well as other malicious files used to gain persistence and access to the infected machines. We will\nalso discuss the two infection vectors we saw being used to deliver the malware: an infected installer and\nexploitation of a vulnerable legitimate application, `WPS` `Office .`\n\n[We identified a new vulnerability (CVE-2022-24934) in the WPS Office updater wpsupdate.exe, which we](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-24934)\nsuspect that the attackers abused.\n\nWe would like to thank Taiwan’s `TeamT5 for providing us with IoCs related to the infection vector.`\n\n## Infrastructure and toolset\n\n\n-----\n\nIn the diagram above, we describe the relations between the malicious files. Some of the relations might not\nbe accurate, e.g. we are not entirely sure if the MulCom backdoor is loaded by the `CorePlugin . However, we`\nstrongly believe that it is one of the malicious files used in this campaign.\n\n## Infection Vector\n\nWe’ve seen multiple infection vectors used in this campaign. Among others, an attacker sent an email with an\ninfected installer to the support team of one of the targeted companies asking to check for a bug in their\nsoftware. In this post, we are going to describe another vector we’ve seen: a fake `WPS Office update`\npackage. We suspect an attacker exploited a bug in the WPS updater wpsupdate.exe, which is a part of the\nWPS Office installation package. We have contacted WPS Office team about the vulnerability ( CVE-2022```\n24934 ), which we discovered, and it has since been fixed.\n\n```\nDuring our investigation we saw suspicious behavior in the WPS updater process. When analyzing the binary\nwe discovered a potential security issue that allows an attacker to use the updater to communicate with a\nserver controlled by the attacker to perform actions on the victim’s system, including downloading and\nrunning arbitrary executables. To exploit the vulnerability, a registry key under `HKEY_CURRENT_USER` needs\nto be modified, and by doing this an attacker gains persistence on the system and control over the update\nprocess. In the case we analyzed, the malicious binary was downloaded from the domain `update.wps[.]cn,`\nwhich is a domain belonging to `Kingsoft, but the serving IP ( 103.140.187.16 ) has no relationship to the`\ncompany, so we assume that it is a fake update server used by the attackers.\n\nThe downloaded binary ( setup_CN_2052_11.1.0.8830_PersonalDownload_Triale.exe ```\nB9BEA7D1822D9996E0F04CB5BF5103C48828C5121B82E3EB9860E7C4577E2954 ) drops two files for\n\n```\n\n-----\n\nsideloading: a signed `QMSpeedupRocketTrayInjectHelper64.exe - Tencent Technology`\n```\n(a3f3bc958107258b3aa6e9e959377dfa607534cc6a426ee8ae193b463483c341) and a malicious DLL\n\n```\n```\nQMSpeedupRocketTrayStub64.dll.\n\n```\n\n## Dropper 1 (QMSpeedupRocketTrayStub64.dll)\n\n76adf4fd93b70c4dece4b536b4fae76793d9aa7d8d6ee1750c1ad1f0ffa75491\n\nThe first stage is a backdoor communicating with a C&C ( mirrors.centos.8788912[.]com ). Before\ncontacting the C&C server, the backdoor performs several preparational operations. It hooks three functions:\n```\nGetProcAddress, FreeLibrary, LdrUnloadDll . To get the C&C domain, it maps itself to the memory\n\n```\nand reads data starting at the offset `1064` from the end. The domain name is not encrypted in any way and\nis stored as a wide string in clear text in the binary.\n\nThen it initializes an object for a `JScript class with the named item` `ScriptHelper . The dropper uses the`\n\n`ImpersonateLoggedOnUser` API Call to re-use a token from `explorer.exe so it effectively runs under the`\nsame user. Additionally, it uses `RegOverridePredefKey` to redirect the current `HKEY_CURRENT_USER` to\n\n`HKEY_CURRENT_USER` of an impersonated user. For communication with C&C it constructs a UserAgent\nstring with some system information e.g. `Mozilla/4.0 (compatible; MSIE 9.0; Windows NT 6.1;.NET`\n```\nCLR 2.0). The information that is exfiltrated is: Internet Explorer version, Windows\nversion, the value of the “User Agent\\Post Platform” registry values.\n\n```\nAfter that, the sample constructs `JScript` code to execute. The header of the code contains definitions of\ntwo variables: `server with the C&C domain name and a hardcoded` `key . Then it sends the HTTP` `GET`\nrequest to `/api/connect, the response should be encrypted` `JScript` code that is decrypted, appended to\nthe constructed header and executed using the `JScript` class created previously.\n\nAt the time of analysis, the C&C was not responding, but from the telemetry data we can conclude that it was\ndownloading the next stage from\n```\nhxxp://mirrors.centos.8788912.com/upload/ea76ad28a3916f52a748a4f475700987.exe to\n%ProgramData%\\icbc_logtmp.exe and executing it.\n\n## Dropper 2 (IcbcLog)\n\n```\na428351dcb235b16dc5190c108e6734b09c3b7be93c0ef3d838cf91641b328b3\n\nThe second dropper is a runner that, when executed, tries to escalate privileges via the `COM Session`\n\n`Moniker Privilege` Escalation `(MS17-012), then dropping a few binaries, which are stored with the`\nfollowing resource IDs:\n\n\n-----\n\n**Resource ID** **Filename** **Description**\n\n1825 smcache.dat List of C&C domains\n\n1832 log.dll Loader (CoreX) 64bit\n\n1840 bdservicehost.exe Signed PE for sideloading 64bit\n\n1841 N/A Filenames for sideloading\n\n1817 inst.dat Working path\n\n1816 hostcfg.dat Used in the Host header, in C&C communication\n\n1833 bdservicehost.exe Signed PE for sideloading 32bit – N/A\n\n1831 log.dll Loader (32bit) – N/A\n\nThe encrypted payloads have the following structure:\n\nThe encryption key is a wide string starting from offset `0x8 . The encrypted data starts at the offset` `0x528 .`\nTo decrypt the data, a SHA256 hash of the key is created using `CryptHashData` API, and is then used with a\nhard-coded IV 0123456789abcde to decrypt the data using `CryptDecrypt` API with the `AES256`\nalgorithm. After that, the decrypted data is decompressed with `RtlDecompressBuffer . To verify that the`\ndecryption went well, the `CRC32 of the data is computed and compared to the value at the offset` `0x4` of\nthe original resource data. When all the payloads are dropped to the disk, `bdservicehost.exe` is executed\nto run the next stage.\n\n## Loader (CoreX)\n\n97c392ca71d11de76b69d8bf6caf06fa3802d0157257764a0e3d6f0159436c42\n\nThe `Loader (CoreX)` DLL is sideloaded during the previous stage `(Dropper 2) and acts as a dropper.`\nSimilarly to `Dropper 1, it hooks the` `GetProcAddress` and `FreeLibrary` API functions. These hooks\nexecute the main code of this library. The main code first checks whether it was loaded by `regsvr32.exe`\nand then it retrieves encrypted data from its resources. This data is dropped into the same folder as\n```\nsyscfg.dat . The file is then loaded and decrypted using AES-256 with the following options for setup:\n\n```\nKey is the computer name and IV is `qwertyui12345678`\nAES-256 setup parameters are embedded in the resource in the format `<key>#<IV> . So you may e.g.`\nsee `cbfc2vyuzckloknf#8o3yfn0uee429m8d`\n\nAES-256 setup parameters\n\nThe main code continues to check if the process `ekrn.exe is running.` `ekrn.exe is an ESET Kernel`\nservice. If the ESET Kernel service is running, it will try to remap `ntdll.dll . We assume that this is used to`\nbypass `ntdll.dll hooking.`\n\n\n-----\n\nAfter a service check, it will decompress and execute shellcode, which in turn loads a DLL with the next stage.\nThe DLL is stored, unencrypted, as part of the shellcode. The shellcode enumerates exports of `ntdll.dll`\nand builds an array with hashes of names of all `Zw* functions (windows native API system calls) then sorts`\nthem by their RVA. By doing this, the shellcode exploits the fact that the order of RVAs of `Zw* functions`\nequals the order of the corresponding syscalls, so an index of the `Zw* function in this array is a syscall`\nnumber, which can be called using the syscall instruction. Security solutions can therefore be bypassed based\non the hooking of the API in userspace. Finally, the embedded core module DLL is loaded and executed.\n\n## Proto8 (Core module)\n\nf3ed09ee3fe869e76f34eee1ef974d1b24297a13a58ebff20ea4541b9a2d86c7\n\nThe core module is a single DLL that is responsible for setting up the malware’s working directory, loading\nconfiguration files, updating its code, loading plugins, beaconing to C&C servers and waiting for commands.\n\nIt has a cascading structure with four steps:\n\n### Step 1\n\nThe first part is dedicated to initial checks and a few evasion techniques. At first, the core module verifies that\nthe DLL is being run by `spdlogd.exe (an executable used for persistence, see below) or that it is not being`\nrun by `rundll32.exe. If this check fails, the execution terminates. The DLL proceeds by hooking the`\n\n`GetProcAddress` and `FreeLibrary` functions in order to execute the main function, similarly to the\nprevious infection stages.\n\n_The GetProcAddress hook contains an interesting debug output “in googo”._\n\nThe malware then creates a new window (named `Sample ) with a custom callback function. A message with`\nthe ID `0x411` is sent to the window via `SendMessageW which causes the aforementioned callback to`\nexecute the main function. The callback function can also process the `0x412` message ID, even though no\nspecific functionality is tied to it.\n\n_Exported function Core2 sends message 0x411_\n\n\n-----\n\n_Exported function Ldr2 sends message 0x412_\n\n_The window callback only contains implementation for message 0x411_\n\n_but there is a check for 0x412 as well_\n\n### Step 2\n\nIn the second step, the module tries to self-update, load configuration files and set up its working directory\n(WD).\n\n**Self-update**\n\n\n-----\n\nThe malware first looks for a file called `new_version.dat – if it exists, its content is loaded into memory,`\nexecuted in a new thread and a debug string `“run code ok” is printed out. We did not come across this file,`\nbut based on its name and context, this is most likely a self update functionality.\n\nLoad configuration file `inst.dat` and set up working directory. First, the core module configuration file\ninst.dat is searched for in the following three locations:\n\nthe directory where the core module DLL is located\nthe directory where the EXE that loaded the core module DLL it is located\n\n```\nC:\\ProgramData\\\n\n```\n\nIt contains the path to the malware’s working directory in plaintext. If it is not found, a hard-coded directory\nname is used and the directory is created. The working directory is a location the malware uses to drop or\nread any files it uses in subsequent execution phases.\n\nLoad configuration file `smcache.dat .`\n\nAfter the working directory is set up, the sample will load the configuration file `smcache.dat from it. This`\nfile contains the domains, protocols and port numbers used to communicate with C&C servers (details in Step\n4) plus a `“comment” string. This string is likely used to identify the campaign or individual victims. It is`\nused to create an empty file on the victim’s computer (see below) and it’s also sent as a part of the initial\nbeacon when communicating with C&C servers. We refer to it as the “comment string” because we have\nseen a few versions of smcache.dat where the content of the string was “the comment string here” and\nit is also present in another configuration file with the name `comment.dat which has the INI file format and`\ncontains this string under the key COMMENT.\n\nCreate a `log` file\n\nRight after the sample finds and reads smcache.dat, it creates a file based on the victim’s username and the\ncomment string from smcache.dat. If the comment string is not present, it will use a default hard-coded value\n(for example `M86_99.lck ). Based on the extension it could be a log of some sort, but we haven’t seen any`\npart of the malware writing into it so it could just serve as a lockfile. After the file is successfully created, the\nmalware creates a mutex and goes on to the next step.\n\n### Step 3\n\nNext, the malware collects information about the infected environment (such as username, DNS and NetBios\ncomputer names as well as OS version and architecture) and sets up its internal structures, most notably a list\nof `“call objects” . Call objects are structures each associated with a particular function and saved into a`\n```\n“dispatcher” structure in a map with hard-coded 4-byte keys. These keys are later used to call the\n\n```\nfunctions based on commands from C&C servers.\n\nThe key values (IDs) seem to be structured, where the first three bytes are always the same within a given\nsample, while the last byte is always the same for a given usage across all the core module samples that we’ve\nseen. For example, the function that calls the `RevertToSelf` function is identified by the number\n\n\n-----\n\n`0x20210326` in some versions of the core module that we ve seen and `0x19181726` in others. This\nsuggests that the first three bytes of the ID number are tied to the core module version, or more likely the\ninfrastructure version, while the last byte is the actual ID of a function.\n\n**ID (last byte)** **Function description**\n\n0x02 unimplemented function\n\n0x19 retrieves content of `smcache.dat and sends it to the C&C server`\n\n0x1A writes data to `smcache.dat`\n\n0x25 impersonates the logged on user or the explorer.exe process\n\n0x26 function that calls `RevertToSelf`\n\n0x31 receives data and copies it into a newly allocated executable buffer\n\n0x33 receives core plugin code, drops it on disk and then loads and calls it\n\n0x56 writes a value into `comment.dat`\n\n**Webdav**\n\nWhile initializing the call objects the core module also tries to connect to the URL\n\n`hxxps://dav.jianguoyun.com/dav/ with the username` `12121jhksdf` and password `121121212` by\ncalling `WNetAddConnection3W . This address was not responsive at the time of analysis but`\n```\njianguoyun[.]com is a Chinese file sharing service. Our hypothesis is that this is either a way to get plugin\n\n```\ncode or an updated version of the core module itself.\n\n**Plugins**\n\nThe core module contains a function that receives a buffer with plugin DLL data, saves it into a file with the\nname `kbg<tick_count>.dat in the malware working directory, loads it into memory and then calls its`\nexported function `InitCorePlug . The plugin file on disk is set to be deleted on reboot by calling`\n\n`MoveFileExW` with the parameter `MOVEFILE_DELAY_UNTIL_REBOOT . For more information about the`\nplugins, see the dedicated Plugins section.\n\n### Step 4\n\nIn the final step, the malware will iterate over C&C servers contained in the smcache.dat configuration file\nand will try to reach each one. The structure of the `smcache.dat config file is as follows:`\n\nThe protocol string can have one of nine possible values:\n\n\n-----\n\nDepending on the protocol tied to the particular C&C domain, the\nmalware sets up the connection, sends a beacon to the C&C and\nwaits for commands.\n\nIn this blogpost, we will mainly focus on the HTTP protocol option\nas we’ve seen it being used by the attackers.\n\nThe structure of the `smcache.dat config`\n\nfile\n\nWhen using the HTTP protocol, the core module first opens two persistent request handles – one for `POST`\nand one for `GET` requests, both to `“/connect” . These handles are tested by sending an empty buffer in the`\n\n`POST` request and checking the HTTP status code of the `GET` request. Following this, the malware sends\nthe initial beacon to the C&C server by calling the `InternetWriteFile` API with the previously opened\n\n`POST` request handle and reads data from the `GET` request handle by calling `InternetReadFile .`\n\nHTTP packet order\n\n\n-----\n\nHTTP POST beacon\n\nThe core module uses the following (mostly hard-coded) HTTP headers:\n```\n   Accept: */*\n\n```\n`x-cid: {<uuid>} – new uuid is generated for each` `GET/POST` request pair\n```\n   Pragma: no-cache\n   Cache-control: no-transform\n   User-Agent: <user_agent> – generated from registry or hard-coded (see below)\n   Host: <host_value> – C&C server domain or the value from hostcfg.dat (see below)\n   Connection: Keep-Alive\n   Content-Length: 4294967295 (max uint, only in the POST request)\n\n```\n**User-Agent header**\n\nThe User-Agent string is constructed from the registry the same way as in the `Dropper 1 module (including`\nthe logged-on user impersonation when accessing registry) or a hard-coded string is used if the registry access\nfails: `“Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET`\n```\nCLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)” .\n\n```\n**Host header**\n\nWhen setting up this header, the malware looks for either a resource with the ID 1816 or a file called\n```\nhostcfg.dat if the resource is not found. If the resource or file is found, the content is used as the value in\n\n```\nthe `Host` HTTP header for all C&C communication instead of the C&C domain found in `smcache.dat . It`\ndoes not change the actual C&C domain to which the request is made – this suggests the possibility of the\nC&C server being behind a reverse proxy.\n\n**Initial beacon**\n\nThe first data packet the malware sends to a C&C server contains a base64 encoded LZNT1-compressed\nbuffer, including a newly generated uuid (different from the uuid used in the x-cid header), the victim’s\nusername, OS version and architecture, computer DNS and BIOS names and the comment string found in\n\n`smcache.dat` or comment.dat . The value from `comment.dat takes precedence if this file exists.`\n\nIn the core module sample we analyzed, there was actually a typo in the function that reads the value from\n\n`comment.dat` – it looks for the key “COMMNET” instead of `“COMMENT” .`\n\n\n-----\n\nAfter this, the malware enters a loop waiting for commands from the C&C server in the form of the ID value of\none of the call objects.\nEach message sent to the C&C server contains a hard-coded four byte number value with the same structure\nas the values used as keys in the call-object map. The ID numbers associated with messages sent to C&C\nservers that we’ve seen are:\n\n**ID (last byte)** **Usage**\n\n0x1B message to C&C which contains `smcache.dat` content\n\n0x24 message to C&C which contains a debug string\n\n0x2F general message to C&C\n\n0x30 message to C&C, unknown specific purpose\n\n0x32 message to C&C related to plugins\n\n0x80 initial beacon to a C&C server\n\nInteresting observations about the protocols, other than the HTTP protocol:\n\nHTTPS does not use persistent request handles\nHTTPS uses HTTP `GET` request with data Base64-encoded in the cookie header to send the initial\nbeacon\nHTTPS, TCP and UDP use a custom “magic” header: `Magic-Code: hhjjdfgh`\n\n### General observations on the core module\n\nThe core samples we observed often output debug strings via `OutputDebugStringA` and\n\n`OutputDebugStringW` or by sending them to the C&C server. Examples of debug strings used by the core\nmodule are: its filepath at the beginning of execution, `“run code ok” after self-update,` `“In googo” in`\nthe hook of `GetProcAddress,` `“recv bomb” and` `“sent bomb” in the main C&C communicating`\nfunction, etc.\n\n**String obfuscation**\n\nWe came across samples of the core module with only cleartext strings but also samples with certain strings\nobfuscated by XORing them with a unique (per sample) hard-coded key.\n\nEven within the samples that contain obfuscated strings, there are many cleartext strings present and there\nseems to be no logic in deciding which string will be obfuscated and which won’t. For example, most format\nstrings are obfuscated, but important IoCs such as credentials or filenames are not.\n\nTo illustrate this: most strings in the function that retrieves a value from the comment.dat file are obfuscated\nand the call to `GetPrivateProfileStringW` is dynamically resolved by the `GetProcAddress` API, but all\nthe strings in the function that writes into the same config file are in cleartext and there is a direct call to\n\n\n-----\n\n```\nWritePrivateProfileStringW .\n\n```\nOverall, the core module code is quite robust and contains many failsafes and options for different scenarios\n(for example, the amount of possible protocols used for C&C communication), however, we probably only saw\nsamples of this malware that are still in active development as there are many functions that are not yet\nimplemented and only serve as placeholders.\n\n### Plugins\n\nIn the section below, we will describe the functionality of the plugins used by the `Core Module (Proto8) to`\nextend its functionality.\n\nWe are going to describe three plugins with various functionalities, such as:\n\nAchieving persistence\nBypassing UAC\nRegistering an RPC interface\nCreating a new account\nBackdoor capabilities\n\n**Core Plugin**\n\n0985D65FA981ABD57A4929D8ECD866FC72CE8C286BA9EB252CA180E280BD8755\n\nThis plugin is a DLL binary loaded by the fileless core module ( Proto8 ) as mentioned above. It extends the\nmalware’s functionality by adding methods for managing additional plugins. These additional plugins export\nthe function `\"GetPlugin\" which the core plugin executes.`\n\nThis part uses the same command ID based calling convention as the core module (see above), adding three\nnew methods:\n\n**ID (last byte)** **Function description**\n\n0x2B send information about plugin location to the to C&C server\n\n0x2C remove a plugin\n\n0x2A load a plugin\n\nAll plugin binaries used by the core module are stored in the working directory under the name\n```\nkbg<tick_count>.dat . After the Core Plugin is loaded, it first removes all plugins from the working\n\n```\ndirectory – see the image below.\n\n\n-----\n\n**Zload(Atomx.dll,xps1.dll)**\n\n2ABC43865E49F8835844D30372697FDA55992E5A6A13808CFEED1C37BA8F7876\n\nThe DLL we call `Zload` is an example of a plugin loaded by the `Core Plugin . It exports four functions:`\n```\n“GetPlugin”, “Install”, “core_zload” and ”zload” . The main functionality of this plugin is setting\n\n```\nup persistence, creating a backdoor user account, and concealing itself on the infected system. We will focus\non the exported functions `zload,` `core_zload and the default` `DllMain` function, as they contain the\nmost interesting functionality.\n\nZload (process starter)\n\nThis function is fairly simple, its main objective is to execute another binary. It first retrieves the path to the\ndirectory where the `Zload` plugin binary is located `(<root_folder>) and creates a new subfolder called`\n\n`\"mec\"` in it. After this it renames and moves three files into it:\n\nthe `Zload` plugin binary itself as <root_folder>\\mec\\logexts.dll,\n```\n   <root_folder>\\spdlogd.exe as <root_folder>\\mec\\spdagent.exe and\n   <root_folder>\\kb.ini as <root_folder>\\mec\\kb.ini\n\n```\nAfter the files are renamed and moved, it creates a new process by executing the binary\n```\n<root_folder>\\mec\\spdagent.exe (originally <root_folder>\\spdlogd.exe ).\n\n```\ncore_zload (persistence setup)\n\nThis function is responsible for persistence which it achieves by registering itself into the list of security\nsupport providers (SSPs). Windows SSP DLLs are loaded into the `Local Security Authority (LSA)`\nprocess when the system boots. The code of this function is notably similar to the\n```\nmimikat_ssp/AddSecurityPackage_RawRPC source code found on github.\n\n```\nDllMain (sideloading, setup)\n\nThe default DllMain function leverages several persistence and evasion techniques. It also allows the attacker\nto create a backdoor account on the infected system and lower the overall system security.\n\n\n-----\n\nPersistence\n\nThe plugin first checks if its DLL was loaded either by the processes `“lsass.exe” or “spdagent.exe” . If`\nthe DLL was loaded by `“spdagent.exe”, it will adjust the token privileges of the current process.`\n\nIf it was loaded by `“lsass.exe”, it will retrieve the path` `“kb<num>.dll” from the configuration file`\n```\n“kb.ini” and write it under the registry key\nHKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\WinSock2\\\\Parameters\nAutodialDLL . This ensures persistence, as it causes the DLL “kb<num>.dll” to be loaded each time the\n\n```\nWinsock 2 library ( ws2_32.dll ) is invoked.\n\nEvasion\n\nTo avoid detection, the plugin first checks the list of running processes for `“avp.exe” (Kaspersky Antivirus)`\nor `“NortonSecurity.exe” and exits if either of them is found. If these processes are not found on the`\nsystem, it goes on to conceal itself by changing its own process name to `“explorer.exe” .`\n\nThe plugin also has the capability to bypass the UAC mechanisms and to elevate its process privileges through\n```\nCMSTP COM interfaces, such as CMSTPLUA {3E5FC7F9-9A51-4367-9063-A120244FBEC7} .\n\n```\nBackdoor user account creation\n\nNext, the plugin carries out registry manipulation (details can be found in the appendix), that lowers the\nsystem’s protection by:\n\nAllowing local accounts to have full admin rights when they are authenticating via network logon\nEnabling RDP connections to the machine without the user password\nDisabling admin approval on an administrator account, which means that all applications run with full\nadministrative privileges\nEnabling anonymous SID to be part of the everyone group in Windows\nAllowing `“Null Session” users to list users and groups in the domain`\nAllowing `“Null Session” users to access shared folders`\nSetting the name of the pipe that will be accessible to “Null Session” users\n\nAfter this step, the plugin changes the `WebClient` service startup type to `“Automatic” . It creates a new`\nuser with the name `“DefaultAccount” and the password` `“Admin@1999!” which is then added to the`\n```\n“Administrator” and “Remote Desktop Users” groups. It also hides the new account on the logon\n\n```\nscreen.\n\nAs the last step, the plugin checks the list of running processes for process names `“360tray.exe” and`\n```\n“360sd.exe” and executes the file \"spdlogd.exe\" if neither of them is found.\n\n```\n**MecGame(kb%num%.dll)**\n\n4C73A62A9F19EEBB4FEFF4FDB88E4682EF852E37FFF957C9E1CFF27C5E5D47AD\n\nMecGame is another example of a plugin that can be loaded by the `Core Plugin . Its main purpose is`\nsimilar to the previously described `Zload plugin – it executes the binary` `“spdlogd.exe” and achieves`\npersistence by registering an RPC interface with `UUID {1052E375-2CE2-458E-AA80-F3B7D6EA23AF} . This`\nRPC interface represents a function that decodes and executes a base64 encoded shellcode.\n\nThe `MecGame` plugin has several methods for executing spdlogd.exe depending on the level of available\nprivileges. It also creates a lockfile with the name `MSSYS.lck or` `<UserName>-XPS.lck depending on the`\nname of the process that loaded it, and deletes the files `atomxd.dll` and logexts.dll .\n\n\n-----\n\nIt can be installed as a service with the service name `inteloem` or can be loaded by any executable that\nconnects to the internet via the `Winsock2 library.`\n\n**MulCom**\n\nABA89668C6E9681671A95B3D7A08AAE2A067DEED2D835BA6F6FD18556C88A5F2\n\nThis DLL is a backdoor module which exports four functions: `“OperateRoutineW”,` `“StartRoutineW”,`\n```\n“StopRoutineW” and ”WorkRoutineW” ; the main malicious function being “StartRoutineW” .\n\n```\nFor proper execution, the backdoor needs configuration data accessed through a shared object with the file\nmapping name either `“Global\\\\4ED8FD41-2D1B-4CC3-B874-02F0C60FF9CB” or` `\"Local\\\\4ED8FD41-`\n```\n2D1B-4CC3-B874-02F0C60FF9CB” . Unfortunately we didn’t come across the configuration data, so we are\n\n```\nmissing some information such as the C&C server domains this module uses.\n\nThere are 15 commands supported by this backdoor (although some of them are not implemented) referred to\nby the following numerical identifiers:\n\n\nCommand\nID\n\n\nFunction description\n\n\n1 Sends collected data from executed commands. It is used only if the authentication with a\nproxy is done through NTLM\n\n2 Finds out information about the domain name, user name and security identifier of the\nprocess `explorer.exe . It finds out the user name, domain name, and computer name of`\nall Remote Desktop sessions.\n\n3 Enumerates root disks\n\n4 Enumerates files and finds out their creation time, last access time and last write time\n\n5 Creates a process with a duplicated token. The token is obtained from one of the processes\nin the list (see Appendix).\n\n6 Enumerates files and finds out creation time, last time access, last write time\n\n7 Renames files\n\n8 Deletes files\n\n9 Creates a directory\n\n101 Sends an error code obtained via `GetLastError` API function\n\n102 Enumerates files in a specific folder and finds out their creation time, last access time and\nlast write time\n\n103 Uploads a file to the C&C server\n\n104 Not implemented (reserved)\n\n\nCombination\nof\n105/106/107\n\n\nCreates a directory and downloads files from the C&C server\n\n\nCommunication protocol\n\n\n-----\n\nThe `MulCom` backdoor is capable of communicating via HTTP and TCP protocols. The data it exchanges\nwith the C&C servers is encrypted and compressed by the RC4 and aPack algorithms respectively, using the\nRC4 key loaded from the configuration data object.\n\nIt is also capable of proxy server authentication using schemes such as Basic, NTLM, Negotiate or to\nauthenticate via either the SOCKS4 and SOCKS5 protocols.\n\nAfter successful authentication with a proxy server, the backdoor sends data xorred by the constant `0xBC .`\nThis data is a set with the following structure:\n\nData structure\n\nAnother interesting capability of this backdoor is the usage of layered C&C servers. If this option is enabled in\nthe configuration object (it is not the default option), the first request goes to the first layer C&C server, which\nreturns the IP address of the second layer. Any subsequent communication goes to the second layer directly.\n\nAs previously stated, we found several code similarities between the `MulCom` DLL and the `FFRat` (a.k.a.\n```\nFormerFirstRAT ).\n\n## Conclusion\n\n```\nWe have described a robust and modular toolset used most likely by a Chinese speaking APT group targeting\ngambling-related companies in South East Asia. As we mentioned in this blogpost, there are notable code\nsimilarities between `FFRat` samples and the `MulCom` backdoor. `FFRat` or `\"FormerFirstRAT'' has`\nbeen publicly associated with the DragonOK group according to the Palo Alto Network report, which has in\nturn been associated with backdoors like `PoisonIvy and` `PlugX` – tools commonly used by Chinese\nspeaking attackers.\n\nWe also described two different infection vectors, one of which weaponized a vulnerable WPS Office updater.\nWe rate the threat this infection vector represents as very high, as WPS Office claims to have 1.2 billion\ninstallations worldwide, and this vulnerability potentially allows a simple way to execute arbitrary code on\nany of these devices. We have contacted WPS Office about the vulnerability we discovered and it has since\nbeen fixed.\n\nOur research points to some unanswered questions, such as reliable attribution and the attackers’ motivation.\n\n## Appendix\n\n### List of processes:\n\n\n-----\n\n```\nZhuDongFangYu.exe\n\n```\n\n### Registry values changed by the Zload plugin:\n\nRegistry path in `HKEY_LOCAL_MACHINE` Registry key\n\n`SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System` LocalAccountTokenFilterPolicy\n= 1 FilterAdministratorToken =\n0\n\n`SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa` LimitBlankPasswordUse = 0\nEveryoneIncludesAnonymous\n= 1 RestrictAnonymous = 0\n\n`System\\\\CurrentControlSet\\\\Services\\\\LanManServer\\\\Parameters` RestrictNullSessAccess = 0\nNullSessionPipes =\nRpcServices\n\n### Core module working directory (WD)\n\nDefault hard-coded WD names (created either in C:\\ProgramData\\ or in `%TEMP% ):`\n```\n   spptools\n   NewGame\n   TspSoft\n   InstallAtomx\n\n```\nFile used to test permissions: `game_<tick_count>.log – the WD path is written into it and then the file is`\ndeleted.\n\nHard-coded security descriptor used for WD access: `“D:(A;;GA;;;WD)(A;OICIIO;GA;;;WD)” .`\n\nLockfile name format: `“<working_dir>\\<victim_username>-<comment_string>.log”`\n\n## Core module mutexes:\n```\nGlobal\\sysmon-windows-%x (%x is a CRC32 of an MD5 hash of the victim’s username)\nGlobal\\IntelGameSpeed-%x (%x is a CRC32 of an MD5 hash of the victim’s username\n\n```\n`Global\\TencentSecuriryAgent-P01-%s` (%s is the victim’s username)\n\n## Indicators of Compromise (IoC)\n\n[Repository: https://github.com/avast/ioc/tree/master/OperationDragonCastling](https://github.com/avast/ioc/tree/master/OperationDragonCastling)\n\n\n-----\n\nList of SHA\n256: [https://github.com/avast/ioc/blob/master/OperationDragonCastling/samples.sha256](https://github.com/avast/ioc/blob/master/OperationDragonCastling/samples.sha256)\n\nAvast Threat Intelligence Team has found a remote access tool (RAT) actively being used in the wild in the\nPhilippines that uses what appears to be a compromised digital certificate belonging to the Philippine Navy.\n\nThis is the story of piecing together information and research leading to the discovery of one of the largest\nbotnet-as-a-service cybercrime operations we’ve seen in a while. This research reveals that a cryptomining\nmalware campaign we...\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/xtmf4vkiyrwbnyk9dp0aa3v3aoe7zoc9"
    ],
    "report_names": [
        "Avast_Operation-Dragon-Castling-APT-targeting-betting-companies(03-22-2022)"
    ],
    "threat_actors": [
        {
            "id": "5ffe400c-6025-44c2-9aa1-7c34a7a192b0",
            "created_at": "2023-01-06T13:46:38.469688Z",
            "updated_at": "2025-03-27T02:00:02.84172Z",
            "deleted_at": null,
            "main_name": "DragonOK",
            "aliases": [
                "Moafee",
                "BRONZE OVERBROOK",
                "G0017",
                "G0002",
                "Shallow Taurus"
            ],
            "source_name": "MISPGALAXY:DragonOK",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "7ebda3c6-1789-4d84-97cf-47fb18a0cb28",
            "created_at": "2022-10-25T15:50:23.78829Z",
            "updated_at": "2025-03-27T02:00:55.547275Z",
            "deleted_at": null,
            "main_name": "DragonOK",
            "aliases": [
                "DragonOK"
            ],
            "source_name": "MITRE:DragonOK",
            "tools": [
                "PoisonIvy",
                "PlugX"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "60d9c778-488b-459e-a2f6-9e48c607ba45",
            "created_at": "2022-10-25T16:47:55.606462Z",
            "updated_at": "2025-03-27T02:05:17.281676Z",
            "deleted_at": null,
            "main_name": "BRONZE OVERBROOK",
            "aliases": [
                "DragonOK ",
                "Samurai Panda ",
                "Temp.DragonOK ",
                "Danti "
            ],
            "source_name": "Secureworks:BRONZE OVERBROOK",
            "tools": [
                " DDKONG",
                " HelloBridge",
                " IsSpace",
                " NFLog Trojan",
                " PLAINTEE",
                " PlugX",
                " Rambo",
                "Aveo"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "340d1673-0678-4e1f-8b75-30da2f65cc80",
            "created_at": "2022-10-25T16:07:23.552036Z",
            "updated_at": "2025-03-27T02:02:09.85925Z",
            "deleted_at": null,
            "main_name": "DragonOK",
            "aliases": [
                "Bronze Overbrook",
                "Shallow Taurus"
            ],
            "source_name": "ETDA:DragonOK",
            "tools": [
                "Agent.dhwf",
                "CT",
                "Chymine",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "FF-RAT",
                "FormerFirstRAT",
                "Gen:Trojan.Heur.PT",
                "HTran",
                "HUC Packet Transmit Tool",
                "HelloBridge",
                "IsSpace",
                "KHRAT",
                "Kaba",
                "Korplug",
                "Mongall",
                "NFlog",
                "NewCT",
                "NfLog RAT",
                "PlugX",
                "Poison Ivy",
                "Rambo",
                "RedDelta",
                "SPIVY",
                "Sogu",
                "SysGet",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "TidePool",
                "Xamtrav",
                "brebsd",
                "ffrat",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "06260304-49f9-4d51-a22d-373c7fcb80ca",
            "created_at": "2022-10-25T16:07:23.944881Z",
            "updated_at": "2025-03-27T02:02:10.04328Z",
            "deleted_at": null,
            "main_name": "Operation Dragon Castling",
            "aliases": [],
            "source_name": "ETDA:Operation Dragon Castling",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716491,
    "ts_updated_at": 1743041834,
    "ts_creation_date": 1649015159,
    "ts_modification_date": 1649015159,
    "files": {
        "pdf": "https://archive.orkl.eu/57578072d22b95901e875f19cfb7ead3002d07f1.pdf",
        "text": "https://archive.orkl.eu/57578072d22b95901e875f19cfb7ead3002d07f1.txt",
        "img": "https://archive.orkl.eu/57578072d22b95901e875f19cfb7ead3002d07f1.jpg"
    }
}