{
    "id": "cef183b8-3403-4287-9270-8aae0886eb02",
    "created_at": "2023-01-12T15:06:26.036426Z",
    "updated_at": "2025-03-27T02:15:38.02097Z",
    "deleted_at": null,
    "sha1_hash": "def2026ba3146747c53b78a4d0208bed269c1c18",
    "title": "2021-11-21 - Dridex Trojan - Defeating Anti-Analysis - Strings Decryption - C&C Extraction",
    "authors": "",
    "file_creation_date": "2022-05-28T00:40:07Z",
    "file_modification_date": "2022-05-28T00:40:07Z",
    "file_size": 3331956,
    "plain_text": "# Dridex Trojan\n\n**cyber-anubis.github.io/malware analysis/dridex/**\n\n### Nidal Fikri\n\nHatching Triage Malware Research Analyst. Ex-Trend Micro Intern.\n\n15 minute read\n\n## Dridex in a Nutshell\n\n\nNovember 21, 2021\n\n\n-----\n\nDridex is a famous banking Trojan which appeared around 2011 and is still very active today. This is\nbecause of its evolution and its complex architecture, which is based on proxy layers to hide the main\n[command and control servers (C&C). The APT known as TA505 is associated to Dridex, as well as with](https://malpedia.caad.fkie.fraunhofer.de/actor/ta505)\nother malwares such as TrickBot and Locky ransomware. Dridex is known for its unique anti-analysis\ntechniques which combines API hashing with VEH (Vectored Exception Handling) manipulation. As a\nconsequence, Dridex is able to effectively hide its intentions and requires skillful reverse engineers to\naccurately dissect it. Once installed, Dridex can download additional files to provide more functionality to\nthe Trojan.\n\n## Technical Summary\n\n1. Dridex uses API hashing to conceal its imports. It’s using CRC32 hashing, as well as another layer\n\nof XORing with hard-coded key. It’s prasing the loaded DLLs in memory and its export tables. As a\nconsequence, Dridex can resolve any imported win APIs then jumps to their addresses.\n2. Another layer of complication is done with Vectored Exception Handling manipulation. Dridex inserts\n\na lot of `int 3 and` `ret instructions everywhere to make the reverse engineering harder.`\nFurthermore, the use of `int 3 triggers a custom exception handler planted by the malware. This`\nmalicious handler alters the execution flow to effectively jump between APIs.\n3. Dridex comes with encrypted strings on its `.rdata section. These strings are used as API`\n\nparameters/settings for the malicious impact. Therefore, they are must be decrypted to know its\nintentions. Dridex uses RC4 to do the decryption. The first 40 bytes of every data chunk is the key\n(stored in a reverse order) then followed by the encrypted data.\n4. Dridex stores its network configuration in plain text on its `.data section. Obviously, it establishes`\n\nconnection with its C&C for further commands, and also to download additional malware modules.\nThese modules extend its functionality. Dridex comes with 4 embedded C&C IP addresses.\n\n## Technical Analysis\n\n Defeating Anti-Analysis\n\n### API Hashing\n\nDridex is famous for its anti-analysis techniques which include API hashing. API hashing -in a nutshell- is\nwhen a malware hashes the names (strings) of its imports, making it harder to know what APIs it will\nresolve at run-time. API hashing is famous among shellcodes. That’s because a tightly crafted shellcode\ncan’t make use of the OS loader, it’s not a PE file and it must depend on itself to find where DLLs are\nresiding in memory. Once it finds the targeted module, it parses its export table to know where it’s\nproviding its exported APIs (the address in memory). One way to spot API hashing techniques, is to look\nfor a function which takes constant (random-like data) inputs, and finding that they are using its return\nvalue as a function pointer.\n\n\n-----\n\nFigure(1): sub_6015C0 will be renamed to be mw_API_Resolver\n\nWe can see that `sub_6015C0 matches the description we have just stated. It’s called twice to resolve`\ntwo Windows APIs. Also, we can notice that the 1st parameter is the same during the two calls here. This\nmay indicate that the 1st parameter is likely to be the hashed DLL name and the 2nd parameter is likely to\nbe the hashed API name.\n\nWe can label `sub_6015C0 as a potential API resolving routine. Now let’s dive into it for more detailed`\nanalysis. We can see that it’s depending on two more functions: `sub_607564 and` `sub_6067C8 .`\n\nFigure(2): Using IDA Pro structs.\n\nIn `sub_607564, we find that Dridex is parsing the process` `PEB structure in order to get the loaded`\nmodules- in the process address space- By using the appropriate structs in IDA Pro the code looks more\n\n\n-----\n\nreadable right now.\n\n**Variable Name** **Struct**\n\nLdr Pointer to _PEB_LDR_DATA\n\nCurrent_DLL Pointer to [_LDR_MODULE (Click the link and search the documentation)](http://undocumented.ntinternals.net/)\n\nPrev_DLL Pointer to [_LDR_MODULE](http://undocumented.ntinternals.net/)\n\nAs we can see, Dridex is using the `Flink pointer to parse the loaded modules (DLLs) as`\n```\n_LDR_MODULE structs. The BaseDllName of every loaded module is obtained, and properly converted\n\n```\nto the right form for further comparison. The `BaseDllName is hashed by` `sub_61D620 and XORed`\nagainst the `38BA5C7B hard-coded key.`\n\nFigure(3): Hash comparison; between the function input hash and the obtained name (after hashing and\nXORing).\n\nWe can determine the type of hashing algorithm using PEiD tool. Using the Krypto ANALyzer plugin, it\nwas able to identify the hashing algorithm as `CRC32 based on the used algorithm constants. After`\nhashing and XORing the `BaseDllName of the loaded module, it’s compared against the target hash.`\nOnce there is a match, at `0X60769A, the` `BaseAddress of the wanted module (DLL) is returned. This`\naddress is used later for locating the wanted API within the module’s export table. This address also\npoints to the `IMAGE_DOS_HEADER aka MZ header of the module. All that is purely done in the memory`\nwithout the need of exposing the malware’s imports.\n\nWe proceed to reverse `sub_6067C8 . The routine accepts the previously returned DLL` `BaseAddress as`\na parameter along with the second hash. We can make a strong prediction that this function is using\nthose parameters to return the API address in order to be used by Dridex. As we can see, The malware is\nparsing the module header in order to locate its export table. The export table of a certain DLL contains\nthe addresses which its exported APIs are residing in memory.\n\n\n-----\n\nFigure(4): The offsets are calculated based on the function argurment (DLL ImageAddress)\n\nThe malwares first references the `e_lfanew field at offset` `0X3C from the beginning of the module. This`\nfield denotes the offset which the `NT Headers begin. From there and by offset` `0X78 -i.e. at offset`\n```\n0X3C + 0X78 = 0X160 from the beginning of the DLL-, the malware can access the Data Directory .\n\n```\nThe first two fields of this array is the address of the `Export Directory address and its` `size . We can`\nuse PEBear tool to visualize all these offsets within the PE header. We use the\n```\n_IMAGE_EXPORT_DIRECTORY struct with the variable EXPORT_TABLE_Start_Address to make the code\n\n```\nmore readable.\n\nHence, we can see the malware parsing `AddressOfNames,` `AddressOfNameOrdinals, and`\n```\nAddressOfFunctions to make a mapping between every exported API’s name and its memory address.\n\n```\nIf the hashed -and XORed- API name matches the 2nd argument of the function, its memory address is\nreturned. By using this way, Dridex is able to effectively hide its needed APIs from security solutions. For\n[more details about how to find an API address in memory check this out.](https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode#offsets-in-tables)\n\nCombining all together from the previous analysis, we now know that Dridex is doing API hashing using\nCRC32 + another layer of XORing. We can try to write a script to create a hash table of the famous\nWindows DLLs and their exports. Generating this table, we can then search into it using the hashes that\nDridex uses. As a consequence, we can know which API and DLL Dridex is trying to resolve without the\nneed of dynamic code analysis.\n\n[Fortunately, we don’t have to create this script. We can use the amazing hashdb IDA plugin from OALabs.](https://github.com/OALabs/hashdb)\nIt will automate everything for us. We just need to identify the hashing algorithm and the XOR key to make\nhashdb ready.\n\nFigure(5): Use enums with the 'm' button\n\nThis announces our victory over API hashing anti-analysis, and we can easily use the newly added\nenums to make the malware code more readable right now. For instance, at `0X5F9E47 we find that`\n\n\n-----\n\n```\nCreatThread is being resolved at that particular address.\n\n### Vectored Exception Handling\n\n```\nTo fully understand the intention of this anti-analysis technique, we need to know how Dridex is utilizing\nAPI hashing:\n\nFigure(6): This pattern is found hunderds of times in this sample and also in any downloaded module.\n\nThe returned API address from `sub_6015C0 (labeled as` `mw_API_Resolver ) is not used as` `call`\ninstruction operand. Rather, at `sub_607980, Dridex is registering (adding) a new customized Exception`\n_Handler using_ `RtlAddVectoredExceptionHandler API, which accepts an` `_EXCEPTION_POINTERS`\narguemnt. This customized exception handler will adjust the thread stack and `EIP register, in order to`\nalter the process flow to the previously resolved API address (via the `ret instruction).`\n\nAfter calling the `mw_API_Resolver function,` `EAX now contains the address of the resolved API. Dridex`\nthen traps the debugger or -more accurately- generates an `EXCEPTION_BREAKPOINT using` `int 3`\ninstruction. This exception is passed to the process exception handlers vector in order to be properly\nhandled. The previously planted customized exception handler will be the first to process the exception.\n\nFigure(7): A process context is like a snapshot of its registers and stack.\n\nThis malicious handler will execute and alter the process’ context if and only if the exception is caused by\n```\nint 3 instruction -which Dridex exactly wants-. The final process’ context will be altered by these steps:\n\n```\n\n-----\n\n1. Incrementing `EIP by 1 in order to make it point to the` `ret instruction.`\n\n2. Mimicking a `push EIP+1 instruction, in order to save the address of the instruction after` `ret on`\n\nthe stack ( manually building a stack frame).\n\n3. Also mimicking a `push EAX instruction, in order to make` `ESP = Resolved API Address .`\n\nSuccessfully achieving these steps, the flow will exactly resume at the `ret instruction, pointed by the`\ncorrupted `EIP, which will pop the address on top of the stack and jumps to it. This will make the wanted`\njump to the resolved API with no `call instruction. Furthermore, after executing the resolved API code,`\nthe flow resumes at the previously saved address of the manually built stack frame (step no. 2). This will\nmake the flow resume at the instruction after the `ret, successfully returning back to the previous normal`\nflow before the `int 3 instruction. Not to forget, this technique makes the dynamic code analysis harder,`\nbecause you will deal with hundreds of debugger traps everywhere in the code.\n\nMoreover, inserting `ret instructions everywhere in the code tricks the disassemblers when trying to`\nidentify functions. Some disassemblers use `ret instructions to identify the end of the functions. This`\nmakes another layer of complication using this anti-disassembly technique.\n\nTo overcome all this, we need to create a script which parses the code section of the sample, in order to\nfix those complication. We can create a small IDA Python script to search for the opcodes `int 3 and`\n```\nret, and then patch them to be call EAX . This means that we are looking for the bytes 0xCCC3,\n\n```\nthen we patch them to be `0xFFD0 . The script is below:`\n```\nimport idautils\nimport idaapi\nimport ida_search\ndef get_text_section ():\n  for seg in idautils.Segments():\n    if idc.get_segm_name(seg) == \".text\":\n      return [idc.get_segm_start(seg), idc.get_segm_end(seg)]\ndef search_N_patch(pattern, patch):\n  search_range = []\n  search_range = get_text_section()\n  flag = True\n  while(flag):\n# The value 16 is the default.\n    addr = ida_search.find_binary(search_range[0], search_range[1], pattern, 16,\nida_search.SEARCH_DOWN)\n    idc.patch_word(addr,patch)\n    if (addr == ida_idaapi.BADADDR or addr >= search_range[1]):\n      flag = False\npattern = 'cc c3'  # int 3 ret\npatch = 0xd0ff   # call eax (Little Endian)\nsearch_N_patch(pattern,patch)\n\n```\nPS: This script only alters the IDA database and not the actual binary. To patch the sample in order to\nopen it in a debugger, use the `pefile python library instead.`\n\n\n-----\n\nNow, using hashdb as well as our IDA Python script, we have a better chance to understand Dridex\nfunctionality. First, we edit the data types of the `mw_API_Resolver arguments to be`\n```\nhashdb_strings_crc32 enum instead of integers. This in order to make IDA Pro automatically resolve\n\n```\nthe hashes, Secondly, we use IDA Pro Xrefs to know which API is being resolved at any particular\nlocation.\n\n## Strings Decryption\n\nDridex contains a lot of malicious functionality. From simple host profiling up to DLL hijacking, there are a\nlot to cover when reversing Dridex. I will not dive deeply into all of its functionality, I will rather focus on the\ninteresting parts only. To get the most of its intentions, you need to decrypt all the embedded strings. They\nare stored on the `.rdata section in chunks. These strings are used as parameters with the resolved`\nAPIs to perform certain malicious impact.\n\nFigure(8): The key is initialized in the KSA part of the RC4. Check the wiki page.\n\n[We can use the amazing capa tool from Mandiant to find out if it can detect any encryption algorithms.](https://github.com/mandiant/capa)\n[Fortunately, capa was able to identify RC4 is being used at](https://en.wikipedia.org/wiki/RC4) `sub_61E5D0 . Also, from capa’s output, we`\ncan detect the operation: “key modulo its length” at the address `0x61E657 .`\n\nFigure(9): The first renamed function just copies memory from certain source to defined destination.\n\nFrom here, we can trace the Xrefs to `sub_61E5D0 to find out where the key is located and what is the`\nkey length. Taking the last Xref, at `sub_607B30, we can trace back the function arguments to find that`\nthe key is loaded from a certain offset at the `.rdata section. The key length is 40 bytes and the data to`\n\n\n-----\n\ndecrypted starts after the key. As a consequence, we can deduce that for every chunk of data, their\ndecryption key is the first 40 bytes then followed by the encrypted data. Also from other threat intel\nresources, we can know that Dridex stores the decryption key bytes in a reverse order.\n\nFigure(10): It's always a good habit to quickly test decryption using CyberChef before developing scripts.\n\nLet’s try to use CyberChef to manually decrypt the data at the address `0X629BC0 . The key starts at`\n```\n0X629BC0 with a length of 40 bytes in a reverse order. The encrypted data starts at 0X629BE8 . We can\n\n```\nsee the fully decrypted strings clearly now. The first two words are “Program Manager”. That’s why I didn’t\nprefer to reverse all of Dridex functionality. The more important is to find out how the decryption is\nhappening and then you can decipher any code snippets. From this point, you can try yourself to decrypt\nevery chunk of data and find out how they are being used for every malicious impact.\n\n## Extracting C&C Configuration\n\nDridex of course tries to connect with its threat actor. It’s a must to find these remote ends in order to\nblock them and cut out the lines between the malware operators and the infected machines. One way to\nfind out the C&C servers, is to look for where networking functions are being called. From Xrefs to\n```\nmw_API_Resolver, we can find that there are two important functions which are responsible for\n\n```\nnetworking functionality; `sub_623370 and` `sub_623820 . At` `sub_623820, it seems that it is used for`\nfurther download activity, because it’s resolving the `InternetReadFile API. Inside` `sub_623370, we`\ncan see Dridex is resolving `InternetConnectW API which accepts the` `lpszServerName parameter.`\nThis parameter identifies the remote end to where the connection is happening.\n\n\n-----\n\nFigure(11): This chuck of code is a little before the Xref.\n\nTracing the only Xref to `sub_623370, we can spot Dridex parsing a data offset to extract the embedded`\nIPs. This is at the address `0X5F7232 just a little before the call to` `sub_623370 .`\n\nFigure(12): This pattern is repeated starting from (c2_array) to store the whole 4 IPs and their associated\nports.\n\n\n-----\n\nThe network configuration is not encrypted. Starting at offset `0X62B024 . The ports can be converted via`\nsimple hex to decimal conversion. Yet, for the IPs we can use this small Python script to convert them into\na human-readable format:\n```\nimport socket\nimport struct\ndef int2ip(addr):\n  return socket.inet_ntoa(struct.pack(\"!I\", addr))\nprint(int2ip(0xC02ED2DC)) # First IP\n\n```\nThe extracted C&C IPs are below:\n\n**No** **IP Address : Port Number**\n\n1 192.46.210.220:443\n\n2 143.244.140.214:808\n\n3 45.77.0.96:6891\n\n4 185.56.219.47:8116\n\n## Conclusion\n\nThe techniques of Dridex are somehow unique when combined together. We can easily defeat API\nhashing once we know the hashing algorithm and the XOR key. The use of VEH makes the reverse\nengineering process very painful and needs urgent patching. Dridex has a lot of capabilities and\ntechniques, I’ve decided to rather focus on defeating anti-analysis and strings decryption. From there, you\nare able to identify any of its intentions.\n\n## IoCs\n\n**No** **Description** **Value**\n\n\n1 Unpacked\nSample\nHash\n\n\nF9495E968F9A1610C0CF9383053E5B5696ECC85CA3CA2A338C24C7204CC93881\n\n\n2 1st C2 192.46.210.220:443\n\n3 2nd C2 143.244.140.214:808\n\n4 3rd C2 45.77.0.96:6891\n\n5 4th C2 185.56.219.47:8116\n\n6 Botnet ID 10444\n\n\n-----\n\n## Refrences\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-21 - Dridex Trojan - Defeating Anti-Analysis - Strings Decryption - C&C Extraction.pdf"
    ],
    "report_names": [
        "2021-11-21 - Dridex Trojan - Defeating Anti-Analysis - Strings Decryption - C&C Extraction.pdf"
    ],
    "threat_actors": [
        {
            "id": "99cb4e5b-8071-4f9e-aa1d-45bfbb6197e3",
            "created_at": "2023-01-06T13:46:38.860754Z",
            "updated_at": "2025-03-27T02:00:02.937438Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "SectorJ04 Group",
                "Dudear",
                "G0092",
                "ATK103",
                "Hive0065",
                "Spandex Tempest",
                "GRACEFUL SPIDER",
                "GOLD TAHOE",
                "CHIMBORAZO",
                "SectorJ04"
            ],
            "source_name": "MISPGALAXY:TA505",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5e6b31a6-80e3-4e7d-8b0a-d94897ce9b59",
            "created_at": "2024-06-19T02:03:08.128175Z",
            "updated_at": "2025-03-27T02:05:17.400394Z",
            "deleted_at": null,
            "main_name": "GOLD TAHOE",
            "aliases": [
                "SectorJ04 ",
                "Spandex Tempest ",
                "TA505 ",
                "FIN11 "
            ],
            "source_name": "Secureworks:GOLD TAHOE",
            "tools": [
                " Cobalt Strike",
                " FlawedAmmy",
                " Get2",
                " GraceWire",
                " Malichus",
                " SDBbot",
                " ServHelper",
                " TrueBot",
                "Clop"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "75d4d6a9-b5d1-4087-a7a0-e4a9587c45f4",
            "created_at": "2022-10-25T15:50:23.5188Z",
            "updated_at": "2025-03-27T02:00:55.489882Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "TA505",
                "Hive0065",
                "Spandex Tempest",
                "CHIMBORAZO"
            ],
            "source_name": "MITRE:TA505",
            "tools": [
                "AdFind",
                "Azorult",
                "FlawedAmmyy",
                "Mimikatz",
                "Dridex",
                "TrickBot",
                "Get2",
                "FlawedGrace",
                "Cobalt Strike",
                "ServHelper",
                "Amadey",
                "SDBbot",
                "PowerSploit"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "e447d393-c259-46e2-9932-19be2ba67149",
            "created_at": "2022-10-25T16:07:24.28282Z",
            "updated_at": "2025-03-27T02:02:10.159466Z",
            "deleted_at": null,
            "main_name": "TA505",
            "aliases": [
                "ATK 103",
                "Chimborazo",
                "Gold Evergreen",
                "Gold Tahoe",
                "Graceful Spider",
                "Hive0065",
                "Operation Tovar",
                "Operation Trident Breach",
                "SectorJ04",
                "Spandex Tempest",
                "TA505",
                "TEMP.Warlock"
            ],
            "source_name": "ETDA:TA505",
            "tools": [
                "Amadey",
                "AmmyyRAT",
                "AndroMut",
                "Azer",
                "Bart",
                "Bugat v5",
                "CryptFile2",
                "CryptoLocker",
                "CryptoMix",
                "CryptoShield",
                "Dridex",
                "Dudear",
                "EmailStealer",
                "FRIENDSPEAK",
                "Fake Globe",
                "Fareit",
                "FlawedAmmyy",
                "FlawedGrace",
                "FlowerPippi",
                "GOZ",
                "GameOver Zeus",
                "GazGolder",
                "Gelup",
                "Get2",
                "GetandGo",
                "GlobeImposter",
                "Gorhax",
                "GraceWire",
                "Gussdoor",
                "Jaff",
                "Kasidet",
                "Kegotip",
                "Kneber",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Locky",
                "MINEBRIDGE",
                "MINEBRIDGE RAT",
                "MirrorBlast",
                "Neutrino Bot",
                "Neutrino Exploit Kit",
                "P2P Zeus",
                "Peer-to-Peer Zeus",
                "Philadelphia",
                "Philadephia Ransom",
                "Pony Loader",
                "Rakhni",
                "ReflectiveGnome",
                "Remote Manipulator System",
                "RockLoader",
                "RuRAT",
                "SDBbot",
                "ServHelper",
                "Shifu",
                "Siplog",
                "TeslaGun",
                "TiniMet",
                "TinyMet",
                "Trojan.Zbot",
                "Wsnpoem",
                "Zbot",
                "Zeta",
                "ZeuS",
                "Zeus"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535986,
    "ts_updated_at": 1743041738,
    "ts_creation_date": 1653698407,
    "ts_modification_date": 1653698407,
    "files": {
        "pdf": "https://archive.orkl.eu/def2026ba3146747c53b78a4d0208bed269c1c18.pdf",
        "text": "https://archive.orkl.eu/def2026ba3146747c53b78a4d0208bed269c1c18.txt",
        "img": "https://archive.orkl.eu/def2026ba3146747c53b78a4d0208bed269c1c18.jpg"
    }
}