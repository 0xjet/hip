{
    "id": "5a27418c-530b-400a-a2e1-3bd1da51da61",
    "created_at": "2022-10-25T16:48:16.315499Z",
    "updated_at": "2025-03-27T02:16:01.110811Z",
    "deleted_at": null,
    "sha1_hash": "31c376f79371e512fcddea903a8e0d3bb7636e76",
    "title": "Qakbot report",
    "authors": "",
    "file_creation_date": "0001-01-01T00:00:00Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 2437814,
    "plain_text": "# A reverse engineer primer on Qakbot Dll Stager:\n From initial execution to multithreading.\n\nHello everybody, in this blog post I will show some of the capabilities of the Qakbot DLL stager, as of\nJune 2022.\nI was interested in tracking known e-crime malware, so this is the perfect example besides Dridex or\nEmotet.\n\nMore soon to come, but in the next few months.\n\n**_DISCLAIMER:_**\nThis malware has been documented by several people.\nIt might seem like some kind of reuse from previous research (specially for the crypto part), and to\nsome point it is, and at the same time it's not, this has been reversed from scratch since March and\nupdated through the following months.\n\nThis work won't cover all the components of the stager. Instead, it focuses from the initial execution of\nthe binary, to the function table that includes the C2 functions. This paper won't go further than that.\n\nMy main objective is to give a notion in the execution flow that leads us to these procedures and some\nof the recovered structures involved in this process, for those who are new at tracking this malware.\n**_(Most of this work was done through static analysis, but specific things have been confirmed_**\n**_through dynamic analysis)._**\n\nIf you consider there has been imprecise information, let me know in my DMs so I can fix it. There is a\nlot of information inside here, but I have done my best to be precise.\n\n[Specially dedicated to @Myrtus0x0 and](https://twitter.com/Myrtus0x0) [@dark0pcodes, since they have helped me with the](https://twitter.com/dark0pcodes)\ndevelopment of some of the scripts used during the reverse engineering phase.\n\nThe hashes of the used samples will be at the end of this paper. If you want IDB, ask me privately.\n\n\n-----\n\n## 0.0: Initialization (before main thread):\n\nThis first stage starts checking for DLL_PROCESS_ATTACH.\nIf this is the case, it will proceed to do its first initialization procedures, which include:\n\n1.-Create a heap object which will be used later for allocations of dynamic structs or strings.\n\n2.-Initialize a character set global string, which will be used for string manipulation.\n\n3.-Copy the Import directory table from the DLL module, to a new global buffer\n(array of IMAGE_IMPORT_DESCRIPTOR references through DataDirectory in the Optional Header).\n\n4.-Resolve with API hashing a dynamic kernel32.dll function table, with a different number of APIs\nused during the execution flow.\n\n5.-Check with GetFileAttributes, for “C:\\INTERNAL\\__empty”.\nThis has been described as a way to check for Windows Defender emulation.\n**(See references for an in depth detail in this sense.)**\n\nAfter all these steps have been done successfully, Qakbot will use the newly created kernel32 IAT to\ncall CreateThread with the main malicious thread.\n\nIt is important to clarify that Qakbot also uses string decryption for both WCHAR and CHAR, which\nuse two wrappers each.\n\nAs of May/June 2022, one of the new functions that has been added is the check for an environment\nvariable SELF_TEST1. This serves as a flag for doing specific checks in terms of the path of the\nmodule itself, which seems to be mainly for debugging purposes, since it pops up a MessageBox with\n_“Self Check”, “Self Check ok!” and “ERROR: GetModuleFileNameW() failed with error: 0“._\n\nIn this sense, the debug string describes the core functionality, which is a custom\nGetModuleFilenameW() implemented using CommandLineToArgvW.\n\n\n-----\n\n-----\n\n**_0.1: The main malicious thread (First stage): first process detection and information gathering._**\n\nAfter successful checks, the main malicious thread will call the same API hashing function that\nrebuilds a new IAT for more modules including: ntdll.dll, user32.dll, netapi32.dll, advapi32.dll,\nshlwapi.dll, userenv.dll, and ws2_32.dll\n\n_(This last module ws2_32.dll has been recently added in February/March 2022, to replace inet_ntoa_\n_which was in the imports of the DLL so you could just use xrefs to easily reverse the structure that_\n_stored both the C2 IPs and ports, more of that at the end of the paper, in additional details.)_\n\nThen it will proceed to build a structure based on the information from the computer, where all types of\ninformation are initialized in the structure members for different purposes, like random names for\nmutexes or events.\n\nSome of the information includes: Computer Name, Volume information, Primary Domain Controller\nName, Privileges, Module name, Type of Process (WOW64 or x64 binary), TickCount, Os Version Info\nand much more.\n\nAdditionally, it sets up environment variables as needed for USERPROFILE, TEMP and SystemDrive.\n\n**_(See the initialization struct below for more details, in terms of the structure)._**\n\n```\nstruct merserne_twister{\n  uint32_t twister[624];\n  uint32_t index;\n};\n\n```\n\n-----\n\n```\nstruct initialization\n{\n OSVERSIONINFOEXA info_struct_os;\n DWORD m_procesorArchitecture;\n DWORD m_spawn_regsvr32_instance_check; //Used for certain checks in operations.\n DWORD m_detected_flag; //Used for certain checks in operations.\n DWORD m_is_wow64_process;\n DWORD m_crc32_hash_computer_info;\n CHAR m_result_random_computer_info[32]; //Computer information related\n WCHAR m_result_random_computer_info_wchar[32]; //Computer information related wchar\n TOKEN_USER *m_current_process_token;\n WCHAR m_account_name[128]; //Account name for current option\n DWORD m_checks_sid_option; //Depends on SID, used for different operations.\n LPWSTR m_name_netbios_buffer;\n DWORD m_dc_name_ptr; //Domain controller related\n DWORD m_buffer_type_netDC; //Domain controller related\n DWORD m_dll_module_handle;//Handle\n WCHAR m_current_container_executable_full_path[262]; //Executable that loaded dll\n PWCHAR m_ptr_current_folder_container; //ptr to folder of container executable.\n WCHAR m_current_folder_container_executable[262]; //Executable that loaded dll folder\n DWORD m_unknown; //Only referenced once, usage not clear.\n merserne_twister mersenne_tick_count_info; //Based on tick count info.\n CHAR m_pos_bot_id[16]; //Used in C2 comms functions, possible bot info.\n DWORD m_sid_subauthority_option;\n WCHAR m_windows_dir_path[261]; //Windows Dir path\n WCHAR m_temp_path[261]; //Temp path\n WCHAR m_user_profile_path[262]; //User profile\n UINT m_current_proc_ID;\n WCHAR m_current_container_executable_wchr[262]; //Container exec wchr version\n DWORD m_check_system_metrics;\n PWCHAR m_current_folder_wchar_ptr; //Container executable folder wchar ptr\n CHAR m_seed_mersenne_twister_string_32[32];//Random 1\n CHAR m_second_seed_random[32]; //Random 2\n DWORD m_ored_total_process_detection; //Bitmask for first process detection.\n BYTE unused_bytes[256]; //Not initialized in constructor, padding bytes.\n WCHAR m_ComputerName[148]; //Current computer name.\n};\n\n```\n\nIn the final part from this structure constructor, there will be a check for certain processes as a\ndetection mechanism, mainly done through an array of structures where each element will store a\nvalue that will decrypt the process names strings separated by ‘;’ character, using the WCHAR\nversion of this function.\n\nFor example: “explorer.exe;notepad.exe;cmd.exe”, each process names separated by ’;’ one of\nthem will be stored as a char* inside the ptrToProcessNames char** (char*[ ])\n\n\n-----\n\n```\nstruct ProcessDetection //Per processes detection structure.\n{\n  DWORD dwBitmask; //Total Bitmask\n  DWORD dwEncryptedNameIndex; //can store several names\n  DWORD dwCountProcessNames; //Number of processes separated by ‘;’\n  CHAR** ptrToProcessNames; //Process names separated by ‘;’\n};\nstruct ContainerProcessDetection\n{\n  DWORD dwBitmaskDetection;\n  DWORD dwNumDetectionStructures;\n  ProcessDetection *arrDetectStructs;\n};\n\n```\n\nThe value in dwBitMaskDetection inside the ContainerProcessDetection struct will serve as a\nbitmask, where each time one of the processes is detected, it will be ORd in this member with the\ncurrent ProcessDetection member dwBitmask.\n\nAll the processes detected this way include:\n**_ccSvcHst.exe, avgcsrvx.exe;avgsvcx.exe;avgcsrva.exe, MsMpEng.exe,mcshield.exe,_**\n**_avp.exe;kavtray.exe,egui.exe;ekrn.exe,bdagent.exe;vsserv.exe;vsservppl.exe_**\n**_AvastSvc.exe,coreServiceShell.exe;PccNTMon.exe;NTRTScan.exe,SAVAdminService.exe;SavS_**\n**_ervice.exe, fshoster32.exe,WRSA.exe,vkise.exe;isesrv.exe;cmdagent.exe_**\n**_ByteFence.exe,MBAMService.exe;mbamgui.exe,fmon.exe,dwengine.exe;dwarkdaemon.exe;dw_**\n**_watcher.exe_**\n\n\n-----\n\nThis will be stored in the initialization struct, where it is labeled as m_ored_total_process_detection.\nEach bitfield inside this bitmask will be checked in different functions for specific operations as it will\nbe seen below.\n\nOnce everything above has been done successfully, certain checks are done which determine the\ndifferent variations for executing the “second stager”function:\n\n**_-Code injection through entrypoint function hooking in newly created suspended process:_**\n**_-Service creation and register of malicious status handlers._**\n**_-Direct call to the second stager function._**\n\nLet's inspect some of these methods, and how they are being used.\n\n**_0.2: Entrypoint function hooking and service status handling for code execution:_**\n\nQakbot will decide based on the bitfields checks found, which processes to create for the code\ninjection of the next important function.\nIn this sense, all the decrypted relative paths will use ExpandEnvironmentStringsW to get a full path to\nthe binary to be executed, where 3 of them are returned through a WCHAR** pointer (WCHAR*[ ]),\ndepending on the processes detected during the first process detection phase.\n\nSome decrypted paths include:\n\n**_'%SystemRoot%\\SysWOW64\\explorer.exe'_**\n**_'%SystemRoot%\\SysWOW64\\mobsync.exe'_**\n**_'%SystemRoot%\\System32\\mobsync.exe'_**\n**_'%SystemRoot%\\explorer.exe'_**\n**_'%ProgramFiles%\\Internet Explorer\\iexplore.exe'_**\n**_'%SystemRoot%\\SysWOW64\\OneDriveSetup.exe'_**\n**_'%SystemRoot%\\SysWOW64\\msra.exe'_**\n**_'%ProgramFiles(x86)%\\Internet Explorer\\iexplore.exe'_**\n**_'%SystemRoot%\\System32\\OneDriveSetup.exe'_**\n**_'%SystemRoot%\\System32\\msra.exe'_**\n\nOnce the process has been created with CreateProcess, using the CREATE_SUSPENDED flag, it\nuses NtCreateSection to create a section with the size of the current DLL Optional Header\nSizeOfImage, which is the size of the PE when it is mapped in memory.\n\nIn this sense, NtMapViewOfSection is used with this section handle to map the new section in the\ncurrent process address space and in the remote address space.\n\nAfter these steps finish successfully, VirtualAllocEx and WriteProcessMemory are being used to\nallocate virtual memory for a newly copied initialization struct inside our target process created,\nchanging its member m_dll_module_handle to the address of the mapped section in the external\nprocess.\n\nAdditionally, to deal with relocations, first the dll is copied to the view of the section mapped in the\ncurrent process using SizeOfImage in the Optional Header.\nand after it, proper relocations will be done for the DLL using both the addresses of both views,\neffectively fixing the DLL for usage in the external process.\n\n\n-----\n\nAfter this process has finished successfully, Qakbot will proceed to hook the entrypoint function, using\nthe ThreadContext structure, specifically the EAX register, which contains the entrypoint address of\nthe external process, patching the bytes with NtProtectVirtualMemory and NtWriteVirtualMemory, and\neventually resuming the main thread with the hooked entrypoint in the remote process (the hooking\nfunction is inside the mapped dll)\n\nOn the other hand, if the dll has system privileges, it will proceed to start a service control dispatcher\nwith StartServiceCtrlDispatcherA. In this sense, this dispatcher will call RegisterServiceCtrlHandlerA\nand set the current state of the service.\nThe most interesting detail is that, once the SERVICE_RUNNING status is set, the execution\ncontinues to the next important function.\n\nAll of these executions lead to the Second Stager function itself, which contains a lot of functionality\nthat we will be describing next.\n\n\nand set the current state of the service.\nThe most interesting detail is that, once the SERVICE_RUNNING status is set, the execution\ncontinues to the next important function.\n\nAll of these executions lead to the Second Stager function itself, which contains a lot of functionality\nthat we will be describing next.\n\n\n-----\n\nHere you can see in the screenshots above how precisely it is done the operations for the mappings\nof the section which contains the current stager dll.\nTo be completely precise, the HookFunction (shown below) will be executed in the context of the\nremote mapped dll thanks to the calculations shown in the BytesHook[1] operation. (shown above)\n\nAdditionally, one of the most important things to remember is the m_detected_flag member in the\n**_initialization struct._**\nThis will be important for operations as you will see later, where both ServiceProc and the normal\n**_call to this function will set this member to be 1, meanwhile, for the hook case, the value has to_**\n**_be 2._**\n\nIt is important to mention that the event signaled in the HookFunction will be checked while spawning\nand hooking processes, and if the event is found, it will stop to try spawning new target processes\nwith the 3 attempts. Additionally the HookFunction will resolve the IAT for this mapped dll, so all\nnecessary functionalities can be executed properly.\n\nInside the Execution::FirstStager function image, this function is labeled as\n**Injection::ManualMapDllAndHookEntrypoint()**\n\n\n-----\n\n**_1.0: The second stage function: execution states and configurations._**\n\nLet's understand some of the most important functionality that can be seen in this procedure.\n\n**_1.1: The execution states of a Qakbot stager instance:_**\n\nIt is not too clear how it is possible to differentiate what would be executed depending on certain\nconditions for a Qakbot instance.\n\nFor this purpose, in the second stage function, the Dll will check what is going to continue to be\nexecuted, based on the stored config in the current system, which involves events, mutexes and\nregistry values.\n\nIt is also important to describe that before checking this\n\nThe execution state is set mainly with following 4 options:\n\n0 == First instance (no container executable found in registry)\n1 == Same container executable name as registry.\n2 == Mutex based on computer info already exists (initialized in the execution state 3)\n3 == Event already signaled (mainly done inside an exception handler function that we will\nsee later in section 1.6)\n\nAll these conditions determine which parts of the code are going to be executed, for now, we will only\nfocus on the execution state 0, since this is the one that relates to the first execution flow.\n\nAdditionally, I consider important to describe that before the execution state is set, if the member in\nthe initialization struct, m_detected_flag, is not equal to 1 (Hook entrypoint case), it will proceed to\ngenerate a new buffer in memory of the current container executable, which will be used for later\noperations.\n\n**_(Both aspects are described in depth in section 2.2 and section 1.4 for the structs used, with_**\n**_some more additional details)_**\n\n\n-----\n\nFor each case, the results (assuming everything works out as intended) are:\n\n**_-Execution state 0: Proceed to spreader component (section 1.5), then check for member_**\n**m_detected_flag != 1 (Hook Entrypoint case), if this is the case, then it proceeds to delete**\nschtasks/run key persistence set in one of the generated regsvr32 execution instances (described in\n**_section 1.4/1.5), then proceed to execute the Execution::ThirdStager function, additionally_**\n_registering an exception handler (all of this aspects described from the section 1.6 onwards)._\n\n**_-Execution state 1: Check for member m_detected_flag != 1 (Hook Entrypoint case), if this is the_**\ncase, then it proceeds to delete schtasks/run key persistence from previously generated regsvr32\nexecution instances (section 1.4/1.5). After this proceeds to Execution::ThirdStager()\n**_(section 1.6 onwards)_**\n\n_-Execution state 2: Returns 0 (EXIT_SUCCESS)._\n\n**_-Execution state 3: Proceeds to signal event, where the GUID uses the computer info hash as seed._**\nThen proceeds to create the mutex that is relevant to achieve execution state 2.\nReplaces container executable if the value stored in the registry config (section 1.2) is not the same,\nstoring the current one and then deleting the file from the previous value.\n\nAfter that, it will execute Execution::ThirdStager, additionally registering an exception handler (which\n_is described in the section 1.6.1)._\n\nYou can see all these details graphically, in the image at the start of this section, showing the\n**_Execution::SecondStager() function._**\n\n\n-----\n\n**_1.2: Configuration storage in registry for preservation between instances:_**\n\nQakbot at this point initializes a structure that will be used for storing and retrieving important\ninformation from the Windows Registry. This is very important to remember because it is used for\nretrieving specific configuration that can be used by different instances of this stager.\n\n```\nstruct ContainerSubkeyToStore\n{\n  DWORD dwLengthSubkeyValue;\n  BYTE EncryptedSubkeyValue[260];\n  BYTE HashKeyToDecryptSubkey[4]; //This is based on CRC32 hash.\n  HKEY hKeyUsers;\n};\n//Size is allocated dynamically for each case, struct mainly for static analysis.\nstruct __unaligned EncryptedConfig\n{\n  BYTE typePayload; //Takes several values: 5, 2, 3, 4.\n  BYTE bValidPayload; //Verified in the found handlers to do decryption.\n  DWORD dwFullSizePayload; //Size of the payload.\n  //IMPORTANT: The two last members change the size depending on each case.\n  BYTE PayloadBuffer[1]; //Actual buffer to the payload buffer.\n  BYTE RandomBufferGen[1]; //Generated buffer inside Random::GenerateRandomBuffer\n};\n\n```\n\nDuring the constructor phase, the member HashKeyToDecryptSubkey is used to encrypt the\nsubkeyValue to be created. The HashKeyToDecryptSubkey value comes from a CRC32 based on the\ncomputer information.\n\nThis hash value is used for each BYTE in the encryption/decryption process, working it through from\ni = 0, with i & 3, this way we enforce always looping the 4 bytes of the hash.\n\nWhen certain informations needs to be stored, the structure EncryptedConfig is used, where\nan specific index is passed through the function to create a SHA1 hash, using this hash as salt for\ngenerating the encryption key, which is used for encrypting the entire EncryptConfig buffer before\nbeing stored with an RC4 encryption algorithm.\n\nAfter to then encrypt it and store it as a value in the corresponding value, where\n**_EncryptedSubkeyValue, HashKeyToDecryptSubkey and dwLengthSubkeyValue are all used,_**\nfrom the ContainerSubkeyToStore, where RegOpenKeyExA and RegSetValueExA are used for this\npurpose.\n\n\n-----\n\n**_1.3: Configuration storage in resources:_**\n\nAt this point, the structure that I labeled as ResourceDecryption below, will be initialized.\nEverybody knows where the config is usually stored and how it usually is decrypted in the first\ninstance, but what is the layout of the structure that uses it?\n\nSimple, it's the ExtractedElements structures shown below, which basically store the index element\nand the string of the element.\n\nIf the decrypted config stores as an example: \"10 = obama165\", indexElement would be 10 (as an\ninteger) and stringElement will contain obama165, for the current element struct.\n\n```\nstruct ResourceDecryption //Struct for storing the valuable config.\n{\n  DWORD dwCountExtracted;\n  DWORD dwUnknown;\n  HMODULE hCurrentModuleDll;\n  ExtractedElements *ExtractedResourcesConfig; //config from resources of stager.\n  ExtractedElements *ExtractedCfgFileConfig; //config from .cfg\n};\n\n```\n\n-----\n\n```\nstruct element\n{\n  DWORD indexElement;\n  char *stringElement;\n};\nstruct ExtractedElements\n{\n  DWORD numElements;\n  element *Elements;\n};\nstruct ResourceBufferStruct //Struct used for in-memory decryption of resource.\n{\n wchar_t m_path_file[512];\n DWORD m_sha1_hash_buffer[8];\n WORD dwSizeKey;\n BYTE padding1[2];\n void*  m_ptrToDynamicAllocBuffer;//In-memory buffer of the resource\n DWORD m_dwSizeDecrypted; //In-memory size of the resource decrypted\n DWORD m_dwSizeDecryptedCopy;\n HANDLE hHandle;\n BYTE m_dwOptionDecryption;\n BYTE padding2[3];\n DWORD m_dwInitHeaderAplibCheck; //Check done before using APLIB compression.\n DWORD m_dwNumberElements;\n DWORD m_dwNumberOfCurrentElements;\n ExtractedElements ** BufferElements;\n};\n//Important: This struct will be used again, e.g: injector.\n\n```\n\nI do not want to focus on all the possible methods that are used for decrypting and decompressing the\npayloads depending on each specific case (BriefLZ can be still used and size of 0x28 is also checked\nfor the resource buffer to do an entirely different decryption operation, RC4 is also done in this case).\n\nI want to focus on how the config is extracted for the main usual case, which is what most people are\ninterested in:\n\nA key is decrypted at runtime with one of the CHAR decrypt string wrapper, which is important for\ndecryption.\n\nThis key (20 bytes) will be processed using SHA-1 algorithm, and then it will decrypt the buffer with\nRC4 algorithm, and it will additionally use SHA-1 for integrity checks, the core payload is finally\nobtained to be parsed correctly for proper usage by the Qakbot stager, which is mainly done through\nthe ExtractedElements structure.\n\nTo reimplement it, it is just required for you to extract this key statically (or dynamically), and then\nreplicate the same as what it is executed in the function. I will show below how it looks so you get a\nfeeling of it when you are reversing it.\n\n\n-----\n\nAbove you can see the function that is in charge of both decrypting and checking the integrity of the\ndecrypted payload, in my IDB this is labeled as Decryption::DecryptBufferAndCheckIntegrity, as\n_you can see in the image)_\n\nI recommend the following resource for more description related to this specific decryption part:\n[https://darkopcodes.wordpress.com/2020/06/07/malware-analysis-qakbot-part-2/](https://darkopcodes.wordpress.com/2020/06/07/malware-analysis-qakbot-part-2/)\n\nThis resource describes a little bit better how old the code is, and how it has not really changed that\nmuch. However, it will most likely change in the future, so it is important that you reverse it on your\nown, so you can get a grasp of it\n\n**_(If your goal is just IP extraction, go to the additional details in section 2.0, I will describe the_**\n**_main structure I could find in this sense (in terms of IPs))._**\n\n\n-----\n\n**_1.4: AV detection checks and methods to manipulate relevant stager files:_**\n\nQakbot stager will try to detect aswhookx.dll and aswhooka.dll in the current process where it is\nloaded, if a related process has been found in the detection bitmask described in the section 0.1.\n\nAt this point I consider it important to describe the function\n**_Storage::GenerateNewDllandRegistryPaths, because it is used in other components such as the_**\nnetwork spreader.\n\nFirst of all, a random dll name will be generated using different operations that use the current\naccount name and CRC32 hashing. This random dll name will be concatenated with a newly created\nfolder name, to eventually generate a working path for usage.\n\nHaving in mind the picture above, you can see that the folder name depends on the random dll name\ngenerated previously. This is shown in the function Random::GenerateRandom16LengthString.\nThis random folder will be created in the same function with CreateDirectoryW, if it does not exist.\n\n\n-----\n\nAdditionally, if certain processes are found with the bitmask member inside the initialization struct and\nthe privileges are enough, the folder is added in the following HKLM registry keys :\n\n**_1.SOFTWARE\\Microsoft\\Microsoft Antimalware\\Exclusions\\Paths_**\n**_2.SOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\Paths_**\n\nAfter this steps have finished, a ContainerSubkeyToStore constructor is called, where some of the\ninformation initialized at this function is used as arguments, mainly using the Profile Path (the profile\npath is obtained with ProfileImagePath at the start of the function), the full path of the random dll and\nthe crc32 hash generated from the computer info.\nUsing this structure, some configuration is stored in the registry, which includes decrypted c2 config\ninformation in the resources for both the current stager and .cfg file (if found), random dll path, and\n_time._\n\nAt this point, depending on the member m_detected_flag described before, it can work out some of\nthe relevant stager files in different ways. This also depends on the current SID of the current user\n(m_checks_sid_option).\n\n**_There are two main ways this is done by Qakbot:_**\n\nThe first one, which is mainly done for the hook entrypoint case, involves using some in-memory\nbuffer of a file, to create and write to the current random dll.\nThe additional details of how this is generated for each case are detailed in section 2.2 of this paper,\nbut essentially, for this case, the buffer used will be the current container executable.\nIt is important to mention that this function will be very important for regsvr32 execution, because it\ncan generate new execution instances through persistence, which will be described in section 1.4.\n\n\n-----\n\nThe second one is much more complex, and involves invoking different function pointers, which are\ncalled in pairs, until one of them succeeds.\nEach one passes the random dll path and the current executable path that has loaded the dll\nI will describe individually all the methods, without a particular order:\n\n1.-Generating bat file with contents:\n**_wmic process call create 'expand <container executable> <random dll path>', then creating a_**\nprocess with the bat file.\nAfter it, it proceeds to try to delete the bat file.\n\n2.-Creates a memory buffer of the container executable, and then it proceeds to write it to the target\ndll, effectively generating a new copy.\n\n3. Using a vbs file which is executed through cscript.exe using ShellExecuteW.\nThe main that this contains is the following vb code:\n\n\nSet objWMIService = GetObject(\"winmgmts:\"&\"{impersonationLevel=impersonate}!\\\\.\\%coot\\cimv2\")\nSet colFiles = objWMIService.ExecQuery(\"Select * From CIM_DataFile Where Name = <container executable>'\")\nFor Each objFile in colFiles\n\nobjFile.Copy(<random dll path>)\nNext\n\n\n4.-Use CopyFileW to copy files from the container executable to target dll.\n\nIt is important to point out that one array entry will be added in an dynamic array of structures after all\nthis process has finished correctly, increasing a counter. We do not really care about the layout of this\nstruct because it is not explicitly used, but we will point out the usage of the counter in the next\nsection, which is labeled as indexCryptoStruct.\n\n\n-----\n\n**_1.5: Network/Local accounts spreader component with run key persistence, and schtasks_**\n**_persistence:_**\n\n```\nstruct NetworkSpreader\n{\n DWORD sid_option; //Copied from m_checks_sid_option inside the initialization\nstruct.\n ResourceDecryption *structResources; //Overall config so far extracted\n PWTS_SESSION_INFOW pSessionInfo; //Extracted used inside WTSEnumerateSessionsW\n DWORD CountSessionStructs; //Extracted used inside WTSEnumerateSessionsW\n DWORD dwCountGenerationAndStorage; //Increased per new execution for new user\n};\n\n```\n\nAt this point of execution, if some checks in terms of OS version and current SID are met successfully,\nQakbot will proceed to call WTSEnumerateSessions() to enumerate Sessions on an RDP server.\n\nIn this sense, NetUserEnum first uses the server name parameter NULL, so it spreads to the current\ncomputer accounts only. After this process has finished, it will proceed to call NetGetDCName to get\nthe primary domain controller’s name, and from this point, do some lateral movement in the current\nnetwork.\n\nLet's describe how this is done:\n\n1.-It will look up the account name and SID for one specific account with LookupAccountNameW for\nthe local computer/network.\n\n2.-Will generate a random dll with the method and operations described in the section 1.4.\n(Storage::GenerateNewDllandRegistryPaths)\nIn this sense, additionally to the expected behavior of the funcion already described in terms of\nconfiguration storage, it will proceed to build a proper regsvr32 path for execution.\n\n\nconfiguration storage, it will proceed to build a proper regsvr32 path for execution.\n\n\n-----\n\nThe full command line to work with regsvr32 with the randomly generated dll name is:\n\n**_regsvr32.exe -s \\ <full dll path to random dll> \\_**\n\nNow, for both remote sessions and the other accounts in the current computer, once that regsvr32\ncommand line has been generated, it will be used to create a process with\nCreateProcessAsUserW, where WTSQueryToken and EqualSID are used to check for the SID.\n\n\n-----\n\nAfter this process has finished, it writes the regsvr32 in:\n<CurrentSidString>\\\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n\nThe main purpose of this is to achieve persistence after reboot, for each account where this is set.\n\n\n-----\n\nAfter the execution of the spreader component has finished, Qakbot will generate a buffer long\nenough to store the current command line string format:\n\n**_\"%s\\system32\\schtasks.exe\" /Create /RU \"NT AUTHORITY\\SYSTEM\" /tn %s /tr \"%s\" /SC ONCE_**\n**_/Z /ST %02u:%02u /ET %02u:%02u_**\n\nSome of the most relevant values in the sense of this string format include for example the time,\nwhich is calculated for each case with GetLocalTime, the Windows directory path and another\nregsvr32 command line which passes the container path. (regsvr32 -s \\\\\\<path executable>\\\\\\)\n\nDo you remember the indexCryptoStruct that I mentioned in the previous section?.\nThis is checked here before the generation of the string format. Additionally, using the container\nexecutable path, the in-memory container buffer is written to it, if it exists.\n**_(Execution::GeneratePayloadsAndRegsvrInstanceDependingCheck)_**\n\n_(Important: The screenshot above is from a labeled sample from March, nowadays the argument_\n_passed to the labeled function String::WcharStringDecryptWrapper1 for decrypting the command line_\n_format is 0x338 instead of 0x1f8. The calculations are still the same as of June.)_\n\nAnother possibility based on the m_checks_sid_option is that Qakbot will proceed to try to build some\ncommand line to spawn a certain process, but, as of today (6/16/2022), verified both statically and\ndynamically, the string decryption for 0x3c0 for wchar_t is instead generating some broken exclusions\npath.\n\n\n-----\n\n(Same as above, the core functionality has not changed, the main difference is the string decryption\nwrapper, which in this case is 0x164 for the argument, but as of June, it is 0x3c0)\n\nGenerally, after I have described these two options of execution, the last details to take in mind are\nthese:\n\n_-Detecting for attributes of the cfg file for the current executable that has loaded the dll stager. This_\n_way it knows it exists, it proceeds to delete it._\n\n_-Update the members depending on the values initialized inside the execution of functions described_\n_in section 1.4_\n\nOnce all these functions, there is no remarkable functionality to be highlighted, therefore let's move on\nto the Execution::ThirdStage function, to describe the most important functionality for those that\nwant to create C2 emulators.\n\n\n-----\n\n**_1.6.0: Third stage function: Regsvr32 instances, more detections and function entries._**\n\nLet's describe the most important features that this “third stage” of the stager has to offer, below you\ncan see roughly how it looks after a lot of annotation.\n\n**_1.6.1: Different methods to trigger regsvr32 execution, and injector based on extracted data:_**\n\nOn the other hand, I think it's important to describe some of the usages that Qakbot has for spawning\nregsvr32 with payload dlls.\n**_Remember the first method I mentioned inside section 1.4,_**\n**_Execution::GeneratePayloadsAndRegsvrInstanceDependingCheck?_**\n\nThis function is core to this purpose, because all the methods mentioned next will use it one way or\nanother. There are two versions of the usage of the function we need to be aware of.\nThe first case just creates a regsvr32 instance with some random dll name which is based on tick\ncount, as you can see below (mersenne_tick_count_info). This can be achieved using either the run\n_persistence key or scheduled tasks persistence, depending on the current privileges._\n\n**_We will see the second usage when we look at the vectored exception handling case._**\n\n\n-----\n\nThe main command line string format for scheduled tasks is: schtasks.exe /Create /RU \"NT\n**_AUTHORITY\\SYSTEM\" /SC ONSTART /TN %u /TR \"%s\" /NP /F, where the first value in the string_**\nformat is a random number and the second one is the regsvr32 command line generated.\n\nWindow Classes are also used for triggering the regsvr32 execution. In this sense, a Window is\ncreated with CreateWindowExA. Then once the Window has been created it is hidden through\nSW_HIDE using ShowWindow. GetMessageA is used to retrieve for dispatching importante\nmessages, where TranslateMessage and DispatchMessageA help in this purpose.\n\nThe most important call in this process is RegisterClassA, since it describes the WNDCLASSA that it\nis used for dispatching the messages. In this sense, the windows dispatcher function will proceed to\nexecute the regsvr32 instance with methods already mentioned if the first additional parameter\n(wParam) is the same as 4 or the MessageWindow (uMsg) value is equal to 0x11.\n\n\nmessages, where TranslateMessage and DispatchMessageA help in this purpose.\n\nThe most important call in this process is RegisterClassA, since it describes the WNDCLASSA that it\nis used for dispatching the messages. In this sense, the windows dispatcher function will proceed to\n\n\n-----\n\n**AllocConsole() and SetConsoleCtrlHandler are also misused for this purpose.**\nIn this sense, the Handler function checks if CTRL_SHUTDOWN_EVENT is set, if this is the case,\nit will proceed with the same function described in the other method, spawning a regsvr32\ninstance.\n\nAs you can see, there is an additional check for WinSta0, using GetProcessWindowStation and\n**_GetUserObjectInformationW, this is because processes started by a logged-on user are associated_**\nwith the Winsta0 desktop.\n\n\n-----\n\nVectored Exception Handling is also used for this purpose. In this sense, if the exception matches one\nof the certain specific exception codes, then the creation of a new regsvr32 instance is accomplished\nas well.\n\nFor this case, if the HookEntrypoint method has been used, it will be generated either a dll or exe\npath in the same folder as the container executable, writing the file from a different file buffer\ngenerated one of the function_entry cases (described in the next section and in section 2.0 for\n**_the different buffers generated), setting the appropriate persistence method, and generating a_**\nproper regsvr32 command line, finally being spawned with CreateProcessW.\nIf a different method is used, then it will just generate a regsvr32 command line and spawn it.\n\nAfter this has been executed, the event checked in the second stage is sent and additionally, it will set\nthe flag that ends the execution of the third stage timed execution, which we will see in the next\n**_section._**\n\nMethod for entrypoint hooking\n\nMethod for all other cases (Service and direct call)\n\n\n-----\n\nI want to additionally mention that Qakbot also implements an injector, using a similar method of\nentrypoint hooking like the one described in section 0.2.\n\nThe main difference in this case, it's that the HookFunction goes further than just fixing the IAT and\nAPI hashing for resolving the functions to use: It's in charge of aspects such as properly mapping the\nsections and executing the entrypoint of the payload directly, resembling more to a proper manual\nmapping of the dll.\n\n(The function is labeled as Injection::InjectorFromDataInresources inside the\n**_Execution::ThirdStage image at the start of this section)_**\n\nIn this specific case, the main buffers are mainly extracted from the resources of a DLL that uses the\ncomputer info hash for building the path.\n\n(The core data of this DLL seems to be stored through the execution of methods described in section\n1.6, so how this is done is beyond the scope of this paper.)\n\nHere are some images that describe some of the capabilities of the injector:\n\n\n-----\n\n**_1.6.2: Named pipes communications, thread management, and timed execution based on_**\n**_configuration, with some more process detection._**\n\nFirst of all, it is important that we start describing how Qakbot achieves the execution of multiple\nthreads and the methods that involve c2 functions.\n\nThe core structure for this purpose is:\n\n\nstruct ThreadHandler\n{\n\nHANDLE hThread;\nDWORD ThreadID;\nvoid* pFunctionToExecute;\nvoid* pArgumentsBuffer;\nDWORD dwBytesArguments;\nDWORD dwEndThreadFlag; //Checked before calling destructor of Thread Handler instance.\nDWORD dwResultFunction; //return value from function.\nHANDLE hMutexThread;\n};\n\n\nQakbot supports a maximum of 128 of these ThreadHandler structs, which are used for additional\nfunctionality like anti-analysis mechanisms or named pipe communications.\nInside the named pipes communications routine, we will find functionality that leads to the execution\n**_of methods (function entries) where the C2 communications functions are also in._**\n\n\n-----\n\nTo get further into this topic, it is necessary that we touch named pipes communications. The main\nmethod that this is done is through ConnectNamedPipe and ReadFile, where the buffer read is\n0x80000, therefore the most appropriate way to think in terms of this buffer is that it is “serialized” for\nread/write.\n\nQakbot has many options depending on the wOption inside the IPCPacket, but we are only interested\nwhen wOption is 7. In this specific case, a buffer for pointers are specifically allocated and then\npassed as arguments to a function that executes methods based on IDs.\n\n\n#define MAX_SIZE_BUFFER 524280\nstruct IPCPacket\n{\n\nWORD wOption; //Option to be executed in handler.\nWORD wReserved; //Initialized as 3, maybe number of members to Initialize, not used in\nhandler.\n\nDWORD dwSizeToSend; //Size of the buffer to send.\nBYTE Buffer[MAX_SIZE_BUFFER]; //Buffer used for read/write in communications.\n};\n\n\n-----\n\nInside the function Execution::ExecuteFunctionEntry, different functions can be executed\ndepending on ID, having in mind certain conditions.\nThe main structure for each function entry which is used in this case is:\n\n```\nstruct function_entry\n{\n    WORD FunctionID;\n    WORD checkNoThread;\n    void *functionPointer;\n};\n\n```\n\n-----\n\nThis Execution::ExecuteFunctionEntry function can be both used in the IPC handler described or in\nanother function that will execute functions based on time. (There are other functions that can call it,\n_but they are out of scope for this section, e.g, called inside one function entry itself)_\n\nThe structures for the timed execution are these and the function is labeled as\n\n```\nstruct ExecuteTimeStruct\n{\n  TimeExecution *timeContext;\n};\nstruct TimeExecution\n{\n  DWORD dwTimingCount; //Check for current time, compare it if it's more so it fails.\n  DWORD dwUnknown; //Set as 0 in the constructor, use is not clear using xrefs.\n  DWORD FunctionID; //Function ID to execute, if pointer does not exist.\n  void* functionPointer; //Function to execute.\n  timeval dwTimeSetExec; //Set tv_sec and tv_usec for currTime timeval struct.\n  DWORD dwSecondsCheckTiming; //Used as check inside one function, most likely seconds.\n  DWORD bExecutedId; //Set as one after executing the function.\n};\n\n```\n\n**_ExecuteTimeStruct is the array of structures used for executing functions based on time_**\nconfiguration. The format for the timed configuration storage looks like this:\n\n**_\"%u;%u;%u\",  ExecutionFunctionTable.timeContext[k].dwTimingCount,_**\n\n**_ExecutionFunctionTable.timeContext[k].FunctionID,_**\n**_ExecutionFunctionTable.timeContext[k].dwTimeSetExec.tv_sec);_**\n\nAnd the separation for each entry is the “|” character, so it roughly looks like this:\n\n**_%u;%u;%u | %u;%u;%u | %u;%u;%u | ….._**\n\nIt is important to mention that for this specific case, the functionID used requires that the methods\ncalled do not pass arguments, this is different for the IPC case, where this is possible.\n\n\n-----\n\nThe while loop of timed execution ends when one flag is set in mainly through one regsvr32 execution\nmethod or in one IPC packet option. The flag can be seen in the paper as\n**_dwSpawnedRegsvrEndStager_**\n\nThis check is presented at the image in the start of the section as\n**Execution::CheckEventEndStagerFunction()**\n\nOn the other hand, I consider important to describe the detection of additional tooling at this point,\nwhich are:\n\n**_frida-winjector-helper-32.exe;frida-winjector-helper-64.exe;tcpdump.exe;windump.exe;ethereal_**\n**_.exe;wireshark.exe;ettercap.exe;rtsniff.exe;packetcapture.exe;capturenet.exe;qak_proxy;dump_**\n**_cap.exe;CFFExplorer.exe;not_rundll32.exe;ProcessHacker.exe;tcpview.exe;filemon.exe;procm_**\n**_on.exe;idaq64.exe;PETools.exe;ImportREC.exe;LordPE.exe;SysInspector.exe;proc_analyzer.ex_**\n**_e;sysAnalyzer.exe;sniff_hit.exe;joeboxcontrol.exe;joeboxserver.exe;ResourceHacker.exe;x64d_**\n**_bg.exe;Fiddler.exe;sniff_hit.exe;sysAnalyzer.exe_**\n\n```\nstruct ToolingDetection //Struct made for detecting additional tooling in third stage\n{\n  char **ptrProcessesToDetect; //ptrs to strings of process names to detect.\n  int dwNumberOfProcessesToDetect; //Number processes to detect.\n  char *pPcapModuleString; //wpcap.dll decrypted str ptr stored here.\n};\n\n```\n\nIf any of the processes listed above is found, the main check that is done using\n**_CreateToolhelp32Snapshot, Module32First and Module32Next, is in terms of whether the module_**\n**_wpcap.dll is loaded inside of it. This entire function is executed in a new thread._**\n\nIf this is found, it will sleep for 1000 milliseconds each time it finds it, using SleepEx, where the\nbAlertableState is used, so it can end through time out or when I/O completion callback function\noccurs.\n\nAll the descriptions above are most of the core functionality that people should be aware of, but there\nare some more details that compliment some of the information missing during this paper, so let's\ndescribe them as well.\n\n\n-----\n\n**_2.0: Additional structures and details for reverse engineering Qakbot:_**\n\nThese are some more important details that can be helpful for any reverse engineer that wants to\nmess around more around the main Qakbot dll stager.\n\nMy general advice is to look at the functions entries described in section 1.6, some of these functions\ncontain the methods we need to be aware of for doing proper C2 emulation, including the infamous\nsysinfo struct that is constantly changing.\n\nThe best way to deal with the network communications could be doing some binary rewriting\n(specially to spot which parts of the functions are creating the JSON and encrypting it)\n\n**(I recommend looking at the Kaspersky report of this malware** **[(link here) for a general](https://securelist.com/qakbot-technical-analysis/103931/)**\n**description on how this is done.)**\n\nIt describes the communication very well, and there are even more sources, so just look them up and\nreverse engineer the proper methods as well if you are interested in creating your own emulator)\n\n**_2.1: C2 IPs used for proper communications inside the resources:_**\n\nInside one of the c2 handlers of the stager, we can describe the structures that contain the IPs.\n\nThe main IP config structure looks like, which includes both registry and resources retrieved C2\nservers.\n\n```\nstruct custom_ip\n{\n in_addr IP_c2;//Proper C2 ip to be used.\n u_short sin_portC2; //Port which is manipulated in the constructor.\n};\nstruct IpConfig //IP config used for proper communications.\n{\n  BYTE bCheckValidConfig;\n  custom_ip IPStruct;\n  BYTE padding[20]; //NULL bytes in each entry.\n};\n\n```\n```\nstruct __unaligned IpConfigBuffer //Buffer stored in registry and resources.\n{\n  BYTE bValidStructIp; //Checked before decoding the values.\n  DWORD ipEncoded; //IP encoded.\n  WORD port; //Port encoded.\n};\n\n```\n\nThis custom_ip struct is used in one function with inet_ntoa (which was in the IAT of the binary, at\n**_least until March 2022)._**\n\nOf course, since there are multiple IPs stored for comms, an array of structs of type IpConfig is used.\n\n\n-----\n\nFor successful extraction, you need to rewrite the operation related to the ports in a Python script,\nmainly.\n\nThis structure is used in one method inside one function entry of the methods already described\nabove, so it is important that from there you reverse engineer the rest.\n\nAdditionally, the communications are done through JSON so if you want an additional challenge you\ncan reverse the different structures/objects employed for building it.\n\n**_(Spoiler alert: It seems most likely one of them is using a linked list, but I leave the rest to you)._**\n\n\nFor successful extraction, you need to rewrite the operation related to the ports in a Python script,\n\n\n-----\n\n**_2.2: Corrupting container executable in disk and generating file buffers._**\n\nWe saw earlier in the second stage and third stage function that Qakbot writes files to disk from a\nbuffer of memory, but from where and how is it done?\n\nThere are two main buffers used but both of them use the following structure.\n\n```\nstruct fileBuffer\n{\n  BYTE *pFileBuffer;\n  DWORD dwFileBufferSize;\n};\n\n```\n\nThe first buffer which is commonly used for all the functions previously, such as\n**_Execution::GeneratePayloadsAndRegsvrInstanceDependingCheck, is copied from the container_**\nexecutable, while the second case will use the buffer obtained through one of the function_entry\nmethods already described. (You will notice both structures when you xref it).\n\nIt is important to mention how this fileStruct structure is used for the container executable buffer, in\nthe HookEntrypoint case before the proper execution state is selected in the second stage function.\n\nFirst of all, the first 1024 bytes will be read from the current executable container, and then it will\nproceed to read armstream.dll from the system32 directory.\n\nOnce this has finished, if the size is more than 1024, it will proceed to copy from the next 1024 bytes\nfrom the start for armstream.dll, to this new payload buffer.\n\nNext, it will proceed to write the container executable in disk until it reaches the maximum size of 4096\n\nBecause it is written on disk, it makes sense the container executable is corrupted and needs to be\nrewritten in other instances.\n\n\nBecause it is written on disk, it makes sense the container executable is corrupted and needs to be\nrewritten in other instances.\n\n\n-----\n\n**_2.3 Prevention of infection in CIS countries:_**\n\nThis function will be used both in the SecondStage and ThirdStage function, you will notice it 2 times\nwhen reversing the stager.\n\nThe main operation is set through GetKeyboardLayoutList(), and will verify for specific IDs.\n\nThe main keyboard layout IDs detected this way are found in CIS countries, and these are:\n00000419,0000041a,00000422,00000423,00000428,0000042b,0000042c,00000437,0000043f,00000\n440,00000442,0000081a,0000082c,00000843,00000c1a,0000201a,00010419,0001042b,0001042c,0\n0010437,00020419,00020422,0002042b,00020437,0003042b,00030437,00040437.\n\nIn terms of keyboards detected, we can find: Russian, Croatian, Ukrainian, Belarusian, Tajik,\nArmenian Eastern, Georgian, Kazakh, Kyrgyz Cyrillic, Turkmen, Serbian (Latin), Azerbaijani Cyrillic,\nUzbek Cyrillic, Serbian (Cyrillic), Bosnian (Cyrillic), Russian (Typewriter), Armenian Western,\nAzerbaijani (Standard), Georgian (QWERTY), Russian - Mnemonic, Ukrainian (Enhanced), Armenian\nPhonetic, Georgian (Ergonomic), Armenian Typewriter, Georgian Ministry of Education and Science\nSchools, Georgian (Old Alphabets).\n\n\n-----\n\n**_Some final comments/words:_**\n\nIf you have reached this point, thank you very much for reading. This has been some months of non\ncontinuous work, although I hadn't planned to write this paper at first.\n\nI will work on more malware reports for known e-crime malware.\n\n_(ICEID will be next, most likely, but I will be not active for some months, because I need a proper c2_\n_emulator and maintain it, for both ICEID and QBOT)._\n\nI will maintain new details related to the stager in twitter, as it gets updated.\n\nFinally, I want to express my interest in meeting/joining an active community of malware reverse\nengineers/analysts that track e-crime malware, since I would like to collaborate with\nother people who are far more experienced in this sense.\n\nAs of now, I consider myself as a beginner-intermediate RE with lots of concepts to review/get a better\ngrasp of the technical details (in terms of C/C++ RE, and also regarding Windows Internals).\n\nHowever, I am able to achieve a significant amount of work if the time constraints are not an issue and\nwith some guidance.\n\nIf you are interested, please, contact me in my twitter DMs.\n\nWithout any further to add, I hope you enjoyed it and see you next time.\n\n## Additional references:\n\n 1.Comments on the new feature adding Defender Engine detection https://twitter.com/jroosen/status/1398035408252985346 and https://web.archive.org/web/20210527192027/https://www.kernelmode.info/forum/viewtopic3 04a.html?t=5496\n\n 2.My source of income in terms of Qakbot: https://twitter.com/pr0xylife\n\n Hashes for the samples:\n\n -Qakbot stager june unpacked:\n -MD5:E9E9D194F3EE9822852309CC83455EEA -SHA-1: 48978331E9FD88ABD2E6778D36DDE9B81FF1768D\n\n -Qakbot stager march unpacked:\n -MD5: B4E811ABBBF0D4BD450C770060711E03 -SHA-1: 6992CF181CE54EF41B02D5C376F3E947DD763699\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://raw.githubusercontent.com/NtQuerySystemInformation/Malware-RE-papers/main/Qakbot%20report.pdf"
    ],
    "report_names": [
        "Qakbot%20report.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "bbefc37d-475c-4d4d-b80b-7a55f896de82",
            "created_at": "2022-10-25T15:50:23.571783Z",
            "updated_at": "2025-03-27T02:00:55.502112Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "BRONZE BUTLER",
                "REDBALDKNIGHT"
            ],
            "source_name": "MITRE:BRONZE BUTLER",
            "tools": [
                "Mimikatz",
                "build_downer",
                "cmd",
                "ABK",
                "at",
                "BBK",
                "schtasks",
                "down_new",
                "Daserf",
                "ShadowPad",
                "Windows Credential Editor",
                "gsecdump"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716496,
    "ts_updated_at": 1743041761,
    "ts_creation_date": 0,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/31c376f79371e512fcddea903a8e0d3bb7636e76.pdf",
        "text": "https://archive.orkl.eu/31c376f79371e512fcddea903a8e0d3bb7636e76.txt",
        "img": "https://archive.orkl.eu/31c376f79371e512fcddea903a8e0d3bb7636e76.jpg"
    }
}