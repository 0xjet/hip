{
    "id": "e81f6f5c-7d41-4786-8a08-7cbf27809126",
    "created_at": "2023-01-12T15:09:45.00479Z",
    "updated_at": "2025-03-27T02:05:25.335142Z",
    "deleted_at": null,
    "sha1_hash": "c4569cdcac0d64e5f6280cb47576743e3025c738",
    "title": "2022-07-26 - HOW to Analyze Linux Malware - A Case Study of Symbiote",
    "authors": "",
    "file_creation_date": "2022-09-01T10:30:07Z",
    "file_modification_date": "2022-09-01T10:30:07Z",
    "file_size": 6837719,
    "plain_text": "# How to analyze Linux malware – A case study of Symbiote\n\n**[cybergeeks.tech/how-to-analyze-linux-malware-a-case-study-of-symbiote](https://cybergeeks.tech/how-to-analyze-linux-malware-a-case-study-of-symbiote)**\n\nSummary\n\nSymbiote is a Linux threat that hooks libc and libpcap functions to hide the malicious activity.\nThe malware hides processes and files that are used during the activity by implementing two\nfunctions called hidden_proc and hidden_file. It can also hide network connections based on\na list of ports and by hijacking any injected packet filtering bytecode. The malware’s purpose\nis to steal credentials from the SSH and SCP processes by hooking the libc read function.\nThe extracted credentials are encrypted using RC4, stored in a file on the system, and then\nexfiltrated to the C2 server via DNS requests.\n\n**Analyst:** [@GeeksCyber](https://twitter.com/GeeksCyber)\n\nTechnical analysis\n\nSHA256: 121157e0fcb728eb8a23b55457e89d45d76aa3b7d01d3d49105890a00662c924\n\nThis is a 64-bit ELF shared object that appears to be an early development build for\n[Symbiote malware. Newer versions of this malware have even more functionalities which are](https://blogs.blackberry.com/en/2022/06/symbiote-a-new-nearly-impossible-to-detect-linux-threat)\ndescribed in BlackBerry’s analysis. The file is not stripped.\n\nThe malware hooks the following functions: fopen, fopen64, pam_authenticate,\npam_set_item, read, readdir, readdir64, and recvmsg. We will give details about the hooks\nimplementation.\n\nThe dlsym function is utilized to obtain the address of fopen, and then the process calls the\noriginal function (0xFFFFFFFFFFFFFFFF = RTLD_DEFAULT):\n\n\n-----\n\nFigure 1\n\nWhen an application tries to open the “/proc/net/tcp” file, which contains all TCP connections,\nthe execution flow of the hooked function is different:\n\nFigure 2\n\n\n-----\n\nThe ELF file creates a temporary file by calling the tmpfile method, reads the first line from\nthe above file, and writes it to the newly created file:\n\nFigure 3\n\nThe file is read line-by-line using the getline function. In the case of returning -1 because of a\nfailure (including end-of-file condition), the process closes the file and frees the memory area\nallocated to the line:\n\nFigure 4\nThere is a function called gen_proc_net_port implemented by the malware. The purpose of\nthis function is to retrieve a list of ports that should be hidden. Whether a line read above\ncontains any of the ports, the line is not written to the temporary file, and the process moves\n\n\n-----\n\nto the next line:\n\nFigure 5\nThe function implementation is displayed in the figure below:\n\n\n-----\n\nFigure 6\n\nThe hooked function returns the file descriptor corresponding to the temporary file. The\nfopen64 function is hooked in a similar way.\n\nThe dlsym function is utilized to obtain the address of pam_authenticate, and then the\nprocess calls the original function:\n\n\n-----\n\nFigure 7\n\nThe malware calls the pam_get_item method in order to obtain the following information: 0x1\n= PAM_SERVICE – the service name, 0x4 = PAM_RHOST – the requesting hostname, 0x2\n= PAM_USER – the username. There is also a function call to getaddrlist, which will be\nexplained in the upcoming paragraphs:\n\n\n-----\n\nFigure 8\n\nBased on the information extracted above, the process constructs the following string “pam|\n<getaddrlist result>|<PAM_SERVICE>|<PAM_RHOST>|<PAM_USER>|<cs:pampassword>”.\nThere is a call to a function named saveline with the “/usr/include/linux/usb/usb.h” parameter\n(see figure 9). This particular function will be dissected in the upcoming paragraphs.\n\nFigure 9\n\nThe ELF binary implements an erase function called erasefree. It overwrites an area with\nzeros, and then the pointer which points to this area will be freed:\n\n\n-----\n\nFigure 10\n\nFigure 11\n\nThe dlsym function is utilized to obtain the address of pam_set_item, and then the process\ncalls the original function:\n\n\n-----\n\nFigure 12\n\nThe process expects that the item_type value is equal to 0x6 (PAM_AUTHTOK), which is the\nauthentication token (usually it’s a password):\n\n\n-----\n\nFigure 13\n\nThe dlsym function is utilized to obtain the address of readdir, as highlighted below:\n\n\n-----\n\nFigure 14\n\nThe malware implements a function called check_proc, which will be explained in a bit.\nDepending on the boolean value returned by this function, the process calls the original\nreaddir method and then hidden_file or hidden_proc:\n\n\n-----\n\nFigure 15\nThe readdir64 function is hooked in a similar way.\n\nThe dlsym function is utilized to obtain the address of recvmsg, and then the process calls\nthe original function:\n\n\n-----\n\nFigure 16\n\nThe malicious process expects a specific message structure i.e. message[8] = 0xc,\nmessage[16] != 0, as displayed in the figure below:\n\nFigure 17\nThe ELF binary converts unsigned short integers from host byte order to network byte order\nusing htons. The message is copied to another memory area using the memcpy method:\n\n\n-----\n\nFigure 18\n\nIn the check_proc function, the malware gets the directory stream file descriptor and\ncomputes the following path “/proc/self/fd/<File descriptor>”:\n\n\n-----\n\nFigure 19\nThe path constructed above points to a symbolic link that is read using the readlink method.\nThe function returns 1 whether the symbolic link contains “/proc” and 0 otherwise:\n\n\n-----\n\nFigure 20\nThe malware implements a function called check_ssh_scp. It obtains the location of an\nexecutable by calling the readlink function with the “/proc/self/exe” parameter:\n\n\n-----\n\nFigure 21\n\nThe purpose of this function is to detect the presence of the SCP/SSH executable and\nreturns 0 if that’s the case:\n\nFigure 22\n\n\n-----\n\nSymbiote implements the CRC32b algorithm in a function called crc32b. The algorithm can\nbe identified using the 0xEDB88320 constant:\n\nFigure 23\n\nThere is a function called create_file that can be used to create files. It calls the open method\n(0x441 = O_WRONLY | O_CREAT | O_APPEND):\n\n\n-----\n\nFigure 24\n\nThe process changes the permissions of a file to 0x1B6 = S_IRUSR | S_IWUSR | S_IRGRP |\n**S_IWGRP | S_IROTH | S_IWOTH, which means that all users can read and write but cannot**\nexecute the file:\n\nFigure 25\n\nIn the function called dns, the ELF binary retrieves the current process ID that is converted\nfrom host byte order to network byte order using htons:\n\n\n-----\n\nFigure 26\n\nThe malware calls a function named ChangetoDnsNameFormat that will be explained below:\n\nFigure 27\n\n\n-----\n\nThe malicious process creates a socket that will be used to communicate with the C2 server\n(0x2 = AF_INET, 0x2 = SOCK_DGRAM, 0x11 = IPPROTO_UDP). The C2 server address is\nconverted from dotted decimal notation to an integer using the inet_addr method:\n\nFigure 28\n\nThe sendto function is utilized to send data to the C2 server:\n\nFigure 29\n\nThe function called ChangetoDnsNameFormat prepares the structure of the request for DNS\ndata exfiltration:\n\n\n-----\n\nFigure 30\nIn the function named getaddrlist, the ELF binary extracts a linked list of structures\ncontaining the network interfaces of the local machine using the getifaddrs method:\n\n\n-----\n\nFigure 31\nBased on the structures extracted above, the process extracts the IP addresses by calling\nthe getnameinfo function:\n\nFigure 32\n\nThe interfaces IP addresses are concatenated together using the strcat method:\n\n\n-----\n\nFigure 33\n\nIn the getserver function, the malicious binary tries to open a file called “/tmp/resolv.conf”:\n\n\n-----\n\nFigure 34\n\nThe malware is looking for a nameserver in the above file. If there is no nameserver, then the\nprocess will use the Google DNS server (8.8.8.8) to send the DNS request as a UDP\nbroadcast:\n\nFigure 35\nThe process compares two strings (file names) in the hidden_file function and returns 0 if\nthey match:\n\n\n-----\n\nFigure 36\nThe hidden_proc function expects a process ID as an argument. It calls the strspn and strlen\nfunctions in order to ensure that the process ID consists of digits only:\n\n\n-----\n\nFigure 37\n\nThe ELF binary retrieves information about a process from the “/proc/<pid>/status” file, as\nshown in figure 38.\n\n\n-----\n\nFigure 38\nThe purpose of this function is to compare two process names and to return 0 if they match\n(see figure 39). Symbiote’s objective is to hide some processes that are related to the\nmalware such as: certbotx64, certbotx86, javautils, javaserverx64, javaclientex64,\njavanodex86 (BlackBerry’s article).\n\nFigure 39\n\n\n-----\n\nThe dlsym function is utilized to obtain the address of the read method. If an SSH or SCP\nprocess is calling the libc read function, then hook_read is set to keylogger, which is\nexplained below:\n\nFigure 40\nIn the keylogger function, the process calls the original read function with a file descriptor\ncorresponding to SSH or SCP. It also performs a call to the isatty method in order to ensure\nthat the file descriptor is referring to a terminal:\n\n\n-----\n\nFigure 41\n\nThe executable calls a function named log_cmd_line and then getaddrlist. The first function\nwill be detailed in the following paragraphs:\n\n\n-----\n\nFigure 42\n\nThe malware constructs a string with the following structure “<getaddrlist result>|\n<log_cmd_line result>|pw_5673”. It calls the saveline function with the\n“/usr/include/linux/usb/usb.h” parameter:\n\n43\n\n\nFigure\n\n\n-----\n\nThe log_cmd_line method is called only for the SSH or SCP process. The command line of\none of these processes is read from “/proc/self/cmdline”:\n\nFigure 44\nThe realloc method is utilized to deallocate the old object and to return a pointer to a new\nobject:\n\n\n-----\n\nFigure\n\n45\nThe credentials extracted from the SSH or SCP process are encrypted using the RC4\nalgorithm (key = “suporte42atendimento53log”). The encrypted content will be used to\nconstruct DNS requests in the sendlinedns function:\n\n\n-----\n\nFigure 46\n\nThe malicious process creates a file called “/usr/include/linux/usb/usb.h” by calling\ncreate_file:\n\n\n-----\n\nFigure 47\nThe encrypted credentials are written to the file created above:\n\nFigure 48\n\nIn the sendlinedns function, the malware obtains information about the current kernel using\nthe uname method. Based on the resulting buffer, the process computes a machine ID which\nconsists of 4 bytes generated using crc32b (stored in id_6274):\n\n\n-----\n\nFigure 49\n\nThe encrypted credentials are hex-encoded and splitted to be exfiltrated via DNS requests to\na domain owned by the threat actor. The A DNS request has the following format:\n\n<Packet number – starts from 0x2B67 = 11111>.<Machine ID – Crc32b hash>.<Hex**encoded data>.px32.nss.atendimento-estilo[.]com**\n\nFinally, the executable calls the dns function that will exfiltrate data:\n\n\n-----\n\nFigure 50\nThe implementation of the RC4 algorithm can be identified below:\n\n\n-----\n\nFigure 51\n\n\n-----\n\nFigure 52\nINDICATORS OF COMPROMISE\n\nC2 domain: px32.nss.atendimento-estilo[.]com\n\nSHA256: 121157e0fcb728eb8a23b55457e89d45d76aa3b7d01d3d49105890a00662c924\n\nFiles created: /usr/include/linux/usb/usb.h\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-07-26 - HOW to Analyze Linux Malware - A Case Study of Symbiote.pdf"
    ],
    "report_names": [
        "2022-07-26 - HOW to Analyze Linux Malware - A Case Study of Symbiote.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536185,
    "ts_updated_at": 1743041125,
    "ts_creation_date": 1662028207,
    "ts_modification_date": 1662028207,
    "files": {
        "pdf": "https://archive.orkl.eu/c4569cdcac0d64e5f6280cb47576743e3025c738.pdf",
        "text": "https://archive.orkl.eu/c4569cdcac0d64e5f6280cb47576743e3025c738.txt",
        "img": "https://archive.orkl.eu/c4569cdcac0d64e5f6280cb47576743e3025c738.jpg"
    }
}